目录
CONTENTS
第章 程序设计和C语言 ⋯
什么是计算机程序 ⋯
什么是计算机语言 ⋯
C语言的发展及其特点 ⋯
最简单的C语言程序⋯
最简单的C语言程序举例 ⋯
C语言程序的结构⋯
运行C程序的步骤与方法 ⋯
程序设计的任务⋯
习题 ⋯
第章 算法——程序的灵魂 ⋯
程序算法数据结构⋯
什么是算法⋯
简单的算法举例⋯
算法的特性⋯
怎样表示一个算法⋯
用自然语言表示算法 ⋯
用流程图表示算法 ⋯
三种基本结构和改进的流程图 ⋯
用NS流程图表示算法 ⋯
用伪代码表示算法 ⋯
用计算机语言表示算法 ⋯
结构化程序设计方法⋯
习题 ⋯
第章 最简单的C程序设计——顺序程序设计⋯
顺序程序设计举例⋯
数据的表现形式及其运算⋯
C程序设计第五版
常量和变量 ⋯
数据类型 ⋯
整型数据 ⋯
字符型数据 ⋯
浮点型数据 ⋯
怎样确定常量的类型 ⋯
运算符和表达式⋯
C运算符 ⋯
基本的算术运算符 ⋯
自增、自减运算符⋯
算术表达式和运算符的优先级与结合性 ⋯
不同类型数据间的混合运算 ⋯
强制类型转换运算符 ⋯
C语句⋯
C语句的作用和分类 ⋯
最基本的语句——赋值语句 ⋯
数据的输入输出⋯
输入输出举例 ⋯
有关数据输入输出的概念 ⋯
用 printf函数输出数据 ⋯
用 scanf函数输入数据 ⋯
字符输入输出函数 ⋯
习题 ⋯
第章 选择结构程序设计 ⋯
选择结构和条件判断⋯
用 if语句实现选择结构 ⋯
用 if语句处理选择结构举例 ⋯
if语句的一般形式 ⋯
关系运算符和关系表达式⋯
关系运算符及其优先次序 ⋯
关系表达式 ⋯
逻辑运算符和逻辑表达式⋯
逻辑运算符及其优先次序 ⋯
逻辑表达式 ⋯
条件运算符和条件表达式⋯
选择结构的嵌套⋯
用 switch语句实现多分支选择结构 ⋯
选择结构程序综合举例 ⋯
目 录
习题⋯
第章 循环结构程序设计⋯
为什么需要循环控制 ⋯
用 while语句实现循环 ⋯
用 do… while语句实现循环 ⋯
用 for语句实现循环 ⋯
循环的嵌套 ⋯
几种循环的比较 ⋯
改变循环执行的状态 ⋯
用 break语句提前终止循环⋯
用 continue语句提前结束本次循环 ⋯
break语句和 continue 语句的区别⋯
循环程序举例 ⋯
习题⋯
第章 利用数组处理批量数据⋯
怎样定义和引用一维数组 ⋯
怎样定义一维数组⋯
怎样引用一维数组元素⋯
一维数组的初始化⋯
一维数组程序举例⋯
怎样定义和引用二维数组 ⋯
怎样定义二维数组⋯
怎样引用二维数组的元素⋯
二维数组的初始化⋯
二维数组程序举例⋯
字符数组 ⋯
怎样定义字符数组⋯
字符数组的初始化⋯
怎样引用字符数组中的元素⋯
字符串和字符串结束标志⋯
字符数组的输入输出⋯
使用字符串处理函数⋯
字符数组应用举例⋯
习题⋯
第章 用函数实现模块化程序设计⋯
为什么要用函数 ⋯
C程序设计第五版
怎样定义函数 ⋯
为什么要定义函数⋯
定义函数的方法⋯
调用函数 ⋯
函数调用的形式⋯
函数调用时的数据传递⋯
函数调用的过程⋯
函数的返回值⋯
对被调用函数的声明和函数原型 ⋯
函数的嵌套调用 ⋯
函数的递归调用 ⋯
数组作为函数参数 ⋯
数组元素作函数实参⋯
一维数组名作函数参数⋯
多维数组名作函数参数⋯
局部变量和全局变量 ⋯
局部变量…
全局变量⋯
变量的存储方式和生存期 ⋯
动态存储方式与静态存储方式⋯
局部变量的存储类别⋯
全局变量的存储类别⋯
存储类别小结⋯
关于变量的声明和定义⋯
内部函数和外部函数 ⋯
内部函数⋯
外部函数⋯
习题⋯
第章 善于利用指针⋯
指针是什么 ⋯
指针变量 ⋯
使用指针变量的例子⋯
怎样定义指针变量⋯
怎样引用指针变量⋯
指针变量作为函数参数⋯
通过指针引用数组 ⋯
数组元素的指针⋯
在引用数组元素时指针的运算⋯
目 录
通过指针引用数组元素⋯
用数组名作函数参数⋯
通过指针引用多维数组 ⋯
通过指针引用字符串 ⋯
字符串的引用方式 ⋯
字符指针作函数参数⋯
使用字符指针变量和字符数组的比较⋯
指向函数的指针 ⋯
什么是函数的指针⋯
用函数指针变量调用函数⋯
怎样定义和使用指向函数的指针变量 ⋯
用指向函数的指针作函数参数 ⋯
返回指针值的函数 ⋯
指针数组和多重指针 ⋯
什么是指针数组 ⋯
指向指针数据的指针变量⋯
指针数组作 main函数的形参 ⋯
动态内存分配与指向它的指针变量 ⋯
什么是内存的动态分配⋯
怎样建立内存的动态分配⋯
void 指针类型 ⋯
有关指针的小结 ⋯
习题⋯
第章 用户自己建立数据类型⋯
定义和使用结构体变量 ⋯
自己建立结构体类型⋯
定义结构体类型变量 ⋯
结构体变量的初始化和引用⋯
使用结构体数组 ⋯
定义结构体数组⋯
结构体数组的应用举例⋯
结构体指针 ⋯
指向结构体变量的指针⋯
指向结构体数组的指针⋯
用结构体变量和结构体变量的指针作函数参数⋯
用指针处理链表 ⋯
什么是链表 ⋯
建立简单的静态链表⋯
C程序设计第五版
建立动态链表⋯
输出链表⋯
共用体类型 ⋯
什么是共用体类型⋯
引用共用体变量的方式⋯
共用体类型数据的特点⋯
使用枚举类型 ⋯
用 typedef声明新类型名 ⋯
习题⋯
第章 对文件的输入输出 ⋯
C文件的有关基本知识⋯
什么是文件⋯
文件名⋯
文件的分类⋯
文件缓冲区⋯
文件类型指针⋯
打开与关闭文件⋯
用 fopen 函数打开数据文件⋯
用 fclose 函数关闭数据文件⋯
顺序读写数据文件⋯
怎样向文件读写字符⋯
怎样向文件读写一个字符串⋯
用格式化的方式读写文本文件⋯
用二进制方式向文件读写一组数据⋯
随机读写数据文件⋯
文件位置标记及其定位⋯
随机读写 ⋯
文件读写的出错检测⋯
习题⋯
附录⋯
附录 A 常用字符与ASCⅡ代码对照表 ⋯
附录B C语言中的关键字⋯
附录C 运算符和结合性⋯
附录D C语言常用语法提要⋯
附录E C库函数⋯
参考文献⋯
第章 程序设计和C语言
什么是计算机程序
有人以为计算机是“万能”的，会自动进行所有的工作，甚至觉得计算机神秘莫测。这是很多初学者的误解，其实，计算机的每一个操作都是根据人们事先指定的指令进行的。例如用一条指令要求计算机进行一次加法运算，用另一条指令要求计算机将某一运算结果输出到显示屏。为了使计算机执行一系列的操作，必须事先编好一条条指令，输入计算机。
所谓程序，就是一组计算机能识别和执行的指令。每一条指令使计算机执行特定的操作。只要让计算机执行这个程序，计算机就会“自动地”执行各条指令，有条不紊地进行工作。一个特定的指令序列用来完成一定的功能。为了使计算机系统能实现各种功能，需要成千上万个程序。这些程序大多数是由计算机软件设计人员根据需要设计好的，作为计算机的软件系统的一部分提供给用户使用。此外，用户还可以根据自己的实际需要设计一些应用程序，例如学生成绩统计程序、财务管理程序、工程中的计算程序等。
总之，计算机的一切操作都是由程序控制的，离开程序，计算机将一事无成。所以，计算机的本质是程序的机器，程序和指令是计算机系统中最基本的概念。只有懂得程序设计，才能真正了解计算机是怎样工作的，才能更深入地使用计算机。
什么是计算机语言
人和人之间的交流需要通过语言。中国人之间用汉语，英国人用英语，俄罗斯人用俄语，等等。人和计算机交流信息也要解决语言问题。需要创造一种计算机和人都能识别的语言，这就是计算机语言。计算机语言经历了以下几个发展阶段。
机器语言 计算机工作基于二进制，从根本上说，计算机只能识别和接受由和组成的指令。在计算机发展的初期，一般计算机的指令长度为，即以个二进制数或组成一条指令，个和可以组成各种排列组合。例如，用
让计算机进行一次加法运算。要使计算机知道和执行自己的意图，就要编写许多条由和组成的指令。然后要用纸带穿孔机以人工的方法在特制的黑色纸带上穿孔，在指定的位置上有孔代表，无孔代表。一个程序往往需要一卷长长的纸带。在需要运行此程序时就将此纸带装在光电输入机上，当光电输入机从纸带读入信息时，有孔处产生一个电脉冲，指令变成电信号，让计算机执行各种操作。
这种计算机能直接识别和接受的二进制代码称为机器指令 machine instruction。机
C程序设计第五版
器指令的集合就是该计算机的机器语言 machine language。在语言的规则中规定各种指令的表示形式以及它的作用。
显然，机器语言与人们习惯用的语言差别太大，难学，难写，难记，难检查，难修改，难以推广使用，因此初期只有极少数的计算机专业人员会编写计算机程序。
符号语言 为了克服机器语言的上述缺点，人们创造出符号语言 symbolic language，它用一些英文字母和数字表示一个指令，例如用 ADD代表“加”，SUB代表“减”，LD代表“传送”等。如上面介绍的那条机器指令可以改用符号指令代替：
ADD A，B 执行AB⇒A，将寄存器A中的数与寄存器B中的数相加，放到寄存器A中
显然，计算机并不能直接识别和执行符号语言的指令，需要用一种称为汇编程序的软件把符号语言的指令转换为机器指令。一般，一条符号语言的指令对应转换为一条机器指令。转换的过程称为“代真”或“汇编”，因此，符号语言又称为符号汇编语言 symbolic assembler language或汇编语言 assembler language。
虽然汇编语言比机器语言简单好记一些，但仍然难以普及，只在专业人员中使用。
不同型号的计算机的机器语言和汇编语言是互不通用的。用甲机器的机器语言编写的程序在乙机器上不能使用。机器语言和汇编语言是完全依赖于具体机器特性的，是面向机器的语言。由于它“贴近”计算机，或者说离计算机“很近”，故称为计算机低级语言 low level language。
高级语言 为了克服低级语言的缺点，世纪年代创造出了第一个计算机高级语言——FORTRAN语言。它很接近于人们习惯使用的自然语言和数学语言。程序中用到的语句和指令是用英文单词表示的，程序中所用的运算符和运算表达式和人们日常所用的数学式子差不多，很容易理解。程序运行的结果用英文和数字输出，十分方便。例如在 FORTRAN语言程序中，想计算和输出×sinπ，只须写出下面这样一个语句：
PRINTSIN
即可得到计算结果。显然这是很容易理解和使用的。
这种语言功能很强，且不依赖于具体机器，用它写出的程序对任何型号的计算机都适用或只须作很少的修改，它与具体机器距离较“远”，故称为计算机高级语言 highlevel language。
当然，计算机也是不能直接识别高级语言程序的，也要进行“翻译”。用一种称为编译程序的软件把用高级语言写的程序称为源程序 source program转换为机器指令的程序称为目标程序 object program，然后让计算机执行机器指令程序，最后得到结果。高级语言的一个语句往往对应多条机器指令。
自从有了高级语言后，一般的科技人员、管理人员、大中学生以及广大计算机爱好者都能较容易地学会用高级语言编写程序，指挥计算机进行工作，而完全无须考虑什么机器指令，也可以不必深入懂得计算机的内部结构和工作原理，就能得心应手地利用计算机进行各种工作，为计算机的推广普及创造了良好的条件，人们称高级语言的出现是计算机发展史上“惊人的成就”。
高级语言经历了不同的发展阶段：
第章 程序设计和C语言
非结构化的语言。初期的语言属于非结构化的语言，编程风格比较随意，只要符合语法规则即可，没有严格的规范要求，程序中的流程可以随意跳转。人们往往追求程序执行的效率而采用了许多“小技巧”，使程序变得难以阅读和维护。早期的BASIC，FORTRAN和 ALGOL等都属于非结构化的语言。
结构化语言。为了解决以上问题，提出了“结构化程序设计方法”，规定程序必须由具有良好特性的基本结构顺序结构、选择结构、循环结构构成，程序中的流程不允许随意跳转，程序总是由上而下顺序执行各个基本结构。这种程序结构清晰，易于编写、阅读和维护。QBASIC，FORTRAN 和C语言等属于结构化的语言，这些语言的特点是支持结构化程序设计方法。
以上两种语言都是基于过程的语言，在编写程序时需要具体指定每一个过程的细节。在编写规模较小的程序时，还能得心应手，但在处理规模较大的程序时，就显得捉襟见肘、力不从心了。在实践的发展中，人们又提出了面向对象的程序设计方法。程序面对的不是过程的细节，而是一个个对象，对象是由数据以及对数据进行的操作组成的。
面向对象的语言。近十多年来，在处理规模较大的问题时，开始使用面向对象的语言。CC Visual Basic和 Java 等语言是支持面向对象程序设计方法的语言。有关面向对象的程序设计方法和面向对象的语言在本书中不作详细介绍，有兴趣的读者可参考有关专门书籍如作者编著的《C面向对象程序设计第版》。
进行程序设计，必须用到计算机语言，人们根据任务的需要选择合适的语言，编写出程序，然后运行程序得到结果。
C语言的发展及其特点
年，美国贝尔实验室的D M Ritchie 在B语言的基础上设计出了C语言。最初的C语言只是为描述和实现 UNIX 操作系统提供一种工作语言而设计的。年， Ken Thompson 和D M Ritchie合作把 UNIX 的以上用C语言改写即 UNIX第版。随着 UNIX的日益广泛使用，C语言也迅速得到推广。年以后，C语言先后移植到大、中、小和微型计算机上。C语言便很快风靡全世界，成为世界上应用最广泛的程序设计高级语言。
以UNIX第版中的C语言编译程序为基础年 Brian W Kernighan 和 Dennis M Ritchie 合著了影响深远的名著 The C Programming Language这本书中介绍的C语言成为后来广泛使用的C语言版本的基础，它是实际上第一个C语言标准。年，美国国家标准协会ANSI，根据C语言问世以来各种版本对C语言的发展和扩充，制定了第一个C语言标准草案’ ANSI C。年ANSI公布了一个完整的C语言标准——ANSI X—常称为 ANSI C 或 C 。 年国际标准化组织 ISO International Standard Organization接受C作为国际标准 ISOIEC 它和ANSI的C 基本上是相同的。
年，ISO 又对C语言标准进行了修订，在基本保留原来的C语言特征的基础上，针对应用的需要，增加了一些功能，尤其是C中的一些功能，并在年和年先后进行了两次技术修正，它被称为C，C是C的扩充。
C程序设计第五版
应该注意到，目前由不同软件公司所提供的一些C语言编译系统并未完全实现C建议的功能，它们多以C为基础开发。读者应了解自己所使用的C语言编译系统的特点。
C语言是一种用途广泛、功能强大、使用灵活的过程性 procedural编程语言，既可用于编写应用软件，又可用于编写系统软件。因此C语言问世以后得到迅速推广。自世纪年代初，C语言在我国开始推广以来，学习和使用C语言的人越来越多，C语言成了学习和使用人数最多的一种计算机语言，绝大多数理工科大学都开设了“C语言程序设计”课程。掌握C语言成为计算机开发人员的一项基本功。
C语言有以下一些主要特点。
语言简洁、紧凑，使用方便、灵活。C语言一共只有个关键字见附录B、种控制语句，程序书写形式自由，主要用小写字母表示，压缩了一切不必要的成分。C语言程序比其他许多高级语言简练，源程序短，因此输入程序时工作量少。
实际上，C是一个很小的内核语言，只包括极少的与硬件有关的成分，C语言不直接提供输入和输出语句、有关文件操作的语句和动态内存管理的语句等这些操作是由编译系统所提供的库函数来实现的，C的编译系统相当简洁。
运算符丰富。C语言的运算符包含的范围很广泛，共有种运算符见附录C。C语言把括号、赋值和强制类型转换等都作为运算符处理，从而使C语言的运算类型极其丰富，表达式类型多样化。灵活使用各种运算符可以实现在其他高级语言中难以实现的运算。
数据类型丰富。C语言提供的数据类型包括整型、浮点型、字符型、数组类型、指针类型、结构体类型和共用体类型等，C又扩充了复数浮点类型、超长整型 longlong和布尔类型 bool等。尤其是指针类型数据，使用十分灵活和多样化，能用来实现各种复杂的数据结构如链表、树、栈等的运算。
具有结构化的控制语句如 if… else 语句、 while语句、 do… while语句、 switch 语句和 for语句。用函数作为程序的模块单位，便于实现程序的模块化。C语言是完全模块化和结构化的语言。
语法限制不太严格，程序设计自由度大。例如，对数组下标越界不进行检查，由程序编写者自己保证程序的正确。对变量的类型使用比较灵活，例如，整型量与字符型数据以及逻辑型数据可以通用。一般的高级语言语法检查比较严，能检查出几乎所有的语法错误，而C语言为了使编写者有较大的自由度放宽了语法检查。程序员应当仔细检查程序，保证其正确，不要过分依赖C语言编译程序查错。“限制”与“灵活”是一对矛盾。限制严格，就失去灵活性；而强调灵活，就必然放松限制。对于不熟练的人员，编写一个正确的C语言程序可能会比编写一个其他高级语言程序难一些。也就是说，对用C语言的人要求更高一些。
C语言允许直接访问物理地址，能进行位 bit操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作。因此C语言既具有高级语言的功能，又具有低级语言的许多功能，可用来编写系统软件。C语言的这种双重性，使它既是成功的系统描述语言，又是通用的程序设计语言。
用C语言编写的程序可移植性好。由于C的编译系统相当简洁，因此很容易移植
第章 程序设计和C语言
到新的系统。而且C编译系统在新的系统上运行时，可以直接编译“标准链接库”中的大部分功能，不需要修改源代码，因为标准链接库是用可移植的C语言写的。因此，几乎在所有的计算机系统中都可以使用C语言。
生成目标代码质量高，程序执行效率高。
C原来是专门为编写系统软件而设计的，许多大的应用软件也都用C语言编写，这是因为C语言的可移植性好，硬件控制能力高，表达和运算能力强。许多以前只能用汇编语言处理的问题，后来可以改用C语言来处理了。目前C的主要用途之一是编写嵌入式系统程序。由于具有上述优点，使C语言应用面十分广泛，许多应用软件也用C语言编写。
对C语言以上的特点，待学完C语言以后再回顾一下，就会有比较深的体会。
最简单的C语言程序
为了使用C语言编写程序，必须了解C语言，并且能熟练地使用C语言。本书将由浅入深地介绍怎样阅读C语言程序和使用C语言编写程序。
最简单的C语言程序举例
下面介绍几个最简单的C语言程序。
【例】 要求在屏幕上输出以下一行信息。
This is a C program
解题思路： 在主函数中用 printf函数原样输出以上文字。
编写程序：
include stdio h 这是编译预处理指令
int main 定义主函数
函数开始的标志
printfThis is a C programn 输出所指定的一行信息
return 函数执行完毕时返回函数值
函数结束的标志
运行结果：
This is a C program
Press any key to continue
以上运行结果是在 VisualC 环境下运行程序时屏幕上得到的显示。其中第行是程序运行后输出的结果，第行是 VisualC 系统在输出完运行结果后自动输出的一行信息，告诉用户“如果想继续进行下一步，请按任意键”。当用户按任意键后，屏幕上不再显示运行结果，而返回程序窗口，以便进行下一步工作如修改程序。为节省篇幅，本书在以后显示运行结果时不再包括内容为“Press any key to continue”的行。
程序分析： 先看程序第行，其中 main是函数的名字，表示“主函数”， main前面的 int 表示此函数的类型是 int类型整型。在执行主函数后会得到一个值即函数值，其值为整型。程序第行“return ；”的作用是： 当 main函数执行结束前将整数作为函数值，
C程序设计第五版
返回到调用函数处①。每一个C语言程序都必须有一个 main 函数。函数体由花括号括起来。本例中主函数内有两个语句，程序第行是一个输出语句， printf是C编译系统提供的函数库中的输出函数详见第 章。 printf函数中双撇号内的字符串This is a C program 按原样输出。n是换行符即在输出This is a C program 后显示屏上的光标位置移到下一行的开头。这个光标位置称为输出的当前位置，即下一个输出的字符出现在此位置上。每个语句最后都有一个分号，表示语句结束。
在使用函数库中的输入输出函数时，编译系统要求程序提供有关此函数的信息例如对输入输出函数的声明和宏的定义、全局量的定义等，这些以后会介绍的 ，程序第行“ include stdio h”的作用就是用来提供这些信息的。 stdio h是系统提供的一个文件名 stdio是 standard input output的缩写文件后缀 h的意思是头文件 header file因为这些文件都是放在程序各文件模块的开头的。输入输出函数的相关信息已事先放在 stdio h文件中。现在，用 include指令把这些信息调入供使用。如果没有此 include 指令就不可能执行 printf函数。关于编译预处理指令 include，读者可先不必深究，只要记住： 在程序中如要用到标准函数库中的输入输出函数，应该在本文件模块的开头加下面一行：
include stdio h
在以上程序各行的右侧，如果有，则表示从此处到本行结束是“注释”，用来对程序有关部分进行必要的说明。在写C程序时应当多用注释，以方便自己和别人理解程序各部分的作用。在程序进行预编译处理时将每个注释替换为一个空格，因此在编译时注释部分不产生目标代码，注释对运行不起作用。注释只是给人看的，而不是让计算机执行的。
说明：C语言允许用两种注释方式：
以开始的单行注释。如上面介绍的注释。这种注释可以单独占一行，也可以出现在一行中其他内容的右侧。此种注释的范围从开始，以换行符结束。也就是说这种注释不能跨行。如果注释内容一行内写不下，可以用多个单行注释，如下面两行是连续的注释行：
如注释内容一行内写不下
可以在下一行重新用“”，然后继续写注释。
以开始，以结束的块式注释。这种注释可以包含多行内容。它可以单独占一行在行开头以开始，行末以结束，也可以包含多行。编译系统在发现一个后，会开始找注释结束符，把二者间的内容作为注释。
但应注意的是在字符串中的和都不作为注释的开始。而是作为字符串的一部分。如：
printf how do you don
① C建议把 main函数指定为 int型整型，它要求函数带回一个整数值。在 main函数中，在执行的最后设置一个“return ；”语句。当主函数正常结束时，得到的函数值为；当执行 main函数过程中出现异常或错误时，函数值为一个非的整数。这个函数值是返回给调用 main函数的操作系统的。程序员可以利用操作指令检查 main 函数的返回值，从而判断 main函数是否已正常执行，并据此决定以后的操作。如果在程序中不写“return ；”语句，有的C编译系统会在目标程序中自动加上这一语句，因此。主函数正常结束时，也能使函数值为。为使程序规范和可移植，希望读者写的程序一律将 main函数指定为 int型并在 main函数的最后加一个“return ”语句。
第章 程序设计和C语言
或
printf how do you don
输出分别是：
how do you do
和
how do you do
注释可以用汉字或英文字符表示。
在C只允许用…形式的注释，而C则允许用形式的注释，注释被称为“C风格”的注释。但许多C编译系统在C 之前就已支持这种方便的注释方法，C正式将注释纳入C语言新标准。目前使用的一些编译系统如 Visual C ， Turbo C 和GCC等都支持单行注释。在本书的程序中，将利用对程序的各部分作简要的说明。如果读者输入并运行这些程序，可不必包括这些注释内容。
【例】 求两个整数之和。
解题思路：设置个变量，a和b用来存放两个整数， sum用来存放和数。用赋值运算符“”把相加的结果传送给 sum。
编写程序：
include stdio h 这是编译预处理指令
int main 定义主函数
函数开始
int ab sum 本行是程序的声明部分，定义a，b， sum为整型变量
a 对变量a赋值
b 对变量b赋值
sumab 进行ab的运算，并把结果存放在变量 sum中
printfsum is dn sum 输出结果
return 使函数返回值为
函数结束
运行结果：
sum is
然后换行，程序执行结束。
程序分析：本程序的作用是求两个整数a和b之和。第行是声明部分，定义a，b和 sum为整型 int变量。第行是两个赋值语句使a和b 的值分别为和。第行使 sum的值为a与b之和。第行输出结果，这个 printf函数圆括号内有两个参数。第一个参数是双撇号中的内容 sum is dn，它是输出格式字符串，作用是输出用户希望输出的字符和输出的格式。其中 sum is是用户希望输出的字符这和例是一样的，d是指定的输出格式，d表示用“十进制整数”形式输出。圆括号内第二个参数 sum表示要输出变量 sum的值。在执行 printf函数时，将sum变量的值以十进制整数表示取代双撇号中的d。现在 sum的值是即与之和，所以在输出时，十进制整数取代
C程序设计第五版
了d见图n是换行符。
输出时用 sum的值取代d
最后输出双撇号中的字符 sum is ，然后换行，程序执行结束。
printf sum is dn
sum
由于本程序正常运行和结束，因此 main 函数的返回值应为。现在并没有去检查和利用这个函数值，但是以后在某些时候会需要用到 main 函数值的。
图
【例】 求两个整数中的较大者。
解题思路：用一个函数来实现求两个整数中的较大者。在主函数中调用此函数并输出结果。
编写程序：
include stdio h
主函数
int main 定义主函数
主函数体开始
int max int x int y 对被调用函数 max的声明
int abc 定义变量abc
scanfddab 输入变量 a 和 b 的值
c maxab 调用 max函数，将得到的值赋给c
printfmaxdnc 输出c的值
return 返回函数值为
主函数体结束
求两个整数中的较大者的 max函数
int max int x int y 定义 max函数，函数值为整型，形式参数 x和y为整型
int z max函数中的声明部分，定义本函数中用到的变量z为整型
ifxyzx 若xy成立，将x的值赋给变量z
else zy 否则即xy不成立，将y的值赋给变量z
returnz 将z的值作为 max函数值，返回到调用 max函数的位置
运行结果：
max
在运行时，第行输入和，赋给变量a和b，程序在第行输出“max”。
程序分析： 本程序包括两个函数：①主函数 main；②被调用的函数 max。
max函数的作用是将x和y中较大者的值赋给变量z。第行 return语句将z的值作为 max的函数值返回给调用 max函数的函数即主函数 main。返回值是通过函数名 max带回到 main函数中去的带回到程序第行， main函数调用 max函数处。
程序第行是对被调用函数 max的声明 declaration。为什么要作这个函数声明呢因为在主函数中要调用 max函数程序第行“c maxab” 而 max函数的定义却在 main函数之后，对程序的编译是自上而下进行的，在对程序第行进行编译时，编译系统无法知道 max是什么，因而无法把它作为函数调用处理。为了使编译系统能识别 max函数，
第章 程序设计和C语言
就要在调用 max函数之前用“int max int x int y”对 max函数进行“声明”所谓声明通俗地说就是告诉编译系统 max是什么，以及它的有关信息。有关函数的声明详见第章。
程序第行 scanf是输入函数的名字 scanf和 printf都是C的标准输入输出函数。该 scanf函数的作用是输入变量a和b的值。 scanf后面圆括号中包括两部分内容。一是双撇号中的内容，它指定输入的数据按什么格式输入。“d”的含义是“以十进制整数形式”。二是输入的数据准备放到哪里，即赋给哪个变量。现在， scanf函数中指定的是a和b，在a和b的前面各有一个，在C语言中“”是地址符，a的含义是“变量a的地址”， b是“变量b的地址”。执行 scanf函数，从键盘读入两个整数，放到变量a和b的地址，然后把这两个整数分别赋给变量 a和b。
程序第行用 maxa，b调用 max函数。在调用时将a和b 作为 max函数的参数称为实际参数的值分别传送给 max函数中的参数x和y称为形式参数，然后执行 max函数的函数体程序第行，使max函数中的变量 z得到一个值即 x和y中大者的值， returnz的作用是把z的值作为 max函数值带回到程序第行“”的右侧主函数调用 max函数的位置，取代 maxa，b，然后把这个值赋给变量c。
第行用来输出结果。在执行 printf函数时，对双撇号括起来的 maxdn是这样处理的：将max原样输出，d由变量c的值取代，n的作用是换行。
注意：本例程序中两个函数都有 return语句，请注意它们的异同。两个函数都定义为整型，都有函数值，都需要用 return语句为函数指定返回值。但是 main 函数中的 return语句指定的返回值一般为，而max函数的返回值是 max函数中求出的两数中的最大值z，只有通过 return语句才能把求出的z值作为函数的值并返回调用它的 main函数中即程序第行，并把此值赋给变量c。不要以为在 max函数中求出最大值z后就会自动地作为函数值返回调用处，必须用 return语句指定将哪个值作为函数值。也不要不加分析地在所有函数的最后都写上“return ”。
本例用到了函数调用、实际参数和形式参数等概念，只作了简单的解释。初学者对此可能不大理解，可以先不予深究，在学到以后有关章节时自然迎刃而解。在本章介绍此例子，主要是使读者对C程序的组成和形式有一个初步的了解。
C语言程序的结构
通过以上几个程序例子，可以看到一个C语言程序的结构有以下特点：
一个程序由一个或多个源程序文件组成。一个规模较小的程序，往往只包括一个源程序文件，如例和例是一个源程序文件中只有一个函数 main函数，例中有两个函数，属于同一个源程序文件。
在一个源程序文件中可以包括个部分：
①预处理指令。如 include stdio h还有一些其他预处理指令如 define等。C编译系统在对源程序进行“翻译”以前，先由一个预处理器也称预处理程序、预编译器对预处理指令进行预处理对于 include stdio h指令来说就是将 stdio h头文件的内容读进来，取代 include stdio h。由预处理得到的结果与程序其他部分一起，组成一个完整的、可以用来编译的最后的源程序，然后由编译程序对该源程序正式进行编译，才得到目标程序。
C程序设计第五版
②全局声明。即在函数之外进行的数据声明。例如可以把例程序中的“int a，b，sum；”放到 main函数的前面，这就是全局声明，在函数外面声明的变量称为全局变量。如果是在程序开头定义函数之前声明的变量，则在整个源程序文件范围内有效。在函数中声明的变量是局部变量，只在函数范围内有效。关于全局变量和局部变量的概念和用法见本书第章。在本章的例题中没有用全局声明，只有在函数中定义的局部变量。
③函数定义。如例、例和例中的 main函数和例中的 max函数要指定每个函数的功能。在调用这些函数时，会完成函数定义中指定的功能。
函数是C程序的主要组成部分。程序的几乎全部工作都是由各个函数分别完成的，函数是C程序的基本单位，在设计良好的程序中，每个函数都用来实现一个或几个特定的功能。编写C程序的工作主要就是编写一个个函数。
一个C语言程序是由一个或多个函数组成的，其中必须包含一个 main函数且只能有一个 main函数。例 和例中的程序只由一个 main函数组成，例程序由一个 main函数和一个 max函数组成，它们组成一个源程序文件，在进行编译时对整个源程序文件统一进行编译。
一个小程序只包含一个源程序文件，在一个源程序文件中包含若干个函数其中有一个 main函数。当程序规模较大时，所包含的函数的数量较多，如果把所有的函数都放在同一个源程序文件中，则此文件显得太大，不便于编译和调试。为了便于调试和管理，可以使一个程序包含若干个源程序文件，每个源程序文件又包含若干个函数。一个源程序文件就是一个程序模块，即将一个程序分成若干个程序模块。
在进行编译时是以源程序文件为对象进行的。在分别对各源程序文件进行编译并得到相应的目标程序后，再将这些目标程序连接成为一个统一的二进制的可执行程序。
C语言的这种特点使得容易实现程序的模块化。
在程序中被调用的函数，可以是系统提供的库函数例如 printf和scanf函数，也可以是用户根据需要自己编制设计的函数例如例中的 max函数。C的函数库十分丰富，ANSI C建议提供了一百多个标准库函数，不同的C编译系统除了提供标准库函数外，还增加了其他一些专门的函数，如TurboC提供了三百多个库函数。不同编译系统所提供的库函数个数和功能是不完全相同的。
一个函数包括两个部分。
① 函数首部。即函数的第行，包括函数名、函数类型、函数属性、函数参数形式参数名、参数类型。
例如，例中的 max函数的首部为
int
max
int
x
int
y
函数类型
函数名
函数参数类型 函数参数名 函数参数类型 函数参数名
一个函数名后面必须跟一对圆括号，括号内写函数的参数名及其类型。如果函数没有参数，可以在括号中写 void，也可以是空括号，如：
int main void
或
第章 程序设计和C语言
int main
②函数体。即函数首部下面的花括号内的部分。如果在一个函数中包括有多层花括号，则最外层的一对花括号是函数体的范围。
函数体一般包括以下两部分。
·声明部分。声明部分包括：定义在本函数中所用到的变量，如例中在 main函数中定义变量“int a，b，c；”；对本函数所调用函数进行声明，如例 中在 main函数中对 max函数的声明“int max int x int y”。
· 执行部分。由若干个语句组成，指定在函数中所进行的操作。
在某些情况下也可以没有声明部分例如例，甚至可以既无声明部分也无执行部分。如：
void dump
是一个空函数，什么也不做，但这是合法的。
程序总是从 main 函数开始执行的，而不论 main函数在整个程序中的位置如何 main函数可以放在程序最前头，也可以放在程序最后，或在一些函数之前、另一些函数之后。
程序中要求计算机的操作是由函数中的C语句完成的。如赋值、输入输出数据的操作都是由相应的C语句实现的。
C程序书写格式是比较自由的。一行内可以写几个语句，一个语句可以分写在多行上，但为清晰起见，习惯上每行只写一个语句。
在每个数据声明和语句的最后必须有一个分号。分号是C语句的必要组成部分。如：
cab
中的分号是不可缺少的。
C语言本身不提供输入输出语句。输入和输出的操作是由库函数 scanf和 printf等函数来完成的。C语言对输入输出实行“函数化”。由于输入输出操作涉及具体的计算机设备，把输入输出操作用库函数实现，就可以使C语言本身的规模较小，编译程序简单，很容易在各种机器上实现，程序具有可移植性。
程序应当包含注释。一个好的、有使用价值的源程序都应当加上必要的注释，以增加程序的可读性。
运行C程序的步骤与方法
在节中看到的用C语言编写的程序是源程序。计算机不能直接识别和执行用高级语言写的指令，必须用编译程序也称编译器把C源程序翻译成二进制形式的目标程序，然后再将该目标程序与系统的函数库以及其他目标程序连接起来，形成可执行的目标程序。
在编写好一个C源程序后，怎样上机进行编译和运行呢 一般要经过以下几个步骤：
C程序设计第五版
上机输入和编辑源程序。通过键盘向计算机输入程序，如发现有错误，要及时改正。最后将此源程序以文件形式存放在自己指定的文件夹内如果不特别指定，一般存放在用户当前目录下，文件用 c作为后缀，生成源程序文件，如f c。
对源程序进行编译，先用C编译系统提供的“预处理器”又称“预处理程序”或“预编译器”对程序中的预处理指令进行编译预处理。例如，对于 include stdio h指令来说就是将 stdio h头文件的内容读进来取代 include stdio h行。由预处理得到的信息与程序其他部分一起组成一个完整的、可以用来进行正式编译的源程序，然后由编译系统对该源程序进行编译。
编译的作用首先是对源程序进行检查，判定它有无语法方面的错误，如有，则发出“出错信息”，告诉编程人员认真检查改正。修改程序后重新进行编译，如果还有错，再发出“出错信息”。如此反复进行，直到没有语法错误为止。这时，编译程序自动把源程序转换为二进制形式的目标程序在 Visual C中后缀为 obj如f obj。如果不特别指定此目标程序一般也存放在用户当前目录下，此时源文件没有消失。
在用编译系统对源程序进行编译时，自动包括了预编译和正式编译两个阶段，一气呵成。用户不必分别发出二次指令。
进行连接处理。经过编译所得到的二进制目标文件后缀为 obj还不能供计算机直接执行。前面已说明：一个程序可能包含若干个源程序文件，而编译是以源程序文件为对象的，一次编译只能得到与一个源程序文件相对应的目标文件也称目标模块，它只是整个程序的一部分。必须把所有的编译后得到的目标模块连接装配起来，再与函数库相连接成一个整体，生成一个可供计算机执行的目标程序，称为可执行程序 executive program，在 Visual C中其后缀为 exe如 f exe。
即使一个程序只包含一个源程序文件，编译后得到的目标程序也不能直接运行，也要经 过连接阶段，因为要与函数库进行连接，才能生成可执开始行程序。
以上连接的工作是由一个称为“连接编辑程序” linkage editor的软件来实现的。
编辑
源程序
运行可执行程序，得到运行结果。
编译
f c
有
有错
目标程序
无
f obj
以上过程如图所示。其中实线表示操作流程，虚线表示文件的输入输出。例如，编辑后得到一个源程序文件f c，然后在进行编译时再将源程序文件f c输入，经过编译得到目标程序文件f obj，再将所有目标模块输入计算机，与系统提供的库函数等进行连接，得到可执行的目标程序 f exe，最后把 f exe输入计算机，并使之运行，得到结果。
连接
可执行
库函数
目标程序
和其他目
f exe
执行
标程序
不正确
结果
正确
正确
一个程序从编写到运行得到预期结果，并不是一次就能成功的，往往要经过多次反复。编写好的程序并不一定能保证正确无误，除了用人工方式检查外，还须借助编译系统来检查有无语法错误。从图中可以看到： 如果在编译过程中发现错误，应当重新检查
结束
图
第章 程序设计和C语言
源程序，找出问题，修改源程序，并重新编译，直到无错为止。有时编译过程未发现错误，能生成可执行程序，但是运行的结果不正确。一般情况下，这不是语法方面的错误，而可能是程序逻辑方面的错误，例如计算公式不正确、赋值不正确等，应当返回检查源程序，并改正错误。
为了编译、连接和运行C程序，必须要有相应的编译系统。目前使用的很多C编译系统都是集成开发环境IDE的，把程序的编辑、编译、连接和运行等操作全部集中在一个界面上进行，功能丰富，使用方便，直观易用。
在 Windows 环境下用 Visual Studio 比较方便。本书的辅导用书《C程序设计第五版学习辅导》介绍了用 Visual Studio 对C程序进行编辑、编译、连接和运行的方法，读者可以参考。
不应当只会使用一种编译系统，无论用哪一种编译系统，都应当能举一反三，在需要时会用其他编译系统进行工作。
在与本书配套出版的《C程序设计第五版学习辅导》中，详细介绍了常用的C编译工具的使用方法，可供读者上机调试程序时参考。
程序设计的任务
如果只是编写和运行一个很简单的程序，上面介绍的步骤就够了。但是实际上要处理的问题比上面见到的例子复杂得多，需要考虑和处理的问题也复杂得多。程序设计是指从确定任务到得到结果、写出文档的全过程。
从确定问题到最后完成任务，一般经历以下几个工作阶段：
问题分析。对于接手的任务要进行认真的分析，研究所给定的条件，分析最后应达到的目标，找出解决问题的规律，选择解题的方法。在此过程中可以忽略一些次要的因素，使问题抽象化，例如用数学式子表示问题的内在特性。这就是建立模型。
设计算法。即设计出解题的方法和具体步骤。例如要解一个方程式，就要选择用什么方法求解，并且把求解的每一个步骤清晰无误地写出来。一般用流程图来表示解题的步骤。
编写程序。根据得到的算法，用一种高级语言编写出源程序。
对源程序进行编辑、编译和连接，得到可执行程序。
运行程序，分析结果。运行可执行程序，得到运行结果。能得到运行结果并不意味着程序正确，要对结果进行分析，看它是否合理。例如把“ba；”错写为“ab；”，程序不存在语法错误，能通过编译，但运行结果显然与预期不符。因此要对程序进行调试 debug。调试的过程就是通过上机发现和排除程序中故障的过程。经过调试，得到了正确的结果，但是工作不应到此结束。不要只看到某一次结果是正确的，就认为程序没有问题。例如，求cba当ab时求出c的值为是正确的但是当ab时就无法求出c的值。说明程序对某些数据能得到正确结果，对另外一些数据却得不到正确结果，程序还有漏洞，因此，还要对程序进行测试 test。所谓测试，就是设计多组测试数据，检查程序对不同数据的运行情况，从中尽量发现程序中存在的漏洞，并修改程序，使之能适用于各种情况。作为商品提供使用的程序，是必须经过严格测试的。
C程序设计第五版
在本书的配套书《C程序设计第五版学习辅导》中对程序的调试和测试做了进一步的说明，读者可以参考。
编写程序文档。许多程序是提供给别人使用的，如同正式的产品应当提供产品说明书一样，正式提供给用户使用的程序，必须向用户提供程序说明书也称为用户文档。内容应包括程序名称、程序功能、运行环境、程序的装入和启动、需要输入的数据，以及使用注意事项等。
程序文档是软件的一个重要组成部分，软件是计算机程序和程序文档的总称。现在的商品软件光盘中，既包括程序，也包括程序使用说明，有的则在程序中以帮助 help或 readme 形式提供。
习 题
什么是程序 什么是程序设计
为什么需要计算机语言 高级语言有哪些特点
正确理解以下名词及其含义：
源程序，目标程序，可执行程序。
程序编辑，程序编译，程序连接。
程序，程序模块，程序文件。
函数，主函数，被调用函数，库函数。
程序调试，程序测试。
编写一个C程序，运行时输出
Hello World
这个程序是一些国外C教材中作为第一个程序例子介绍的，一般称为 Hello程序。
编写一个C程序，运行时输出以下图形：
编写一个C程序，运行时输入a，b，c三个值，输出其中值最大者。
看懂《C程序设计第五版学习辅导》第 章中介绍的用 Visual Studio 对C 程序进行编辑、编译、连接和运行的方法，并进行以下操作：
建立一个新项目定名为 project。
建立一个新文件定名为 testl。
向test文件输入源程序此源程序为读者自己编写的程序。
编译该源程序，如发现程序有错，请修改之，直到不出现“编译出错”为止。
连接并运行，得到结果。分析结果。
第章 算法——程序的灵魂
通过第章的学习，初步知道了什么是C语言，了解了C语言的特点，看到了几个用C语言编写的简单程序，有的读者可能已经上机运行了简单的C程序，了解了怎样从程序得到运算结果。这些是学习本课程的最基本的准备知识。
但是现在还不能直接开始进行程序设计，因为第章中看到的程序是最简单不过的程序，而实际上需要处理的问题比这复杂得多。为了进行程序设计，还必须掌握更多的知识。
本章的内容并不难，但很重要，是学好后续各章的基础，请读者重视。
程序算法数据结构
一个程序主要包括以下两方面的信息：
对数据的描述。在程序中要指定用到哪些数据，以及这些数据的类型和数据的组织形式。这就是数据结构 data structure。
对操作的描述。要求计算机进行操作的步骤，也就是算法 algorithm。
数据是操作的对象，操作的目的是对数据进行加工处理，以得到期望的结果。打个比方，厨师制作菜肴，需要有菜谱，菜谱上一般应说明：①所用配料，指出为了做出顾客所指定的菜肴，应该使用哪些材料；②操作步骤，指出有了这些原料，应按什么样的步骤进行加工，才能做出所需的菜肴。
没有原料是无法加工成所需菜肴的，而同一些原料可以加工出不同风味的菜肴。作为程序设计人员，必须认真考虑和设计数据结构和操作步骤即算法。著名计算机科学家沃思 Nikiklaus Wirth提出一个公式
算法数据结构程序
直到今天，这个公式对于过程化程序来说依然是适用的。
实际上，一个过程化的程序除了以上两个主要要素之外，还应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言表示。因此，算法、数据结构、程序设计方法和语言工具个方面是一个程序设计人员所应具备的知识，在设计一个程序时要综合运用这几方面的知识。在本书中不可能全面介绍这些内容，它们都属于有关的专门课程范畴。在这个方面中，算法是灵魂，数据结构是加工对象，语言是工具，编程需要采用合适的方法。
算法是解决“做什么”和“怎么做”的问题。程序中的操作语句，实际上就是算法的体现。显然，不了解算法就谈不上程序设计。本书不是一本专门介绍算法的教材，也不是一本只介绍C语言语法规则的使用说明。本书将通过一些实例把以上个方面的知识结合起来，使读者学会考虑解题的思路，并且能正确地编写出C语言程序。
由于算法的重要性，本章先介绍有关算法的初步知识，以便为后面各章的学习建立一定的基础。
C程序设计第五版
什么是算法
做任何事情都有一定的步骤。例如，你想从北京去天津开会，首先要去买火车票，然后按时乘坐地铁到北京站，登上火车，到天津站后坐汽车到会场，参加会议；要考大学，首先要填志愿表，交报名费，拿到准考证，按时参加考试，得到录取通知书，到指定学校报到注册等。这些步骤都是按一定的顺序进行的，缺一不可，次序错了也不行。从事各种工作和活动，都必须事先想好进行的步骤，然后按部就班地进行，才能避免产生错乱。实际上，在日常生活中，由于已养成习惯，所以人们并没意识到每件事都需要事先设计出“行动步骤”。例如吃饭、上学、打球和做作业等，事实上都是按照一定的规律进行的，只是人们不必每次都重复考虑它而已。
不要认为只有“计算”的问题才有算法。广义地说，为解决一个问题而采取的方法和步骤，就称为“算法”。例如，描述太极拳动作的图解，就是“太极拳的算法”。一首乐曲的乐谱，也可以称为该乐曲的算法，因为它指定了演奏该乐曲的每一个步骤，按照它的规定就能演奏出预定的曲子。
对同一个问题，可以有不同的解题方法和步骤。例如，求…， 即有人可能先进行，再加，再加，一直加到，而有的人采取这样的方法：…×。还可以有其他方法。当然，方法有优劣之分。有的方法只须进行很少的步骤，而有些方法则需要较多的步骤。一般来说，希望采用方法简单、运算步骤少的方法。因此，为了有效地进行解题，不仅需要保证算法正确，还要考虑算法的质量，选择合适的算法。
本书所关心的当然只限于计算机算法，即计算机能执行的算法。例如，让计算机算××××，或将个学生的成绩按高低分数的次序排列，是可以做到的，而让计算机去执行“替我理发”或“煎一份牛排”，是做不到的至少目前如此。
计算机算法可分为两大类别： 数值运算算法和非数值运算算法。数值运算的目的是求数值解，例如求方程的根、求一个函数的定积分等，都属于数值运算范围。非数值运算涉及的面十分广泛，最常见的是用于事务管理领域，例如对一批职工按姓名排序、图书检索、人事管理和行车调度管理等。目前，计算机在非数值运算方面的应用远远超过了在数值运算方面的应用。
由于数值运算往往有现成的模型，可以运用数值分析方法，因此对数值运算的算法的研究比较深入，算法比较成熟。对各种数值运算都有比较成熟的算法可供选用。人们常常把这些算法汇编成册写成程序形式，供用户调用。例如有的计算机系统提供“数学程序库”，使用起来十分方便。
非数值运算的种类繁多，要求各异，难以做到全部都有现成的答案，因此只有一些典型的非数值运算算法例如排序算法、查找搜索算法等有现成的、成熟的算法可供使用。许多问题往往需要使用者参考已有的类似算法的思路，重新设计解决特定问题的专门算法。本书不可能罗列所有算法，只是想通过一些典型算法的介绍，帮助读者了解什么是算法，怎样设计一个算法，帮助读者举一反三。希望读者通过本章介绍的例子了解怎样提出问题，怎样思考问题，怎样表示一个算法。
第章 算法——程序的灵魂
简单的算法举例
【例】求××××。
可以用最原始的方法进行：
步骤： 先求乘以，得到结果。
步骤：将步骤得到的乘积再乘以，得到结果。
步骤将再乘以得。
步骤：将再乘以，得。这就是最后的结果。
这样的算法虽然是正确的，但太烦琐。如果要求××…×，则要写个步骤，显然是不可取的。而且每次都要直接使用上一步骤的具体运算结果如，，等，也不方便。应当能找到一种通用的表示方法。
不妨这样考虑： 设置两个变量，一个变量代表被乘数，一个变量代表乘数。不另设变量存放乘积结果，而是直接将每一步骤的乘积放在被乘数变量中。今设变量p为被乘数，变量i为乘数。用循环算法来求结果。可以将算法改写如下：
S令 p或写成⇒p表示将存放在变量p中
S令i或写成⇒i表示将存放在变量i中
S：使p与i相乘，乘积仍放在变量p中，可表示为： pi⇒p
S 使i的值加即i⇒i
S：如果i不大于，返回重新执行S及其后的步骤S和S；否则，算法结束。最后得到 p的值就是！的值。
上面的S，S…代表步骤、步骤 ……S是 Step步的缩写。这是写算法的习惯用法。
请读者仔细分析这个算法，能否得到预期的结果。显然这个算法比前面列出的算法简练。
如果题目改为 求×××××。
算法只须做很少的改动：
S⇒p
S⇒i
S pi⇒p
Si⇒i
S 若i≤返回S否则结束。
其中S 也可以表示为：
S 若i结束否则返回 S。
上面两种写法，作用是相同的。
可以看出用这种方法表示的算法具有一般性、通用性和灵活性。SS 组成一个循环，在满足某个条件i≤时，反复多次执行 S，S 和S步骤，直到某一次执行 S步骤时，发现乘数i已超过事先指定的数值而不返回S为止。此时算法结束，变量p的值就是所求结果。
C程序设计第五版
由于计算机是高速运算的自动机器，实现循环是轻而易举的，所有计算机高级语言中都有实现循环的语句，因此，上述算法不仅是正确的，而且是计算机能方便实现的较好的算法。
请读者仔细分析循环结束的条件，即S。如果在求××…×时，将S写成
S 若返回S。
这样会有什么问题 得到什么结果
【例】 有个学生，要求输出成绩在分以上的学生的学号和成绩。
为描述方便，可以统一用n表示学生学号，用下标i代表第几个学生，n₁ 代表第一个学生的学号，n₁代表第i个学生的学号；统一用g表示学生的成绩，g₁代表第个学生的成绩，g，代表第i个学生的成绩。
本来问题是很简单的：先检查第个学生的成绩g₁，如果它的值大于或等于，就将此成绩输出，否则不输出。然后再检查第个学生的成绩g₂……直到检查完第个学生的成绩g₅₀为止。但是这样表示步骤太多，太烦琐，最好能找到简明的表示方法。
分析此过程的规律，每次检查的内容和处理方法都是相似的，只是检查的对象不同，而检查的对象都是学生的成绩g，只是下标不同从g₁变化到g₅₀。只要有规律地改变下标i的值从，就可以把检查的对象统一表示为gᵢ，这样就可以用循环的方法来处理了。算法可表示如下：
S ⇒i
S 如果gᵢ≥则输出n₁和g₁否则不输出
Si⇒i
S： 如果i≤，返回到步骤S，继续执行，否则，算法结束。
变量i代表下标，先使它的值为，检查g₁g₁到g₅₀都是已知的。然后使i增值，再检查g₁。通过控制i的变化，在循环过程中实现了对个学生的成绩处理。
可以看到，这样表示的算法比最初的表示方法抽象简明，抓住了解题的规律，易于用计算机实现。请读者通过这个简单的例子学会怎样归纳解题的规律，把具体的问题抽象化，设计出简明的算法。
【例】 判定—年中的每一年是否为闰年，并将结果输出。
先分析闰年的条件：
能被 整除但不能被 整除的年份都是闰年如年、年、年、年是闰年
能被 整除的年份是闰年如年、年是闰年。
不符合这两个条件的年份不是闰年。例如年、年不是闰年。
设 year为被检测的年份。算法可表示如下：
S⇒year
S： 若 year不能被整除，则输出 year的值和“不是闰年”。然后转到 S，检查下一个年份
S 若 year能被 整除不能被整除则输出 year的值和“是闰年”。然后转到 S
S 若 year能被整除输出 year的值和“是闰年”然后转到S
S 输出 year的值和“不是闰年”
第章 算法——程序的灵魂
S year⇒year
S当 year≤时转S继续执行否则算法停止。
在这个算法中，采取了多次判断。先判断 year能否被整除，如不能，则 year必然不是闰年。如year能被整除，并不能马上决定它是否闰年，还要检查它能否被整除。如不能被整除，则肯定是闰年例如年。如能被整除，还不能判断它是否闰年，还要检查它能否被整除，如果能被整除，则是闰年；否则不是闰年。
在这个算法中，每做一步，都分别分离出一些范围已能判定为闰年或非闰年，逐步缩 小范围，使被判断的范围愈来愈小，直至执行S时，只可能是非闰年，见图。① year不能被
被整除
从图可以看出：“其他”这一部分，包括不能被 整除的年份，以及能被 整除，又能被 整除，但不能被整除的那些年份如年 ，它们都是非闰年。
非闰年
③
year被
② year被整除
整除， 又能
但不能被
被整除
整除
考虑算法时，应当仔细分析所需判断的条件，如何一步一步缩小检查判断的范围。对有的问题，判断的先后次序是无所谓的；而有的问题，判断条件的先后次序是不能任意颠倒的，读者可根据具体问题决定其逻辑。
闰年
闰年
【例】 求
④其他
非闰年
解题思路： 表面看，每一项都不一样，但稍加分析，就可以看到：
①第项的分子分母都是，即
图
②第项的分母是，以后每一项的分母都是前一项的分母加；
③第项前的运算符为“一”，后一项前面的运算符都与前一项前的运算符相反。
这就找到了多项式的规律，能把多项式表示为一般形式，即把问题抽象化了。
有此基础就可以写出下面的算法，用sign代表当前处理的项前面的数值符号， term代表当前项的值。 sum 表示当前各项的累加和， deno是当前项的分母英文 denominator的缩写。本例中用有含义的单词作变量名，以使算法更易于理解。
S sign
S sum
S deno
S sign sign
S term sign deno
S sum sum term
S deno deno
S 若 deno≤返回 S否则算法结束。
在S中先预设 sign的值为 sign代表多项式中当前项的符号，它的值为或。在 S中使 sum等于，相当于已将多项式中的第一项加到了 sum中了，后面应该从第项开始累加。在S中使分母的值为，它是第项的分母。在S中使 sign的值变为，此
C程序设计第五版
时它代表第项的符号。在S 中求出多项式中第项的值。在S中将刚才求出的第项的值累加到 sum中。至此 sum 的值是。在S中使分母 deno的值加变成。执行S由于deno≤故返回S sign的值改为在S 中求出 term的值为，在S中将累加到 sum中。然后S 再使分母变为。按此规律反复执行SS步骤，直到分母大于为止。一共执行了次循环，向 sum累加入了个分数。 sum 最后的值就是多项式的值。
【例】 给出一个大于或等于的正整数，判断它是不是一个素数。
解题思路： 所谓素数 prime，是指除了和该数本身之外，不能被其他任何整数整除的数。例如是素数因为它不能被…整除。
判断一个数 nn≥是否为素数的方法是很简单的： 将n作为被除数，将n的各个整数先后作为除数，如果都不能被整除，则n为素数。
算法可以表示如下：
S 输入n的值
Si i作为除数
S n被i除得余数r
S：如果r，表示 n能被i整除，则输出n“不是素数”，算法结束；否则执行S
Si⇒i
S： 如果i≤n，返回S；否则输出n的值以及“是素数”，然后结束
实际上，n不必被n的整数除，只须被n的整数除即可，甚至只须被的整数除即可。例如，判断是否为素数，只须将被和除即可，如都除不尽，n必为素数。S步骤可改为
S如果返回S；否则算法结束
通过以上几个例子，可以初步了解怎样设计一个简单的算法。
算法的特性
在节了解了几种简单的算法，这些算法是可以在计算机上实现的。为了能编写程序，必须学会设计算法。不要以为任意写出的一些执行步骤就构成一个有效且好的算法。一个有效算法应该具有以下特点。
有穷性。一个算法应包含有限的操作步骤，而不能是无限的。例如例的算法，如果将S步骤改为：“若 deno，返回S”，则循环永远不会停止，这不是有穷的步骤。事实上， “有穷性”往往指“在合理的范围之内”。如果让计算机执行一个历时年才结束的算法，这虽然是有穷的，但超过了合理的限度，人们也不把它视为有效算法。究竟什么算“合理限度”，由人们的常识和需要判定。
确定性。算法中的每一个步骤都应当是确定的，而不应当是含糊的、模棱两可的。例如，有一个健身操的动作要领，其中有一个动作：“手举过头顶”，这个步骤就是不确定的，含糊的。是双手都举过头 还是左手或右手 举过头顶多少厘米 不同的人可以有不同的理解。算法中的每一个步骤应当不致被解释成不同的含义，而应是明确无误的。如例中的S步骤如果写成“n被一个整数除，得余数r”，这也是不确定的，它没有说明 n被哪个
第章 算法——程序的灵魂
整数除，因此无法执行。也就是说，算法的含义应当是唯一的，而不应当产生“歧义性”。所谓“歧义性”，是指可以被理解为两种或多种的可能含义。
有零个或多个输入。所谓输入是指在执行算法时需要从外界取得必要的信息。例如，在执行例算法时，需要输入n的值，然后判断n是否为素数。也可以有两个或多个输入，例如，求两个整数m和n的最大公约数，则需要输入m 和n的值。一个算法也可以没有输入，例如，例在执行算法时不需要输入任何信息，就能求出！。
有一个或多个输出。算法的目的是为了求解， “解”就是输出。如例求素数的算法，最后输出的n“是素数”或“不是素数”就是输出的信息。但算法的输出并不一定就是计算机的打印输出或屏幕输出，一个算法得到的结果就是算法的输出。没有输出的算法是没有意义的。
有效性。算法中的每一个步骤都应当能有效地执行，并得到确定的结果。例如，若b，则执行ab是不能有效执行的。
对于一般最终用户来说，他们并不需要在处理每一个问题时都要自己设计算法和编写程序，可以使用别人已设计好的现成算法和程序，只须根据已知算法的要求给予必要的输入，就能得到输出的结果。对使用者来说，已有的算法如同一个“黑箱子”一样，他们可以不了解“黑箱子”中的结构，只是从外部特性上了解算法的作用，即可方便地使用算法。例如，对一个“输入个数，求其中最大值”的算法，可以用图表示，只要输入a，b，c这个数，执行算法后就能得到其中最大的数。
对于程序设计人员来说，必须学会设计常用的算法，并且根据算法编写程序。
怎样表示一个算法
为了表示一个算法，可以用不同的方法。常用的方法有：自然语言、传统流程图、结构化流程图和伪代码等。
用自然语言表示算法
第节介绍的算法是用自然语言来表示的，自然语言就是人们日常使用的语言，可以是汉语、英语或其他语言。用自然语言表示通俗易懂，但文字冗长，容易出现歧义。自然语言表示的含义往往不大严格，要根据上下文才能判断其正确含义。例如有这样一句话：“张先生对李先生说他的孩子考上了大学”， 请问是张先生的孩子考上大学还是李先生的孩子考上大学呢 光从这句话本身难以判断。此外，用自然语言来描述包含分支和循环的算法不大方便如例的算法。因此，除了那些很简单的问题以外，一般不用自然语言表示算法。
用流程图表示算法
流程图是用一些图框来表示各种操作。用图形表示算法，直观形象，易于理解。美国国家标准化协会 American National Standard Institute ANSI规定了一些常用的流程图符号见图，已为世界各国程序工作者普遍采用。
图中菱形框的作用是对一个给定的条件进行判断，根据给定的条件是否成立决定
C程序设计第五版
如何执行其后的操作。它有一个入口，两个出口，见图。
起止框
输入输出框
判断框
处理框
或
流程线
Y
N
x≥
连接点
输出x
输出x
注释框
图
图
连接点小圆圈是用于将画在不同地方的流程线连接起来。如图中有两个以①为标志的连接点，它表示这两个点是连接在一起的，实际上它们是同一个点，只是画不下才分开来画。用连接点可以避免流程线交叉或过长，使流程图清晰。注释框不是流程图中必要的部分，不反映流程和操作，只是为了对流程图中某些框的操作作必要的补充说明，以帮助阅读流程图的人更好地理解流程图的作用。
下面将节中所举的几个算法例子，改用流程图表示。
【例】 将例的算法用流程图表示。求××××。
按照流程图的规定，把算法用图所示的流程图表示。菱形框两侧的 Y和N代表“是” Yes和“否” No。
如果需要将最后结果输出，可以在菱形框的下面再加一个输出框，见图。
开始
⇒t
开始
⇒t
①
③
②
N
③
③
Y
N
输出t
①
Y
②
结束
结束
图
图
图
第章 算法——程序的灵魂
【例】 例的算法用流程图表示。有个学生，要求输出成绩在分以上的学生的学号和成绩。
流程图见图，在此算法中没有包括输入个学生数据的部分。如果包括这个输入数据的部分，流程图如图所示。
开始
⇒i
为第i个
输入
学生的学号和
成绩
开始
N
⇒i
Y
Y
N
Y
N
输出n₁、g
输出n₁、 gi
N
N
Y
Y
结束
结束
图
图
【例】 例判定闰年的算法用流程图表示。判定—年中的每一年是否为闰年，将结果输出。
流程图见图。显然，用图 表示算法要比用文字描述算法逻辑清晰、易于理解。
请读者考虑，如果例所表示的算法中，S步骤内没有最后“转到S”这一句话，而只是：
S 若 year不能被 整除则输出y“不是闰年”
这样就意味着执行完S步骤后，不论S的执行情况如何都应执行S步骤。请读者画出相应的流程图。请思考这样的算法在逻辑上有什么错误 从流程图上是很容易发现逻辑上的错误的。
【例】 将例 的算法用流程图表示。求
流程图见图。
【例】 例判断素数的算法用流程图表示。对一个大于或等于的正整数，判断它是不是一个素数。
流程图见图。
C程序设计第五版
开始
year不能被
Y
整除
N
year不能被
N
整除
Y
Y
year不能被
N
输出 year
整除
“是闰年”
输出 year
输出 year
输出 year
不是闰年”
“是闰年”
“不是闰年”
N
Y
结束
图
开始
开始
⇒sum
输入n
⇒deno
⇒
i
⇒sign
ni的余数⇒r
Y
term
r
N
sum term
sum
输出n
“不是素数”
deno
deno
N
N
deno
Y
Y
输出n
“是素数”
输出 sum
结束
结束
图
图
第章 算法——程序的灵魂
通过以上几个例子可以看出流程图是表示算法的较好的工具。一个流程图包括以下几部分。
表示相应操作的框；
带箭头的流程线；
框内外必要的文字说明。
需要提醒的是： 流程线不要忘记画箭头，因为它是反映流程的先后的，如不画出箭头就难以判定各框的执行次序了。
用流程图表示算法直观形象，比较清楚地显示出各个框之间的逻辑关系。有一段时期国内外计算机书刊都广泛使用这种流程图表示算法。但是，这种流程图占用篇幅较多，尤其当算法比较复杂时，画流程图既费时又不方便。在结构化程序设计方法推广之后，许多书刊已用NS结构化流程图代替这种传统的流程图见节，但是每一个程序编制人员都应当熟练掌握传统流程图，会看会画。
三种基本结构和改进的流程图
传统流程图的弊端
传统的流程图用流程线指出各框的执行顺序，对流程线的使用没有严格限制。因此，使用者可以不受限制地使流程随意地转来转去，使流程图变得毫无规律，阅读时要花很大精力去追踪流程，使人难以理解算法的逻辑。这种情况如图所示，这种如同乱麻一样的算法称为BS型算法意为一碗面条a bowl of spaghetti毫无头绪。
像图这样的算法是不好的，难以阅读，也难以修改，从而使算法的可靠性和可维护性难以保证。如果写出的算法能限制流程的无规律任意转向，像一本书那样由各章各节顺序组成，那么阅读起来就很方便，不会有任何困难，只须从头到尾顺序地看下去即可。而如果一本书不是由各章节顺序组成，而是毫无规律地乱排，例如第章从页开始到页，第章从页到页，第章从页到页……各章内各节也是毫无规律地乱排，阅读这种书是不会感到愉快的。
为了提高算法的质量，使算法的设计和阅读方便，必须限制箭头的滥用，即不允许无规律地使流程随意转向，只能顺序地进行下去。但是，算法上难免会包含一些分支和循环，而不可能全部由一个个顺序框组成。例如图图都不是由各框顺序进行的，都包含一些流程的向前或向后的非顺序转向。为了解决这个问题，人们规定出几种基本结构，然后由这些基本结构按一定规律组成一个算法结构如同用一些基本预制构件来搭成房屋一样，如果能做到这一点，算法的质量就能得到保证和提高。
三种基本结构
年， Bohra 和 Jacopini 提出了以下种基本结构，用这种基本结构作为表示一个良好算法的基本单元。
C程序设计第五版
顺序结构。如图所示，虚线框内是一个顺序结构。其中A和B两个框是顺序执行的。即：在执行完A框所指定的操作后，必然接着执行B框所指定的操作。顺序结构是最简单的一种基本结构。
选择结构。选择结构又称选取结构或分支结构，如图所示。虚线框内是一个选择结构。此结构中必包含一个判断框。根据给定的条件p是否成立而选择执行 A框或B框。例如p条件可以是 x≥或xyabcd等。
注意： 无论p条件是否成立，只能执行A框或B框之一，不可能既执行A 框又执行B框。无论走哪一条路径，在执行完A或B之后，都经过b点，然后脱离本选择结构。A或B两个框中可以有一个是空的，即不执行任何操作，如图所示。
a
a
a
成立
不成立
成立
p
不成立
A
p
A
A
B
B
b
b
b
图
图
图
循环结构。又称重复结构，即反复执行某一部分的操作。有两类循环结构。
①当型 while型循环结构。当型循环结构如图a所示。它的作用是： 当给定的条件p成立时，执行A框操作，执行完A后，再判断条件p是否成立，如果仍然成立，再执行A框，如此反复执行 A框，直到某一次 p条件不成立为止，此时不执行 A 框，而从b点脱离循环结构。
②直到型 until 型循环结构。直到型循环结构如图b所示。它的作用是：先执行A框，然后判断给定的p条件是否成立，如果p条件不成立，则再执行A，然后再对p条件作判断，如果p条件仍然不成立，又执行 A……如此反复执行A，直到给定的p条件成立为止，此时不再执行A，从b点脱离本循环结构。
图是当型循环的应用例子，图是直到型循环的应用例子。
a
a
输出x值
A
A
输出x
P
不成立
不成立
成立
成立
Y
N
b
b
N
Y
a while型
b until型
图
图
图
第章 算法——程序的灵魂
图和图的作用都是输出个数：，，，，。可以看到：对同一个问题既可以用当型循环来处理，也可以用直到型循环来处理。
以上种基本结构，有以下共同特点：
只有一个入口。图图中的a点为入口点。
只有一个出口。图图中的b点为出口点。请注意，一个判断框有两个出口，而一个选择结构只有一个出口。不要将判断框的出口和选择结构的出口混淆。
结构内的每一部分都有机会被执行到。也就是说，对每一个框来说，都应当有一条从入口到出口的路径通过它。图中没有一条从入口到出口的路径通过A框。
结构内不存在“死循环”无终止的循环。图就是一个死循环。
A
A
P₁
B
图
图
由以上种基本结构顺序组成的算法结构，可以解决任何复杂的问题。由基本结构所构成的算法属于“结构化”的算法，它不存在无规律的转向，只在本基本结构内才允许存在分支和向前或向后的跳转。
其实，基本结构并不一定只限于上面种，只要具有上述个特点的都可以作为基本结构。人们可以自己定义基本结构，并由这些基本结构组成结构化程序。例如，也可以将图和图这样的结构定义为基本结构。图 所示的是一个多分支选择结构，根据给定的表达式的值决定执行哪一个框。图 和图 虚线框内的结构也只有一个入口和一个出口，并且具有上述全部的个特点。由它们构成的算法结构也是结构化的算法。但是，可以认为像图和图那样的结构是由种基本结构派生出来的。因此，人们普遍认为最基本的是本节介绍的种基本结构。
a
根据表达式的
值进行选择
a
pP₁
pP₂
p Pr
p Pn
M
N
A
B
A
B
P
成立
不成立
b
b
图
图
C程序设计第五版
用 NS流程图表示算法
既然用基本结构的顺序组合可以表示任何复杂的算法结构，那么，基本结构之间的流程线就是多余的了。
年美国学者I Nassi 和 B Shneiderman 提出了一种新的流程图形式。在这种流程图中，完全去掉了带箭头的流程线。全部算法写在一个矩形框内，在该框内还可以包含其他从属于它的框，或者说，由一些基本的框组成一个大的框。这种流程图又称NS结构化流程图N和S是两位美国学者的英文姓氏的首字母。这种流程图适于结构化程序设计，因而很受欢迎。
NS流程图用以下的流程图符号。
顺序结构。顺序结构用图形式表示。A和B两个框组成一个顺序结构。
选择结构。选择结构用图 表示。它与图 所表示的意思是相同的。当p条件成立时执行A操作，p不成立则执行B操作。注意：图 是一个整体，代表一个基本结构。
循环结构。当型循环结构用图形式表示，当p条件成立时反复执行A操作，直到 p条件不成立为止。
直到型循环结构用图形式表示。
p
当p₁成立
成立
不成立
A
A
A
B
A
B
直到p₁成立
图
图
图
图
在初学时，为清楚起见，可如图和图 那样，写明“当 pl成立”或“直到 p成立”，待熟练之后，可以不写“当”和“直到”字样，只写“p”和“p”。从图的形状即可知道是当型还是直到型。
用以上种 NS流程图中的基本框可以组成复杂的 NS流程图，以表示算法。
p≥
成立
不成立
A
应当说明，在图图中的A框或B框，可以是一个简单的操作如读入数据或打印输出等，也可以是种基本结构之一。例如，图所示的顺序结构，其中的A框可以又是一个选择结构，B框可以又是一个循环结构。如图所示那样，由A 和B这两个基本结构组成一个顺序结构。
r
r
当n≤
B
p·r⇒p
通过下面的几个例子，读者可以了解如何用NS流程图表示算法。
图
【例】 将例的求算法用NS图表示。
NS图见图它和图对应。
【例】 将例的算法用NS图表示。输出名学生中成绩高于分者的学号和成绩。
NS图见图和图它和图和图对应。
第章 算法——程序的灵魂
⇒i
是 gi≥ 否
⇒t⇒iti⇒ti⇒i直到i输出t
⇒i 输入n和 gi i⇒i直到i⇒igi≥是否输出n₁、 gii⇒i直到i
输出n和g
i⇒i
直到i
图 图 图
【例】 将例判定闰年的算法用NS图表示。NS图见图它和图对应。
【例】 将例的算法用NS图表示。求NS图见图它和图对应只是最后加了一个“输出 sum”框。
⇒year
year的余数为
是
否
year的余数
⇒sum
不为
是
否
⇒deno
year的余数
输出 year
⇒sign
为
“非闰年”
输出 year
是
否
“是闰年”
signdeno⇒term
输出 year
输出 year
sumterm⇒sum
“是闰年”
“非闰年”
deno⇒deno
year⇒year
直到 deno
直到 year
输出 sum
图
图
【例】 将例判别素数的算法用NS流程图表示。
在例中用传统流程图图。可以看出，图不是由种基本结构组成的。图中间的循环部分有两个出口一个从第个判断框右面出口，另一个在第个判断框下边出口，不符合基本结构的特点。由于不能分解为种基本结构，就无法直接用NS流程图的种基本结构的符号来表示。因此，应当先对图作必要的变换。要将第个判断框的两个出口汇合在一点，以解决两个出口问题。当r时意味着 n为非素数，但此时不马上输出n“不是素数”的信息，而只使标志变量 w的值由改为w的值为w。如果 r≠则保持w见图。
w的作用如同一个开关一样，有两种工作状况： w和w，可以从一种状态转换到另一状态。当w时表示被检查的数n为非素数。如果最终 w，则表示 n为素数。将框的出口线改为指向第个判断框，同时将第个判断框中的条件改为和w，即只有当和w两个条件都满足时才继续执行循环。如果出现或 w≠
C程序设计第五版
之一，都不会继续执行循环见图。
如果在某一次 r，则应执行⇒w，然后，由第个判断框判断为“条件不成立”，接着执行图下部的选择结构。此时，由于表示 n不是素数，故应输出 n不是素数的信息。如果，则表示在上面的每次循环中，n都不能被每一个i整除，所以n是素数，故输出 n是素数的信息。
图已变成由种基本结构组成的流程图。可以改用 NS图表示此算法，见图。注意，图 直到型循环的判断条件为直到 in或即只要 in或之一成立，就不再继续执行循环。这和图菱形框中的表示形式和正好相反，请读者考虑为什么。
开始
输入n
ni的余数⇒r
Y
N
Y
和
输入n
⇒w
N
⇒i
Y
N
ni的余数⇒r
w
r
是 否
输出n
输出n
⇒w
“是素数”
“不是素数”
直到或w≠
w
是 否
结束
输出n“是素数” 输出n“不是素数”
图
图
通过以上几个例子，可以看出用NS图表示算法的优点。它比文字描述直观、形象、易于理解；比传统流程图紧凑易画，尤其是它废除了流程线，整个算法结构是由各个基本结构按顺序组成的，NS流程图中的上下顺序就是执行时的顺序，也就是图中位置在上面的先执行，位置在下面的后执行。写算法和看算法只须从上到下进行就可以了，十分方便。用NS图表示的算法都是结构化的算法它不可能出现流程无规律的跳转，而只能自上而下地顺序执行。
第章 算法——程序的灵魂
归纳起来可知：一个结构化的算法是由一些基本结构顺序组成的；在基本结构之间不存在向前或向后的跳转，流程的转移只存在于一个基本结构范围之内如循环中流程的跳转；一个非结构化的算法如图可以用一个等价的结构化算法如图代替，其功能不变。如果一个算法不能分解为若干个基本结构，则它必然不是一个结构化的算法。
NS图如同一个多层的盒子又称盒图 box diagram。
用伪代码表示算法
用传统的流程图和NS图表示算法直观易懂，但画起来比较费事，在设计一个算法时，可能要反复修改，而修改流程图是比较麻烦的。因此，流程图适于表示一个算法，但在设计算法过程中使用不是很理想尤其是当算法比较复杂、需要反复修改时。为了设计算法时方便常用一种称为伪代码 pseudo code的工具。
伪代码是用介于自然语言和计算机语言之间的文字和符号来描述算法。它如同一篇文章一样，自上而下地写下来。每一行或几行表示一个基本操作。它不用图形符号，因此书写方便，格式紧凑，修改方便，容易看懂，也便于向计算机语言算法即程序过渡。
用伪代码写算法并无固定的、严格的语法规则，可以用英文，也可以中英文混用。只要把意思表达清楚，便于书写和阅读即可，书写的格式要写成清晰易读的形式。
【例】 求！，用伪代码表示的算法如下：
begin 算法开始
⇒t
⇒i
while i≤
ti⇒t
i⇒i
print t
end 算法结束
在本算法中采用当型循环第行是一个当型循环。while意思为“当”，它表示当i≤时执行循环体花括号中两行的操作。
【例 】 求
用伪代码表示的算法如下：
begin
⇒sum
⇒deno
⇒sign
while deno≤
sign⇒sign
signdeno→term
sumterm⇒sum
deno⇒deno
C程序设计第五版
print sum
end
从以上例子可以看到：伪代码书写格式比较自由，容易表达出设计者的思想。同时，用伪代码写的算法很容易修改，例如加一行或删一行，或将后面某一部分调到前面某一位置，都是很容易做到的。而这却是用流程图表示算法时所不便处理的。用伪代码很容易写出结构化的算法。例如上面几个例子都是结构化的算法。但是用伪代码写算法不如流程图直观，可能会出现逻辑上的错误例如循环或选择结构的范围弄错等。
上面介绍了常用的表示算法的几种方法，在程序设计中读者可以根据需要和习惯选用。软件专业人员一般习惯使用伪代码，考虑到国内广大初学人员的情况，为便于理解，在本书中主要采用形象化的NS图表示算法。但是，读者应对其他方法也有所了解，以便在阅读其他书刊时不致发生困难。
用计算机语言表示算法
要完成一项工作，包括设计算法和实现算法两个部分。例如，作曲家创作一首乐谱就是设计一个算法，但它仅仅是一个乐谱，并未变成音乐，而作曲家的目的是希望使人们听到悦耳动人的音乐。演奏家按照乐谱的规定进行演奏，就是“实现算法”。在没有人实现它时，乐谱是不会自动发声的。一个菜谱是一个算法，厨师炒菜就是在实现这个算法。设计算法的目的是为了实现算法。因此，不仅要考虑如何设计一个算法，也要考虑如何实现一个算法。
到目前为止，只讲述了描述算法，即用不同的方法来表示操作的步骤。而要得到运算结果，就必须实现算法。实现算法的方式可能不止一种。例如对例求！表示的算法，可以用人工心算的方式实现而得到结果。也可以用笔算或算盘、计算器来求出结果，这都是实现算法。
我们考虑的是用计算机解题，也就是要用计算机实现算法，而计算机是无法识别流程图和伪代码的，只有用计算机语言编写的程序才能被计算机执行，因此在用流程图或伪代码描述一个算法后，还要将它转换成计算机语言程序。用计算机语言表示的算法是计算机能够执行的算法。
用计算机语言表示算法必须严格遵循所用的语言的语法规则，这是和伪代码不同的。下面将前面介绍过的算法用C语言表示。
【例】 将例表示的算法求用C语言表示。
include stdio h
int main
int it
t
i
whilei
ii
第章 算法——程序的灵魂
printfdnt
return
【例】 将例 表示的算法求多项式的值用C语言表示。
include stdio h
int main
int sign
double deno sum term 定义 deno sum term为双精度型变量
while deno
signsign
term sign deno
sum sum term
deno deno
printffn sum
return
读者只须大体看懂即可，在以后各章中会详细介绍C语言有关的使用规则。
应当强调说明的是，写出了C程序，仍然只是描述了算法，并未实现算法。只有运行程序才是实现算法。
结构化程序设计方法
前面介绍了结构化的算法和种基本结构。一个结构化程序就是用计算机语言表示的结构化算法，用种基本结构组成的程序必然是结构化的程序。这种程序便于编写、阅读、修改和维护，这就减少了程序出错的机会，提高了程序的可靠性，保证了程序的质量。
结构化程序设计强调程序设计风格和程序结构的规范化，提倡清晰的结构。怎样才能得到一个结构化的程序呢 如果面临一个复杂的问题，是难以一下子写出一个层次分明、结构清晰、算法正确的程序的。结构化程序设计方法的基本思路是： 把一个复杂问题的求解过程分阶段进行，每个阶段处理的问题都控制在人们容易理解和处理的范围内。
具体说，采取以下方法来保证得到结构化的程序：
自顶向下
逐步细化
模块化设计；
结构化编码。
在接受一个任务后应怎样着手进行呢 有两种不同的方法：一种是自顶向下，逐步细
C程序设计第五版
化；一种是自下而上，逐步积累。以写文章为例来说明这个问题。有的人胸有全局，先设想好整个文章分成哪几个部分，然后再进一步考虑每一部分分成哪几节，每一节分成哪几段，每一段应包含什么内容，如图示意。
工作报告
顶层设计
单位概况
前一阶段工作情况
当前遇到的问题
今后打算
第二层
第
第
设计
第
一
二
三
点
点
点
第三层
设计
图
用这种方法逐步分解，直到作者认为可以直接将各小段表达为文字语句为止。这种方法就叫做“自顶向下，逐步细化”。
另有些人写文章时不拟提纲，如同写信一样提笔就写，想到哪里就写到哪里，直到他认为把想写的内容都写出来了为止。这种方法叫做自下而上，逐步积累。
显然，用第一种方法考虑周全，结构清晰，层次分明，作者容易写，读者容易看。如果发现某一部分中有一段内容不妥，需要修改，只须找出该部分，修改有关段落即可，与其他部分无关。提倡用这种方法设计程序，这就是用工程的方法设计程序。
设计房屋就是用自顶向下、逐步细化的方法。先进行整体规划，然后确定建筑物方案，再进行各部分的设计，最后进行细节的设计如门窗、楼道等，而绝不会在没有整体方案之前先设计楼道和厕所。而在完成设计，有了图纸之后，在施工阶段则是自下而上实施的，用一砖一瓦先实现一个局部，然后由各部分组成一个建筑物。
应当掌握自顶向下、逐步细化的设计方法。这种设计方法的过程是将问题求解由抽象逐步具体化的过程。如图所示，最开始拿到的题目是作“工作报告”，这是一个很笼统而抽象的任务，经过初步考虑之后把它分成个大的部分。这就比刚才具体一些了，但还不够具体。这一步只是粗略地划分，称为“顶层设计”。然后一步一步细化，依次称为第层、第层设计，直到不需要细分为止。
用这种方法便于验证算法的正确性，在向下一层展开之前应仔细检查本层设计是否正确，只有上一层是正确的才能向下细化。如果每一层设计都没有问题，则整个算法就是正确的。由于每一层向下细化时都不太复杂，因此容易保证整个算法的正确性。检查时也是由上而下逐层检查，这样做，思路清楚，有条不紊地一步一步地进行，既严谨又方便。
在程序设计中常采用模块设计的方法，尤其当程序比较复杂时，更有必要。在拿到一个程序模块实际上是程序模块的任务书以后，根据程序模块的功能将它划分为若干个子模块，如果这些子模块的规模还嫌大，可以再划分为更小的模块。这个过程采用自顶向下的方法来实现。
第章 算法——程序的灵魂
程序中的子模块在C语言中通常用函数来实现有关函数的概念将在第章中介绍。
程序中的子模块一般不超过行，即把它打印输出时不超过一页，这样的规模便于组织，也便于阅读。划分子模块时应注意模块的独立性，即使用一个模块完成一项功能，耦合性愈少愈好。模块化设计的思想实际上是一种“分而治之”的思想，把一个大任务分为若干个子任务，每一个子任务就相对简单了。
结构化程序设计方法用来解决人脑思维能力的局限性和被处理问题的复杂性之间的矛盾。
在设计好一个结构化的算法之后，还要善于进行结构化编码 coding。所谓编码就是将已设计好的算法用计算机语言来表示，即根据已经细化的算法正确地写出计算机程序。结构化的语言如 PascalC Visual Basic等都有与种基本结构对应的语句进行结构化编程序是不困难的。
本章的内容是十分重要的，是学习后面各章的基础。学习程序设计的目的不只是为了掌握某一种特定的语言，而应当学习程序设计的一般方法。脱离具体的语言去学习程序设计是困难的，但是，学习语言是为了设计程序，它本身绝不是目的。高级语言有许多种，每种语言也都在不断发展，因此千万不能只拘泥于一种具体的语言，而应当能举一反三，在需要的时候能很快地使用另一种语言编程。关键是掌握算法，有了正确的算法，用任何语言进行编码都不是什么困难的事。
本章只是初步介绍了有关算法的基本知识，并没有深入介绍如何设计各种类型的算法。在以后各章中将结合程序实例陆续介绍有关的算法。
习 题
什么是算法 试从日常生活中找个例子，描述它们的算法。
什么叫结构化的算法 为什么要提倡结构化的算法
试述种基本结构的特点，请另外设计两种基本结构要符合基本结构的特点。
用传统流程图表示求解以下问题的算法。
有两个瓶子A和B，分别盛放醋和酱油，要求将它们互换即A 瓶原来盛醋，现改盛酱油，B瓶则相反。
依次将个数输入，要求输出其中最大的数。
有个数a，b，c，要求按大小顺序把它们输出。
求…。
判断一个数 n能否同时被 和 整除。
将之间的素数输出。
求两个数m和n的最大公约数。
求方程式的根。分别考虑：
①有两个不等的实根；
②有两个相等的实根。
用NS图表示第题中各题的算法。
用伪代码表示第题中各题的算法。
C程序设计第五版
什么叫结构化程序设计 它的主要内容是什么
用自顶向下、逐步细化的方法进行以下算法的设计：
输出—年中是闰年的年份，符合下面两个条件之一的年份是闰年：
① 能被 整除但不能被整除；
②能被整除且能被整除。
求的根。分别考虑大于、等于和小于这种情况。
输入个数，输出其中最大的一个数。
第章 最简单的C程序设计
——顺序程序设计
有了前两章的基础，现在可以开始由浅入深地学习C语言程序设计了。
为了能编写出C语言程序，必须具备以下的知识和能力：
要有正确的解题思路，即学会设计算法，否则无从入手。
掌握C语言的语法，知道怎样使用C语言所提供的功能编写出一个完整的、正确的程序。也就是在设计好算法之后，能用C语言正确表示此算法。
在写算法和编写程序时，要采用结构化程序设计方法，编写出结构化的程序。
算法的种类很多，不可能等到把所有算法都学透以后再来学习编程序。C语言的语法规定很多，很烦琐，孤立地学习语法不但枯燥乏味，而且即使倒背如流，也不一定能写出一个好的程序，必须找到一种有效的学习方法。
本书的做法是： 以程序设计为主线，把算法和语法紧密结合起来，引导读者由易及难地学会编写C程序。对于简单的程序，算法比较简单，程序中涉及的语法现象也比较简单一般只用到简单的变量、简单的输出格式。对于比较复杂的算法，程序中用到的语法现象也比较复杂例如要使用数组、指针和结构体等。
本章先从简单的程序开始，介绍简单的算法，同时介绍最基本的语法现象，使读者具有编写简单的程序的能力。在此基础上，逐步介绍复杂一些的程序，介绍比较复杂的算法，同时介绍较深入的语法现象，把算法与语法有机地结合起来，由浅入深，由简单到复杂，使读者很自然地、循序渐进地学会编写程序。
顺序程序设计举例
【例】 有人用温度计测量出用华氏法表示的温度如，今要求把它转换为以摄氏法表示的温度如
解题思路：这个问题的算法很简单，关键在于找到二者间的转换公式。根据物理学知识，知道以下转换公式：
输入f的值
其中f代表华氏温度，c代表摄氏温度。据此可以用NS图表示算法见图。
输出c的值
算法由个步骤组成，这是一个简单的顺序结构。
图
编写程序： 有了 NS图，很容易用C语言表示，写出求此问题的C程序。
include stdio h
int main
C程序设计第五版
float fc 定义f和c为单精度浮点型变量
f 指定f的值
cf 利用公式计算c的值
printfff ncfnfc 输出 c的值
return
运行结果：
f
c
读者应能看懂这个简单的程序。
【例】 计算存款利息。有元，想存一年。有种方法可选：活期，年利率为 rl；一年期定期，年利率为r；存两次半年定期，年利率为r。请分别计算出一年后按种方法所得到的本息和。
解题思路： 关键是确定计算本息和的公式。从数学知识可知，若存款额为 p，则：
活期存款一年后本息和为ppr。
一年期定期存款，一年后本息和为 ppr。
两次半年定期存款，一年后本息和为
画出NS流程图见图。
编写程序： 按照 NS图所表示的算法，很容易写出C程序。
include stdio h
输入prrr的值计算ppr计算 ppr计算pp¹²¹²输出 ppp
int main
float prr rppp
定义变量
图
ppr 计算活期本息和
ppr 计算一年定期本息和
pprr 计算存两次半年定期的本息和
printfpfnpfnpfnppp 输出结果
return
运行结果：
p
p
p
第行是活期存款一年后本息和，第行是一年期定期存款一年后本息和，第行是两次半年定期存款一年后本息和。
程序分析： 第行，在定义实型变量 pppprrr 的同时对变量prrr赋予初值。
第行，在输出p，p 和p的值之后，用n使输出换行。
第章 最简单的C程序设计——顺序程序设计
注意： 在VisualC 系统中对以上两个程序进行编译时，会显示出“警告”信息。这是因为编译系统把所有实数都作为双精度数处理。因此提醒用户：把双精度常量转换成 float型会造成精度损失。对这类“警告”，用户知道是怎么回事就可以了。承认此现实，让程序继续进行连接和运行，不影响运行结果。如果用GCC编译系统，则不会出现此“警告”信息。
数据的表现形式及其运算
有了以上写程序的基础，本节对程序中最基本的成分作必要的介绍。
说明：本节介绍的主要是C语言的一些语法规定，在编程序时会用到这些知识，因此不知道是不行的，所以本书作了简单的介绍。但是，不需要死记硬背，这样既枯燥又难以奏效，教师也不必在课堂中一一讲授。建议学习本节时采取“浏览”的方法，大致知道有这些因素就可以了，这样在遇到有关问题时就不会茫然。在后续的章节中，通过阅读程序和分析程序对这些内容会具体掌握的，必要时再回头查阅一下即可。
常量和变量
在计算机高级语言中，数据有两种表现形式： 常量和变量。
常量
在程序运行过程中，其值不能被改变的量称为常量。如例程序中的，，和例程序中的是常量。数值常量就是数学中的常数。
常用的常量有以下几类：
整型常量。如 等都是整型常量。
实型常量。有两种表示形式：
①十进制小数形式由数字和小数点组成。如等。
②指数形式如e代表×³e代表E代表等。由于在计算机输入或输出时无法表示上角或下角，故规定以字母e或E代表以为底的指数。但应注意：e或E之前必须有数字，且e或E后面必须为整数。如不能写成e，e。
字符常量。有两种形式的字符常量：
①普通字符用单撇号括起来的一个字符如aZ。不能写成 ab或。请注意： 单撇号只是界限符，字符常量只能是一个字符，不包括单撇号。a和A是不同的字符常量。字符常量存储在计算机存储单元中时，并不是存储字符如a，z，等本身，而是以其代码一般采用ASCII代码存储的，例如字符a的ASCII代码是，因此，在存储单元中存放的是以二进制形式存放。ASCⅡ字符与代码对照表见附录 A①。
① C语言并没有指定使用哪一种字符集，由各编译系统自行决定采用哪一种字符集。C语言只是规定；基本字符集中的每个字符必须用一个字节表示；空字符也占一个字节，它的所有二进位都是；对数字字符的代码，后面一个数字的代码应比前一个数字的代码大如在ASCⅡ字符集中，数字的代码是，数字的代码是，后者比前者的代码大符合要求。中小型计算机系统大都采用 ASCII字符集ASCII 是 American Standard Code for Information Interchange美国标准信息交换代码的缩写。
C程序设计第五版
②转义字符，除了以上形式的字符常量外，C语言还允许用一种特殊形式的字符常量，就是以字符“”开头的字符序列。例如，前面已经遇到过的，在printf函数中的n代表一个“换行”符。t代表将输出的位置跳到下一个 Tab位置制表位置，一个 Tab位置为列。这是一种在屏幕上无法显示的“控制字符”，在程序中也无法用一个一般形式的字符来表示，只能采用这样的特殊形式来表示。
常用的以“”开头的特殊字符见表。
表转义字符及其作用
转 义 字 符 字 符 值 输 出 结 果 V 一个单撇号 输出单撇号字符 一个双撇号 输出双撇号字符” 一个问号 输出问号字符 一个反斜线 输出反斜线字符 a 警告alert 产生声音或视觉信号 b 退格backspace 将光标当前位置后退一个字符 f 换页form feed 将光标当前位置移到下一页的开头 n 换行 将光标当前位置移到下一行的开头 r 回车carriage return 将光标当前位置移到本行的开头 t 水平制表符 将光标当前位置移到下一个 Tab位置v垂直制表符将光标当前位置移到下一个垂直制表对齐点o、 oo 或 ooo其中o代表一个八进制数字与该八进制码对应的ASCⅡ字符与该八进制码对应的字符 xhh…其中h代表一个十六进制数字与该十六进制码对应的ASCII字符与该十六进制码对应的字符
表中列出的字符称为转义字符，意思是将“”后面的字符转换成另外的意义。如“n”中的“n”不代表字母 n 而作为“换行”符。
表中倒数第行是一个以八进制数表示的字符，例如代表八进制数的ASCII字符，即A八进制数 相当于十进制数，从附录A 可以看到ASCII码十进制数为 的字符是大写字母A。代表八进制数即十进制数的的 ASCⅡ码所对应的字符“换行”符。表中倒数第行是一个以十六进制数表示的ASCⅡ字符，如xl代表十六进制数的ASCⅡ字符，也是A十六进制数相当于十进制数。用表中的方法可以表示任何可显示的字母字符、数字字符、专用字符、图形字符和控制字符。如或xB代表ASCII代码为的字符即 ESC控制符。或是代表ASCⅡ码为的控制字符，即“空操作”字符，它常用在字符串中。
字符串常量。如boy， 等，用双撇号把若干个字符括起来，字符串常量是双撇号中的全部字符但不包括双撇号本身。注意不能错写成CHINA， boy，。单撇
第章 最简单的C程序设计——顺序程序设计
号内只能包含一个字符，双撇号内可以包含一个字符串。
说明： 从其字面形式上即可识别的常量称为“字面常量”或“直接常量”。字面常量是没有名字的不变量。
符号常量。用 define指令，指定用一个符号名称代表一个常量。如：
define PI 注意行末没有分号
经过以上的指定后，本文件中从此行开始所有的 PI都代表。在对程序进行编译前，预处理器先对PI进行处理，把所有PI全部置换为。这种用一个符号名代表一个常量的，称为符号常量。在预编译后，符号常量已全部变成字面常量。使用符号常量有以下好处。
①含义清楚。看程序时从PI就可大致知道它代表圆周率。在定义符号常量名时应考虑“见名知义”。在一个规范的程序中不提倡使用很多的常数，如： sum﹡﹡﹡，在检查程序时搞不清各个常数究竟代表什么。应尽量使用“见名知义”的变量名和符号常量。
②在需要改变程序中多处用到的同一个常量时，能做到“一改全改”。例如在程序中多处用到某物品的价格，如果价格用一个常数表示，则在价格调整为时，就需要在程序中作多处修改，若用符号常量 PRICE 代表价格，只须改动一处即可：
define PRICE
注意：要区分符号常量和变量，不要把符号常量误认为变量。符号常量不占内存，只是一个临时符号，代表一个值，在预编译后这个符号就不存在了，故不能对符号常量赋新值。为与变量名相区别，习惯上符号常量用大写表示，如PI，PRICE等。
变量
如例程序中的cf和例程序中的pppprrr等是变量。变量代表一个有名字的、具有特定属性的一个存储单元。它用来存放数据，也就是存放变量的值。在程序运行期间，变量的值是可以改变的。
变量必须先定义，后使用①。在定义时指定该变量的名字和类型。一个变量应该有一个名字，以便被引用。请注意区分变量名和变量值这两个不同的概念，图中a是变量名，是变量a的值，即存放在变量a的内存单元中的数据。变量名实际上是以一个名字代表的一个存储地址。在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。从变量中取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据。
常变量
C允许使用常变量，方法是在定义变量时，前面加一个关键字 const，如：
① 定义变量的位置：一般在函数开头的声明部分中定义变量，也可以在函数外定义变量即外部变量、全局变量，见第章。C允许在函数中的复合语句用一对花括号包起来中定义变量。
C程序设计第五版
const int a
定义a为一个整型变量，指定其值为，而且在变量存在期间其值不能改变。
常变量与常量的异同是：常变量具有变量的基本属性： 有类型，占存储单元，只是不允许改变其值。可以说，常变量是有名字的不变量，而常量是没有名字的不变量。有名字就便于在程序中被引用。
请思考： 常变量与符号常量有什么不同 如：
define Pi 定义符号常量
const float pi 定义常变量
符号常量 Pi和常变量 pi都代表，在程序中都能使用。但二者性质不同：定义符号常量用 define指令，它是预编译指令，它只是用符号常量代表一个字符串，在预编译时仅进行字符替换，在预编译后，符号常量就不存在了全置换成了，对符号常量的名字是不分配存储单元的。而常变量要占用存储单元，有变量值，只是该值不改变而已。从使用的角度看，常变量具有符号常量的优点，而且使用更方便。有了常变量以后，可以不必多用符号常量。
说明： 有些编译系统还未实现C的功能，因此不能使用常变量。
标识符
在计算机高级语言中，用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为标识符 identifier。简单地说，标识符就是一个对象的名字。前面用到的变量名ppcf符号常量名 PIPRICE函数名 printf等都是标识符。
C语言规定标识符只能由字母、数字和下画线种字符组成，且第个字符必须为字母或下画线。下面列出的是合法的标识符，可以作为变量名：
sum average total Class day month Student name lotus BASIC li ling。
下面是不合法的标识符和变量名：
M D John￥Dab
注意：编译系统认为大写字母和小写字母是两个不同的字符。因此， sum 和SUM是两个不同的变量名，同样， Class和class也是两个不同的变量名。一般而言，变量名用小写字母表示，与人们日常习惯一致，以提高可读性。
数据类型
在例和例中可以看到：在定义变量时需要指定变量的类型。如例中变量f和c被定义为单精度 float型。C语言要求在定义所有的变量时都要指定变量的类型。常量也是区分类型的。
为什么在用计算机运算时要指定数据的类型呢 在数学中，数值是不分类型的，数值的运算是绝对准确的例如与之和为 的值是…循环小数。数学是一门研究抽象问题的学科，数和数的运算都是抽象的。而在计算机中，数据是存放在存储单元中的，它是具体存在的。而且，存储单元是由有限的字节构成的，每一个存储单元中
第章 最简单的C程序设计——顺序程序设计
存放数据的范围是有限的，不可能存放“无穷大”的数，也不能存放循环小数。例如用C程序计算和输出：
printff
得到的结果是，只能得到位小数，而不是无穷位的小数。
注意： 用计算机进行的计算不是抽象的理论值的计算，而是用工程的方法实现的计算，在许多情况下只能得到近似的结果。
所谓类型，就是对数据分配存储单元的安排，包括存储单元的长度占多少字节以及数据的存储形式。不同的类型分配不同的长度和存储形式。
C语言允许使用的类型见图，图中有的是C所增加的。
基本整型 int
短整型 short int
整型类型
长整型 long int
双长整型 long long int
字符型 char
基本类型
布尔型 bool
单精度浮点型 float
浮点类型
双精度浮点型 double
复数浮点型 float complex double complex long long complex
数据类型
枚举类型 enum
空类型 void
指针类型
数组类型
派生类型
结构体类型 struct
共用体类型 union
函数类型
图
其中，基本类型包括整型和浮点型和枚举类型变量的值都是数值，统称为算术类型 arithmetic type。算术类型和指针类型统称为纯量类型 scalar type因为其变量的值是以数字来表示的。枚举类型是程序中用户定义的整数类型。数组类型和结构体类型统称为组合类型 aggregate type，共用体类型不属于组合类型，因为在同一时间内只有一个成员具有值。函数类型用来定义函数，描述一个函数的接口，包括函数返回值的数据类型和参数的类型。
不同类型的数据在内存中占用的存储单元长度是不同的，例如， VisualC 为char型字符型数据分配个字节，为int型基本整型数据分配个字节，存储不同类型数据的方法也是不同的。
本书不孤立地、枯燥地叙述以上各种类型的规则，而是结合编程介绍怎样使用各种数据类型。本章及第、章介绍基本数据类型的应用，第章介绍数组，第章介绍函数，第章介绍指针，第章介绍结构体类型、共用体类型和枚举类型。
C程序设计第五版
整型数据
整型数据的分类
本节介绍最基本的整型类型。
基本整型 int型
编译系统分配给 int型数据个字节或个字节由具体的C编译系统自行决定。如 Turbo C为每一个整型数据分配个字节个二进位而 Visual C为每一个整型数据分配个字节位。在存储单元中的存储方式是：用整数的补码 complement形式存放。一个正数的补码是此数的二进制形式，如的二进制形式是，如果用两个字节存放一个整数，则在存储单元中数据形式如图所示。如果是一个负数，则应先求出负数的补码。求负数的补码的方法是：先将此数的绝对值写成二进制形式，然后对其所有二进位按位取反，再加。如的补码见图。
的补码
图
的原码
a
按位取反
b
再加
的补码
c
图
在存放整数的存储单元中，最左面一位是用来表示符号的。如果该位为，表示数值为正；如果该位为，表示数值为负。
有关补码的知识不属本书范围，在此不深入介绍，如需进一步了解，可参考有关计算机原理的书籍。
说明： 如果给整型变量分配个字节，则存储单元中能存放的最大值为 ， 第位为代表正数，后面位为全，此数值是 ¹⁵ 即十进制数。最小值为此数是¹⁵即。因此一个整型变量的值的范围是。超过此范围，就出现数值的“溢出”，输出的结果显然不正确。如果给整型变量分配个字节 Visual C其能容纳的数值范围为即 。
短整型 short int
类型名为 short int 或 short。如用 Visual C编译系统分配给 int 数据个字节短整型个字节。存储方式与 int型相同。一个短整型变量的值的范围是 。
长整型 long int
类型名为 long int 或 long。 Visual C对一个 long 型数据分配个字节即位因此 long int 型变量的值的范围是即 。
第章 最简单的C程序设计——顺序程序设计
双长整型 long long int
类型名为 long long int 或 long long一般分配个字节。这是C新增的类型但许多C编译系统尚未实现。
说明：C标准没有具体规定各种类型数据所占用存储单元的长度，这是由各编译系统自行决定的。C标准只要求 long型数据长度不短于 int型， short型不长于 int型。即
sizeof short≤sizeof int≤sizeof long≤sizeof long long
sizeof是测量类型或变量长度的运算符。在 Turbo C 中 int 型和 short 型数据都是个字节位而 long型数据是个字节位。在 Visual C中 short数据的长度为字节， int数据的长度为 字节， long数据的长度为 字节。通常的做法是： 把 long定为位，把 short定为位，而 int可以是位，也可以是位，由编译系统决定。读者应了解所用系统的规定。在将一个程序从 A系统移到B系统时，需要注意这个区别。例如，在 A 系统，整型数据占个字节，程序中将整数赋给整型变量 price 是合法的、可行的。但在B系统，整型数据占个字节，将整数赋给整型变量 price 就超过整型数据的范围，出现“溢出”。这时应当把 int 型变量改为 long型，才能得到正确的结果。
整型变量的符号属性
以上介绍的几种类型，变量值在存储单元中都是以补码形式存储的，存储单元中的第个二进位制代表符号。整型变量的值的范围包括负数到正数见表。
表 整型数据常见的存储空间和值的范围 Visual C的安排
类 型 字节数 取 值 范 围 int基本整型 即³¹³¹ unsigned int无符号基本整型 即³² short短整型 即¹⁵¹⁵ unsigned short无符号短整型 即¹⁶ long长整型 即³¹³¹ unsigned long无符号长整型 即³² long long双长型 即⁶³⁶³ unsigned long long无符号双长整型 即⁶⁴
在实际应用中，有的数据的范围常常只有正值如学号、年龄、库存量、存款额等。为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。可以在类型符号前面加上修饰符 unsigned，表示指定该变量是“无符号整数”类型。如果加上修饰符 signed，则是“有符号类型”。因此，在以上种整型数据的基础上可以扩展为以下种整型数据：
C程序设计第五版
有符号基本整型 signed int
无符号基本整型 unsigned int
有符号短整型 signed short int
无符号短整型 unsigned short int
有符号长整型 signed long int
无符号长整型 unsigned long int
有符号双长整型· signed long long int
无符号双长整型· unsigned long long int
以上有“”的是C增加的，方括号表示其中的内容是可选的，既可以有，也可以没有。如果既未指定为 signed 也未指定为 unsigned的默认为“有符号类型”。如 signed int a和 int a等价。
有符号整型数据存储单元中最高位代表数值的符号为正，为负。如果指定unsigned为无符号型，存储单元中全部二进位b都用作存放数值本身，而没有符号。无符号型变量只能存放不带符号的整数，如，等，而不能存放负数，如，。由于左面最高位不再用来表示符号，而用来表示数值，因此无符号整型变量中可以存放的正数的范围比一般整型变量中正数的范围扩大一倍。如果在程序中定义a和b 两个短整型变量占个字节，其中b为无符号短整型：
short a a为有符号短整型变量
unsigned short b b为无符号短整型变量
则变量a的数值范围为 而变量b的数值范围为 。图a表示有符号整型变量a的最大值 ，图b表示无符号整型变量 b的最大值 。
符号位
a
b
图
说明：
只有整型包括字符型数据可以加 signed或 unsigned修饰符，实型数据不能加。
对无符号整型数据用“u”格式输出。u表示用无符号十进制数的格式输出。如：
unsigned short price 定义 price为无符号短整型变量
printfun price 指定用无符号十进制数的格式输出
在将一个变量定义为无符号整型后，不应向它赋予一个负值，否则会得到错误的结果。如： unsigned short price 不能把一个负整数存储在无符号变量中 printfdn price
得到结果为。显然与原意不符。
第章 最简单的C程序设计——顺序程序设计
请思考：这是为什么
原因是： 系统对先转换成补码形式，就是全部二进位都是见图，然后把它存入变量 price中。由于 price是无符号短整型变量，其左面第一位不代表符号，按“d”格式输出就是。
price
图
对以上补码的表示有初步了解即可，暂时可不细究。
说明： 在程序中经常会对各种类型的数据进行操作，使用C语言编程时应当对数据在计算机内部的存储情况有一些基本的了解。否则，对运行时出现的问题会感到莫名其妙，无从分析。
字符型数据
由于字符是按其代码整数形式存储的，因此C把字符型数据作为整数类型的一种。但是，字符型数据在使用上有自己的特点，因此把它单独列为一节来介绍。
字符与字符代码
字符与字符代码并不是任意写一个字符，程序都能识别的。例如代表圆周率的π在程序中是不能识别的，只能使用系统的字符集中的字符，目前大多数系统采用ASCⅡ字符集。各种字符集包括ASCⅡ字符集的基本集都包括了个字符。其中包括：
·字母： 大写英文字母AZ，小写英文字母az。
·数字。
·专门符号：个，包括
”
·空格符空格、水平制表符 tab、垂直制表符、换行、换页 form feed。
· 不能显示的字符空 null字符以表示、警告以a表示、退格以b表示、回车以r表示等。
详见附录AASCII字符表。这些字符用来写英文文章、材料或编程序基本够用了。
前已说明，字符是以整数形式字符的 ASCⅡ代码存放在内存单元中的。例如：
大写字母A的 ASCⅡ代码是十进制数二进制形式为 。
小写字母a的 ASCII代码是十进制数二进制形式为。
数字字符的 ASCII代码是十进制数二进制形式为。
空格字符的ASCII代码是十进制数，二进制形式为。
专用字符的 ASCII代码是十进制数二进制形式为。
转义字符n的 ASCII代码是十进制数二进制形式为 。
可以看到，以上字符的ASCⅡ代码最多用个二进位就可以表示。所有个字符都
C程序设计第五版
可以用个二进位表示ASCII代码为时，二进制形式为，位全。所以在C语言中，指定用一个字节位存储一个字符所有系统都不例外。此时，字节中的第位置为。
如小写字母a在内存中的存储情况见图aASCⅡ代码是十进制数，二进制数为。
注意： 字符和整数是不同的概念。字符只是代表一个形状为的符号，在需要时按原样输出，在内存中以ASCⅡ码形式存储，占个字节，见图a；而整数是以整数存储方式二进制补码方式存储的，占个或个字节，见图b。
字符ASCII码为
整数
a
b
图
图
整数运算等于整数，而字符 并不等于整数或字符。
字符变量
字符变量是用类型符 char定义字符变量。 char是英文 character字符的缩写，见名即可知义。如：
定义c为字符型变量并使初值为字符。的ASCII代码是，系统把整数赋给变量c。
c是字符变量，实质上是一个字节的整型变量，由于它常用来存放字符，所以称为字符变量。可以把之间的整数赋给一个字符变量。
在输出字符变量的值时，可以选择以十进制整数形式输出，或以字符形式输出。如：
printfd cncc
输出结果是
说明： 用“d”格式输出十进制整数，用“c”格式输出字符。
前面介绍了整型变量可以用 signed 和 unsigned 修饰符表示符号属性。字符类型也属于整型也可以用 signed和 unsigned修饰符。
字符型数据的存储空间和值的范围见表。
表字符型数据的存储空间和值的范围
类 型 字节数 取 值 范 围 signed char有符号字符型 即⁷⁷ unsigned char无符号字符型即⁸
第章 最简单的C程序设计——顺序程序设计
说明：在使用有符号字符型变量时，允许存储的值为，但字符的代码不可能为负值，所以在存储字符时实际上只用到 这一部分，其第位都是①。
浮点型数据
浮点型数据是用来表示具有小数点的实数的。为什么在C 中把实数称为浮点数呢 在C语言中，实数是以指数形式存放在存储单元中的。一个实数表示为指数可以有不止一 种形式，如可以表示为：×⁰×¹×²×⁻¹×⁻²等，它们代表同一个值。可以看到：小数点的位置是可以在几个数字之间、之前或之后加浮动的，只要在小数点位置浮动的同时改变指数的值，就可以保证它的值不会改变。由于小数点位置可以浮动，所以实数的指数形式称为浮点数。
浮点数类型包括 float单精度浮点型、 double双精度浮点型、 long double长双精度浮点型。
float型单精度浮点型。编译系统为每一个 float 型变量分配个字节，数值以规范化的二进制数指数形式存放在存储单元中。在存储时，系统将实型数据分成小数部分和指数部分两个部分，分别存放。小数部分的小数点前面的数为。如 在内存中的存放形式可以用图 表示。
图 是用十进制数来示意的，实际上在计算机中是用二进制数来表示小数部分以及用 的幂次来表示指数部分的。在 个字节位中，究竟用多少位来表示小数部分，多少位来表示指数部分，C标准并无具体规定，由各C语言编译系统自定。有的C语言编译系统以位表示小数部分包括符号，以位表示指数部分包括指数的符号。由于用二进制形式表示一个实数以及存储单元的长度是有限的，因此不可能得到完全精确的值，只能存储成有限的精确度。小数部分占的位 bit数愈多，数的有效数字愈多，精度也就愈高。指数部分占的位数愈多，则能表示的数值范围愈大。 float型数据能得到位有效数字，数值范围为
double型双精度浮点型。为了扩大能表示的数值范围，用个字节存储一个
① 前面已介绍：个基本字符用个二进制位存储，如果系统只提供个字符，那么就将 char型变量的第个二进制位设置为，用后面位存放个字符的代码。在这种情况下，系统提供的 char类型相当于 signed char。但是在实际应用中，往往觉得个字符不够用，希望能多提供一些可用的字符。根据此需要，有的系统提供了扩展的字符集。把可用的字符由个扩展为个，即扩大了一倍。怎么解决这个问题呢 就是把本来不用的第一位用起来。把 char变量改为 unsigned char，即第一位并不固定设为，而是把位都用来存放字符代码。这样，可以存放⁸即个字符代码。附录A中ASCⅡ代码的部分就是某系统扩展的ASCⅡ字符，它并不适用于所有的系统。
读者可以用以下语句检查ASCⅡ代码从到部分的扩展字符。
unsigned char c 定义c为无符号字符变量
printfdcncc 输出 ASCⅡ代码为的字符
观察是否输出附录A中代码为的字符。可以用类似方法检查其他扩展字符。
在中文操作系统下，ASCⅡ代码为以后的部分被作为中文字符处理，故不会显示出附录A中的扩展字符。
C程序设计第五版
double型数据，可以得到 位有效数字，数值范围为为了提高运算精度，在C语言中进行浮点数的算术运算时，将float型数据都自动转换为 double型，然后进行运算。
long double型长双精度型不同的编译系统对 long double型的处理方法不同 Turbo C对 long double型分配个字节。而 Visual C则对 long double型和 double型一样处理，分配个字节。请读者在使用不同的编译系统时注意其差别。
表列出实型数据的有关情况 Visual C环境下。
表实型数据的有关情况
类 型 字节数 有效数字 数值范围绝对值 float 以及×⁻³⁸×³⁸ double 以及×⁻³⁰⁸×³⁰⁸ long double 以及×⁻³⁰⁸×³⁰⁸以及×⁻×⁴
说明：用有限的存储单元不可能完全精确地存储一个实数，例如 float型变量能存 储的最小正数为 不能存放绝对值小于此值的数，例如⁻⁴⁰。 float型变量能存储的范围见图。即数值可以在个范围内：×³⁸×⁻³⁸
图
怎样确定常量的类型
在C语言中，不仅变量有类型，常量也有类型。为什么要把常量分为不同的类型呢在程序中出现的常量是要存放在计算机中的存储单元中的。这就必须确定分配给它多少字节，按什么方式存储。例如，程序中有整数，在VisualC中会分配给它个字节，按补码方式存储。
怎样确定常量的类型呢 从常量的表示形式即可以判定其类型。对于字符常量很简单，只要看到由单撇号括起来的单个字符或转义字符就可以知道它是字符常量。对于数值常量按以下规律判断。
整型常量。不带小数点的数值是整型常量，但应注意其有效范围。如在 TurboC中， 系统为整型数据分配个字节，其表值范围为 ，如果在程序中出现数值常量系统把它作为 int 型处理用个字节存放。如果出现由于超过个字节放不下系统会把它作为长整型 long int处理分配个字节。在 Visual C中在范围 的不带小数点的数都作为 int型分配个字节在此范围外而又在 long long 型数的范围内的整数作为 long long 型处理。
第章 最简单的C程序设计——顺序程序设计
在一个整数的末尾加大写字母L 或小写字母l，表示它是长整型 longint。例如Ll等。但在 Visual C中由于对 int 和 long int 型数据都分配个字节因此没有必要用 long int型。
浮点型常量。凡以小数形式或指数形式出现的实数均是浮点型常量，在内存中都以指数形式存储。如，是整型常量，是浮点型常量。那么对浮点型常量是按单精度处理还是按双精度处理呢 C编译系统把浮点型常量都按双精度处理，分配个字节。
注意：C程序中的实型常量都作为双精度浮点型常量。
如果有
float a
在进行编译时，对float变量分配个字节，但对于浮点型常量，则按双精度处理，分配个字节。编译系统会发出“警告” warning truncation from const double to float。意为“把一个双精度常量转换为 float型”，提醒用户注意这种转换可能损失精度。这样的“警告”，一般不会影响程序运行结果的正确性，但会影响程序运行结果的精确度。
可以在常量的末尾加专用字符，强制指定常量的类型。如在后面加字母F或f，就表示是 float型常量，分配个字节。如果在实型常量后面加大写或小写的L，则指定此常量为 long double型。如
float af 把此按单精度浮点常量处理，编译时不出现“警告”
long double a L 把此作为 long double型处理
注意：要区分类型与变量。
有些读者容易弄不清类型和变量的关系，往往把它们混为一谈。应当看到它们是既有联系又有区别的两个概念。每一个变量都属于一个确定的类型，类型是变量的一个重要的属性。变量是占用存储单元的，是具体存在的实体，在其占用的存储单元中可以存放数据。而类型是变量的共性，是抽象的，不占用存储单元，不能用来存放数据。
例如， “大学生”是一个抽象的名词，它代表所有大学生共有的属性在高等学校学习的、具有正式学籍的学生，而张方章、李四元、王建则是具体存在的大学生，他们有姓名、家庭、成绩等。可以输出张方章的成绩，但不能输出“大学生”的成绩。同理，可以对一个变量赋值，但不能向一个类型赋值。如：
int aa 正确。对整型变量a赋值
int 错误。不能对类型赋值
运算符和表达式
几乎每一个程序都需要进行运算，对数据进行加工处理，否则程序就没有意义了。要进行运算，就需规定可以使用的运算符。C语言的运算符范围很宽，把除了控制语句和输入输出以外几乎所有的基本操作都作为运算符处理，例如将赋值符“”作为赋值运算符、方括号作为下标运算符等。
C程序设计第五版
C运算符
C语言提供了以下运算符：
算术运算符
关系运算符
逻辑运算符
位运算符
赋值运算符 及其扩展赋值运算符
条件运算符
逗号运算符
指针运算符 和
求字节数运算符 sizeof
强制类型转换运算符 类型
成员运算符
下标运算符
其他 如函数调用运算符
本章先介绍算术运算符和赋值运算符，其余的在以后各章中陆续介绍。
基本的算术运算符
最常用的算术运算符见表。
表最常用的算术运算符
运算符 含 义 举例 结 果 正号运算符单目运算符 a a的值 — 负号运算符单目运算符 a a的算术负值 乘法运算符 ab a 和b的乘积 除法运算符 ab a除以b的商 求余运算符 ab a除以 b的余数 加法运算符aba 和 b的和—减法运算符aba 和b的差
说明：
·由于键盘无×号，运算符×以﹡代替。
· 由于键盘无÷号，运算符÷以代替。两个实数相除的结果是双精度实数，两个整数相除的结果为整数，如的结果值为，舍去小数部分。但是，如果除数或被除数中有一个为负值，则舍入的方向是不固定的。例如，，有的系统中得到的结果为，在有的系统中则得到结果为。多数C编译系统如 Visual C采取“向零取整”的方法即取整后向零靠拢。
第章 最简单的C程序设计——顺序程序设计
· 运算符要求参加运算的运算对象即操作数为整数，结果也是整数。如，结果为。
· 除以外的运算符的操作数都可以是任何算术类型。
自增、自减一一运算符
自增、自减运算符的作用是使变量的值加或减，例如：
ii 在使用i之前先使i的值加减
ii 在使用i之后使i的值加减
粗略地看i和i的作用相当于ii。但i和i的不同之处在于i是先执行ii，再使用i的值；而i是先使用i的值，再执行ii。如果i的原值等于，请分析下面的赋值语句：
①ji i的值先变成再赋给jj的值为
②ji 先将i的值赋给jj的值为然后i变为
又例如：
i
printfdi
输出。若改为
printfdni
则输出。
自增减运算符常用于循环语句中，使循环变量自动加；也用于指针变量，使指针指向下一个地址。这些将在以后的章节中介绍。
有些专业人员喜欢在使用或运算符时采用一些技巧，但是注往会出现意想不到的副作用例如ij是理解为ij还是ij呢 程序应当清晰易读不致引起歧义。建议谨慎使用和运算符，只用最简单的形式，即i，i。而且把它们作为单独的表达式，而不要在一个复杂的表达式中使用或运算符。
算术表达式和运算符的优先级与结合性
用算术运算符和括号将运算对象也称操作数连接起来的、符合C语法规则的式子称为C算术表达式。运算对象包括常量、变量、函数等。例如，下面是一个合法的C算术表达式：
C语言规定了运算符的优先级例如先乘除后加减，还规定了运算符的结合性。
在表达式求值时，先按运算符的优先级别顺序执行，如表达式abc，b的左侧为减号，右侧为乘号，而乘号优先级高于减号，因此，相当于abc。
如果在一个运算对象两侧的运算符的优先级别相同，如abc，则按规定的“结合方向”处理。C语言规定了各种运算符的结合方向结合性，算术运算符的结合方向都是“自
C程序设计第五版
左至右”，即先左后右，因此b先与减号结合，执行ab的运算，然后再执行加c的运算。“自左至右的结合方向”又称“左结合性”，即运算对象先与左面的运算符结合。以后可以看到有些运算符的结合方向为“自右至左”，即右结合性例如，赋值运算符，若有abc，按从右到左顺序，先把变量c的值赋给变量b，然后把变量 b的值赋给变量a。关于“结合性”的概念在其他一些高级语言中是没有的，是C语言的特点之一，希望能弄清楚。附录C列出了所有运算符以及它们的优先级别和结合性。
说明： 不必死记，只要知道：算术运算符是自左至右左结合性，赋值运算符是自右至左右结合性，其他复杂的遇到时查一下即可。
不同类型数据间的混合运算
在程序中经常会遇到不同类型的数据进行运算，如﹡。如果一个运算符两侧的数据类型不同，则先自动进行类型转换，使二者成为同一种类型，然后进行运算。整型、实型、字符型数据间可以进行混合运算。规律为：
、、、运算的两个数中有一个数为 float或 double型结果是 double型因为系统将所有 float 型数据都先转换为 double型，然后进行运算。
如果 int型与 float 或 double型数据进行运算先把 int 型和 float 型数据转换为 double型然后进行运算结果是 double型。
字符 char型数据与整型数据进行运算，就是把字符的 ASCII代码与整型数据进行运算。如：由于字符A 的ASCII代码是相当于等于。如果字符型数据与实型数据进行运算，则将字符的ASCII代码转换为 double型数据，然后进行运算。
以上的转换是编译系统自动完成的，用户不必过问。
分析下面的表达式，假设已指定i为整型变量，值为，f为 float型变量，值为，d为 double型变量值为。
编译时，从左至右扫描，运算次序如下：
①进行 的运算a的值是整数，运算结果为。
②由于“”比“”优先级高，先进行if的运算。先将i与f都转成 double型，运算结果为 double型。
③整数 与if的积相加。先将整数 转换成双精度数，相加结果为， double型。
④进行d的运算先将转换成 double型d结果为 double型。
⑤将的结果与d的商 相减结果为 double型。
【例】 给定一个大写字母，要求用小写字母输出。
解题思路： 前已介绍，字符数据以 ASCⅡ码存储在内存中，形式与整数的存储形式相同。所以字符型数据和其他算术型数据之间可以互相赋值和运算。
要进行大小写字母之间的转换，就要找到一个字母的大写形式和小写形式之间有什么内在联系。从附录A 中可以找到其内在规律： 同一个字母，用小写表示的字符的 ASCII代码比用大写表示的字符的 ASCII代码大 。例如字符a的 ASCII 代码为而A的
第章 最简单的C程序设计——顺序程序设计
ASCⅡ代码为。将A的ASCⅡ代码加就能得到a的ASCⅡ代码。有此思路就可以编写程序了。
编写程序：
include stdio h
int main
char cc
将字符A的 ASCⅡ代码放到c变量中
cc 得到字符a的ASCⅡ代码，放在c变量中
printfcnc 输出c的值，是一个字符
printfdnc 输出c的值是字符a的 ASCII代码
return
运行结果：
a
程序分析 程序第行“cc”把字符变量c的值是字符A的 ASCII代码与整数相加。c 就是就是，其值为。将赋给字符变量c，在c的存储单元中存放了以二进制形式存储。
一个字符数据既可以以字符形式输出，也可以以整数形式输出。第行的目的是以字符形式输出c，在 printf函数中指定用“c”格式，系统会将 c变量的值转换成相应字符a，然后输出。最后一行的目的是以 ASCⅡ码十进制整数形式输出c的值，故指定用“d”输出格式得到见图。
a
存储ASCII码
c
d
输出格式符
a
显示结果
图
强制类型转换运算符
可以利用强制类型转换运算符将一个表达式转换成所需类型。例如：
doublea 将a转换成 double型
intxy 将 xy的值转换成 int 型
float 将的值转换成 float型
其一般形式为
C程序设计第五版
类型名表达式
注意，表达式应该用括号括起来。如果写成
intxy
则只将x转换成整型，然后与 y相加。
需要说明的是，在强制类型转换时，得到一个所需类型的中间数据，而原来变量的类型未发生变化。例如：
a intx
如果已定义x为 float型变量，a为整型变量，进行强制类型运算 intx后得到一个 int类型的临时值，它的值等于 x的整数部分，把它赋给a，注意x的值和类型都未变化，仍为 float型。该临时值在赋值后就不再存在了。
从上可知，有两种类型转换。一种是在运算时不必用户干预，系统自动进行的类型转换，如。另一种是强制类型转换。当自动类型转换不能实现目的时，可以用强制类型转换。如运算符要求其两侧均为整型量，若x为 float型，则 x不合法，必须用 intx。从附录C可以查到，强制类型转换运算优先于运算，因此先进行 intx的运算，得到一个整型的中间变量，然后再对求余。此外，在函数调用时，有时为了使实参与形参类型一致，可以用强制类型转换运算符得到一个所需类型的参数。
C 语 句
C语句的作用和分类
在前面的例子中可以看到：一个函数包含声明部分和执行部分，执行部分是由语句组成的，语句的作用是向计算机系统发出操作指令，要求执行相应的操作。一个C语句经过编译后产生若干条机器指令。声明部分不是语句，它不产生机器指令，只是对有关数据的声明。
C程序结构可以用图表示。即一个C程序可以由若干个源程序文件编译时以文件模块为单位组成，一个源文件可以由若干个函数和预处理指令以及全局变量声明部分组成关于“全局变量”见第章。一个函数由数据声明部分和执行语句组成。
C程序
源程序文件
源程序文件
源程序文件n
预处理指令
数据声明
函数
…
函数n
函数首部
函数体
数据声明
执行语句
图
第章 最简单的C程序设计——顺序程序设计
C语句分为以下类。
控制语句。控制语句用于完成一定的控制功能。C语言只有种控制语句，它们的形式是：
① if… else… 条件语句
② for… 循环语句
③ while… 循环语句
④ do… while 循环语句
⑤ continue 结束本次循环语句
⑥ break 中止执行 switch 或循环语句
⑦ switch 多分支选择语句
⑧ return 从函数返回语句
⑨goto 转向语句，在结构化程序中基本不用 goto语句
上面种语句表示形式中的表示括号中是一个“判别条件”， “…”表示内嵌的语句。例如上面的“if … else…”的具体语句可以写成
ifxy zx else zy
其中xy是一个“判别条件” “zx”和“zy”是C语句这两个语句是内嵌在 if… else语句中的。这个 if… else语句的作用是：先判别条件“xy”是否成立，如果xy成立，就执行内嵌语句“zx；”，否则就执行内嵌语句“zy；”。
函数调用语句。函数调用语句由一个函数调用加一个分号构成，例如：
printfThis is a C statement
其中 printfThis is a C statement 是一个函数调用加一个分号成为一个语句。
表达式语句。表达式语句由一个表达式加一个分号构成，最典型的是由赋值表达式构成一个赋值语句。例如：
a
是一个赋值表达式，而
a
是一个赋值语句。可以看到，一个表达式的最后加一个分号就成了一个语句。一个语句必须在最后有一个分号，分号是语句中不可缺少的组成部分，而不是两个语句间的分隔符号。例如：
ii 是表达式，不是语句
ii 是语句
任何表达式都可以加上分号而成为语句，例如：
i
是一个语句，作用是使i值加。又例如：
xy
C程序设计第五版
也是一个语句，作用是完成xy的操作，它是合法的，但是并不把xy的和赋给另一变量，所以它并无实际意义。
表达式能构成语句是C语言的一个重要特色。其实“函数调用语句”也属于表达式语句，因为函数调用如sinx也属于表达式的一种。只是为了便于理解和使用，才把“函数调用语句”和“表达式语句”分开来说明。
空语句。下面是一个空语句：
此语句只有一个分号，它什么也不做。那么它有什么用呢 可以用来作为流程的转向点流程从程序其他地方转到此语句处，也可用来作为循环语句中的循环体循环体是空语句，表示循环体什么也不做。
复合语句。可以用把一些语句和声明括起来成为复合语句又称语句块。例如下面是一个复合语句：
float pi r area 定义变量
area pi r r
可以在复合语句中包含声明部分如上面的第行，C允许将声明部分放在复合语句中的任何位置，但习惯上把它放在语句块开头位置。复合语句常用在 if语句或循环中，此时程序需要连续执行一组语句。
注意：复合语句中最后一个语句末尾的分号不能忽略不写。
最基本的语句——赋值语句
在C程序中，最常用的语句是：赋值语句和输入输出语句。其中最基本的是赋值语句。程序中的计算功能大部分是由赋值语句实现的，几乎每一个有实用价值的程序都包括赋值语句。有的程序中的大部分语句都是赋值语句。本节先介绍赋值语句，下一节介绍程序的输入输出。
先分析一个例子。
【例】 给出三角形的三边长，求三角形面积。
解题思路： 假设给定的三个边符合构成三角形的条件：任意两边之和大于第三边。解此题的关键是要找到求三角形面积的公式。从数学知识已知求三角形面积的公式为
其中sabc。
编写程序： 根据上面的公式编写程序如下：
include stdio h
include math h
int main
第章 最简单的C程序设计——顺序程序设计
double abcs area 定义各变量均为 double型
a 对边长a赋值
b 对边长b赋值
c 对边长c赋值
sabc 计算s
area sqrtssasbsc 计算 area
printfaf tbftfnabc 输出三边abc的值
输出面积 area的值
return
运行结果：
a b c
area
程序分析：程序执行部分主要由赋值语句构成，分别实现对a，b，c的赋值，计算s和 area。为了提高精度，几个变量全部定义为双精度型。第行中 sqrt函数是求平方根的函数。由于要调用数学函数库中的函数，必须在程序的开头加一条 include 指令，把头文件“math h”包含到程序中来。
printf函数双撇号内字符串中的t是转义字符，在表 中可以查到，它的作用是“使输出位置跳到下一个 Tab位置”。分析 printf函数的输出情况： 先原样输出字符a，然后按f格式输出变量a的值，这时输出了“a”，共个字符，然后遇到t，输出位置就跳到下一个 Tab区。一个 Tab区有列在输出“a”后已进入第个 Tab区，今要求跳到下一个 Tab区，就应该跳到第个 Tab区，即从列开始的区。然后接着输出其后的数据。所以从第列开始输出“b”，再遇到t，使输出位置又移到第个 Tab区从第列开始输出“c”。
在安排输出时，常用t来调整输出的位置，使输出的数据清晰、整齐、美观。
注意： 以后凡在程序中要用到数学函数库中的函数，都应当在本文件的开头包含 math h头文件。
下面归纳一下与赋值有关的一些问题。
赋值运算符
赋值符号“”就是赋值运算符，它的作用是将一个数据赋给一个变量。如a的作用是执行一次赋值操作或称赋值运算。把常量赋给变量a。也可以将一个表达式的值赋给一个变量。
复合的赋值运算符
在赋值符之前加上其他运算符，可以构成复合的运算符。如果在“”前加一个“”运算符就成了复合运算符“”。例如，可以有以下的复合赋值运算：
a 等价于 aa
xy 等价于 xxy
x 等价于 xx
C程序设计第五版
以“a”为例来说明，它相当于使a进行一次自加的操作。即：先使a加，再赋给 a。同样，的作用是使x乘以y，再赋给 x。
为便于理解和记忆，可以这样理解ab：
①ab 其中a为变量，b为表达式
② 将有下画线的“a”移到右侧
③aab 在左侧补上变量名a
注意： 如果b是包含若干项的表达式，则相当于它有括号。例如，以下种写法是等价的：
①xy
②x²y
③xxy 不要错写成xxy
凡是二元二目运算符，都可以与赋值符一起组合成复合赋值符。有关算术运算的复合赋值运算符有。
C语言采用这种复合运算符，一是为了简化程序，使程序精练，二是为了提高编译效率，能产生质量较高的目标代码。专业人员往往喜欢使用复合运算符，程序显得专业一点。对初学者来说，不必多用，首要的是保持程序清晰易懂。本节在此作简单的介绍，是为了便于读者阅读别人编写的程序。对本小节内容有一定了解即可。
赋值表达式
前面介绍过，赋值语句是在赋值表达式的末尾加一个分号构成的。那么什么是赋值表达式呢
由赋值运算符将一个变量和一个表达式连接起来的式子称为“赋值表达式”。它的一般形式为
变量 赋值运算符 表达式
赋值表达式的作用是将一个表达式的值赋给一个变量，因此赋值表达式具有计算和赋值的双重功能。如a是一个赋值表达式。对赋值表达式求解的过程是：先求赋值运算符右侧的“表达式”的值，然后赋给赋值运算符左侧的变量。既然是一个表达式，就应该有一个值，表达式的值等于赋值后左侧变量的值。例如，赋值表达式a，对表达式求解后，变量a的值和表达式的值都是。
赋值运算符左侧应该是一个可修改值的“左值” left value，简写为 lvalue。左值的意思是它可以出现在赋值运算符的左侧，它的值是可以改变的。并不是任何形式的数据都可以作为左值的，左值应当为存储空间并可以被赋值。变量可以作为左值，而算术表达式ab就不能作为左值，常量也不能作为左值，因为常量不能被赋值。能出现在赋值运算符右侧的表达式称为“右值” right value，简写为 rvalue。显然左值也可以出现在赋值运算符右侧，因而凡是左值都可以作为右值。例如：
ba b是左值
第章 最简单的C程序设计——顺序程序设计
cb b也是右值
赋值表达式中的“表达式”又可以是一个赋值表达式。例如：
ab
括号内的b是一个赋值表达式，它的值等于。执行表达式‘就是执行和ab两个赋值表达式。因此a的值等于，整个赋值表达式的值也等于。从附录C可知赋值运算符按照“自右而左”的结合顺序，因此，b外面的括号可以不要，即ab和ab等价，都是先求b的值得，然后再赋给a，下面是赋值表达式的例子：
abc 赋值表达式的值为，a，b，c值均为
ac 表达式值为a值为c值为
abc 表达式值为a值为b等于c等于
abc 表达式值为a等于b等于c等于
请分析下面的赋值表达式：
ab
将的值先赋给变量b，然后把变量b的值赋给变量a，最后a和b的值都等于。
把赋值表达式作为表达式的一种，使得赋值操作不仅可以出现在赋值语句中，而且可以以表达式的形式出现在其他语句中如输出语句、循环语句等，如：
printfdab
如果b的值为，则输出a的值也是表达式ab的值为。在一个 printf函数中完成了赋值和输出双重功能。这是C语言灵活性的一种表现。以后将进一步看到这种应用及其优越性。
赋值过程中的类型转换
如果赋值运算符两侧的类型一致，则直接进行赋值。如：
i 设已定义i为整型变量
此时直接将整数存入变量i的存储单元中。
如果赋值运算符两侧的类型不一致，但都是基本类型时，在赋值时要进行类型转换。类型转换是由系统自动进行的，转换的规则是：
将浮点型数据包括单、双精度赋给整型变量时，先对浮点数取整，即舍弃小数部分，然后赋予整型变量。如果i为整型变量，执行“i；”的结果是使i的值为，以整数形式存储在整型变量中。
将整型数据赋给单、双精度变量时，数值不变，但以浮点数形式存储到变量中。如果有 float变量f，执行“f；”。先将整数转换成实数，再按指数形式存储在变量f中。如将赋给 double型变量d即执行“d”则将整数转换成双精度实数然后以双精度浮点数形式存储到变量d中。
将一个 double型数据赋给 float变量时，先将双精度数转换为单精度，即只取位有效数字，存储到 float型变量的个字节中。应注意双精度数值的大小不能超出 float 型
C程序设计第五版
变量的数值范围。例如，将一个 double型变量d中的双精度实数赋给一个 float 型变量 f。
double de 指数为，超过了 float数据的最大范围
fd
f无法容纳如此大的数，就出现错误，无法输出正确的信息。
将一个 float型数据赋给 double型变量时，数值不变，在内存中以个字节存储，有效位数扩展到位。
字符型数据赋给整型变量时，将字符的 ASCII代码赋给整型变量。如：
已定义i为整型变量
由于A字符的 ASCII代码为，因此赋值后i的值为。
将一个占字节多的整型数据赋给一个占字节少的整型变量或字符变量例如把占个字节的 int 型数据赋给占个字节的 short变量或占个字节的 char变量时，只将其低字节原封不动地送到被赋值的变量即发生“截断”。例如：
int i
char ca
ci
赋值情况见图。c的值为如果用“c”输出c将得到字符“”其ASCⅡ码为。
又如：
int a
short b
ba
按理论上应得到，但输出的结果却是，看上去莫名其妙，其实原因很简单，对短整型数据分配个字节，最大能表示，无法表示，见图。
a
i
a
b
c
b
图
图
图a表示 int 型变量用个字节存储的情况，加以后，两个低字节的第位为，后位为，把它传送到 short变量b中，见图b。由于整型变量的最高位代表符号，第位是，代表此数是负数，它就是的补码形式。对一般初学者来说，只需要知道变量的数值范围即可。
要避免把占字节多的整型数据向占字节少的整型变量赋值，因为赋值后数值可能发生失真。如果一定要进行这种赋值，应当保证赋值后数值不会发生变化，即所赋的值在变量的允许数值范围内。如果把上面的a值改为 ，就不会失真。
以上的赋值规则看起来比较复杂，其实，不必死记。只要知道整型数据之间的赋值，按存储单元中的存储形式直接传送。实型数据之间以及整型与实型之间的赋值，是先转换类
第章 最简单的C程序设计——顺序程序设计
型后赋值。
由于C语言使用灵活，在不同类型数据之间赋值时，常常会出现数据的失真，而且这不属于语法错误，编译系统并不提示出错，全靠程序员的经验来找出问题。这就要求编程人员对出现问题的原因有所了解，以便迅速排除故障。
赋值表达式和赋值语句
在C程序中，赋值语句是用得最多的语句。在节的C语句分类中，并没有看到赋值语句，实际上，C语言的赋值语句属于表达式语句，由一个赋值表达式加一个分号组成。其他一些高级语言如BASICFORTRANCOBOL Pascal等有赋值语句而无“赋值表达式”这一概念。这是C语言的一个特点，使之应用灵活方便。
前面已经提到，在一个表达式中可以包含另一个表达式。赋值表达式既然是表达式，那么它就可以出现在其他表达式之中。例如：
ifab maxa
按一般理解， if后面的括号内应该是一个“条件”，例如可以是
ifa maxa
现在，在a的位置上换上一个赋值表达式ab，其作用是： 先进行赋值运算将b的值赋给a，然后判断a是否大于，如大于，执行 maxa。请注意，在 if语句中的ab不是赋值语句，而是赋值表达式。如果写成
ifab maxa “ab” 是赋值语句
就错了。在if 的条件中可以包含赋值表达式，但不能包含赋值语句。由此可以看到，C语言把赋值语句和赋值表达式区别开来，增加了表达式的种类，使表达式的应用几乎“无孔不入”，能实现其他语言中难以实现的功能。
注意：要区分赋值表达式和赋值语句。
赋值表达式的末尾没有分号，而赋值语句的末尾必须有分号。在一个表达式中可以包含一个或多个赋值表达式，但绝不能包含赋值语句。
变量赋初值
从前面的程序中可以看到： 可以用赋值语句对变量赋值，也可以在定义变量时对变量赋以初值。这样可以使程序简练。如：
int a 指定a为整型变量，初值为
float f 指定f为浮点型变量，初值为
指定c为字符变量，初值为a
也可以使被定义的变量的一部分赋初值。例如：
int abc
指定a，b，c为整型变量，但只对c初始化，c的初值为。
如果对几个变量赋予同一个初值，应写成
C程序设计第五版
int ab c
表示a，b，c的初值都是。不能写成
一般变量初始化不是在编译阶段完成的只有在静态存储变量和外部变量的初始化是在编译阶段完成的，而是在程序运行时执行本函数时赋予初值的，相当于执行一个赋值语句。例如：
相当于
int a 指定a为整型变量
赋值语句，将赋给a
又如：
int abc
相当于
int abc 指定a，b，c为整型变量
c 将 赋给c
数据的输入输出
输入输出举例
前面已经看到了利用 printf函数进行数据输出的程序，现在再介绍一个包含输入和输出的程序。
【例】 求方程的根。a，b，c由键盘输入，设
解题思路： 首先要知道求方程式的根的方法。由数学知识已知： 如果则一元二次方程有两个实根：
可以将上面的分式分为两项：
则
有了这些式子，只要知道a，b，c的值，就能顺利地求出方程的两个根。
剩下的问题就是输入a，b，c的值和输出根的值了。需要用 scanf函数输入a，b，c的值，用 printf函数输出两个实根的值。
第章 最简单的C程序设计——顺序程序设计
编写程序：
include stdio h
include math h 程序中要调用求平方根函数 sqrt
int main
double abc discxxpq disc用来存放判别式bbac的值
scanf lf lf lfabc 输入双精度型变量的值要用格式声明f
discbbac
pba
q sqrt disca
xpqxpq 求出方程的两个根
printfxfnxfnxx 输出方程的两个根
return
运行结果：
x
x
注意在输入数据时，，，这个数之间用空格分隔，最后按“回车”键。
程序分析：
用 scanf函数输入abc的值请注意在 scanf函数中括号内变量abc的前面要用地址符，即a，b，c。a表示变量a在内存中的地址。该scanf函数表示从终端输入的个数据分别送到地址为a，b，c的存储单元，也就是赋给变量a，b，c。双撇号内用 lf格式声明，表示输入的是双精度型实数。
在 scanf函数中格式声明为“ lf lf lf”连续个“ lf”。要求输入个双精度实数。请注意在程序运行时应怎样输入数据。从上面运行情况中可以看到输入“”，两个数之间用空格分开。这是正确的，如果用其他符号如逗号会出错。现在输入的是整数，但由于指定用 lf格式输入，因此系统会先把这个整数转换成实数，然后赋给变量abc。
在 printf函数中，不是简单地用f格式声明，而是在格式符f的前面加了“”，表示在输出x 和x时，指定数据占列，其中小数占列。请分析运行结果。这样做的好处是：①可以根据实际需要来输出小数的位数，因为并不是任何时候都需要位小数的，例如价格只须位小数即可第位按四舍五入处理。②如果输出多个数据，各占一行，而用同一个格式声明如f，即使输出的数据整数部分值不同，但输出时上下行必然按小数点对齐，使输出数据整齐美观。读者可自己试一下。
在本例中假设给定的a，b，c的值满足所以程序不对此进行判断。在实际上，用所输入的a，b，c并不一定能求出两个实根。因此为稳妥起见，应在程序的开头检查是否大于等于。只有确认它大于等于，才能用上述方法求方程的根。在学习了下一章后，就可以用 if语句来进行检查了。
有关数据输入输出的概念
从前面的程序可以看到： 几乎每一个C程序都包含输入输出。因为要进行运算，就必
C程序设计第五版
须给出数据，而运算的结果当然需要输出，以便人们应用。没有输出的程序是没有意义的。输入输出是程序中最基本的操作之一。
在讨论程序的输入输出时首先要注意以下几点。
所谓输入输出是以计算机主机为主体而言的。从计算机向输出设备如显示器、打印机等输出数据称为输出，从输入设备如键盘、光盘、扫描仪等向计算机输入数据称为输入，如图所示。
C语言本身不提供输入输出语句，输入和输出操作是由C标准函数库中的函数来实现的。在C标准函数库中提供了一些输入输出函数，例如 printf函数和 scanf函数。读者在使用它们时，千万不要误认为它们是C语言提供的“输入输出语句”。 printf和 scanf不是C语言的关键字而只是库函数的名字。实际上可以不用 printf和scanf这两个名字，而另外编写一个输入函数和一个输出函数，用来实现输入输出的功能，采用其他名字作为函数名。
C提供的标准函数以库的形式在C的编译系统中提供，它们不是C语言文本中的组成部分。不把输入输出作为C语句的目的是使C语言编译系统简单精练，因为将语句翻译成二进制的指令是在编译阶段完成的，没有输入输出语句就可以避免在编译阶段处理与硬件有关的问题，可以使编译系统简化，而且通用性强，可移植性好，在各种型号的计算机和不同的编译环境下都能适用，便于在各种计算机上实现。
各种C编译系统提供的系统函数库是各软件公司编制的，它包括了C语言建议的全部标准函数，还根据用户的需要补充一些常用的函数，已对它们进行了编译，成为目标文件obj文件。它们在程序连接阶段与由源程序经编译而得到的目标文件 obj文件相连接，生成一个可执行的目标程序exe文件。如果在源程序中有 printf函数，在编译时并不把它翻译成目标指令，而是在连接阶段与系统函数库相连接后，在执行阶段中调用函数库中的 printf函数。
不同的编译系统所提供的函数库中，函数的数量、名字和功能是不完全相同的。不过，有些通用的函数如printf和scanf等，各种编译系统都提供，成为各种系统的标准函数。
C语言函数库中有一批标准输入输出函数 ，它是以标准的输入输出设备一般为终端设备为输入输出对象的。其中有 putchar输出字符、 getchar输入字符、 printf格式输出、 scanf格式输入、 puts输出字符串和 gets输入字符串。本章主要介绍前面个最基本的输入输出函数。
要在程序文件的开头用预处理指令 include 把有关头文件放在本程序中。
如：
include stdio h
如果程序调用标准输入输出函数，就必须在本程序的开头用 include 指令把 stdio h头文件包含到程序中。 include 指令放在程序的开头，所以把 stdio h 称为“头文件” header file文件后缀为“ h”。在 stdio h头文件中存放了调用标准输入输出函数时所需要的信息，包括与标准IO库有关的变量定义和宏定义以及对函数的声明。在对程序进行
第章 最简单的C程序设计——顺序程序设计
编译预处理时，系统会把在该头文件中存放的内容调出来，取代本行的 include指令。这些内容就成为了程序中的一部分。调用不同的库函数，应当把不同的头文件包含进来，见本书附录EC库函数。
说明： include 指令还有一种形式，头文件不是用尖括号括起来，而是用双撇号，如：
includestdio h
这两种 include指令形式的区别是：用尖括号形式如 stdio h时，编译系统从存放C编译系统的子目录中去找所要包含的文件如stdio h，这称为标准方式。如果用双撇号形式如stdio h，在编译时，编译系统先在用户的当前目录一般是用户存放源程序文件的子目录中寻找要包含的文件，若找不到，再按标准方式查找。如果用 include 指令是为了使用系统库函数，因而要包含系统提供的相应头文件，这时以用标准方式为宜，以提高效率。如果用户想包含的头文件不是系统提供的相应头文件，而是用户自己编写的文件这种文件一般都存放在用户当前目录中，这时应当用双撇号形式，否则会找不到所需的文件。如果该头文件不在当前目录中，可以在双撇号中写出文件路径如 includeC： tempfile h”，以便系统能从中找到所需的文件。
注意： 应养成习惯，只要在本程序文件中使用标准输入输出库函数时，一律加上 include stdio h指令。
用 printf函数输出数据
在C程序中用来实现输出和输入的主要是 printf函数和 scanf函数。这两个函数是格式输入输出函数。用这两个函数时，程序设计人员必须指定输入输出数据的格式，即根据数据的不同类型指定不同的格式。
说明： C提供的输入输出格式比较多，也比较烦琐，初学时不易掌握，更不易记住。用得不对就得不到预期的结果，不少编程人员由于掌握不好这方面的知识而浪费了大量调试程序的时间。为了使读者便于掌握，本章主要介绍最常用的格式输入输出，有了这些基本知识，就可以顺利地进行一般的编程工作了。以后再结合应用进一步介绍格式输入输出的各种应用。
在初学时不必花许多精力去深究每一个细节，重点掌握最常用的一些规则即可。其他部分可在需要时随时查阅。学习这部分的内容时最好边看书边上机练习，通过编写和调试程序的实践逐步深入而自然地掌握输入输出的应用。
在前面的例题中已经多次用 printf函数输出数据，下面再作比较系统的介绍。
printf函数格式输出函数用来向终端或系统隐含指定的输出设备输出若干个任意类型的数据。
printf函数的一般格式
printf函数的一般格式为
printf格式控制输出表列
例如：
C程序设计第五版
printfdcnic
括号内包括两部分：
“格式控制”是用双撇号括起来的一个字符串，称为格式控制字符串，简称格式字符串。它包括两个信息：
①格式声明。格式声明由“”和格式字符组成，如d、f等。它的作用是将输出的数据转换为指定的格式后输出。格式声明总是由“”字符开始的。
②普通字符。普通字符即需要在输出时原样输出的字符。例如上面 printf函数中双撇号内的逗号、空格和换行符，也可以包括其他字符。
输出表列是程序需要输出的一些数据，可以是常量、变量或表达式。
下面是 printf函数的具体例子：
printfd dnab
格式声明
输出表列
格式声明 输出表列
在第个 printf函数中的双撇号内的字符除了两个“d”以外，还有非格式声明的普通字符如a，b和n，它们全部按原样输出。如果a和b的值分别为和，则输出结果为
ab
执行n使输出控制移到下一行的开头，从显示屏幕上可以看到光标已移到下一行的开头。
上面输出结果中有下画线的字符是 printf函数中的“格式控制字符串”中的普通字符按原样输出的结果。和是a和b的值注意和这两个数字前和后都没有加空格，其数字位数由a和b的值而定。假如a，b，则输出结果为
a b
由于 printf是函数，因此，格式控制字符串和输出表列实际上都是函数的参数。
printf函数的一般形式可以表示为
printf参数参数参数…参数n
参数是格式控制字符串，参数参数n是需要输出的数据。执行 printf函数时，将参数参数n按参数所指定的格式进行输出。参数是必须有的，参数参数n是可选的。
格式字符
前已介绍，在输出时，对不同类型的数据要指定不同的格式声明，而格式声明中最重要的内容是格式字符。常用的有以下几种格式字符。
d格式符。用来输出一个有符号的十进制整数。
在前面的例子中已经看到了： 在输出时，按十进制整型数据的实际长度输出，正数的符号不输出。
第章 最简单的C程序设计——顺序程序设计
可以在格式声明中指定输出数据的域宽所占的列数，如用“d”，指定输出数据占列，输出的数据显示在此列区域的右侧。如：
printfdndn
输出结果为
前面有个空格
前面有个空格
若输出 long长整型数据在格式符d前加字母l代表 long即“ ld”。若输出 long long双长整型数据在格式符d前加两个字母Ⅱ代表 long long即“ lld”。
c格式符。用来输出一个字符。例如：
printfc ch
运行时输出
a
也可以指定域宽，如
printfc ch
运行时输出
a a前面有个空格
一个整数，如果在 范围中，也可以用“c”使之按字符形式输出，在输出前，系统会将该整数作为 ASCⅡ码转换成相应的字符；如：
short a
printfca
输出字符y。如果整数比较大，则把它的最后一个字节的信息以字符形式输出。如：
int a
printfca
也输出字符y，见图。因为用c格式输出时，只考虑一个字节，存放a的存储单元中最后一个字节中的信息是 ，即十进制的它是y的 ASCⅡ代码。
s格式符。用来输出一个字符串。如：
图
printfs CHINA
执行此函数时在显示屏上输出字符串CHINA不包括双引号。
f格式符。用来输出实数包括单、双精度、长双精度，以小数形式输出，有几种用法：
①基本型用f。
不指定输出数据的长度，由系统根据数据的实际情况决定数据所占的列数。系统处理的方法一般是：实数中的整数部分全部输出，小数部分输出位。
C程序设计第五版
【例】 用f输出实数，只能得到位小数。
include stdio h
int main
double a
printffna
return
运行结果：
虽然a是双精度型，a的结果也是双精度型，但是用f格式声明只能输出位小数。
② 指定数据宽度和小数位数，用m nf。
例已经用了“”格式指定了输出的数据占列，其中包括位小数。对其后一位采取四舍五入方法处理，即向上或向下取近似值。如果把小数部分指定为，则不仅不输出小数，而且小数点也不输出。如果在例的 printf函数中指定“f”格式声明，由于其整数部分为，因此输出结果为。所以不要轻易指定小数的位数为。
如果想在例中输出双精度变量a的位小数，可以采用例所用的方法，用“f”格式声明，即把上面程序的第行改为
printffna
运行结果：
注意在的前面有个空格。
这时输出了位小数。但是应该注意：一个双精度数只能保证位有效数字的精确度，即使指定小数位数为如用f，也不能保证输出的位都是有效的数字。读者可以上机试一下。
注意： 在用f输出时要注意数据本身能提供的有效数字，如float型数据的存储单元只能保证位有效数字。 double型数据能保证位有效数字。不要以为计算机输出的所有数字都是绝对精确的。
【例】 float型数据的有效位数。
include stdio h
int main
float a
a
printffna
return
运行结果：
第章 最简单的C程序设计——顺序程序设计
本来计算的理论值应为…但由于 float 型数据只能保证位有效数字，因此虽然程序输出了位小数，但从左面开始的第位数字即第位小数以后的数字并不保证是绝对正确的。
如果将a改为 double型，其他不变，请考虑输出结果如何，可上机一试。
③输出的数据向左对齐，用 m nf。
在 m n的前面加一个负号，其作用与m nf形式作用基本相同，但当数据长度不超过m时，数据向左靠，右端补空格。如：
printfffnaa
运行结果：
第次输出a时输出结果向左端靠，右端空列。第次输出a时输出结果向右端靠，左端空列。
e格式符。用格式声明 e指定以指数形式输出实数。如果不指定输出数据所占的宽度和数字部分的小数位数，许多C编译系统如VisualC会自动给出数字部分的小数位数为位，指数部分占列如e，其中“e”占列，指数符号占列，指数占列。数值按标准化指数形式输出即小数点前必须有而且只有位非零数字。例如：
printfe
输出如下：
e
所输出的实数共占列宽度注：不同系统的规定略有不同。
也可以用“m ne”形式的格式声明，如：
printfe
输出为
e 数的前面有个空格
格式符e也可以写成大写E形式，此时输出的数据中的指数不是以小写字母e表示而以大写字母 E表示如 E。
以上几种输出格式是常用的，在以后各章中会结合实际问题加以具体应用，读者可在实际应用中逐步掌握它们。
其他格式符。
C语言还提供以下几种输出格式符，由于初学时用得不多，不作详细介绍，只供必要时查阅。
①i格式符。作用与d格式符相同，按十进制整型数据的实际长度输出。一般习惯用d而少用i。
②o格式符。以八进制整数形式输出。将内存单元中的各位的值或按八进制形式输出，因此输出的数值不带符号，即将符号位也一起作为八进制数的一部分输出。
C程序设计第五版
例如：
int a
printfdtonaa
在内存单元中的存放形式以补码形式存放在个字节如下：
运行时输出：
用d十进制整数形式输出a时，得到，按o输出时，按内存单元中实际的二进制数按位一组构成八进制数形式，如上面的个二进位可以从右至左每位为一组：
二进制数就是八进制数。因此上面的数用八进制数表示为。八进制整数是不会带负号的。用‰格式声明可以得到存储单元中实际的存储情况。
③x格式符。以十六进制数形式输出整数。例如：
int a
printfdtotxnaaa
输出结果为
fffffff
同样可以用“ lx”输出长整型数，也可以指定输出字段的宽度，如“x”。
如果读者对二进制数、八进制数、十六进制数、补码等不熟悉，可以忽略这部分内容，在需要时可参阅有关书籍，这些不属本书的范围。
④ u格式符。用来输出无符号 unsigned型数据，以十进制整数形式输出。
⑤g格式符。用来输出浮点数，系统自动选f格式或e格式输出，选择其中长度较短的格式，不输出无意义的。如：
double a
printfftetgnaaa
输出结果为
e e
可从以上看到用f格式输出占列，用e格式输出占列，故g采用e格式输出。
综合上面的介绍，格式声明的一般形式可以表示为
附加字符 格式字符
以上介绍的加在格式字符前面的字符如l，m，n，一等就是附加字符，又称为修饰符，起补充声明的作用。
为便于查阅，表和表分别列出了 printf函数中用到的格式字符和附加字符。
第章 最简单的C程序设计——顺序程序设计
表 printf函数中用到的格式字符
格式字符 说 明 di 以带符号的十进制形式输出整数正数不输出符号 o 以八进制无符号形式输出整数不输出前导符 xx 以十六进制无符号形式输出整数不输出前导符x，用x则输出十六进制 数的af时以小写形式输出，用X时，则以大写字母输出 u 以无符号十进制形式输出整数 c 以字符形式输出，只输出一个字符 s输出字符串f以小数形式输出单、双精度数，隐含输出位小数eE以指数形式输出实数，用e时指数以“e”表示如e，用E时指数以“E”表示如EgG选用f或e格式中输出宽度较短的一种格式，不输出无意义的。用G时，若以指数形式输出，则指数以大写表示
在格式声明中，在和上述格式字符间可以插入表中列出的几种附加符号又称修饰符。
表 printf函数中用到的格式附加字符
字 符 说 明 长整型整数，可加在格式符d、o、x、u前面 m代表一个正整数数据最小宽度n代表一个正整数对实数，表示输出n位小数；对字符串，表示截取的字符个数输出的数字或字符在域内向左靠
说明：
printf函数输出时，务必注意输出对象的类型应与上述格式说明匹配，否则将会出现错误。
除了X，E，G外，其他格式字符必须用小写字母，如d不能写成D。
可以在 printf函数中的格式控制字符串内包含转义字符如ntbrf和等。
表中所列出的字母doxucsfegXE和G等如用在格式声明中就作为格式字符。一个格式声明以“”开头，以上述个格式字符之一为结束，中间可以插入附加格式字符也称修饰符。例如：
格式声明
C程序设计第五版
第个格式声明为“c”而不包括其后的字母f；第个格式声明为“f”，不包括其后的字母s；第个格式声明为“s”。其他字符都是在输出时按原样输出的普通字符。
如果想输出字符“”，应该在“格式控制字符串”中用连续两个“”表示，如： printffn
输出：
x
实现了输出“”符号。
用 scanf函数输入数据
在本章例程序中已经看到怎样用 scanf函数输入数据。下面再作比较系统的说明。
scanf 函数的一般形式
scanf格式控制地址表列
“格式控制”的含义同 printf函数。“地址表列”是由若干个地址组成的表列，可以是变量的地址，或字符串的首地址。
scanf函数中的格式声明
与 printf函数中的格式声明相似，以开始，以一个格式字符结束，中间可以插入附加的字符。
例 中的 scanf函数是比较简单的。可以把 scanf函数改写成以下形式：
scanfafbfcfabc
在格式字符串中除了有格式声明f以外，还有一些普通字符有“a”“b”“c”和“，”。
表和表列出 scanf函数所用的格式字符和附加字符。它们的用法和 printf函数中的用法差不多。
表 scanf函数中用到的格式字符
格式字符 说 明 di 输入有符号的十进制整数 u 输入无符号的十进制整数 o 输入无符号的八进制整数 x X 输入无符号的十六进制整数大小写作用相同 C输入单个字符s输入字符串，将字符串送到一个字符数组中，在输入时以非空白字符开始，以第一个空白字符结束。字符串以串结束标志作为其最后一个字符f输入实数，可以用小数形式或指数形式输入e E g G与f作用相同，e与f、g可以互相替换大小写作用相同
第章 最简单的C程序设计——顺序程序设计
表 scanf函数中用到的格式附加字符
字符 说 明 输入长整型数据可用 ld lo lx lu以及 double 型数据用 lf 或 le h 输入短整型数据可用 hd ho hx域宽指定输入数据所占宽度列数，域宽应为正整数本输入项在读入后不赋给相应的变量
这两个表是为了备查用的，不必死记。开始时会用比较简单的形式输入数据即可。
使用 scanf函数时应注意的问题
scanf函数中的格式控制后面应当是变量地址，而不是变量名。例如，若a 和 b为整型变量，如果写成
scanffffabc
是不对的。应将“abc”改为“abc”。许多初学者常犯此错误。
如果在格式控制字符串中除了格式声明以外还有其他字符，则在输入数据时在对应的位置上应输入与这些字符相同的字符。如果有
scanfafbfcfabc
在输入数据时，应在对应的位置上输入同样的字符。即输入
abc∠ 注意输入的内容
如果输入
✔
就错了。因为系统会把它和 scanf函数中的格式字符串逐个字符对照检查的，只是在f的位置上代以一个浮点数。
注意 在“a” 的后面输入一个逗号，它与 scanf函数中的“格式控制”中的逗号对应。如果输入时不用逗号而用空格或其他字符是不对的。
在用“c”格式声明输入字符时，空格字符和“转义字符”中的字符都作为有效字符输入，例如：
scanfcccccc
在执行此函数时应该连续输入个字符，中间不要有空格。如：
abc✔ 字符间没有空格
若在两个字符间插入空格就不对了。如：
abc∠
系统会把第个字符a送给c；第个字符是空格字符 ，送给c；第个字符b送给
C程序设计第五版
c。而并不是把a送给c把b送给 c把c送给c。
提示：输入数值时，在两个数值之间需要插入空格或其他分隔符，以使系统能区分两个数值。在连续输入字符时，在两个字符之间不要插入空格或其他分隔符除非在 scanf函数中的格式字符串中有普通字符，这时在输入数据时要在原位置插入这些字符，系统能区分两个字符。
在输入数值数据时，如输入空格、回车、 Tab键或遇非法字符不属于数值的字符，认为该数据结束。例如：
scanfdcfabc
若输入
a o
a
b
c
第个数据对应d格式，在输入之后遇字符a，因此系统认为数值后已没有数字了，第个数据应到此结束，就把送给变量a。把其后的字符a送给字符变量b，由于c只要求输入一个字符，系统判定该字符已输入结束，因此输入字符a之后不需要加空格。字符a后面的数值应送给变量c。如果由于疏忽把 错打成o，由于后面出现字母o，就认为该数值数据到此结束，将 送给变量c，后面几个字符没有被读入。
字符输入输出函数
除了可以用 printf函数和 scanf函数输出和输入字符外，C函数库还提供了一些专门用于输入和输出字符的函数。它们是很容易理解和使用的。
用 putchar函数输出一个字符
想从计算机向显示器输出一个字符，可以调用系统函数库中的 putchar函数字符输出函数。
putchar函数的一般形式为
putcharc
putchar 是 put character给字符的缩写很容易记忆。C语言的函数名大多是可以见名知义的，不必死记。 putcharc的作用是输出字符变量c的值，显然输出的是一个字符。
【例】 先后输出 BOY 三个字符。
解题思路：定义个字符变量，分别赋以初值B，O，Y，然后用 putchar 函数输出这个字符变量的值。
编写程序：
include stdio h
int main
定义个字符变量并初始化
第章 最简单的C程序设计——顺序程序设计
putchara 向显示器输出字符 B
putcharb 向显示器输出字符O
putcharc 向显示器输出字符Y
putcharn 向显示器输出一个换行符
return
运行结果：
BOY
连续输出B，O，Y个字符，然后换行。
从此例可以看出：用putchar函数既可以输出能在显示器屏幕上显示的字符，也可以输出屏幕控制字符，如putcharn的作用是输出一个换行符，使输出的当前位置移到下一行的开头。
如果把上面的程序改为以下这样，请思考输出结果。
include stdio h
int main
int abc 定义个整型变量，并初始化
putchara 向显示器输出字符B
putcharb 向显示器输出字符O
putcharc 向显示器输出字符Y
putcharn 向显示器输出一个换行符
return
运行结果：
BOY
从前面的介绍已知：字符类型也属于整数类型，因此将一个字符赋给字符变量和将字符的ASCII代码赋给字符变量作用是完全相同的但应注意，整型数据的范围为。 putchar函数是输出字符的函数，它输出的是字符而不能输出整数。是字符 B的 ASCII代码因此 putchar输出字符B。其他类似。
说明： putcharc中的c可以是字符常量、整型常量、字符变量或整型变量其值在字符的 ASCⅡ代码范围内。
可以用 putchar函数输出转义字符，例如：
putchar 输出字符A
putchar 括号中的是转义字符代表单撇号，输出单撇号字符
putchar
八进制数等于十进制数，从附录A查出是“回车”的ASCⅡ代码，因此输出回车，不换行，使输出的当前位置移到本行开头
用 getchar函数输入一个字符
为了向计算机输入一个字符，可以调用系统函数库中的 getchar函数字符输入函数。
C程序设计第五版
getchar函数的一般形式为
getchar
getchar是 get character取得字符的缩写 getchar 函数没有参数它的作用是从计算机终端一般是键盘输入一个字符，即计算机获得一个字符。 getchar函数的值就是从输入设备得到的字符。 getchar函数只能接收一个字符。如果想输入多个字符就要用多个 getchar函数。
【例】 从键盘输入 BOY 个字符，然后把它们输出到屏幕。
解题思路：用个 getchar 函数先后从键盘向计算机输入 BOY 个字符，然后用 putchar函数输出。
编写程序：
include stdio h
int main
char abc 定义字符变量abc
a getchar 从键盘输入一个字符，送给字符变量a
b getchar 从键盘输入一个字符，送给字符变量b
c getchar 从键盘输入一个字符，送给字符变量c
putchara 将变量a的值输出
putcharb 将变量b的值输出
putcharc 将变量c的值输出
putcharn 换行
return
运行结果：
BOY
BOY
注意： 在连续输入 BOY 并按 Enter键后，字符才送到计算机中，然后输出BOY 个字符。
说明：在用键盘输入信息时，并不是在键盘上敲一个字符，该字符就立即送到计算机中去的。这些字符先暂存在键盘的缓冲器中，只有按了 Enter键才把这些字符一起输入到计算机中，然后按先后顺序分别赋给相应的变量。
如果在运行时，每输入一个字符后马上按 Enter键，会得到什么结果
运行情况：
BOBO
输入字符B后马上按 Enter，再输入字符O，按 Enter。立即会分两行输出B和O。
请思考是什么原因
第行输入的不是一个字符 B，而是两个字符： B和换行符，其中字符B赋给了变量a，换行符赋给了变量b。第行接着输入两个字符： O和换行符，其中字符O赋给了变量c，换行符没有送入任何变量。在用 putchar函数输出变量a，b，c的值时，就输出了字符B，然
第章 最简单的C程序设计——顺序程序设计
后输出换行再输出字符O然后执行 putcharn换行。
注意：执行 getchar函数不仅可以从输入设备获得一个可显示的字符，而且可以获得在屏幕上无法显示的字符，如控制字符。
用 getchar函数得到的字符可以赋给一个字符变量或整型变量，也可以不赋给任何变量，而作为表达式的一部分，在表达式中利用它的值。例如，例可以改写如下：
include stdio h
int main
putchar getchar 将接收到的字符输出
putchar getchar 将接收到的字符输出
putchar getchar 将接收到的字符输出
putcharn 换行
return
运行结果：
BOY
BOY
连续输入 BOY后按 Enter键输出 BOY然后换行。
在连续输入 BOY 并按 Enter键后，这些字符才被送到计算机中，然后按得到字符的顺序输出个字符BOY，最后再输出一个回车。因为第个 getchar函数得到的值为B，因此 putchar getchar相当于 putcharB输出B。第个 getchar 函数相当于 putcharO输出得到的值为O。第个情况类似。
注意： 不要在按B后马上按回车键，这样就会把回车也作为一个字符输入。
也可以在 printf函数中输出刚接收的字符：
printfc getchar c是输出字符的格式声明
在执行此语句时，先从键盘输入一个字符，然后用输出格式符c输出该字符。
【例】 改写例程序，使之可以适用于任何大写字母。从键盘输入一个大写字母，在显示屏上显示对应的小写字母。
解题思路：用getchar函数从键盘读入一个大写字母，把它转换为小写字母，然后用 putchar函数输出该小写字母。
编写程序：
include stdio h
int main
char cc
c getchar 从键盘读入一个大写字母，赋给字符变量c
cc 求对应小写字母的 ASCⅡ代码，放在字符变量c中
putcharc 输出c的值，是一个字符
putcharn
return
C程序设计第五版
运行结果：
Bb
从键盘输入一个大写字母，在显示屏上显示对应的小写字母。
当然，也可以用 printf函数输出。把最后两个 putchar函数改用一个 printf函数代替；
include stdio h
int main
char cc
c getchar 从键盘读入一个大写字母，赋给字符变量c
cc 得到对应的小写字母的 ASCⅡ代码，放在字符变量c中
printf大写字母 cn小写字母 cncc 输出cc的值
return
运行结果：
N
大写字母： N
小写字母： n
从键盘输入一个大写字母N，程序输出大写N 和小写n。
说明： 如果使用汉化的C编译系统如 Visual C中文版，可以在 printf函数的格式字符串中包含汉字，在输出时就能显示汉字，以增加可读性。
思考： 可以用 printf函数和 scanf函数输出或输入字符，也可以用字符输入输出函数输入或输出字符，请比较这两个方法的特点，在特定情况下用哪一种方法为宜。
本章结合介绍最简单的程序，系统地介绍了编写程序的各项要素，有了这些基础，就可以开始编写程序了。
习 题
假如我国国民生产总值的年增长率为，计算年后我国国民生产总值与现在相比增长多少百分比。计算公式为
pr
r为年增长率，n为年数，p为与现在相比的倍数。
存款利息的计算。有元，想存年，可按以下种办法存：
一次存年期。
先存年期，到期后将本息再存年期。
先存年期，到期后将本息再存年期。
存年期，到期后将本息再存年期，连续存次。
存活期存款。活期利息每一季度结算一次。
年的银行存款利息如下：
年期定期存款利息为；
第章 最简单的C程序设计——顺序程序设计
年期定期存款利息为；
年期定期存款利息为；
年期定期存款利息为；
活期存款利息为活期存款每一季度结算一次利息。
如果r为年利率，n为存款年数，则计算本息和的公式如下：
年期本息和 Pr
n年期本息和 Pnr
存n次年期的本息和： Pr
活期存款本息和：
说明：是一个季度的本息和。
购房从银行贷了一笔款d，准备每月还款额为p，月利率为r，计算多少月能还清。设d为 元，p为元，r为。对求得的月份取小数点后一位，对第位按四舍五入处理。
提示：计算还清月数m的公式如下：
可以将公式改写为
C的库函数中有求对数的函数 log是求以为底的对数 logp表示 log p。
分析下面的程序：
include stdio h
int main
char cc
c
c
return
运行时会输出什么信息 为什么
如果将程序第，行改为
c
c
运行时会输出什么信息 为什么
如果将程序第行改为
int cc
C程序设计第五版
运行时会输出什么信息 为什么
用下面的 scanf函数输入数据使 a在键盘上应如何输入
include stdio h
int main
int ab
float xy
char cc
scanfa dbdab
scanffeay
scanfcccc
return
请编程序将“China”译成密码，密码规律是：用原来的字母后面第个字母代替原来 的字母。例如字母“A”后面第个字母是“E”用“E”代替“A”。因此 “China”应译为 “Glmre”。请编一程序用赋初值的方法使 ccccc 这个变量的值分别为China经过运算使ccccc分别变为Glmre。分别用 putchar函数和 printf函数输出这个字符。
设圆半径r，圆柱高h，求圆周长、圆面积、圆球表面积、圆球体积、圆柱体积。用scanf输入数据，输出计算结果，输出时要求有文字说明，取小数点后位数字。请编程序。
编程序用 getchar函数读入两个字符给c和c然后分别用 putchar 函数和 printf 函数输出这两个字符。思考以下问题：
变量c 和c应定义为字符型、整型还是二者皆可
要求输出 c和c值的 ASCⅡ码应如何处理 用 putchar函数还是 printf函数
整型变量与字符变量是否在任何情况下都可以互相代替 如：
char cc
与
int cc
是否无条件地等价
第章 选择结构程序设计
第章介绍了顺序结构程序设计。在顺序结构中，各语句是按自上而下的顺序执行的，执行完上一个语句就自动执行下一个语句，是无条件的，不必作任何判断。这是最简单的程序结构。实际上，在很多情况下，需要根据某个条件是否满足来决定是否执行指定的操作任务，或者从给定的两种或多种操作选择其一。这就是选择结构要解决的问题。
选择结构和条件判断
在现实生活中需要进行判断和选择的情况是很多的。如：从北京出发上高速公路，到一个岔路口，有两个出口，一个是去上海方向，另一个是沈阳方向。驾车者到此处必须进行判断，根据自己的目的地，从二者中选择一条路径，见图。
在日常生活或工作中，类似这样需要判断的情况是司空见惯的。如：
·如果你在家，我去拜访你； 需要判断你是否在家
·如果考试不及格，要补考； 需要判断是否及格
· 如果遇到红灯，要停车等待； 需要判断是否红灯
·周末我们去郊游； 需要判断是否周末
·如果可以求出方程的实根。
需要判断是否满足
又如： 输入一个数，要求输出其绝对值。可以写出以下语句：
ifx
printfdx
else
printfdx
用 if语句进行检查，如果x的值符合x≥的条件，就输出x的值。否则就输出x的值。接着执行 if语句的下一个语句。用流程图表示见图。
沈阳
上海
②
①
是
否
x≥
输出x
输出x
北京
图
图
C程序设计第五版
可以看到： 要处理以上问题，关键在于进行“条件判断”。
由于程序处理问题的需要，在大多数程序中都会包含选择结构，需要在进行下一个操作之前先进行条件判断。
C语言有两种选择语句： if语句，用来实现两个分支的选择结构；switch 语句， 用来实现多分支的选择结构。本节先介绍怎样用 if语句实现双分支选择结构，这是很容易理解的，然后在此基础上介绍怎样用 switch语句实现多分支选择结构。输入abc
计算 disc
b²ac
否
disc
是
【例】 在例 的基础上对程序进行改进。题目要求解得方程的根。由键盘输入abc。假设abc的值任意并不保证需要在程序中进行判别，如果就计算并输出方程的两个实根，如果就输出“此方程无实根”的信息。
计算x₁x₂
输出“此方程无实根”
解题思路： 画出流程图，见图。
输出x₁x₂
编写程序：
结束
include stdio h
include math h 程序中要调用求平方根函数 sqrt
图
int main
double abc discxxpq disc是判别式 sqrtbbac
scanf lf lf lfabc 输入双精度浮点型变量的值要用格式声明 lf
discbbac
if disc 若
printfThis equation hasnt real rootsn 输出“此方程无实根”
else
pba
q sqrt disca
xpqxpq 求出方程的两个根
printfreal roots nxlfnxfnxx 输出方程的两个根
return
运行结果运行两次：
This equation hasnt real roots
输入abc的值程序输出“此方程无实根”。
real roots
x
×
输入abc的值程序输出两个实根。
第章 选择结构程序设计
程序分析：
为提高精度以及避免在编译时出现“警告”，将所有变量定义为双精度浮点型。
在用 scanf函数输入双精度实型数据时，不能用“f”格式声明，而应当用“ lf”格式声明。即在格式符f的前面加修饰符l小写字母，表示是“长浮点型”，即双精度型。 scanf函数中附加字符的用法见第 章表。在输出双精度实型数据时，可以用“f”“ lf”或“m nf”以指定输出的精度。
用if语句来实现选择结构。第行是一个选择结构。 if语句对给定条件“disc”进行判断后，形成两条路径，一条是执行第行的输出语句，另一条是输出第行的复合语句。
在第二次运行输入数据时，输入了整数，，。而在 scanf函数中用“ lf”格式声明，要求将数送到双精度变量中。在输入数字之后，输入了一个非数字字符空格，系统就认为第个数据到此结束，把整数转换为双精度数，然后赋给变量a。其他亦然。
输出实根时用“f”格式声明，保留两位小数，对小数点后第位自动四舍五入。如果改用“f”格式声明，则输出：
real roots
x
x
可见对小数点后第位四舍五入，并且上下行小数点对齐。
用 if 语句实现选择结构
用 if 语句处理选择结构举例
从例可以看到：在C语言中选择结构主要是用 if语句实现的。为了进一步了解 if语句的应用，下面再举两个简单的例子。
【例】 输入两个实数，按由小到大的顺序输出这两个数。
解题思路：这个问题的算法很简单，只要做一次比较，然后进行一次交换即可。用if语句实现条件判断。
关键是怎样实现两个变量的值的互换。不能把两个变量直接互相赋值，如为了将a和b对换，不能用下面的办法：
ab 把变量b的值赋给变量a，a的值等于 b的值
ba 再把变量a的值赋给变量b，变量b值没有改变
为了实现互换。必须借助于第个变量。可以这样考虑：将A 和B两个杯子中的水互换，用两个杯子的水倒来倒去的办法是无法实现的。必须借助于第个杯子C，先把A杯的水倒在C杯中，再把B杯的水倒在 A 杯中，最后再把C杯的水倒在B杯中，这就实现了两个杯子中的水互换。这是在程序中实现两变量换值的算法。
编写程序：
include stdio h
C程序设计第五版
int main
float abt
scanfffab
ifab
将a和b的值互换
ta
ab
bt
printfffnab
return
运行结果：
程序分析： 输入和两个数给变量a和b，用 if语句进行判断，如果ab，使a和b的值互换。否则不互换。请熟练掌握交换两个变量的值的方法。经过 if语句的处理后，变量a是小数，b是大数。依次输出a和b，就实现了由小到大顺序的输出。
【例】 输入个数a，b，c，要求按由小到大的顺序输出。
解题思路： 解此题的算法比上一题稍复杂一些。可以先用伪代码写出算法：
S if ab将a 和 b对换 交换后，a是a，b中的小者
S if ac将a 和c对换 交换后，a是a，c中的小者，因此a是三者中最小者
S if bc将b 和c对换 交换后，b是b，c中的小者，也是三者中次小者
S 顺序输出abc。
编写程序：
include stdio h
int main
float abct
scanffffabc
ifab
ta 借助变量t，实现变量 a和变量b互换值
ab
bt
互换后，a小于或等于b
ifac
ta 借助变量t，实现变量a和变量c互换值
ac
ct
第章 选择结构程序设计
互换后，a小于或等于c
ifbc 还要
tb 借助变量t，实现变量b和变量c互换值
bc
ct
互换后，b小于或等于c
printffffnabc 顺序输出abc的值
return
运行结果：
程序分析： 在经过第次互换值后，a≤b，经过第次互换值后a≤c，这样a已是三者中最小的或最小者之一，但是b和c谁大还未解决，还需要进行比较和互换。经过第次互换值后，a≤b≤c。此时，a，b，c个变量已按由小到大顺序排列。顺序输出a，b，c的值即实现了由小到大输出个数。
if语句的一般形式
通过上面个简单的例子，可以初步知道怎样使用 if语句去实现选择结构。
if语句的一般形式如下：
if表达式 语句
else 语句
if语句中的“表达式”可以是关系表达式、逻辑表达式，甚至是数值表达式。其中最直观、最容易理解的是关系表达式。例程序第行 if disc，其中的“disc”就是一个关系表达式。所谓关系表达式就是两个数值进行比较的式子。下一节将对此进行详细的讨论。
在上面 if语句的一般形式中，方括号内的部分即 else子句为可选的，既可以有，也可以没有。
语句和语句可以是一个简单的语句，也可以是一个复合语句，还可以是另一个 if语句即在一个 if语句中又包括另一个或多个内嵌的 if语句。
根据 if语句的一般形式， if语句可以写成不同的形式，最常用的有以下种形式：
if表达式 语句 没有 else子句部分
if表达式 有 else子句部分
语句
else
语句
if表达式 语句 在 else 部分又嵌套了多层的 if语句
else if表达式 语句
else if表达式 语句
⋮
C程序设计第五版
else if表达式m 语句 m
else 语句m
例如：
if number cost
else if number cost
else if number cost
else if number cost
else cost
这种形式相当于：
if number
cost
else
if number 在 if 语句的 else部分内嵌了一个 if语句
cost
else
if number 在内嵌的 if语句的 else部分又内嵌了一个 if语句
cost
else
if number 在第层内嵌的 if语句的 else部分又内嵌了一个 if语句
cost
else 第层内嵌的 if语句中的 else子句
cost
写成上面的“if… else if… else if… else if… else”形式更为直观和简洁。
说明：
整个 if语句可以写在多行上，也可以写在一行上，如：
ifxy else y
但是，为了程序的清晰，提倡写成锯齿形式。
一般形式中“语句”“语句”“语句 m”等是 if语句中的“内嵌语句”。它们是 if语句中的一部分。每个内嵌语句的末尾都应当有分号，因为分号是语句中的必要成分。如：
ifx
y 语句末尾必须有分号
else
y 语句末尾必须有分号
不能写成：
ifx y else y “语句”的末尾缺少分号
如果无此分号，则出现语法错误。
if语句无论写在几行上，都是一个整体，属于同一个语句。不要误认为 if部分是一个语句， else部分是另一个语句。不要一看见分号，就以为是if语句结束了。在系统对 if语
第章 选择结构程序设计
句编译时，若发现内嵌语句结束出现分号，还要检查其后有无 else，如果无 else，就认为整个 if语句结束，如果有 else，则把 else 子句作为 if语句的一部分。注意 else 子句不能作为语句单独使用，它必须是 if语句的一部分，与 if配对使用。
“语句”“语句”…“语句m”可以是一个简单的语句，也可以是一个包括多个语句的复合语句。例程序中的 if语句中的 else子句中的内嵌语句就是一个复合语句。注意：复合语句应当用花括号括起来。请分析，如果程序中的 if语句的 else分支中没有用花括号，情况会怎样。请画出其相应的流程图。
内嵌语句也可以是一个 if语句。如用if语句表示阶跃函数：
可以写成：
ifx
y
else
ifx 内嵌语句是一个 if语句，它也包含 else部分
y
else
y
是
否
其流程图见图。
在if语句中要对给定的条件进行检查，判定所给定的条件是否成立。判断的结果是一个逻辑值“是”或“否”。例如，需要判断的条件是“考试是否合格”，答案只能有两个“是”或“否”而不是数值 或。在计算机语言中用“真”和“假”来表示“是”或“否”。例如，判断一个人是否“岁以上”，如果有一个人年龄为岁，对他而言， “岁以上”是“真的”，如果有一个人年龄为岁，对他而言， “岁以上”是“假的”。又如： 判断“ab”条件是否满足，当时，就称条件“ab”为“真”如果a≤b则不满足“ab”条件就称此时条件“ab”为假。
关系运算符和关系表达式
在例程序中已看到，在if语句中对关系表达式进行判断。其中的“”是一个比较符，用来对两个数值进行比较。在C语言中，比较符或称比较运算符称为关系运算符。所谓“关系运算”就是“比较运算”，将两个数值进行比较，判断其比较的结果是否符合给定的条件。例如，是一个关系表达式，大于号是一个关系运算符，如果a的值为，则满足给定的“a”条件，因此关系表达式的值为“真”即“条件满足”；如果a的值为，不满足“a”条件，则称关系表达式的值为“假”。
C程序设计第五版
关系运算符及其优先次序
C语言提供种关系运算符：
① 小于
② 小于或等于
优先级相同高
③ 大于
④大于或等于
⑤ 等于 优先级相同低
⑥ 不等于
关于优先次序：
前种关系运算符，，，的优先级别相同，后种也相同。前种高于后种。例如 “”优先于“”。而“”与“”优先级相同。
关系运算符的优先级低于算术运算符。
关系运算符的优先级高于赋值运算符。
关系运算符
以上关系见图。
赋值运算符
低
例如：
cab 等效于 cab 关系运算符的优先级低于算术运算符
图
abc 等效于 abc大于运算符的优先级高于相等运算符
abc 等效于 abc 小于运算符的优先级高于相等运算符
abc 等效于 abc 关系运算符的优先级高于赋值运算符
关系表达式
用关系运算符将两个数值或数值表达式连接起来的式子，称为关系表达式。例如，下面都 是合法的关系表达式ababbcabababbc。关系表达式的值是一个逻辑值，即“真”或“假”。例如，关系表达式“”的值为“假”， “”的值为“真”。在C的逻辑运算中以“”代表“真”以“”代表“假”。若abc则
关系表达式“ab”的值为“真”，表达式的值为。
关系表达式“abc”的值为“真”因为ab的值为，等于c的值，表达式的值为。
关系表达式“bca”的值为“假”，表达式的值为。
如果有以下赋值表达式：
dab，由于ab为真，因此关系表达式ab的值为，所以赋值后d的值为。
fabc，则f的值为。因为“”运算符是自左至右的结合方向，先执行“ab”得值为，再执行关系运算“c”，得值，赋给f，所以f的值为。
逻辑运算符和逻辑表达式
有时要求判断的条件不是一个简单的条件，而是由几个给定简单条件组成的复合条件。如：“如果星期六不下雨，我去公园玩”。这就是由两个简单条件组成的复合条件，需要判定
第章 选择结构程序设计
两个条件：是否星期六；是否下雨。只有这两个条件都满足，才去公园玩。又如“参加少年运动会的年龄限制为岁”，这就需要检查两个条件：年龄 age≥，年龄age≤。这个组合条件是不能够用一个关系表达式来表示的，要用两个表达式的组合来表示即 age AND age。用一个逻辑运算符 AND 连接 age 和 age。两个关系表达式组成一个复合条件。“AND”的含义是“与”，即“二者同时满足”。 age AND age 表示 age和 age同时满足。这个复合的关系表达式“age AND age”就是一个逻辑表达式。其他逻辑表达式可以有：
x AND y 同时满足 x和y
age OR age 表示年龄 age小于的儿童或大于的老人
上面第个逻辑表达式的含义是： 只有 x和y都为真时，逻辑表达式x AND y才为真。上面第个逻辑表达式的含义是： age或age至少有一个为真时，逻辑表达式 ageOR age为真。OR 是“或”的意思即“有一即可”在两个条件中有一个满足即可。AND和OR是逻辑运算符。
用逻辑运算符将关系表达式或其他逻辑量连接起来的式子就是逻辑表达式。
逻辑运算符及其优先次序
有种逻辑运算符与AND或OR非NOT。在 BASIC 和 Pascal 等语言中可以在程序中直接用AND，OR，NOT作为逻辑运算符。在C语言中不能在程序中直接用AND，OR，NOT 作为逻辑运算符，而是用其他符号代替。见表。
表C逻辑运算符及其含义
运算符 含 义 举 例 说 明 逻辑与AND a b 如果 a 和b都为真，则结果为真，否则为假 Ⅱ 逻辑或OR ab 如果a和b有一个以上为真，则结果为真，二者都为 假时，结果为假 逻辑非NOTa如果 a为假，则！a为真，如果 a为真，则！a为假
“”和“‖”是双目元运算符，它要求有两个运算对象操作数，如abxyab∥xy。“”是一目元运算符只要求有一个运算对象如ab。
表为逻辑运算的真值表。用它表示当a和b的值为不同组合时，各种逻辑运算所得到的值。
表逻辑运算的真值表
a b a b a b ab 真 真 假 假 真 真 真 假 假 真 假 真 假 真 真 假 假 真 假 假真真假假
C程序设计第五版
在一个逻辑表达式中如果包含多个逻辑运算符，例如：！ab∥xyc。按以下的优先次序：
非→与→‖或即“”为三者中最高的。
逻辑运算符中的“”和“‖”低于关系运算符， “！”高于算术运算符，见图。
非
高
算术运算符
关系运算符
例如：
和
abxy 可写成 abxy
赋值运算符
低
abxy 可写成 ab∥xy
图
aab 可写成 a∥ab
逻辑表达式
如前所述，逻辑表达式的值应该是一个逻辑量“真”或“假”。C语言编译系统在表示逻辑运算结果时，用数值代表“真”，用代表“假”，但在判断一个量是否为“真”时，以代表“假”，以非代表“真”。即将一个非零的数值认作为“真”。例如：
若a，则！a的值为。因为a的值为非，被认作“真”，对它进行“非运算”，得“假”。“假”以代表。
若ab则ab的值为。因为a和b均为非被认为是“真”因此ab的值也为“真”值为。
a和b值分别为和a∥b的值为。
a和b值分别为和 a∥b的值为。
‖的值为。
通过这几个例子可以看出，由系统给出的逻辑运算结果不是就是，不可能是其他数值。而在逻辑表达式中作为参加逻辑运算的运算对象可以是“假”或任何非的数值按“真”对待。如果在一个表达式中不同位置上出现数值，应区分哪些是作为数值运算或关系运算的对象，哪些作为逻辑运算的对象。例如：
表达式自左至右扫描求解。首先处理“”因为关系运算符优先于逻辑运算符。在关系运算符两侧的和作为数值参加关系运算， “”的值为代表真。再进行“ ！”的运算，的左侧为“”，右侧为“”运算符，根据优先规则，应先进行“”的运算，即先进行“！”的运算。现在 的左侧为“”，右侧为“”运算符，而“一”优先于“”，因此应先进行“！”的运算，由于“！”的级别最高，因此先进行“！”的运算，得到结果。然后进行“”的运算，得到结果，再进行“”的运算，得，最后进行“”的运算结果为。
实际上，逻辑运算符两侧的运算对象不但可以是和，或者是 和非的整数，也可以是字符型、浮点型、枚举型或指针型的纯量型数据。系统最终以和非来判定它们属于“真”或“假”。例如cd的值为因为c和d的 ASCII值都不为按“真”处理所以 的值为。
可以将表改写成表形式。
第章 选择结构程序设计
表 逻辑运算的真值表
a b a b a b ab 非 非 非 假 非 假
在逻辑表达式的求解中，并不是所有的逻辑运算符都被执行，只是在必须执行下一个逻辑运算符才能求出表达式的解时，才执行该运算符。举例如下。
abc。 只有a为真非时，才需要判别b的值。只有当a和b都为真的情况下才需要判别c的值。如果a为假，就不必判别 b和c此时整个表达式已确定为假。如果a为真，b为假，不判别c，见图。
a∥b∥c。只要a为真非就不必判断b和c。只有a为假才判别b。a和b都为假才判别c，见图。
假
非真
a
a
非真
假
假
非真
b
b
非真
假
假
非真
c
c
非真
假
真
假
假
真
图
图
也就是说，在中，对运算符来说，只有a≠a为真，才继续进行右面的运算。在中，对∥运算符来说，只有a，才继续进行其右面的运算。因此，如果有下面的逻辑表达式：
mabncd
当abcdm和n的原值为时由于“ab”的值为因此m此时已能 判定整个表达式不可能为真，不必再进行“ncd”的运算，因此n的值不是而仍保持原值。这点请读者注意。
说明： 既然关系表达式和逻辑表达式的值是和，而且在判断一个量是否为“真”时，以代表“假”，以非代表“真”。那么就可以理解为什么在 if 语句中表达式可以是任何数值表达式。如：
ifx语句 括号内的表达式是关系表达式，如果x不等于，执行语句
ifxy语句 表达式是逻辑表达式如果x和y都大于执行语句
ifx语句 表达式是变量，如果x不等于，则条件判断结果为真，执行语句
if语句 表达式是非整数，条件判断结果为真，执行语句
C程序设计第五版
if 语句 表达式是整数，条件判断结果为假，不执行语句，接着执行下一语句
ifx语句 表达式是实数表达式，若x不等于，则条件判断结果为真，执行语句
熟练掌握C语言的关系运算符和逻辑运算符后，可以巧妙地用一个逻辑表达式来表示一个复杂的条件。
例如，判别用 year表示的某一年是否为闰年，可以用一个逻辑表达式来表示。闰年的条件是符合下面二者之一：①能被整除，但不能被整除，如。②能被整除，如。可写出逻辑表达式：
year year year
year为整数年份，如果上述表达式值为真值为，则 year为闰年；否则 year 为非闰年。
可以加一个“！”用来判别非闰年：
year year year
若此表达式值为真，则year为非闰年。也可以用下面逻辑表达式判别非闰年：
year year year
若表达式值为真，则year为非闰年。请注意表达式中右面的括号内的不同运算符，！，，的运算优先次序。
条件运算符和条件表达式
有一种 if语句，当被判别的表达式的值为“真”或“假”时，都执行一个赋值语句且向同一个变量赋值。如：
ifab
maxa
else
maxb
当ab时将a的值赋给 max，当a≤b时将 b的值赋给 max，可以看到无论ab是否满足，都是给同一个变量赋值。C提供条件运算符和条件表达式来处理这类问题。可以把上面的 if语句改写为
maxab ab
赋值号右侧的“ab a：b”是一个“条件表达式”。“”是条件运算符。
如果ab条件为真，则条件表达式的值等于a；否则取值b。如果a等于，b等于，则条件表达式“ab ab”的值就是a的值把它赋给变量 max因此 max的值为。
条件运算符由两个符号和：组成，必须一起使用。要求有个操作对象，称为三目元运算符，它是C语言中唯一的一个三目运算符。
条件表达式的一般形式为
表达式 表达式： 表达式
第章 选择结构程序设计
它的执行过程见图。
可以这样形象地理解： 先计算出表达式的值，表达式后面的问号表示“该往哪里走啊”，有两条路，如果表达式的值为真非，自然直接到表达式，如为假值，就绕过表达式，到表达式，如图示意。
表达式
你的值
真非
假
是什么
真非
表达式
条件表达式
条件表达式
表达式
假
取表达式的值
取表达式的值
表达式
图
图
说明：
条件运算符的执行顺序： 先求解表达式，若为非真则求解表达式，此时表达式的值就作为整个条件表达式的值。若表达式的值为假，则求解表达式，表达式的值就是整个条件表达式的值。赋值表达式
maxab ab
的执行结果就是将条件表达式的值赋给 max，也就是将a和b二者中的大者赋给 max。
条件运算符优先于赋值运算符，因此赋值表达式的求解过程是先求解条件表达式，再将它的值赋给 max。
上面的例子是利用了条件表达式的值，把它赋给一个变量 max。其实也可以不把条件表达式的值赋予一个变量，而在条件表达式中的表达式和表达式中对 max赋值，并在条件表达式后面加一个分号，就成为一个独立的语句。如：
ab maxa maxb 表达式和表达式是赋值表达式
相当于：
ifab maxa
else maxb
条件表达式还可以写成以下形式：
ab printfda printfdb
即“表达式”和“表达式”不仅可以是数值表达式，还可以是赋值表达式或函数表达式。上面条件表达式相当于以下 if… else语句：
ifab
printfd a
else
printfdb
C程序设计第五版
【例】 输入一个字符，判别它是否为大写字母，如果是，将它转换成小写字母；如果不是，不转换。然后输出最后得到的字符。
解题思路： 用条件表达式来处理，当字母是大写时，转换成小写字母，否则不转换。
关于大小写字母之间的转换方法，在本书中已做了介绍，因此可直接编写程序。
编写程序：
include stdio h
int main
char ch
scanfc ch
printfcn ch
return
运行结果：
A
a
输入大写字母A，输出小写字母a。
程序分析： 条件表达式“的作用是：如果字符变量 ch的值为大写字母，则条件表达式的值为，即相应的小写字母，是小写字母和大写字母ASCⅡ的差值。如果 ch的值不是大写字母，则条件表达式的值为 ch，即不进行转换。
可以看到，条件表达式相当于一个不带关键字 if的 if 语句，用它处理简单的选择结构可使程序简洁。但初学时用得不多。
选择结构的嵌套
在 if语句中又包含一个或多个 if语句称为 if语句的嵌套 nest。本章节中 if语句的第种形式就属于 if语句的嵌套，其一般形式如下：
if
if 语句
内嵌 if
else 语句
else
if 语句
内嵌 if
else 语句
应当注意 if与 else 的配对关系。 else 总是与它上面的最近的未配对的 if配对。假如写成：
if
第章 选择结构程序设计
if 语句
else 内嵌 if
if 语句
else 语句
编程序者把 else写在与第个 if外层 if同一列上，意图是使 else与第个 if 对应，但实际上 else是与第个 if配对，因为它们相距最近。为了避免二义性的混淆，最好使内嵌if语句也包含 else部分如本节开头列出的形式，这样 if的数目和 else 的数目相同，从内层到外层一一对应，不致出错。
如果 if 与 else的数目不一样，为实现程序设计者的思想，可以加花括号来确定配对关系。例如：
if
if语句 内嵌 if
else 语句
这时“”限定了内嵌 if语句的范围，因此 else与第一个 if配对。
y
【例】 有一阶跃函数见图
x
编一程序，输入一个x值，要求输出相应的y值。
解题思路： 用if语句检查x的值，根据x的值决定赋予 y的值。由于y的可能值不是两个而是个，因此不可能只用一个简单的无内嵌 if的 if语句来实现。可以有两种方法，其算法如下：开始
图
先后用个独立的 if语句处理：
输入x
输入x
若x则 y
若x则 y
Y
N
若x则y
输出 y
Y
N
用一个嵌套的 if语句处理：
输入x
若 x则y
否则
若x则 y
输出y
否则即x则 y
输出y
结束
用流程图表示，见图。
图
C程序设计第五版
编写程序：
采用嵌套的 if语句处理。
程序：
include stdio h
int main
int xy
scanfdx
ifx
y
else
ifxy
else y
return
运行结果：
y
程序：
可将上面程序改为
include stdio h
int main
intxy
scanfdx
ifx 注意分析此 if 语句
ifx y
else y
else y
printfxdydnxy
return
运行结果：
xy
请读者分析本章习题第题提出的问题，弄清楚嵌套 if中各个 if的配对关系以及在程序中对嵌套 if 的书写格式。为了使逻辑关系清晰，避免出错，一般把内嵌的 if语句放在外层的 else子句中如程序那样，这样由于有外层的 else 相隔，内嵌的 else不会被误认为和外层的 if配对，而只能与内嵌的 if配对，这样就不会搞混。
注意： 为了使程序清晰、易读，写程序时对选择结构和循环结构应采用锯齿形的缩
第章 选择结构程序设计
进形式，如本书例题所示那样。
用 switch语句实现多分支选择结构
if语句只有两个分支可供选择，而实际问题中常常需要用到多分支的选择。例如，学生成绩分类分以上为 A 等，分为B等，分为C等，人口统计分类按年龄分为老、中、青、少、儿童，工资统计分类，银行存款分类等。当然这些都可以用嵌套的 if语句来处理，但如果分支较多，则嵌套的 if语句层数多，程序冗长而且可读性降低。C语言提供 switch语句直接处理多分支选择。
switch语句是多分支选择语句。用来实现如图所表示的多分支选择结构。
【例】 要求按照考试成绩的等级输出百分制分数段，A等为分以上，B等为分，C等为分，D等为分以下。成绩的等级由键盘输入。
解题思路： 这是一个多分支选择问题，根据百分制分数将学生成绩分为个等级，如果用 if语句来处理至少要用层嵌套的 if，进行次检查判断。用 switch语句，进行一次检查即可得到结果。
编写程序：
include stdio h
int main
char grade
scanfc grade
printfYour score
switch grade
caseA printfn break
caseB printfn break
caseC printfn break
caseD printfn break
default printfenter data errorn
return
运行结果：
A
Your score
从键盘输入大写字母A，按回车键，程序输出对应的分数段。
程序分析： 等级 grade定义为字符变量，从键盘输入一个大写字母，赋给变量 grade switch得到 grade的值并把它和各 case中给定的值 ABCD之一相比较如果和其中之一相同称为匹配，则执行该 case后面的语句即 printf语句。输出相应的信息。如果输入的字符与ABCD都不相同，就执行 default后面的语句，输出“输入
C程序设计第五版
数据有错”的信息。注意在每个 case后面后的语句中，最后都有一个 break语句，它的作用是使流程转到 switch语句的末尾即右花括号处。流程图见图。
grade
D
其他
输出
输出
输出
输出
输出
图
可以看到， switch语句的作用是根据表达式的值，使流程跳转到不同的语句。 switch语句的一般形式如下：
switch表达式
case 常量 语句
case 常量 语句
⋮ ⋮ …
case 常量 n 语句 n
default 语句 n
说明：
上面 switch一般形式中括号内的“表达式”，其值的类型应为整数类型包括字符型。
switch下面的花括号内是一个复合语句。这个复合语句包括若干语句，它是 switch语句的语句体。语句体内包含多个以关键字 case 开头的语句行和最多一个以 default 开头的行。 case后面跟一个常量或常量表达式如 caseA它们和 default 都是起标号 label，或称标签、标记的作用，用来标志一个位置。执行 switch语句时，先计算 switch 后面的“表达式”的值，然后将它与各 case标号比较，如果与某一个 case标号中的常量相同，流程就转到此 case标号后面的语句。如果没有与 switch表达式相匹配的 case常量，流程转去执行 default标号后面的语句。
可以没有 default标号此时如果没有与 switch表达式相匹配的 case常量则不执行任何语句，流程转到 switch语句的下一个语句。
各个 case标号出现次序不影响执行结果。例如，可以先出现 default标号，再出现“caseD…”然后是“caseB…”。
每一个 case常量必须互不相同；否则就会出现互相矛盾的现象对 switch表达式的同一个值，有两种或多种执行方案。
case标号只起标记的作用。在执行 switch语句时，根据 switch 表达式的值找到匹
第章 选择结构程序设计
配的入口标号，并不在此进行条件检查，在执行完一个 case标号后面的语句后，就从此标号开始执行下去，不再进行判断。例如在例中，如果在各 case子句中没有 break语句，将连续输出：
Your score
enter data error
注意：一般情况下，在执行一个 case子句后，应当用 break语句使流程跳出 switch结构即终止 switch语句的执行。最后一个 case子句今为 default子句中可不必加 break语句，因为流程已到了 switch 结构的结束处。
在case子句中虽然包含了一个以上执行语句，但可以不必用花括号括起来，会自动顺序执行本 case标号后面所有的语句。当然加上花括号也可以。
多个 case标号可以共用一组执行语句，例如：
caseA
caseB
caseC printfn break
⋮
当 grade的值为ABC时都执行同一组语句输出“”然后换行。
【例】 用 switch语句处理菜单命令。在许多应用程序中，用菜单对流程进行控制，例如从键盘输入一个A或a字符，就会执行A操作，输入一个B或b字符，就会执行B操作。可以按以下思路编写程序。
include stdio h
int main
void actionl int intaction int int 函数声明
char ch
int ab
ch getchar
switch ch
casea
caseA actionab break 调用 actionl 函数执行 A 操作
caseb
caseB actionab break 调用 action函数执行 B操作
⋮
default putchara 如果输入其他字符，发出警告
return
、
C程序设计第五版
void action int x int y 执行加法的函数
printfxydnxy
void action int x int y 执行乘法的函数
printfxydnxy
这是一个非常简单的示意程序。假如有一个菜单，对两个整数进行运算，如果输入a或 A就调用 actionl 函数进行两个整数的相加运算如果输入 b 或B就调用 action 函数进行两个整数的相乘运算。当然还可以有C操作、D操作等。
在实际应用中，所指定的操作可能比较复杂，例如：
A： 输入全班学生各门课的成绩
B： 计算并输出每个学生各门课的平均成绩
C： 计算并输出各门课的全班平均成绩
D： 对全班学生的平均成绩由高到低排序并输出
把各 action函数设计成不同的功能以实现以上的要求。
在学习函数一章后，读者可以参照此思路设计一个简单实用的菜单。
选择结构程序综合举例
前面已学习编写和分析过一些程序，下面再综合介绍几个包含选择结构的应用程序。
【例】 写一程序，判断某一年是否为闰年。
解题思路： 在前面已介绍过判别闰年的方法。现在用不同的方法编写程序，请读者分析比较。
程序： 先画出判别闰年算法的流程图，见图。用变量 leap代表是否为闰年的信息。若闰年令 leap非闰年 leap。最后判断 leap是否为真若是则输出“闰年”信息。
year被整除 真 假 真 year被整除 假 leap year被整除 真 假 leap leap leap真 leap假输出“闰年”输出“非闰年”
图
编写程序：
include stdio h
int main
第章 选择结构程序设计
int year leap
printfenter year
scanfd year
if year
if year
if year
leap
else
leap
else
leap
else
leap
if leap
printfd is year
else
printfd is not year
printfa leap yearn
return
运行结果先后运行两次：
is a leap year
is not a leap year
程序分析：
变量 year代表年份， leap是一个“标志变量”，用来表示相应的年份是否为闰年。如果是闰年，就使 leap等于，如果不是闰年，就使 leap等于。最后检查 leap的值，如果是，就不是闰年，输出“非闰年”的信息，如果不是，就是闰年，输出“是闰年”的信息。
请仔细分析程序中各层 if与 else的配对关系。写程序时采取锯齿形式，可以清楚地看明白嵌套关系。建议读者今后写程序时一定要采用锯齿形式。
第行“if leap”中如果 leap的值为非例如则 if判断结果为真。写 if leap与写成 if leap含义相同。
程序： 也可以将程序中第行改写成以下的 if语句：
if year
leap
else if year
C程序设计第五版
leap
else if year
leap
else
leap
运行结果：
is not a leap year
程序： 可以用一个逻辑表达式包含所有的闰年条件，将上述 if语句用下面的 if语句代替：
if year year year
leap
else
leap
【例】 求方程的解。
解题思路： 在例中曾编写过程序，但实际上应该有以下几种可能。
①a，不是二次方程。
，有两个相等实根。
有两个不等实根。
，有两个共轭复根。应当以 p qi和pqi 的形式输出复根。其中pbaq
输入abc a T F 输出 “不是 二次 方程” b²ac T F 计算和输 出两个相 等实根 b²ac T F 计算和输 出两个不等实根计算和输出两个共轭复根
画出 NS流程图表示算法见图。
编写程序：
include stdio h 图
include math h
int main
double abc discxx realpart imagpart
scanf lf lf lfabc
printfThe equation
if fabsae
printfis not a quadraticn
else
discbbac
if fabs disc le
printfhas two equal rootsfnba
else
if disce
第章 选择结构程序设计
xb sqrt disca
xbsqrt disca
printfhas distinct real rootsf and fnxx
else
realpartba realpart是复根的实部
imagpart sqrtdisca imagpart是复根的虚部
printfhas complex rootsn
printfffin realpart imagpart 输出一个复数
printfffin realpart imagpart 输出另一个复数
return
运行结果运行次：
输入abc的值得到两个相等的实根。
The equation has two equal roots
输入abc的值得到两个共轭的复根。
The equation has complex roots
i
i
输入abc的值得到两个不等的实根。
The equation has distinct real roots and
程序分析： 程序中用 disc代表 先计算 disc的值，以减少以后的重复计 算。对于判断 b²ac 是否等于时，要注意： 由于 disc即 b²ac是实数，而实数在计算和存储时会有一些微小的误差，因此不能直接进行如下判断：“if disc…”，因为这样可能会出现本来是零的量，由于上述误差而被判别为不等于零而导致结果错误。所以采取的办法是判别 disc的绝对值 fabs disc是否小于一个很小的数例如⁻⁶如果小于此数就认为 disc等于。程序中以 realpart代表实部p以 imagpart代表虚部q以增加可读性。
在输出复根时，先分别计算出其实部与虚部，在printf函数的格式字符串中在输出虚部 的格式声明f后面人为地加一个普通字符“i”，就能输 出“p qi”这样的复数形式。
【例】 运输公司对用户计算运输费用。路程越远，运费越低。标准如下：
s 没有折扣
≤s 折扣
≤s 折扣
≤s 折扣
≤s 折扣
≤s 折扣
C程序设计第五版
解题思路： 设每吨每千米货物的基本运费为 p price的缩写，货物重为 w weight的缩写距离为s折扣为 d discount的缩写则总运费 f freight的缩写的计算公式为
fp×w×s×d
经过仔细分析发现折扣的变化是有规律的： 从图可以看到，折扣的“变化点”都是 的倍数。利用这一特点可以在横轴上加一种坐标cc的值为s。c代表的倍数。当c时表示s无折扣≤c时表示≤s折扣d≤c时d≤c时d≤c时dc≥时d。
冬子朵k
s km
c
图
编写程序：
include stdio h
int main
int cs
float pwdf
printfplease enter price weight discount 提示输入的数据
scanfffdpws 输入单价、重量、距离
ifsc km以上为同一折扣
else cs km以下各段折扣不同，c的值不相同
switchc
case d break c代表km以下折扣d
case d break c代表km以下折扣d
case
case d break c和代表km折扣d
case
case
case
case d break c代表km折扣d
case
case
case
case d break c代表km折扣d
第章 选择结构程序设计
case d break c代表km以上折扣d
fpwsd 计算总运费
printffreightfnf 输出总运费，取两位小数
return
运行结果：
please enter price weight discount
freight
程序分析：
解此题的关键是找出折扣d与距离s的关系。一般情况下，这类问题都是有一定规律的，要细心观察分析，找出了规律，问题就变得简单了。如果的确没有什么规律，就不能以这种方式使用 switch语句处理可以用嵌套的 if 语句 if… else if… else if… else 形式处理。
c和s是整型变量因此cs的结果为整数。当s时令c而不使c随s增大，这是为了在 switch语句中便于处理，用一个 case就可以处理所有s的情况。
变量名尽量采用“见名知义”的原则如在本程序中用 price weight discount freight等作为变量名，这样，习惯用英语的人在阅读程序时不必解释，就很容易理解各变量的含义。在本书的例题程序，由于是练习程序，并且考虑到多数读者的习惯和方便，尽量不采用较长的变量名，而用单词的首字母或缩写作为变量名。在读者今后编程时，可根据实际情况决定。
第行“printfplease enter price weight discount”的作用是向用户提示应输入什么数据，以方便用户使用，避免出错，形成友好的界面。建议读者在编程序尤其是供别人使用的应用程序也这样做，在scanf函数语句输入数据前，用 printf函数语句输出必要的“提示信息”。
习 题
什么是算术运算 什么是关系运算 什么是逻辑运算
C语言中如何表示“真”和“假” 系统如何判断一个量的“真”和“假”
写出下面各逻辑表达式的值。设
有个整数a，b，c，由键盘输入，输出其中最大的数。
从键盘输入一个小于的正数，要求输出它的平方根如平方根不是整数，则输出其整数部分。要求在输入数据后先对其进行检查是否为小于的正数。若不是，则
C程序设计第五版
要求重新输入。
有一个函数：
写程序，输入x的值，输出y相应的值。
有一函数：
有人编写了以下两个程序，请分析它们是否能实现题目要求。不要急于上机运行程序，先分析两个程序的逻辑，画出它们的流程图，分析它们的运行情况。然后上机运行程序，观察和分析结果。
include stdio h
int main
int xy
printfenter x
scanfdx
y
ifx
ifx
y
else
y
printfxdydnxy
return
include stdio h
int main
int xy
printfenter x
scanfdx
y
ifx
ifx y
else y
printfxdydnxy
return
、
第章 选择结构程序设计
给出一百分制成绩要求输出成绩等级A、B、C、D、E。分以上为A分为B分为C分为D分以下为E。
给一个不多于位的正整数，要求：
①求出它是几位数；
②分别输出每一位数字；
③按逆序输出各位数字，例如原数为，应输出。
企业发放的奖金根据利润提成。利润I低于或等于 元的，奖金可提成利润高于 元低于 元时低于 元的部分按提成高于 元的部分可提成 I≤ 时低于 元的部分仍按上述办法提成下同。高于 元的部分按提成；I≤ 元时高于 元的部分按提成时，高于 元的部分按提成I 时超过 元的部分按提成。从键盘输入当月利润Ⅰ，求应发奖金总数。
要求：
用 if 语句编程序
用 switch语句编程序。
输入个整数，要求按由小到大的顺序输出。
x
有个圆塔圆心分别为、、 、圆半径为见图。这个塔的高度为m，塔以外无建筑物。今输入任一点的坐标，求该点的建筑高度塔外的高度为零。
图
第章 循环结构程序设计
为什么需要循环控制
前面介绍了程序中常用到的顺序结构和选择结构，但是只有这两种结构是不够的，还需要用到循环结构或称重复结构。因为在日常生活中或是在程序所处理的问题中常常遇到需要重复处理的问题。例如：
·要向计算机输入全班个学生的成绩； 重复次相同的输入操作
·分别统计全班个学生的平均成绩； 重复次相同的计算操作
· 求个整数之和； 重复次相同的加法操作
· 检查个学生的成绩是否及格。 重复次相同的判别操作
要处理以上问题，最原始的方法是分别编写若干个相同或相似的语句或程序段进行处理。例如为了统计全班个学生的平均成绩，可以先编写求一个学生平均成绩的程序段：
scanffffffscorescorescorescorescore
输入一个学生门课的成绩
aver scorelscorescorescorescore 求该学生平均成绩
printfaverf aver 输出该学生平均成绩
然后再重复写个同样的程序段。这种方法虽然可以实现要求，但是显然是不可取的，因为工作量大，程序冗长、重复，难以阅读和维护。相信每一位读者都会认为这是最笨的办法。实际上，几乎每一种计算机高级语言都提供了循环控制，用来处理需要进行的重复操作。
在C语言中，可以用循环语句来处理上面的问题：
i 设整型变量i初值为
whilei 当i的值小于或等于时执行花括号内的语句
scanffffffscorescorescorescorescore
输入一个学生门课的成绩
aver scorelscorescorescorescore 求该学生平均成绩
printfaverf aver 输出该学生平均成绩
i 每执行完一次循环使i的值加
可以看到： 用一个循环语句 while语句，就把需要重复执行次程序段的问题解决了。一个 while语句实现了一个循环结构。请读者先阅读这个程序段，理解循环结构的执行过程，在下一节将对其执行过程作必要的说明。
大多数的应用程序都会包含循环结构。循环结构和顺序结构、选择结构是结构化程序设计的种基本结构，它们是各种复杂程序的基本构成单元。因此熟练掌握选择结构和循
第章 循环结构程序设计
环结构的概念及使用是进行程序设计最基本的要求。
用 while语句实现循环
在节中已看到了在C程序中可以用 while语句来实现循环结构。上面的 while循环结构就是一个 while语句，它的执行过程是：开始时变量i的值为， while语句首先检查变量i的值是否小于或等于，如果是，则执行 while后面的语句称为循环体，在本例中是花括号内的复合语句。在循环体中先输入第个学生门课的成绩，然后求出该学生的平均成绩 aver， 并输出此平均成绩。请思考最后一行“i；”的作用。它使i的值加，i的原值为，现在变成了。然后流程返回到 while语句的开头，再检查i 的值是否小于或等于，由于i的值小于，因此又执行循环体，输入第个学生门课的成绩，然后求出第个学生的平均成绩并输出此平均成绩。i又使变量i的值变为，处理第个学生的数据⋯⋯直到处理完第个学生的数据后，i的值变为。由于它大于，因此不再执行循环体。流程图见图，其中，虚线框内为 while循环结构。
输出一个
while语句的一般形式如下：
学生平均成绩
while表达式 语句
其中的“语句”就是循环体。循环体只能是一个语句，可以是一个简单的语句，还可以是复合语句用花括号括起来的若干语句。执行循环体的次数是由循环条件控制的，这个循环条件就是上面一般形式中的“表达式”，它也称为循环条件表达式。当此表达式的值为“真”以非值表示时，就执行循环体语句；为“假”以表示时，就不执行循环体语句。例如“i”是一个循环条件表达式，它是一个关系表达式。它的值只能是“真”或“假”。在执行 while语句时，先检查循环条件表达式的值，当为非值真时，就执行 while语句中的循环体语句；当表达式为假时，不执行循环体语句。其流程图见图。
while语句可简单地记为： 只要当循环条件表达式为真即给定的条件成立，就执行循环体语句。
注意： while循环的特点是先判断条件表达式，后执行循环体语句。
通过下面的例子，可以学习到怎样利用 while语句进行循环程序设计。
【例】 求…即
解题思路： 在处理这个问题时，先分析此题的特点：
这是一个累加的问题，需要先后将个数相加。要重复进行次加法运算，显然可以用循环结构来实现。重复执行循环体次，每次加一个数。
分析每次所加的数有无规律。发现每次累加的数是有规律的，后一个数是前一个数加。因此不需要每次用 scanf语句从键盘临时输入数据，只须在加完上一个数i后，使i
C程序设计第五版
加就可得到下一个数。
为了使思路清晰，画出传统流程图和NS结构流程图表示算法，见图。
sum
假
真
表达式
当
非
语句
a
b
图
图
编写程序。根据流程图写出程序：
include stdio h
int main
int i sum 定义变量i的初值为， sum的初值为
whilei 当i，条件表达式i的值为假，不执行循环体
循环体开始
sum sumi 第次累加后 sum的值为
i 加完后，i的值加，为下次累加做准备
循环体结束
输出…的累加和
return
运行结果：
sun
程序分析：
循环体如果包含一个以上的语句，应该用花括号括起来，作为复合语句出现。如果不加花括号，则 while语句的范围只到 while后面第个分号处。例如，本例中 while 语句中如无花括号则 while语句范围只到“sum sumi”为止。
不要忽略给i和 sum赋初值这是未进行累加前的初始情况，否则它们的值是不可预测的，结果显然不正确。读者可上机试一下。
在循环体中应有使循环趋向于结束的语句。例如，在本例中循环结束的条件是“i”，因此在循环体中应该有使i增值以最终导致i的语句，本例用“i；”语句来达到此目的。如果无此语句，则i的值始终不改变，循环永远不结束。
第章 循环结构程序设计
用 do… while语句实现循环
除了 while语句以外，C语言还提供了 do… while语句来实现循环结构。如：
int i 设变量i的初值为
do 循环结构开始
printfdi 循环体，输出i的值，然后使i加
whilei 当i小于或等于时，继续执行循环体
它的作用是：执行用 do表示“做” printf语句，然后在 while后面的括号内的表达式中 检查i的值，当i小于或等于时，就返回再执行一次循环体 printf语句，直到i大 于为止。执行此 do… while语句的结果是输出共个数。请注意分析 printf函数中的输出项i的作用：先输出当前i的值，然后再使i的值加。如果改为 printfdi则是先使i的值加，然后输出i的新值。若在执行 printf函数之前，i的值为，则 printf函数的输出是i的新值。在本例中 do下面的一对花括号其实不是必要的，因为花括号内只有一个语句。可以写成
do
printfdi
whilei
但这样写，容易使人在看到第行末尾的分号后误认为整个语句结束了。为了使程序清晰、易读，建议把循环体用花括号括起来。
do… while语句的执行过程是：先执行循环体，然后再检查条件是否成立，若成立，再执行循环体。这是和 while语句的不同。
注意： do… while语句的特点是，先无条件地执行循环体，然后判断循环条件是否成立。
do… while语句的一般形式为
do
语句
while表达式
其中的“语句”就是循环体。它的执行过程可以用图 表示。请注意 do… while循环用NS流程图的表示形式图b。
先执行一次指定的循环体语句，然后判别表达式，当表达式的值为非零“真” 时，返回重新执行循环体语句，如此反复，直到表达式的值等于“假”为止，此时循环结束。
【例】 用 do··· while语句求 … 即
解题思路：与例相似，用循环结构来处理。但题目要求用 do… while语句来实现循环结构。先画出流程图，见图。
C程序设计第五版
sum
i
循环体语句
sum sumi
ii
循环体语句
非真
表达式
真
当表达式值为真
假
当i≤
假
a
b
a
b
图
图
编写程序。根据流程图可以很容易写出以下程序：
include stdio h
int main
int i sum
do
sum sumi
i
whilei
return
运行结果：
sum
程序分析： 从例和例可以看到：对同一个问题可以用 while语句处理，也可以用 do… while语句处理。 do… while语句结构可以转换成 while结构。如图 可以改画成图形式，二者完全等价。而图中虚线框部分就是一个 while结构。可见 do… while结构是由一个“语句”加一个 while结构构成的。若图中表达式值为真，则图也与图等价因为都要先执行一次“语句”。
表达式
非真
在一般情况下，用 while语句和用 do… while语句处理同一问题时，若二者的循环体部分是一样的，那么结果也一样。如例和例程序中的循环体是相同的，得到的结果也相同。但是如果 while后面的表达式一开始就为假值时，两种循环的结果是不同的。
语句
图
第章 循环结构程序设计
【例】 while和 do… while循环的比较。
用 while循环
include stdio h
int main
int i sum
printfplease enter ii
scanfdi
whilei
sum sumi
i
printfsumdn sum
return
运行结果两次：
please enter ii
sum
please enter ii
sum
用 do… while 循环
include stdio h
int main
int i sum
printfplease enter ii
scanfdi
do
sum sumi
i
whilei
printfsumdn sum
return
运行结果两次：
please enter ii
sum
再运行一次：
please enter ii
sum
C程序设计第五版
可以看到，当输入i的值小于或等于时，二者得到的结果相同；而当i时，二者结果就不同了。这是因为此时对 while循环来说，一次也不执行循环体表达式“i”的值为假，而对 do… while循环语句来说则至少要执行一次循环体。可以得到结论：当 while后面的表达式的第次的值为“真”时，两种循环得到的结果相同；否则，二者结果不相同指二者具有相同的循环体的情况。
用 for 语句实现循环
除了可以用 while语句和 do… while语句实现循环外，C语言还提供了 for 语句实现循环，而且 for语句更为灵活，不仅可以用于循环次数已经确定的情况，还可以用于循环次数不确定而只给出循环结束条件的情况，它完全可以代替 while语句。
例如：
foriii 控制循环次数i由变到 共循环 次
printfdi 执行循环体，输出i的当前值
它的执行过程见图。
i
它的作用是 输出共个整数。
for语句的一般形式为
N
for表达式表达式表达式
Y
语句
输出i
括号中个表达式的主要作用是：
ii
表达式： 设置初始条件，只执行一次。可以为零个、一个或多个变量设置初值如i。
表达式： 是循环条件表达式，用来判定是否继续循环。在每次执行循环体前先执行此表达式，决定是否继续执行循环。
图
表达式： 作为循环的调整，例如使循环变量增值，它是在执行完循环体后才进行的。
最常用的 for语句形式是：
for循环变量赋初值；循环条件；循环变量增值
语句
例如：
foriii
sum sumi
其中的“i”是给循环变量i设置初值为， “i”是指定循环条件：当循环变量i的值小于或等于时，循环继续执行。“i”的作用是使循环变量i的值不断变化，以便最终满足终止循环的条件，使循环结束。也就是：循环变量i的初值为，循环变量增量为，循环变量终值为，每执行一次循环，i的值加，直到i的值大于，就不再执行了。
for语句的执行过程如下：
求解表达式。本例中把整数赋给变量i。
求解表达式，若此条件表达式的值为真非，则执行 for语句中的循环体，然后
第章 循环结构程序设计
执行第步。若为假，则结束循环，转到第步。
上例中，循环条件表达式“i”是一个关系表达式，当i时，表达式的值为真非，故执行循环体中的语句，即printf语句，输出i的当前值。然后执行第步。
求解表达式。在本例中，执行i，使i的值加，i的值变成。
转回步骤继续执行。
由于此时i，表达式i的值为真，再次执行循环体中的语句， printf语句输出i的当前值。然后再执行步骤。如此反复，直到i变到，此时表达式i的值为假，不再执行循环体，而转到步骤。
可以用图来表示 for语句的执行过程。
求解表达式
表达式
假
真
注意： 在执行完循环体后，循环变量的值“超过”循环终值，循环结束。例如，在本例中，在执行完循环体后循环变量i的值为，大于循环终值。如果循环变量的增值为负值如 forii；i，执行完循环体后循环变量i的值为，小于循环终值。其规律为： 循环变量沿着变化的方向“超过”循环终值，循环就结束了。
语句
循环结束，执行 for语句下面的一个语句。
求解表达式
上面看到的 for语句
for语句的
foriii
下一语句
sum sumi
图
其执行过程与图完全一样。它相当于以下语句：
i
whilei
sum sumi
i
显然，用for语句简单、方便。
说明：
for语句的一般形式如下：
for表达式表达式表达式 语句
可以改写为 while循环的形式：
表达式；
while 表达式
语句
表达式
二者无条件等价。
C程序设计第五版
“表达式”可以省略，即不设置初值，但表达式后的分号不能省略。例如：
forii sum sumi for语句中没有表达式
应当注意： 由于省略了表达式，没有对循环变量赋初值，因此，为了能正常执行循环，应在for 语句之前给循环变量赋以初值。即
i 对循环变量i赋初值
forii sum sumi for语句中没有表达式
执行 for 语句时，跳过图中的“求解表达式 ”这一步。由于在for 语句前加了 “i”因此其作用仍然不变。
表达式也可以省略，即不用表达式来作为循环条件表达式，不设置和检查循环的条件。如：
求解表达式
forii sum sumi
语句
此时循环无终止地进行下去，也就是认为表达式始终为真，见图。
它相当于
求解表达式
i
while
图
sum sumi
i
循环无终止地进行，i的值不断加大， sum 的值也不断累加。
表达式也可以省略，但此时程序设计者应另外设法保证循环能正常结束。例如：
forii 没有表达式
sum sumi
i 这时可以在循环体中使循环变量增值
在上面的 for语句中只有表达式和表达式，而没有表达式。i的操作不放在表达式的位置，而作为循环体的一部分，效果是一样的，都能使循环正常结束。如果在循环体中无此“i；”语句，则循环体无止境地执行下去。
如果表达式和表达式都没有，只有表达式，即只给循环条件，情况会怎样 如：
fori 没有表达式和表达式，只有表达式
sum sumi
i 在循环体中使循环变量增值
当然，应当在 for语句前给循环变量赋初值，否则循环无法正常执行。即：
i 给循环变量赋初值
fori 没有表达式和表达式，只有表达式
第章 循环结构程序设计
sum sumi
i 在循环体中使循环变量增值
相当于
i
whilei
sum sumi
i
可见 for语句比 while语句功能强，除了可以给出循环条件外，还可以赋初值，使循环变量自动增值等。
甚至可以将个表达式都可省略，例如：
for printfdni
相当于
while printfdni
即不设初值，不判断条件认为表达式为真值，循环变量也不增值，无终止地执行循环体语句，显然这是没有实用价值的。
表达式可以是设置循环变量初值的赋值表达式，也可以是与循环变量无关的其他表达式。例如：
for sumii sum sumi
表达式也可以是与循环控制无关的任意表达式。但不论怎样写 for语句，都必须使循环能正常执行。
表达式和表达式可以是一个简单的表达式，也可以是逗号表达式，即包含一个以上的简单表达式，中间用逗号间隔。如：
for sumiii sum sumi
i
或
forijijijkij
i≤j
假
真
表达式和表达式都是逗号表达式，各包含两个赋值表达式，即同时设 两个初值ij使两个变量增值 ij执行情况见图。
在逗号表达式内按自左至右顺序求解，整个逗号表达式的值为最右边的表达式的值。例如：
foriiii sum sumi
相当于
图
C程序设计第五版
foriiii sum sumi
表达式一般是关系表达式如i或逻辑表达式如ab xy但也可以是数值表达式或字符表达式，只要其值为非零，就执行循环体。分析下面两个例子：
在表达式中先从终端接收一个字符赋给c，然后判断此赋值表达式的值是否不等于n换行符，如果不等于n，就执行循环体。此for语句的执行过程见图，它的作用是不断输入字符，将它们的 ASCII码相加，直到输入一个“换行”符为止。
符⇒c
注意：此for语句的循环体为空语句，把本来要在循环体内处理的内容放在表达式中，作用是一样的。可见 for语句功能强，可以在表达式中完成本来应在循环体内完成的操作。
连换行符
假
真
iic
② for c getcharn
printfcc
图
for语句中只有表达式，而无表达式和表达式。其作用是每读入一个字符后立即输出该字符，直到输入一个“换行”为止。
运行情况：
Computer 输入
Computer 输出
请注意，从终端键盘向计算机输入时，是在按 Enter键以后才将一批数据一起送到内存缓冲区中去的。因此不是从终端输入一个字符马上输出一个字符，而是在按 Enter键后数据才送入内存缓冲区，然后每次从缓冲区读一个字符，再输出该字符。
C允许在 for语句的“表达式”中定义变量并赋初值，如：
for int iii 定义循环变量i，同时赋初值
sum sumi
显然，这可以使程序简练，灵活方便。但应注意：所定义的变量的有效范围只限于 for循环中，在循环外不能使用此变量。
从上面介绍可以知道，C语言的 for语句使用十分灵活，变化多端，可以把循环体和一些与循环控制无关的操作也作为表达式或表达式出现，这样程序可以短小简洁。但应注意： 过分地利用这一特点会使 for语句显得杂乱，可读性降低，最好不要把与循环控制无关的内容放到 for语句中。
注意： 对以上“说明”中介绍的内容，读者应当了解，以便能看懂别人写的程序，并且在熟练掌握C以后能写出简洁高效的程序，但是，建议初学者开始时不要过于追求技巧而写出别人不易看懂的程序，应当尽量写出清晰易读的程序。
循环的嵌套
一个循环体内又包含另一个完整的循环结构，称为循环的嵌套。内嵌的循环中还可以嵌套循环，这就是多层循环。各种语言中关于循环的嵌套的概念都是一样的。
第章 循环结构程序设计
种循环 while循环、 do… while循环和 for循环可以互相嵌套。例如下面几种都是合法的形式：
while do
⋮ ⋮
do
内层循环 … 内层循环
while
while
for while
⋮
do
内层循环 …内层循环
while
⋮
for do
⋮
while ⋮
内层循环 for
… 内层循环
⋮ …
た while
几种循环的比较
种循环都可以用来处理同一问题，一般情况下它们可以互相代替。
在 while循环和 do… while循环中只在 while后面的括号内指定循环条件因此为了使循环能正常结束，应在循环体中包含使循环趋于结束的语句如i，或ii等。
for循环可以在表达式中包含使循环趋于结束的操作，甚至可以将循环体中的操作全部放到表达式中。因此 for语句的功能更强，凡用 while循环能完成的，用 for循环都能实现。
用 while和do⋯while循环时循环变量初始化的操作应在 while 和 do⋯while语句之前完成。而for语句可以在表达式中实现循环变量的初始化。
while循环、 do··· while循环和 for循环都可以用 break语句跳出循环用 continue语句结束本次循环 break语句和 continue语句见 节。
改变循环执行的状态
以上介绍的都是根据事先指定的循环条件正常执行和终止的循环。但有时在某种情况下需要提早结束正在执行的循环操作。例如，慈善募捐，收到万元就结束。可以用循环来处理此问题，每次输入一个捐款人的捐款数，不断累加。但是，事先并不能确定循环的次数，需要每次输入捐款数后进行累加，并检查总数是否达到万，如果未达到，就继续执行
C程序设计第五版
循环，输入下一个捐款数，如果达到万元，就终止循环。可以用 break语句和 continue语句来实现提前结束循环。
用 break语句提前终止循环
如前所述，用 break语句可以使流程跳出 switch结构，继续执行 switch语句下面的一个语句。实际上， break语句还可以用来从循环体内跳出循环体，即提前结束循环，接着执行循环下面的语句。
例如上面统计捐款的例子，可以用以下的程序处理。
【例】 在全系名学生中举行慈善募捐，当总数达到万元时就结束，统计此时捐款的人数以及平均每人捐款的数目。
编程思路：显然应该用循环来处理。实际循环的次数事先不能确定，可以设为最大值，即最多会有人捐款，在循环体中累计捐款总数，并用 if语句检查是否达到万元，如果达到就不再继续执行循环，终止累加，并计算人均捐款数。在程序中定义变量 amount，用来存放捐款数，变量 total，用来存放累加后的总捐款数，变量 aver，用来存放人均捐款数，以上个变量均为单精度浮点型。定义整型变量i作为循环变量。定义符号常量SUM代表 。
编写程序：
include stdio h
define SUM 指定符号常量SUM代表
int main
float amount aver total
int i
fori totalii
printfplease enter amount
scanff amount
total total amount
if totalSUM break
aver totali
printfnumd naverfni aver
return
运行结果为简化起见，只输入几个数据：
please enter amount
please enter amount
please enter amount
please enter amount
please enter amount
please enter anount
please enter amount
num
aver
第章 循环结构程序设计
程序分析： for语句本来指定执行循环体次。在每一次循环中，输入一个捐款人的捐款数，然后把它累加到 total中，如果没有 if语句，则执行循环体 次。现在设置一个 if语句，在每一次累加了捐款数 amount后，立即检查累加和 total 是否达到或超过SUM即 当 total 时就执行 break语句流程跳转到循环体的花括号外，即不再继续执行剩余的几次循环，提前结束循环。请思考此时变量i的值是什么。结论是：已经输入捐款数的人数本例中为人。因此用捐款总数 total除以捐款人数，得到的就是人均捐款额 aver。
break语句的一般形式为
break
其作用是使流程跳到循环体之外，接着执行循环体下面的语句。
注意： break语句只能用于循环语句和 switch语句之中，而不能单独使用。
用 continue 语句提前结束本次循环
有时并不希望终止整个循环的操作，而只希望提前结束本次循环，而接着执行下次循环。这时可以用 continue语句。
【例】 要求输出的不能被整除的数。
编程思路：显然需要对的每一个整数进行检查，如果不能被整除，就将此 数输出，若能被整除，就不输出此数。无论是否输出此数，都要接n着检查下一个数直到为止。
可以画出流程图，见图。
N
从图 可以看出：不论 n能否被整除，循环的次数总是次，不会改变。
Y
n能被
Y
编写程序：
整除
N
include stdio h
输出n
int main
int n
fornnn
ifn
continue
结束
printfdn
图
printfn
return
运行结果：
C程序设计第五版
程序分析： 当n能被 整除时，执行 continue语句，流程跳转到表示循环体结束的右花括号的前面注意不是右花括号的后面，从图可以看到： 流程跳过 printf函数语句，结束本次循环，然后进行循环变量的增值n，只要n，就会接着执行下一次循环。如果 n不能被 整除，就不会执行 continue 语句，而执行 printf函数语句，输出不能被 整除的整数。
当然，例中循环体中也可以不用 continue语句，而改用一个 if语句处理：
ifn printfdn
效果也一样。在本例中用 continue语句无非为了说明 continue语句的作用。为读者提供不同的思路和方法，使编写程序更加灵活多样。
continue 语句的一般形式为
continue
其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，转到循环体结束点之前，接着执行 for语句中的“表达式”在本例中是 n，然后进行下一次是否执行循环的判定。
break语句和 continue 语句的区别
continue语句只结束本次循环，而不是终止整个循环的执行。而 break语句则是结束整个循环过程，不再判断执行循环的条件是否成立。如果有以下两个循环结构：
while表达式
语句
if表达式 break
语句
while表达式
语句
if表达式 continue
语句
程序的流程如图所示，而程序的流程如图 所示。请注意图和图中当表达式为真时流程的转向。
如果是双重循环，在内循环体内有一个 break语句，请思考： 是提前终止内循环，还是提前终止整个循环 或者说，流程是跳转到内循环体之外执行内循环体下面的语句，还是跳转到外循环体之外执行外循环体下面的语句结论是前者，即提前终止内循环。请分析下面程序的执行情况及其输出。
第章 循环结构程序设计
假
表达式
假
表达式
真
真
语句
语句
真
真
表达式
表达式
continue
break
假
假
语句
语句
while循环的
while循环的
下一语句
下一语句
图
图
【例】 输出以下× 的矩阵。
解题思路：可以用循环的嵌套来处理此问题，用外循环来输出一行数据，用内循环来输出一列数据。要注意设法输出以上矩阵的格式每行个数据，即每输出完个数据后换行。
编写程序：
include stdio h
int main
int ijn
foriii
forjjjn n用来累计输出数据的个数
ifn printfn 控制在输出个数据后换行
printfdtij
printfn
return
运行结果：
C程序设计第五版
程序分析：本程序包括一个双重循环，是for循环的嵌套。外循环变量i由变到，用来控制输出行数据；内循环变量j由变到，用来控制输出每行中的个数据。输出的值是ij。在执行第次外循环体时ij由变到因此ij的值就是。在执行第次外循环体时ij由变到因此ij的值就是依此类推。n的初值为，每执行一次内循环，n的值加，在输出完个数据后，n等于，用n是否等于来判定n是否是的倍数。如果是，就进行换行，然后再输出后面的数据，用这样的方法使每行输出个数。
假如在以上程序的基础上作一些改动。在内循环体中增加一个 if语句：
ifij break
此时程序如下：
include stdio h
int main
int ijn
foriii
forjjjn
控制在输出个数据后换行
ifij break 遇到第行第列，终止内循环
printfdtij
printfn
return
请读者分析，输出结果会怎样。实际的输出如下：
第行空白，即不输出第行的个数据。原因是：当i等于和j等于时，执行 break语句，提前终止执行内循环，流程进入下一次外循环，即开始第次外循环，i等于。
如果把上面的 break语句改为 continue语句即
请分析运行情况。实际的输出如下：
原来第行第个数据没有输出，从第行第个数据开始输出，由于没有执行“printf，所以少输出一次“t”，后面个数据向左移动了一个位置。应当注意的是 continue语句只是跳过其后的“printfdtij”结束了当“时的那次内
第章 循环结构程序设计
循环，而接着执行“时的内循环。
请读者画出本例中个程序的流程图。通过本例分析 break 和 continue 语句的区别。
循环程序举例
前面仔细分析了循环结构的特点和实现方法，有了初步编写循环程序的能力，下面通过几个例子进一步掌握循环程序的编写和应用，特别是学习与循环有关的算法。
【例】 用公式求π的近似值，直到发现某一项的绝对值小于为止该项不累加。
解题思路：这是求π值的近似方法中的一种。求π值可以用不同的近似方法。如下面的表达式都可以用来求π的近似值：
不同的方法求出的结果不完全相同近似程度不同。因此用计算机解题时，首先应当确定用哪一种方法来实现计算。专门有一门学科叫做“计算方法”，研究用什么方法最有效，近似程度最好，执行效率最高。这不是本课程的任务。读者只要对此有一些了解即可。
现在，题目已确定要求用以下公式：
求π的近似值。也就是说，计算方法确定了，但是怎样去求出这个多项式的方法和步骤并未解决。例如，有的人按次序一项一项计算和加减，有的人把符号为正的各项即奇数项相加，再把符号为负的各项即偶数项相加，最后再把两者相加得到结果。有的人用笨办法一项一项相加，有的人用循环来处理。计算机一般是不会自动选择采用哪种方法和哪些步骤的，要编程者来指定每一个执行步骤，计算机只是忠实地执行而已。这就是算法要解决的问题。
为解决一个问题，可以有多种算法，当然希望能设计出较好的算法。可以看出：π的值是由求一个多项式的值来得到的。这个多项式从理论上说包含无穷项。包含的项数愈多，近似程度就愈高。但是在实际运算时不可能加减到无穷项，只能在近似程度和效率之间找到一个平衡点。现在题目已明确，当多项式中的某一项的绝对值小于⁻⁶时，就认为足够近似了，可以据此计算出π的近似值了。
现在问题的关键是用什么方法能最简便地求出多项式的值。显然，谁也不会像小学生做算术题那样，用最原始的方法一项一项依次求出各项的值，然后把它们相加。这样做太笨，如果有几千几万项怎么办 应当设法利用计算机的特点，用一个循环来处理就能全部解决问题。经过仔细分析，发现多项式的各项是有规律的：
C程序设计第五版
每项的分子都是。
后一项的分母是前一项的分母加。
第项的符号为正，从第项起，每一项的符号与前一项的符号相反。
找到这个规律后，就可以用循环来处理了。例如前一项的值是，则可以推出下一项为其中分母中n的值是上一项分母n再加上。后一项的符号则与上一项符号相反。
sign pin term当 term≥⁻⁶ pi pi termnn signsign term signn pi pi输出 pi
在每求出一项后，检查它的绝对值是否大于或等于⁻⁶，如果是，则还需要继续求下一项，直到某一项的值小于⁻⁶，则不必再求下一项了。认为足够近似了。
可以用 NS结构化流程图表示算法见图。
图 编写程序： 根据流程图可以很容易写出C程序：
程序如下：
include stdio h
include math h 程序中用到数学函数 fabs应包含头文件 math h
int main
int sign sign用来表示数值的符号
double pin term pi开始代表多项式的值最后代表π的值 n代表分母
term代表当前项的值
while fabs terme 检查当前项 term 的绝对值是否大于或等于⁻⁶
pi pi term 把当前项 term累加到 pi中
nn n是下一项的分母
signsign sign代表符号，下一项的符号与上一项符号相反
term signn 求出下一项的值 term
pi pi 多项式的和 pi乘以，才是π的近似值
输出π的近似值
return
运行结果：
pi
程序分析：
fabs是求绝对值的函数，从附录E中可以看到：在C库函数中，有两个求绝对值的函数。一个是 absx，求整数x的绝对值，结果是整型；另一个是 fabsx，x是双精度数，得到的结果是双精度型。程序中需要求 term的绝对值，而 term 是双精度数，因此不能用 abs函数，而应当用 fabs函数。在用数学函数包括 fabs 函数时，要在本文件模块的开头加预处理指令 include math h。
本题的关键是找出多项式的规律，用同一个循环体处理所有项的求值和累加工作。
第章 循环结构程序设计
计算机处理循环是很得心应手的，不论循环多少次，循环体不须改动，只须修改循环条件即可。例如，想提高精确度，要求计算到当前项的绝对值小于⁻⁸为止，只须改变 while语句的第行即可：
while fabste
本程序输出的结果是，虽然输出了位小数，但是只有前位小数是准确的，因为第位已小于⁻⁶，后面的项没有累加。如果把输出格式改为“f”，则输出为，对第位小数四舍五入了。如果循环条件改为 while fabste则程序运行时输出。
请读者补充程序，统计出执行循环体多少次。经过对程序的补充和运行，可以知道 在 while fabste时执行循环体万次当 while fabste时执行循环体万次。二者时间差倍，在分别运行以上两种情况下的程序时，可以明显地感觉到后者运行的时间长很多。
【例】 求 Fibonacci斐波那契数列的前个数。这个数列有如下特点第两个数为，。从第个数开始，该数是其前面两个数之和。即该数列为，，，，，，，…，用数学方式表示为
这是一个有趣的古典数学问题：有一对兔子，从出生后第个月起每个月都生一对兔子。小兔子长到第个月后每个月又生一对兔子。假设所有兔子都不死，问每个月的兔子总数为多少
可以从表看出兔子繁殖的规律。
表兔子繁殖的规律
月数 小兔子对数 中兔子对数 老兔子对数 兔子总对数
注：假设不满个月的为小兔子，满个月不满个月的为中兔子，满个月以上的为老兔子。
可以看到每个月的兔子总数依次为…这就是 Fibonacci数列。
解题思路： 最简单易懂的方法是，根据题意，从前两个月的兔子数可以推出第个月的兔子数。设第个月的兔子数f，第个月的兔子数f，则第个月的兔子数fff。当然可以在程序中继续写ffffff…但这样的程序烦琐冗长。应当
C程序设计第五版
善于利用循环来处理，这样就要重复利用变量名，一个变量名在不同时间代表不同月的兔子数。
在开始时，f代表第个月的兔子数，f代表第个月的兔子数，f代表第个月的兔
子数。fff。然后在求第个月的兔子数时，需要的是第
和第个月的兔子数。在此不打算用f，f，f等变量名，而把
f作为“本月的前两个月”的兔子数，f是“本月的前一个月”的
ff输出 ff for i to fff输出fffff
兔子数，f就是本月的兔子数。在求第个月的兔子数前，先把
f第个月的兔子数赋给f，作为第个月“前两个月”的兔子
数，把f原来第个月的兔子数赋给f，作为第个月“前一个
月”的兔子数，执行fff，此时的f就是第个月的兔子
图 数。以后依此类推。算法如图所示。
编写程序：
include stdio h
int main
int fff
int i
printfdndnff
foriii
fff
printfdnf
ff
ff
return
运行结果：
il
程序分析： 程序共应输出个月的兔子数。这个程序虽然是正确的，运行结果也是对的读者可以自己运行程序并观察结果，但算法并非最好的，而且每个月的输出占一行，篇幅太大，不可取。
程序改进：可以修改程序，在循环体中一次求出下两个月的兔子数。而且只用两个变量f和f就够了，不必用f。这里有一个技巧，把ff的结果不放在f中，而放在f中取代了f的原值，此时f不再代表前两个月的兔子数，而代表新求出来的第个月的兔子
第章 循环结构程序设计
ff
for i to
输出f、f
数，再执行ff，由于此时的f已是第个月的兔子数，因此ff就是第个月的兔子数了，把它存放在f中。可以看到此时的f和f已是新求出的最近两个月的兔子数。再由此推出下两个月的兔子数。
fff
其算法的 NS流程图见图。
fff
修改后的程序如下：
include stdio h
图
int main
int ff
int i
foriii 每个循环中输出个月的数据，故循环次即可
printfd dff 输出已知的两个月的兔子数
fff 计算出下一个月的兔子数，并存放在f中
fff 计算出下两个月的兔子数，并存放在 f中
return
if语句的作用是使输出个数后换行。i是循环变量，当i为偶数时换行，由于每次循环要输出个数f，f，因此i为偶数时意味着已输出了个数，执行换行。
运行结果：
·
【例】 输入一个大于的整数n，判定它是否为素数 prime，又称质数。
解题思路：采用的算法是，让n 被i 除i的值从 变到 n，如果 n能被n的任何一个整数整除，则表示 n肯定不是素数，不必再继续被后面的整数除，因此，可以提前结束循环。此时i的值必然小于n。分别用传统流程图和NS流程图表示算法见图。从这两种流程图的对比，可以具体了解 break语句的执行情况。
编写程序： 根据流程图可以很容易写出以下程序。
include stdio h
int main
int ni
printfplease enter a integer numbern
scanfdn
C程序设计第五版
foriini
ifni break
ifin printfd is not a prime numbernn
else printfd is a prime numbernn
return
、
运行结果：
please enter a integer numbern
is a prime number
输入n
i
in
N
Y
n被i整除
Y
N
ii
Y
N
输入n i for i to n 是 n被i整除 否 执行 break结束循环iiin输出 n不是素数输出n是素数
in
输出n
输出n
不是素数
是素数
结束
a
b
图
程序分析：在图中可以看到，如果n能被n的一个整数整除例如，n，i时，n能被整除，此时执行 break语句，提前结束循环，流程跳转到循环体之外。那么，怎样判定n是否为素数从而输出相应的信息呢 关键是看结束循环时i的值是否小于n，如果n能被n的一个整数整除，则必然是由 break语句导致循环提前结束，即i并未达到n的值时，循环就终止了。显然此时in。如果 n不能被n的任何一个整数整除，则不会执行 break语句，循环变量i一直变化到等于 n，然后由第个判断框判定“in”条件不成立，从而结束循环。这种正常结束的循环，其循环变量的值必然大于事先指定的循环变量终值本例中循环变量终值为 n。
因此，只要在循环结束后检查循环变量i的值，就能判定循环是提前结束还是正常结束的。如果是正常结束in，则n是素数，如果是提前结束的，则表明是由于n被i整除而执行了 break语句，显然不是素数。
希望读者理解和掌握这一方法，以后会常用到。
第章 循环结构程序设计
程序改进：其实n不必被n的各整数去除，只须将n被n的整数除即可，甚至只须被的整数除即可。因为n的每一对因子，必然有一个小于另一个大于√n。例如，判断是否为素数，只须将被，和除即可，如都除不尽，n必为素数。这样做可以大大减少循环次数，提高执行效率。请读者思考为什么只须使 n被√n的整数除即可判定n是否为素数。
为方便，可以定义一个整型变量k其值为√n的整数部分；如果n不能被k即的任一整数整除，则在完成最后一次循环后，i还要加，因此ik，然后才终止循环。在循环之后判别i的值是否大于或等于k，若是，则表明未曾被k任一整数整除过，因此输出该数是素数。
算法如图 所示。
输入n kn的取整 for i to k 是 n被i整除 否 执行 break 结束循环 ii是ik否输出n不是素数输出n是素数
请读者对比图和图。
修改后的程序如下：
include stdio h
include math h
int main 图
int nik
printfplease enter a integer numbern
scanfdn
k sqrtn
foriiki
ifni break
ifik printfd is not a prime numbernn
else printfd is a prime numbernn
return
运行结果：
please enter a integer numbern
is not a prime number
说明：求素数并不是只有一种方法，可以有不同的算法。下面列出几种处理方法，请读者自己分析。可以把例第个程序第行分别改为以下语句：
fortiini 先定义t为 int型，t作为标志变量
ifni
t t表示 n能被i整除，n不是素数
ift 如果t表示n是素数
printfd is primenn
对所有的i值都作为除数进行检测，共执行循环n次。
fortiini
ifni
t
C程序设计第五版
break
ift
printfd is primenn
若发现n不是素数，立即停止后续判断。
foriini
ifni
break
ifin
printfd is primenn
不用t，直接判断循环是正常执行结束还是中途退出，利用循环控制变量i和 break语句。
forii int sqrtni
ifni
break
ifi int sqrtn
printfd is primenn
把 sqrtn作为除数。
【例】 求的全部素数。
解题思路：有了例的基础，解本题就不困难了，只要增加一个外循环，先后对的全部整数一一进行判定即可。也就是用一个嵌套的 for循环即可处理。请读者自己画出流程图。
编写程序：
include stdio h
include math h
int main
int nkim
fornnnn n从变化到对每个 n进行判定
k sqrtn
foriiki
ifni break 如果n被i整除，终止内循环，此时ik
ifik 若ik表示 n未曾被整除
printfdn 应确定 n是素数
mm m用来控制换行，一行内输出个素数
ifm printfn m累计到 的倍数，换行
printfn
return
运行结果：
第章 循环结构程序设计
程序分析：
根据常识，偶数不是素数，所以不必对偶数进行判定，只对奇数进行检查。故外循环变量 n从开始，每次增值。
从附录E可以看到： sqrt是求平方根的函数，它要求参数为双精度数。在执行时会自动将整数n转换为双精度数。求出的函数值也是双精度数，再把它赋给整型变量k，系统会自动将小数部分舍弃，只把整数部分赋给k。在进行编译时，系统给出警告，提醒用户有可能由此出现误差。只要用户确认没有问题，可以不理会它。
请分析执行 break语句时流程应转至何处。答案是提前终止内循环，流程应转至“ifik”行的开头。
m的作用是累计输出素数的个数，控制每行输出个数据。
【例】译密码。为使电文保密，往往按一定规律将其转换成密码，收报人再按约定的规律将其译回原文。例如，可以按以下规律将电文变成密码：
w
E
将字母A 变成字母E，a变成e，即变成其后的第个字母W变成AX变成BY变成CZ变成D见图。
V
F
U
G
T
H
字母按上述规律转换，非字母字符保持原状不变，如“China”转换为“Glmre”。
S
I
R
J
从键盘输入一行字符，要求输出其相应的密码。
Q
K
P
O N M
L
解题思路： 问题的关键有两个。
如何决定哪些字符不需要改变，哪些字符需要改变，如果需要改变，应改为哪个对应的字符。处理的方法是：输入一个字符给字符变量c，先判定它是否为字母包括大小写。若不是字母，不改变c的值；若是字母，则还要检查它是否在内包括大小写字母。如不在此范围内，则使变量c的值改变为其后第个字母；如果在内，则应按图所示的规律将它转换为AD或ad之一的字母。
怎样使字符变量c改变为所指定的字母 办法是改变它的ASCⅡ值。例如字符变量c的原值是大写字母A，想使c的值改变为E，只须执行“cc”即可，因为A的ASCⅡ值为而E的 ASCⅡ值为二者相差。
如果字符变量c的原值为大写字母W，按规定应变为A。用什么方法可以得到此结果呢 可以用cc即cc。先使c即从附录 A 可知W 的 ASCⅡ值为加后为 它已超出字母AZ的范围了从图 可以看出W应该转换成AA的ASCⅡ代码为故应当使减变成。所以如果变量c的值在内，应执行 c。查 ASCⅡ码表即可弄清楚。
输入一个字符给c 当c不是换行符 c是字母 是 否 c在WZ或 是wz内否cccc输出c的字符值输入一个字符给c
算法可用 NS图表示见图。
图
C程序设计第五版
编写程序：
include stdio h
int main
char c
c getchar 输入一个字符给字符变量c
whilecn 检查c的值是否为换行符n
c如果是字母
如果是个字母中最后个字母之一就使c
else cc 如果是前面个字母之一，就使c加，即变成其后第个字母
printfcc 输出已改变的字符
c getchar 再输入下一个字符给字符变量c
printfn
return
运行结果：
China
GImret
程序分析：以上程序和运行结果都是正确的，程序也比较容易理解，关键在于对字符的ASCII值的运算。在有了一定的基础后，可以对程序作进一步的改进。例如可以把前后两个读入字符的“c getchar；”合并为一个，并且放在 while语句的检查条件中。对 if语句的写法也可改进。
程序改进：
include stdio h
int main
char c
whilec getcharn 输入一个字符给字符变量c并检查其值是否是换行符
c如果是字母
cc 只要是字母，都先加
如果是个字母中最后个字母之一
cc c的值改变为个字母中最前面的个字母中对应的字母
printfcc 输出已改变的字符
printfn
return
运行结果同上。
请对比分析上面两个程序中的第个 if语句中的复合语句的写法有什么不同，分析内
第章 循环结构程序设计
嵌的 if语句中的条件表述的方法有什么不同。
有一点请读者注意： 内嵌的 if语句不能写成：
因为所有小写字母都满足“cZ”条件，从而也执行‘ ”语句，这就会出错。因此必须限制其范围为‘即原字母为在此范围以外的不是大写字母，不应按此规律转换。请考虑： 为什么对小写字母不按此处理，即没有写成而只写成“c’ z’”。
在本节的程序举例中，对怎样分析问题，怎样思考和设计算法，作了比较详尽而通俗易懂的介绍。这种分析和思路对于今后编写程序是非常重要的。希望读者在接触一个任务后，也能这样一步步地进行分析，找出关键，设计算法，编写程序，并改进程序。
说明： 循环程序设计是很重要的，许多问题都需要通过循环来处理，希望大家熟练掌握它的用法和技巧。尽可能多做一些练习，多阅读和编写一些典型的程序，本章习题大多是很基本的如求两个数的最大公约数和最小公倍数，求多项式之和以及用迭代法求方程的根等。在《C程序设计第五版学习辅导》一书第章中提供了这些题目的程序，可供读者参考。
习 题
请画出例中给出的个程序段的流程图。
请补充例程序分别统计当“fabste”和“fabste”时执行循环体的次数。
输入两个正整数m和n，求其最大公约数和最小公倍数。
输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。
求之值，其中a是一个数字，n表示a 的位数，n由键盘输入。例如：
此时n
求即求…。
求
输出所有的“水仙花数”，所谓“水仙花数”是指一个位数，其各位数字立方和等于该数本身。例如，是水仙花数，因为
一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如，的因子为，，，而，因此是“完数”。编程序找出之内的所有完数，并按下面格式输出其因子：
its factors are
有一个分数序列
C程序设计第五版
求出这个数列的前项之和。
一个球从m高度自由落下，每次落地后反弹回原高度的一半，再落下，再反弹。求它在第次落地时共经过多少米，第次反弹多高。
猴子吃桃问题。猴子第天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第天早上想再吃时，就只剩一个桃子了。求第天共摘多少个桃子。
用迭代法求求平方根的迭代公式为
要求前后两次求出的x的差的绝对值小于
用牛顿迭代法求下面方程在附近的根：
用二分法求下面方程在的根
输出以下图案：
两个乒乓球队进行比赛，各出人。甲队为A，B，C人，乙队为X，Y，Z人。已抽签决定比赛名单。有人向队员打听比赛的名单，A说他不和X比，C说他不和X，Z比，请编程序找出对赛手的名单。
注：本章习题 所用的方法，可参考《C程序设计第五版学习辅导》第章习题解答中的介绍。
第章 利用数组处理批量数据
第章之前的程序中使用的变量都属于基本类型，例如整型、字符型、浮点型数据，这些都是简单的数据类型。对于简单的问题，使用这些简单的数据类型就可以了。但是，对于有些需要处理的数据，只用以上简单的数据类型是不够的，难以反映出数据的特点，也难以有效地进行处理。例如，一个班有个学生，每个学生有一个成绩，要求这名学生的平均成绩。从理论上，这是很简单的： 把个学生成绩加起来，再除以就行了。问题是怎样表示个学生成绩 当然可以用个 float 型变量sss…s。但是这里存在两个问题：一是烦琐，要定义个简单变量，如果有 名学生怎么办呢 二是没有反映出这些数据间的内在联系，实际上这些数据是同一个班级、同一门课程的成绩，它们具有相同的属性。
人们想出这样的办法：既然它们都是同一类性质的数据都代表一个班中学生的成绩，就可以用同一个名字如s来代表它们，而在名字的右下角加一个数字来表示这是第几名学生的成绩例如可以用s₁s₂s₃…s₃₀代表学生、学生、学生……学生这个学生的成绩。这个右下角的数字称为下标 subscribeript。一批具有同名的同属性的数据就组成一个数组 array，s就是数组名。
由此可知：
数组是一组有序数据的集合。数组中各数据的排列是有一定规律的，下标代表数据在数组中的序号。
用一个数组名如s和下标如来唯一地确定数组中的元素，如s₁₅就代表第个学生的成绩。
数组中的每一个元素都属于同一个数据类型。不能把不同类型的数据如学生的成绩和学生的性别放在同一个数组中。
由于计算机键盘只能输入有限的单个字符而无法表示上下标，C语言规定用方括号中的数字来表示下标，如用s表示 s₁₅，即第个学生的成绩。
将数组与循环结合起来，可以有效地处理大批量的数据，大大提高了工作效率，十分方便。
本章介绍在C语言中怎样使用数组来处理同类型的批量数据。
怎样定义和引用一维数组
一维数组是数组中最简单的，它的元素只需要用数组名加一个下标，就能唯一地确定。如上面介绍的学生成绩数组s就是一维数组。有的数组，其元素要指定两个下标才能唯一地确定，如用s₂₃表示“第班第名学生的成绩”，其中第个下标代表班，第个下标代表在本班中的学生序号。此时，s就是二维数组。还可以有三维甚至多维数组，如用s₄₂₃表示“年级班第名学生的成绩”，此时，s就是三维数组。它们的概念和用法基本上是相同
C程序设计第五版
的。熟练掌握一维数组后，对二维或多维数组，很容易举一反三，迎刃而解。
怎样定义一维数组
要使用数组，必须在程序中先定义数组，即通知计算机：由哪些数据组成数组，数组中有多少元素，属于哪个数据类型。否则计算机不会自动地把一批数据作为数组处理。例如，下面是对数组的定义：
int a
它表示定义了一个整型数组，数组名为a，此数组包含个整型元素。
定义一维数组的一般形式为
类型符 数组名常量表达式；
说明：
数组名的命名规则和变量名相同，遵循标识符命名规则。
在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式用来表示元素的个数，即数组长度。例如，指定a，表示a数组有个元素。注意，下标是从开始的这个元素是aaaaaaaaaa。请特别注意按上面的定义，不存在数组元素a。
常量表达式中可以包括常量和符号常量，如“int a；”是合法的。不能包含变量，如“int an；”是不合法的。也就是说，C语言不允许对数组的大小作动态定义，即数组的大小不依赖于程序运行过程中变量的值。例如，下面这样定义数组是不行的：
int n
scanfdn 企图在程序中临时输入数组的大小
int an
用“int a；”定义了数组a后，在内存中划出一片存储空间见图，存放了一个有个整型元素的数组如果用 Visual C此空间大小为×字节。可以看到用一个“int a；”，就相当于定义了个简单的整型变量，显然简捷方便。
a数组
a
a
a
a
a
a
a
a
a
a
图
怎样引用一维数组元素
在定义数组并对其中各元素赋值后，就可以引用数组中的元素。应注意：只能引用数组元素而不能一次整体调用整个数组全部元素的值。
引用数组元素的表示形式为
数组名下标
例如，a就是数组a中序号为的元素，它和一个简单变量的地位和作用相似。“下标”可以是整型常量或整型表达式。例如下面的赋值表达式包含了对数组元素的引用：
aaaa
第章 利用数组处理批量数据
每一个数组元素都代表一个整数值。
注意：定义数组时用到的“数组名常量表达式”和引用数组元素时用的“数组名下标”形式相同，但含义不同。例如：
int a 前面有 int，这是定义数组，指定数组包含个元素
ta 这里的a表示引用a数组中序号为的元素
【例】 对个数组元素依次赋值为要求按逆序输出。
解题思路： 显然首先要定义一个长度为的数组，由于赋给的值是整数，因此，数组可定义为整型，要赋的值是，有一定规律，可以用循环来赋值。同样，用循环来输出这个值，在输出时，先输出最后的元素，按下标从大到小输出这个元素。这个算法很简单，可以直接写出程序。
编写程序：
include stdio h
int main
int ia
foriii 对数组元素aa赋值
aii
foriii 输出aa共个数组元素
printfdai
printfn
return
运行结果：
程序分析第个 for循环使 aa的值为见图。第个 for 循环按aa的顺序输出各元素的值。
a数组
a a a
a
a
a
a
a
a a
图
应当特别提醒的是：数组元素的下标从 开始，如果用“int a；”定义数组，则最大下标值为，不存在数组元素a。下面是常见的错误。
foriii 循环变量从开始，变到
aii 下标从开始，变到
foriii 试图输出aa
printfdai
C程序设计第五版
一维数组的初始化
为了使程序简洁，常在定义数组的同时给各数组元素赋值，这称为数组的初始化。可以用“初始化列表”方法实现数组的初始化。
在定义数组时对全部数组元素赋予初值。例如：
int a
将数组中各元素的初值顺序放在一对花括号内，数据间用逗号分隔。花括号内的数据就称为“初始化列表”。经过上面的定义和初始化之后aaaaaaaaaa。
可以只给数组中的一部分元素赋值。例如：
int a
定义a数组有个元素，但花括号内只提供个初值，这表示只给前面个元素赋初值，系统自动给后个元素赋初值为。
如果想使一个数组中全部元素值为，可以写成
int a
或
int a 未赋值的部分元素自动设定为
在对全部数组元素赋初值时，由于数据的个数已经确定，因此可以不指定数组长度。例如：
int a
可以写成
int a
在第种写法中，花括号中有个数，虽然没有在方括号中指定数组的长度，但是系统会根据花括号中数据的个数确定a数组有个元素。但是，如果数组长度与提供初值的个数不相同，则方括号中的数组长度不能省略。例如，想定义数组长度为，就不能省略数组长度的定义，而必须写成
int a
只初始化前个元素，后个元素为。
说明： 如果在定义数值型数组时，指定了数组的长度并对之初始化，凡未被“初始化列表”指定初始化的数组元素，系统会自动把它们初始化为如果是字符型数组，则初始化为，如果是指针型数组，则初始化为 NULL，即空指针。
一维数组程序举例
【例】 用数组来处理求 Fibonacci数列问题。
解题思路： 在第章例中是用简单变量处理的，只定义了两个或个变量，程序可
第章 利用数组处理批量数据
以顺序计算并输出各数，但不能在内存中保存这些数。假如想直接输出数列中第个数，是很困难的。如果用数组来处理，在概念上反而简单了：每一个数组元素代表数列中的一个数，依次求出各数并存放在相应的数组元素中即可。
编写程序：
include stdio h
int main
int i
int f 对最前面两个元素 f和f赋初值
foriii
fififi 先后求出ff的值
foriii
控制每输出个数后换行
printfdfi 输出一个数
printfn
return
运行结果：
程序分析： 为节约篇幅，程序只计算个数。定义数组长度为，对最前面两个元素f和f均指定初值为，根据数列的特点，由前面两个元素的值可计算出第个元素的值，即
fff
在循环中可以用以下语句依次计算出 ff的值。
fififi
if语句用来控制换行，每行输出个数据。
【例】 有个地区的面积，要求对它们按由小到大的顺序排列。
解题思路： 这种问题称为数的排序 sort。排序的规律有两种：一种是“升序”，从小到大；另一种是“降序”，从大到小。可以把这个题目抽象为一般形式“对 n个数按升序排序”。
排序方法是一种重要的、基本的算法。排序的方法很多，本例用起泡法排序。起泡法的基本思路是：每次将相邻两个数比较，将小的调到前面。若有个数：，，，，，，第次先将最前面的两个数 和 对调见图。第次将第 和第个数和对调……如此共进行次，得到的顺序，可以看到： 最大的数已“沉底”，成为最
C程序设计第五版
下面一个数，而小的数“上升”。最小的数已向上“浮起”一个位置。经过第趟共次比较与交换后，已得到最大的数。
然后进行第趟比较，对余下的前面个数，，，，进行新一轮的比较，以便使次大的数“沉底”。按以上方法进行第趟比较，见图。经过这一趟次比较与交换，得到次大的数。
h
δ
。
第次 第次 第次 第次 第次
结果
第次 第次 第次
第次
结果
图
图
按此规律进行下去，可以推知，对个数要比较趟，才能使个数按大小顺序排列。在第趟中要进行两个数之间的比较共次，在第趟过程中比较次……第趟只须比较次。
如果有n个数，则要进行 n趟比较。在第趟比较中要进行n次两两比较，在第j趟比较中要进行 nj次两两比较。
输入个数给aa
j由变到共执行次循环
进行j次比较
aiai
真
假
请读者分析排序的过程，原来 是最后一个数，经过第 趟的比较与交换，上升为第个数最后第 个数。再经过第 趟比较与交换，上升为第个数最后第个数。再经过第趟比较与交换，上升为第个数……每经过一趟的比较与交换，最小的数“上升”一位，最后升到第一个数。这如同水底的气泡逐步冒出水面一样，故称为冒泡法或起泡法。
ai⇔ai
将ai与ai
交换
输出aa
图
据此画出流程图见图。
编写程序：
根据流程图写出程序今设n。
include stdio h
int main
int a
int ijt
printfinput numbers n
foriii
scanfdai
printfn
forjjj 进行次循环，实现趟比较
foriiji 在每一趟中进行j次比较
ifaiai 相邻两个数比较
第章 利用数组处理批量数据
taiaiaiait
printfthe sorted numbers n
foriii
printfdai
printfn
return
运行结果：
input numbers
the sorted numbers
程序分析： 程序中实现起泡法排序算法的主要是第行。请仔细分析嵌套的 for语句。当执行外循环第次循环时，j，然后执行第次内循环，此时i，在if语句中将ai和ai比较就是将a和a比较。执行第次内循环时iai和ai比较就是将a和a比较……执行最后一次内循环时iai和ai比较，就是将a和a比较。这时第趟过程完成了。
当执行第次外循环时，j，开始第趟过程。内循环继续的条件是ij，由于j，因此相当于i，即i由变到，要执行内循环次。其余类推。
说明： 通过此例，着重学习有关排序的算法。排序的算法有多种，本例介绍的是起泡法，常用的还有选择法、希尔法等。本章的习题是要求用选择法排序，其程序在《C程序设计第五版学习辅导》一书第章，建议读者尽可能参考一下。希望读者不要满足于教材中的内容，要善于扩展知识，善于思考，善于比较，善于归纳提高。
重要的是了解和掌握解题思路，学会分析问题，建立算法，以及如何利用C语言编程的技巧。
怎样定义和引用二维数组
前面已提到，有的问题需要用二维数组来处理。例如，有个小分队，每队有名队员，要把这些队员的工资用数组保存起来以备查。这就需要用到二维数组，见图。如果建立一个数组 pay，它应当是二维的，第一维用来表示第几分队，第二维用来表示第几个队员。例如用表示分队第名队员的工资，它的值是。
队员 队员 队员 队员 队员 队员
分队
分队
分队
图
C程序设计第五版
二维数组常称为矩阵 matrix。把二维数组写成行 row和列 column的排列形式可以有助于形象化地理解二维数组的逻辑结构。
怎样定义二维数组
怎样定义二维数组呢 其基本概念与方法和一维数组相似。如：
float pay
以上定义了一个 float型的二维数组，第维有个元素，第维有个元素。每一维的长度分别用一对方括号括起来。
二维数组定义的一般形式为
类型说明符 数组名常量表达式常量表达式；
例如：
float ab
定义a为×行列的数组b为×行列的数组。注意不能写成
float ab 在一对方括号内写两个下标，错误
C语言对二维数组采用这样的定义方式，使得二维数组可被看作一种特殊的一维数组：它的元素又是一个一维数组。例如，可以把a看作一个一维数组，它有个元素：
aaa
每个元素又是一个包含个元素的一维数组，见图。
a a a a
a
a
a
a
a
a
a
a
a
a
a
图
可以把a，a，a看作个一维数组的名字。上面定义的二维数组可以理解为定义了个一维数组，即相当于
float aaa
此处把a，a，a看作一维数组名。C语言的这种处理方法在数组初始化和用指针表示时显得很方便，这在以后会体会到。
C语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第行的元素，接着再存放第行的元素。图表示对a数组存放的顺序。
假设数组a存放在从字节开始的一段内存单元中，一个元素占个字节，前个字节存放序号为的行中的个元素接着的个字节存放序号为的行中的个元素，余类推，如图所示。
注意： 用矩阵形式如行列形式表示二维数组，是逻辑上的概念，能形象地表示出行列关系。而在内存中，各元素是连续存放的，不是二维的，是线性的。这点务请明确。
第章 利用数组处理批量数据
a
a
第行元素
a
a
a
a
a
第行元素
a₀₀
a₀₁
a₀
a₀₃
a
a
a₁₁ a₁₂ a₁₃
a
a₁₀
第行元素
a
a₂₀
a₂ a₂ a₂
a
图
图
C语言还允许使用多维数组。有了二维数组的基础，再掌握多维数组是不困难的。例如，定义三维数组的方法如下：
float a 定义三维数组a，它有页，行，列
多维数组元素在内存中的排列顺序为：第维的下标变化最慢，最右边的下标变化最快。例如，上述三维数组的元素排列顺序为
a→a→a→a→a→a→a→
a→a→a→a→a→a→a→
a→a→a→a→a→a→a→
a→a→a
怎样引用二维数组的元素
二维数组元素的表示形式为
数组名下标下标
例如，a表示a数组中序号为的行中序号为的列的元素。下标应是整型表达式，如a。不要写成a、a形式。
数组元素可以出现在表达式中，也可以被赋值，例如：
ba
注意： 在引用数组元素时，下标值应在已定义的数组大小的范围内。在这个问题上常出现错误。例如：
int a 定义a为×的二维数组
⋮
a 不存在a元素
按以上的定义，数组a可用的“行下标”的范围为， “列下标”的范围为。用a表示元素显然超过了数组的范围。
注意： 请读者严格区分在定义数组时用的a和引用元素时的a的区别。
C程序设计第五版
前者用a来定义数组的维数和各维的大小，后者a中的和是数组元素的下标值，a代表行序号为、列序号为的元素行序号和列序号均从起算。
二维数组的初始化
可以用“初始化列表”对二维数组初始化。
分行给二维数组赋初值。例如：
int a
这种赋初值方法比较直观，把第个花括号内的数据给第行的元素，第个花括号内的数据赋给第行的元素……即按行赋初值。
可以将所有数据写在一个花括号内，按数组元素在内存中的排列顺序对各元素赋初值。例如：
int a
效果与前相同。但以第种方法为好，一行对一行，界限清楚。用第种方法如果数据多，则会写成一大片，容易遗漏，也不易检查。
可以对部分元素赋初值。例如：
int a
它的作用是只对各行第列即序号为的列的元素赋初值，其余元素值自动为。赋初值后数组各元素为
也可以对各行中的某一元素赋初值，例如：
int a
初始化后的数组元素如下：
这种方法对非元素少时比较方便，不必将所有的都写出来，只须输入少量数据。
也可以只对某几行元素赋初值：
int a
数组元素为
第章 利用数组处理批量数据
第行不赋初值。
也可以对第行不赋初值，例如：
int a
如果对全部元素都赋初值即提供全部初始数据，则定义数组时对第维的长度可以不指定，但第维的长度不能省。例如：
int a
与下面的定义等价：
int a
系统会根据数据总个数和第维的长度算出第维的长度。数组一共有个元素，每行列，显然可以确定行数为。
在定义时也可以只对部分元素赋初值而省略第维的长度，但应分行赋初值。例如：
int a
这样的写法，能通知编译系统；数组共有行。数组各元素为
从本节的介绍中可以看到： C语言在定义数组和表示数组元素时采用a这种两个方括号的方式，对数组初始化时十分有用，它使概念清楚，使用方便，不易出错。
二维数组程序举例
【例】 将一个二维数组行和列的元素互换，存到另一个二维数组中。例如：
解题思路：可以定义两个数组：数组a为行列，存放指定的个数。数组b为行列，开始时未赋值。只要将a数组中的元素aij存放到b数组中的bji元素中即可。用嵌套的 for循环即可完成此任务。
编写程序：
include stdio h
int main
int a
int bij
printfarray an
foriii 处理a数组中的一行中各元素
forjjj 处理a数组中某一列中各元素
C程序设计第五版
printfdaij 输出a数组的一个元素
bjiaij 将a数组元素的值赋给 b数组相应元素
printfn
printfarray bn 输出 b数组各元素
foriii 处理b数组中一行中各元素
forjjj 处理b数组中一列中各元素
printfdbij 输出b数组的一个元素
printfn
return
运行结果：
array a
array b
【例】 有一个×的矩阵，要求编程序求出其中值最大的那个元素的值，以及其所在的行号和列号。
解题思路：先思考一下在打擂台时怎样确定最后的优胜者。先找出任一人站在台上，第人上去与之比武，胜者留在台上。再上去第人，与台上的人即刚才的得胜者比武，胜者留台上，败者下台。以后每一个人都是与当时留在台上的人比武。直到所有人都上台比过为止，最后留在台上的就是冠军。这就是“打擂台算法”。
解本题也是用“打擂台算法”。先让a作“擂主”，把它的值赋给变量 max， max用来
存放当前已知的最大值，在开始时还未进行比较，把
最前面的元素暂时认为是当前值最大的。然后让下
一个元素 a与 max比较如果 a max
则表示a是已经比过的数据中值最大的，把它
maxa for i to for j to 真 aij max假 maxaij rowi columj输出 max和 row、 colum
的值赋给 max，取代了max的原值。以后依此处理，
值大的赋给 max。直到全部比完后， max就是最大
的值。
按此思路画出NS图，见图。
图 编写程序：
根据流程图很容易写出程序：
include stdio h
int main
int ij row colum max
第章 利用数组处理批量数据
int a 定义数组并赋初值
maxa 先认为a最大
foriii
forjjj
ifaij max 如果某元素大于 max，就取代 max的原值
maxaij
记下此元素的行号
columj 记下此元素的列号
printfmaxd nrowd ncolumdn max row colum
return
运行结果：
max
row
colum
最大值为此元素为a。
字 符 数 组
前已介绍：字符型数据是以字符的ASCⅡ代码存储在存储单元中的，一般占一个字节。由于ASCII代码也属于整数形式，因此在C 标准中，把字符类型归纳为整型类型中的一种。
由于字符数据的应用较广泛，尤其是作为字符串形式使用，有其自己的特点，因此，在本书中专门加以讨论，希望读者熟练掌握。
C语言中没有字符串类型，也没有字符串变量，字符串是存放在字符型数组中的。
怎样定义字符数组
用来存放字符数据的数组是字符数组。在字符数组中的一个元素内存放一个字符。
定义字符数组的方法与定义数值型数组的方法类似。例如：
char c
cp
以上定义了c为字符数组，包含个元素。赋值以后数组的状态如图所示。
c c
c
c
c
c
c
c
c
c
I
□
a
m
u
h
a
p
p
y
图
由于字符型数据是以整数形式ASCII代码存放的，因此也可以用整型数组来存放字符数据，例如：
C程序设计第五版
int c
合法，但浪费存储空间
字符数组的初始化
对字符数组初始化，最容易理解的方式是用“初始化列表”，把各个字符依次赋给数组中各元素。例如：
char cIamhappy
把个字符依次赋给cc这个元素。
如果在定义字符数组时不进行初始化，则数组中各元素的值是不可预料的。如果花括号中提供的初值个数即字符个数大于数组长度，则出现语法错误。如果初值个数小于数组长度，则只将这些字符赋给数组中前面那些元素，其余的元素自动定为空字符即。例如：
char ccprogram
数组状态如图所示。
如果提供的初值个数与预定的数组长度相同，在定义时可以省略数组长度，系统会自动根据初值个数确定数组长度。例如：
char cIamhappy
数组c的长度自动定为。用这种方式可以不必人工去数字符的个数，尤其在赋初值的字符个数较多时，比较方便。
也可以定义和初始化一个二维字符数组，例如：
char diamond
用它代表一个菱形的平面图形，见图。完整的程序见例。
c c c c c c c c c c
c □ p r o g r a m
图
图
怎样引用字符数组中的元素
可以引用字符数组中的一个元素，得到一个字符。
【例】 输出一个已知的字符串。
解题思路： 先定义一个字符数组，并用“初始化列表”对其赋以初值。然后用循环逐个输出此字符数组中的字符。
编写程序：
include stdio h
第章 利用数组处理批量数据
int main
char cTamastudent
int i
foriii
printfcci
printfn
return
运行结果：
I am a student
【例】 输出一个菱形图。
解题思路： 先画出一个如图 所示的平面菱形图案，每行包括个字符，其中有的是空白字符，有的是字符，记下在每行中字符出现的位置。定义一个字符型的二维数组，用“初始化列表”进行初始化。初始化列表中的字符顺序就是图中各行中的字符顺序。这样字符数组中已存放了一个菱形的图案。然后用嵌套的 for循环输出字符数组中的所有元素。
编写程序：
include stdio h
int main
char diamond
int ij
foriii
forjjj
printfc diamondij
printfn
return
运行结果：
字符串和字符串结束标志
在C语言中，是将字符串作为字符数组来处理的。例就是用一个一维的字符数组来存放字符串Iam a student 的，字符串中的字符是逐个存放到数组元素中的。在该例中，字符串的实际长度与数组长度相等。
在实际工作中，人们关心的往往是字符串的有效长度而不是字符数组的长度。例如，定义一个字符数组长度为 ，而实际有效字符只有个。为了测定字符串的实际长度，
C程序设计第五版
C语言规定了一个“字符串结束标志”，以字符作为结束标志。如果字符数组中存有若干字符，前面个字符都不是空字符，而第个字符是，则认为数组中有一个字符串，其有效字符为个。也就是说，在遇到字符时，表示字符串结束，把它前面的字符组成一个字符串。
注意：C系统在用字符数组存储字符串常量时会自动加一个作为结束符。例如Cprogram共有个字符。字符串是存放在一维数组中的，在数组中它占个字节，最后一个字节是由系统自动加上的。
有了结束标志后，字符数组的长度就显得不那么重要了。在程序中往往依靠检测的位置来判定字符串是否结束，而不是根据数组的长度来决定字符串长度。当然，在定义字符数组时应估计实际字符串长度，保证数组长度始终大于字符串实际长度。如果在一个字符数组中先后存放多个不同长度的字符串，则应使数组长度大于最长的字符串的长度。
说明 代表ASCII码为的字符从ASCII码表中可以查到ASCII码为的字符不是一个可以显示的字符，而是一个“空操作符”，即它什么也不做。用它来作为字符串结束标志不会产生附加的操作或增加有效字符，只起一个供辨别的标志。
前面曾用过以下语句输出一个字符串。
printfHow do you do n
在执行此语句时系统怎么知道应该输出到哪里为止呢 实际上，在向内存中存储时，系统自动在最后一个字符n的后面加了一个，作为字符串结束标志。在执行 printf函数时，每输出一个字符检查一次，看下一个字符是否为，遇就停止输出。
对C语言处理字符串的方法有以上的了解后，再对字符数组初始化的方法补充一种方法，即用字符串常量来使字符数组初始化。例如：
也可以省略花括号，直接写成
这里不像例那样用单个字符作为字符数组的初值，而是用一个字符串注意字符串的两端是用双撇号而不是单撇号括起来的作为初值。显然，这种方法直观、方便、符合人们的习惯。请注意，此时数组c的长度不是，而是。因为字符串常量的最后由系统加上一个。上面的初始化与下面的初始化等价。
char cIamhappy
而不与下面的等价：
前者的长度为，后者的长度为。如果有：
数组c的前个元素为：第个元素为，后个元素也自动设定为空
第章 利用数组处理批量数据
字符见图。
c
h
i
n
a
图
说明： 字符数组并不要求它的最后一个字符为，甚至可以不包含像以下这样写完全是合法的：
是否需要加，完全根据需要决定。由于系统在处理字符串常量存储时会自动加一个，因此，为了使处理方法一致，便于测定字符串的实际长度，以及在程序中作相应的处理，在字符数组中也常常人为地加上一个。例如：
这样做，便于引用字符数组中的字符串。
如定义了以下的字符数组：
由于系统自动在字符串常量的最后一个字符后面加了一个，因此c数组的存储情况如下：
C p r 。 g r a m ·
若想用一个新的字符串代替原有的字符串C program ，如从键盘输入Hello分别赋给c数组中前面个元素。如果不加的话，字符数组中的字符如下：
H e 。 g r a m ·
新字符串和老字符串连成一片，无法区分开。如果想输出字符数组中的字符串，则会连续输出：
Hellogram
如果在Hello后面加一个o，它取代了第个字符g。在数组中的存储情况为
H e 。 r a m ·
是字符串结束标志，如果用以下语句输出数组c中的字符串：
printfsnc 输出数组c中的字符串
在输出字符数组中的字符串时，遇就停止输出，因此只输出了字符串而不会输出” Hellogram”。
从这里可以看到在字符串末尾加的作用。
C程序设计第五版
字符数组的输入输出
字符数组的输入输出可以有两种方法。
逐个字符输入输出。用格式符“c”输入或输出一个字符，如例。
将整个字符串一次输入或输出。用“s”格式符，意思是对字符串 string的输入输出。例如：
printfsnc
在内存中数组c的存储情况为
C h i n a
输出时，遇结束符就停止输出。输出结果为
China
说明：
输出的字符中不包括结束符。
用“s”格式符输出字符串时， printf函数中的输出项是字符数组名，而不是数组元素名。写成下面这样是不对的：
printfsc c不是字符数组名，而是一个数组元素
如果数组长度大于字符串的实际长度，也只输出到遇结束。例如：
字符串长度为，连共占个字节
printfsc
只输出字符串的有效字符“China”，而不是输出个字符。这就是用字符串结束标志的好处。
如果一个字符数组中包含一个以上，则遇第一个时输出就结束。
可以用 scanf函数输入一个字符串。例如：
scanfsc
scanf函数中的输入项c是已定义的字符数组名，输入的字符串应短于已定义的字符数组的长度。例如，已定义：
char c
从键盘输入：
China✔
系统会自动在 China后面加一个结束符。如果利用一个 scanf函数输入多个字符串，则应在输入时以空格分隔。例如：
char strlstrstr
第章 利用数组处理批量数据
scanfsss strlstrstr
输入数据：
How are you☑
由于有空格字符分隔，作为个字符串输入。在输入完后， strl，str和 str数组的状态如下：
strl
str
H o w a r e y o u
str
数组中未被赋值的元素的值自动置。若改为
char str
scanfs str
如果输入以下个字符：
How are you☑
由于系统把空格字符作为输入的字符串之间的分隔符，因此只将空格前的字符How送到 str中。把How作为一个字符串处理，故在其后加。 str数组的状态为
H o w
注意： scanf函数中的输入项如果是字符数组名，不要再加地址符，因为在C语言中数组名代表该数组第一个元素的地址或者说数组的起始地址。下面写法不正确：
scanfs str str前面不应加
c数组
分析图所示的字符数组，若数组占个字节。数组名c代表地址。可以用下面的输出语句得到数组第一个元素的地址。
C
h
i
n
printfoc 用八进制形式输出数组c的起始地址可以得到数组c的起始地址例如。可知数组名c代表数组起始地址。
a
前面介绍的输出字符串的方法：
图
printfsc
实际上是这样执行的：按字符数组名c找到其数组第一个元素的地址，然后逐个输出其中的字符，直到遇为止。
使用字符串处理函数
在C函数库中提供了一些用来专门处理字符串的函数，使用方便。几乎所有版本的C语言编译系统都提供这些函数。下面介绍几种常用的函数。
C程序设计第五版
puts 函数——输出字符串的函数
其一般形式为
puts字符数组
其作用是将一个字符串以结束的字符序列输出到终端。假如已定义 str是一个字符数组名，且该数组已被初始化为China。则执行：
puts str
其结果是在终端上输出China。由于可以用 printf函数输出字符串，因此 puts函数用得不多。
用 puts函数输出的字符串中可以包含转义字符。例如：
puts str
输出：
China
Beijing
在用 puts输出时将字符串结束标志转换成n，即输出完字符串后换行。
gets 函数——输入字符串的函数
其一般形式为
gets字符数组
其作用是从终端输入一个字符串到字符数组，并且得到一个函数值。该函数值是字符数组的起始地址。如执行下面的函数：
gets str str是已定义的字符数组
如果从键盘输入：
Computer✔
将输入的字符串Computer送给字符数组 str请注意，送给数组的共有个字符，而不是个字符，返回的函数值是字符数组 str的第一个元素的地址。一般利用gets函数的目的是向字符数组输入一个字符串，而不大关心其函数值。
注意：用puts和 gets函数只能输出或输入一个字符串，不能写成
puts strlstr
或
getsstrstr
strcat 函数——字符串连接函数
其一般形式为
第章 利用数组处理批量数据
strcat字符数组字符数组
strcat是STRing CATenate字符串连接的缩写。其作用是把两个字符数组中的字符串连接起来，把字符串接到字符串的后面，结果放在字符数组中，函数调用后得到一个函数值——字符数组的地址。例如：
char strPeoples Republic of
char strChina
printfs strcat strl str
输出：
Peoples Republic of China
连接前后的状况见图所示。
strl
P
e
。
p
e
、
s
一
R
e
p
u
b
i
c
。
f
str
C
h
i
n
a
。
f
C
i
str
P
e
。
p
。
ˊ
s
一
R
e
p
u
b
i
c
一
一
h
n
a
图
说明：
字符数组必须足够大，以便容纳连接后的新字符串。本例中定义 strl的长度为 ，是足够大的，如果在定义时改用 strlPeoples Republic of就会出问题，因长度不够。
连接前两个字符串的后面都有，连接时将字符串后面的取消，只在新串最后保留。
strcpy和 strncpy函数——字符串复制函数
其一般形式为
strcpy字符数组字符串
strcpy是STRingCoPY字符串复制的简写。它表示“字符串复制函数”，作用是将字符串复制到字符数组中去。例如：
char strstrChina
strcpy strlstr
执行后， strl的状态如下：
C h i n a
说明：
字符数组必须定义得足够大，以便容纳被复制的字符串。字符数组的长度不应小于字符串的长度。
“字符数组”必须写成数组名形式如strl，“字符串”可以是字符数组名，也可以是一个字符串常量。例如：
C程序设计第五版
strcpy strl China
作用与前面相同。
如果在复制前未对 strl数组初始化或赋值，则 strl各字节中的内容是无法预知的，复制时将str中的字符串和其后的一起复制到字符数组中，取代字符数组中的前面个字符，最后个字符并不一定是，而是 strl中原有的最后个字节的内容。
不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组。字符数组名是一个地址常量，它不能改变值，正如数值型数组名不能被赋值一样。如下面两行都是不合法的：
企图用赋值语句将一个字符串常量直接赋给一个字符数组
strlstr 企图用赋值语句将一个字符数组直接赋给另一个字符数组
只能用 strcpy 函数将一个字符串复制到另一个字符数组中去。用赋值语句只能将一个字符赋给一个字符型变量或字符数组元素。如下面的语句是合法的：
char acc
可以用 strncpy函数将字符串中前面n个字符复制到字符数组中去。例如： strncpy strlstr
作用是将 str中最前面个字符复制到 strl中，取代 strl中原有的最前面个字符。但复制的字符个数n不应多于 strl中原有的字符不包括。
strcmp函数——字符串比较函数
其一般形式为
strcmp字符串字符串
strcmp是 STRing CoMPare字符串比较的缩写。它的作用是比较字符串 和字符串。例如：
strcmp strlstr
strcmpChina Korea
strcmp strl Beijing
说明：字符串比较的规则是：将两个字符串自左至右逐个字符相比按ASCⅡ码值大小比较，直到出现不同的字符或遇到为止。
如全部字符相同，则认为两个字符串相等；
若出现不相同的字符，则以第对不相同的字符的比较结果为准。例如：
AB aA computercompare thesethat A CHINACANADA DOGcat TsinghuaTSINGHUA
说明：如果参加比较的两个字符串都由英文字母组成，则有一个简单的规律：在英文字典中位置在后面的为“大”。例如 computer 在字典中的位置在 compare之后，所以但应注意小写字母比大写字母“大”，所以
第章 利用数组处理批量数据
比较的结果由函数值带回。
如果字符串与字符串相同，则函数值为。
如果字符串字符串，则函数值为一个正整数。
如果字符串字符串，则函数值为一个负整数。
注意： 对两个字符串比较，不能用以下形式：
if strlstr
printfyes
因为 strl和 str代表地址而不代表数组中全部元素，而只能用
if strcmp strlstr
printfyes
这时，系统分别找到两个字符数组的第一个元素，然后顺序比较数组中各个元素的值。
strlen函数——测字符串长度的函数
其一般形式为
strlen字符数组
strlen是STRing LENgth字符串长度的缩写。它是测试字符串长度的函数。函数的值为字符串中的实际长度不包括在内。例如：
char strChina
printfd strlen str
输出结果不是，也不是，而是。也可以直接测试字符串常量的长度，例如：
strlenChina
strlwr函数——转换为小写的函数
其一般形式为
strlwr字符串
strlwr是STRing LoWeRcase字符串小写的缩写。函数的作用是将字符串中大写字母换成小写字母。
strupr函数——转换为大写的函数
其一般形式为
strupr字符串
strupr是 STRing UPpeRcase字符串大写的缩写。函数的作用是将字符串中小写字母换成大写字母。
以上介绍了常用的种字符串处理函数，应当再次强调：库函数并非C语言本身的组成部分，而是C语言编译系统为方便用户使用而提供的公共函数。不同的编译系统提供的函数数量和函数名、函数功能都不尽相同，使用时要小心，必要时查一下库函数手册。当然，有一些基本的函数包括函数名和函数功能，不同的系统所提供的是相同的，这就为程序的
C程序设计第五版
通用性提供了基础。
列出以上字符串函数是为使读者了解怎样用字符串函数去处理字符串的运算。如果不了解这些函数，难以正确有效地进行字符串的运算。但是不必死记，从这些函数规定的名字大体可以猜到它们的含义，用到时查一下即可。
注意： 在使用字符串处理函数时，应当在程序文件的开头用
include string h
把 string h文件包含到本文件中。
字符数组应用举例
【例】 输入一行字符，统计其中有多少个单词，单词之间用空格分隔开。
解题思路： 问题的关键是怎样确定“出现一个新单词了”。可以采取这样的方法： 从第 个字符开始逐个字符进行检查，判断此字符是否是新单词的开头，如果是，就使变量 num的值加用变量 num统计单词数，最后得到的 num的值就是单词总数。
判断是否出现新单词，可以由是否有空格出现来决定连续的若干个空格作为出现一次空格；一行开头的空格不统计在内。如果测出某一个字符为非空格，而它的前面的字符是空格，则表示“新的单词开始了”，此时使 num单词数累加。如果当前字符为非空格而其前面的字符也是非空格，则意味着仍然是原来那个单词的继续， num不应再累加。用变量 word作为判别当前是否开始了一个新单词的标志，若 word表示未出现新单词，如出现了新单词，就把 word置成。
前面一个字符是否为空格可以从 word的值看出来，若 word等于，则表示前一个字符是空格；如果 word等于，意味着前一个字符为非空格，可以用图 表示。
Y
未出现新单词 使 word num不累加。
当前字符空格
前一字符为空格 word新单词出现 使 num加 word。
N
前一字符为非空格 word未出现新单词 num不加。
图
以输入Iam a boy 为例，说明在对每个字符作检查时的有关参数状态，见表所示。
表 输入“I am a boy” 有关参数状态
当前字符 I a m a b 。 y 是否空格 否 是 否 否 是 否 是 否 否 否 否 word原值 新单词开始否 是 否 是 否 否 是 否 是 否 否 否 word新值 num值
第章 利用数组处理批量数据
画出 NS流程图见图。
输入一字符串给 string c stringi 真 c等于空格 假 word 真 word等于假 word num numii输出 num
图
编写程序：
根据流程图编写程序：
include stdio h
int main
char string
int i num word
char c
gets string 输入一个字符串给字符数组 string
foric stringii 只要字符不是就继续执行循环
ifc word 如果是空格字符，使 word置
else if word 如果不是空格字符且 word原值为
word 使 word置
num num累加，表示增加一个单词
printfThere are d words in this linen num 输出单词数
return
运行结果：
I am a boy
There are words in this line
程序分析循环的条件表达式为“c stringi” 先执行括号内的赋值表达式“c stringi”将字符数组 stringi是一个字符赋给字符变量c。此时赋值表达式的值就是该字符。然后再判定它是否为结束符。如果该条件表达式为真字符不是，则继续执行循环体，检查此字符是否空格字符，如果是，表示新单词没有开始， word置。如果不是空格字符而且 word原值为，表示新单词开始了， word置， num加。请分析当下一个字符仍是非空格字符的情况，此时是否开始新单词
循环条件“c stringi” 是一个表达式，包含了一个赋值操作和一个关系运
C程序设计第五版
算，在此表达式中又包括了一个赋值表达式和关系表达式。通过此例可以看到：C语言把 赋值运算作为表达式，它可以出现在另一个表达式之中，使程序灵活、精练。注意：赋值表 达式“c stringi”两侧的括号不可缺少如果写成“c stringi” 由于关系运算符“！”的优先级高于赋值运算符“”，就会先执行关系运算：“stringi”这样字符变量c得到的值是关系运算的结果“真”或“假”，而不是字符。
请分析 for循环的范围，即 for语句到哪一行结束 答案是： for语句的范围是行。
【例】 有个字符串，要求找出其中“最大”者。
解题思路：可以设一个二维的字符数组 str，大小为×，即有行列每一行可以容纳个字符。每一行存放一个字符串。此二维数组的存储情况见图。
str
H
o
a
n
d
str
C
h
i
n
a
str
A
m
e
r
i
c
a
图
如前所述可以把 str str str看作个一维字符数组它们各有个元素可以把它们如同一维数组那样进行处理。今用 gets函数分别读入个字符串，赋给个一维字符数组。然后经过次两两比较，就可得到值最大者，把它放在一维字符数组 string中。
画出 NS流程图见图。
编写程序：
读入个字符中给 str str str Y str str N str⇒string str⇒ stringY str stringN str⇒string输出 string中的字符中
include stdio h
include string h
int main
图
char str 定义二维字符数组
char string 定义一维字符数组，作为交换字符串时的临时字符数组
int i
foriii
gets stri 读入个字符串分别给 str str str
if strcmp str str 若 str大于 str
strcpy string str 把 str的字符串赋给字符数组 string
else 若 str小于等于 str
strcpy string str 把 str的字符串赋给字符数组 string
if strcmp str string 若 str大于 string
strcpy string str 把 str的字符串赋给字符数组 string
printf nthe largest string isnsn string 输出 string
return
、
第章 利用数组处理批量数据
运行结果：
Holland
China
America
the largest string is
Holland
程序分析：
流程图和程序注释中的“大于”是指两个字符串的比较中的“大于”。经过第个 if语句的处理 string 中存放了 str和 str中的“大者”。第个 if语句把 string和 str比较把大者存放在 string中。最后在 string中的就是 str str str三者中的最大者。
str str str和 string是一维字符数组其中可以存放一个字符串。
strcpy函数在将 str str或 str复制到 string时最后都有一个。因此最后用s格式输出 string时遇到 string中第一个即结束输出并不是把 string中的全部字符输出。
当然，这个题目也可以不采用二维数组，而设个一维字符数组来处理。读者可自己完成。
习 题
用筛选法求之内的素数。
用选择法对个整数排序。
求一个×的整型矩阵对角线元素之和。
有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入数组中。
将一个数组中的值按逆序重新存放。例如，原来顺序为，，，，。要求改为，，。
输出以下的杨辉三角形要求输出行。
⋮
⋮
⋮
⋮
⋮
⋮
输出“魔方阵”。所谓魔方阵是指这样的方阵，它的每一行、每一列和对角线之和均相等。例如，三阶魔方阵为
要求输出n² 的自然数构成的魔方阵。
C程序设计第五版
找出一个二维数组中的鞍点，即该位置上的元素在该行上最大、在该列上最小。也可能没有鞍点。
有个数按由大到小顺序存放在一个数组中，输入一个数，要求用折半查找法找出该数是数组中第几个元素的值。如果该数不在数组中，则输出“无此数”。
有一篇文章，共有行文字，每行有个字符。要求分别统计出其中英文大写字母、小写字母、数字、空格以及其他字符的个数。
输出以下图案：
有一行电文，已按下面规律译成密码：
A→Z a→z
B→Y b→y
C→X c→x
⋮ ⋮
即第个字母变成第个字母，第i个字母变成第i个字母，非字母字符不变。要求编程序将密码译回原文，并输出密码和原文。
编一程序，将两个字符串连接起来，不要用 strcat函数。
编一个程序，将两个字符串s和s比较，若ss，输出一个正数；若ss，输出；若ss，输出一个负数。不要用 strcpy函数。两个字符串用 gets函数读入。输出的正数或负数的绝对值应是相比较的两个字符串相应字符的 ASCII码的差值。例如， A与C相比，由于AC，应输出负数，同时由于A与C的ASCⅡ码差值为，因此应输出“”。同理And和Aid比较根据第个字符比较结果 n比i大因此应输出“”。
编写一个程序，将字符数组s中的全部字符复制到字符数组s中。不用 strcpy函数。复制时， 也要复制过去。后面的字符不复制。
第章 用函数实现模块化程序设计
为什么要用函数
通过前几章的学习，已经能够编写一些简单的C程序了，但是如果程序的功能比较多，规模比较大，把所有的程序代码都写在一个主函数 main函数中，就会使主函数变得庞杂、头绪不清，使阅读和维护程序变得困难。此外，有时程序中要多次实现某一功能例如打印每一页的页头，就需要多次重复编写实现此功能的程序代码，这使程序冗长、不精练。
因此，人们自然会想到采用“组装”的办法来简化程序设计的过程。如同组装计算机一样，事先生产好各种部件如电源、主板、光盘驱动器、风扇等，在最后组装计算机时，用到什么就从仓库里取出什么，直接装上就可以了。绝不会采用手工业方式，在用到电源时临时生产一个电源，用到主板时临时生产一个主板。这就是模块化程序设计的思路。
可以事先编好一批常用的函数来实现各种不同的功能，例如用 sin函数实现求一个数的正弦值，用abs函数实现求一个数的绝对值，把它们保存在函数库中。需要用时，直接在程序中写上 sina或 absa就可以调用系统函数库中的函数代码，执行这些代码，就得到预期的结果。
“函数”是从英文 function翻译过来的其实 function 在英文中的意思既是“函数”也是“功能”。从本质意义上来说，函数就是用来完成一定的功能的。这样，对函数的概念就很好理解了，所谓函数名就是给该功能起一个名字，如果该功能是用来实现求正弦运算的，就称为正弦函数。
注意： 函数就是功能。每一个函数用来实现一个特定的功能。函数的名字应反映其代表的功能。
在设计一个较大的程序时，往往把它分为若干个程序模块，每一个模块包括一个或多个函数，每个函数实现一个特定的功能。一个C程序可由一个主函数和若干个其他函数构成。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。图是一个程序中函数调用的示意图。
d
e
g
h
i
除了可以使用库函数外，有的部门还编写一批本领域或本单位常用到的专用函数，供本领域或本单位的人员使用。在程序设计中要善于利用函数，以减少重复编写程序段的工作量，也更便于实现模块化的程序设计。
e
g
【例】 想输出以下的结果，用函数调用实现。
图
How do you do
C程序设计第五版
解题思路： 在输出的文字上下分别有一行“”号，显然不必重复写这段代码，用一个函数 print star来实现输出一行“”号的功能。再写一个 print message 函数来输出中间一行文字信息，用主函数分别调用这两个函数即可。
编写程序：
include stdio h
int main
void print star 声明 print star函数
void print message 声明 print message函数
print star 调用 print star函数
print message print message 函数
print star 调用 print star函数
return
void print star 定义 print star函数
printfn 输出一行号
void print message 定义 print message函数
printfHow do you don 输出一行文字信息
运行结果：
How do you do
程序分析 print star和 print message 都是用户定义的函数名分别用来输出一排“”号和一行文字信息。在定义这两个函数时指定函数的类型为 void，意为函数无类型，即无函数值，也就是说，执行这两个函数后不会把任何值带回 main函数。
在程序中定义 print star函数和 print message函数的位置是在 main函数的后面在这种情况下，应当在 main函数之前或 main函数中的开头部分，对以上两个函数进行“声明”。函数声明的作用是把有关函数的信息函数名、函数类型、函数参数的个数与类型通知编译系统，以便在编译系统对程序进行编译时，在进行到 main 函数调用 print star和 print message时知道它们是函数而不是变量或其他对象。此外，还对调用函数的正确性进行检查如类型、函数名、参数个数、参数类型等是否正确。有关函数的声明，详见本章节。
说明：
一个C程序由一个或多个程序模块组成，每一个程序模块作为一个源程序文件。对较大的程序，一般不希望把所有内容全放在一个文件中，而是将它们分别放在若干个源文件中，由若干个源程序文件组成一个C程序。这样便于分别编写和编译，提高调试效率。一个源程序文件可以为多个C程序共用。
第章 用函数实现模块化程序设计
一个源程序文件由一个或多个函数以及其他有关内容如指令、数据声明与定义等组成。一个源程序文件是一个编译单位，在程序编译时是以源程序文件为单位进行编译的，而不是以函数为单位进行编译的。
C程序的执行是从 main函数开始的，如果在 main函数中调用其他函数，在调用后流程返回到 main函数，在 main函数中结束整个程序的运行。
所有函数都是平行的，即在定义函数时是分别进行的，是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。函数间可以互相调用，但不能调用 main函数。 main 函数是被操作系统调用的。
从用户使用的角度看，函数有两种。
①库函数，它是由系统提供的，用户不必自己定义，可直接使用它们。应该说明，不同的C语言编译系统提供的库函数的数量和功能会有一些不同，当然许多基本的函数是共同的。
②用户自己定义的函数。它是用以解决用户专门需要的函数。
从函数的形式看，函数分两类。
①无参函数。如例中的 print star和 print message 就是无参函数。在调用无参函数时，主调函数不向被调用函数传递数据。无参函数一般用来执行指定的一组操作。例如，例程序中的 print star函数的作用是输出个星号。无参函数可以带回或不带回函数值，但一般以不带回函数值的居多。
②有参函数。在调用函数时，主调函数在调用被调用函数时，通过参数向被调用函数 传递数据，一般情况下，执行被调用函数时会得到一个函数值，供主调函数使用。第章例的 max函数就是有参函数，从主函数把a和b的值传递给 max函数中的参数x和y，经过 max的运算，将变量z的值带回主函数。此时有参函数应定义为与返回值相同的类型例的 max函数定义为 int 型。
怎样定义函数
为什么要定义函数
C语言要求，在程序中用到的所有函数，必须“先定义，后使用”。例如想用 max函数去求两个数中的大者，必须事先按规范对它进行定义，指定它的名字、函数返回值类型、函数实现的功能以及参数的个数与类型，将这些信息通知编译系统。这样，在程序执行 max时，编译系统就会按照定义时所指定的功能执行。如果事先不定义，编译系统怎么能知道 max是什么、要实现什么功能呢！
定义函数应包括以下几个内容：
指定函数的名字，以便以后按名调用。
指定函数的类型，即函数返回值的类型。
指定函数的参数的名字和类型，以便在调用函数时向它们传递数据。对无参函数不需要这项。
指定函数应当完成什么操作，也就是函数是做什么的，即函数的功能。这是最重要
C程序设计第五版
的，是在函数体中解决的。
对于C编译系统提供的库函数，是由编译系统事先定义好的，库文件中包括了对各函数的定义。程序设计者不必自己定义，只须用 include 指令把有关的头文件包含到本文件模块中即可。在有关的头文件中包括了对函数的声明。例如，在程序中若用到数学函数如 sqrt fabs sin cos等就必须在本文件模块的开头写上
include math h
库函数只提供了最基本、最通用的一些函数，而不可能包括人们在实际应用中所用到的所有函数。程序设计者需要在程序中自己定义想用的而库函数并没有提供的函数。
定义函数的方法
定义无参函数
例 中的 print star和 print message 函数都是无参函数读者可以看到 函数名后面的括号中是空的，没有任何参数。定义无参函数的一般形式为
类型名 函数名
函数体
或
类型名 函数名 void
函数体
函数名后面括号内的 void 表示“空”，即函数没有参数。
函数体包括声明部分和语句部分。
在定义函数时要用“类型标识符”即类型名指定函数值的类型，即指定函数带回来的值的类型。例中的 print star和 print message 函数为 void类型表示没有函数值。
定义有参函数
以下定义的 max函数是有参函数：
int max int x int y
int z 声明部分
zxyxy 执行语句部分
returnz
这是一个求x和y二者中大者的函数，第行第个关键字 int表示函数值是整型的。 max为函数名。括号中有两个形式参数x和y，它们都是整型的。在调用此函数时，主调函数把实际参数的值传递给被调用函数中的形式参数x和y。花括号内是函数体，它可以包括声明部分和语句部分。声明部分包括对函数中用到的变量进行定义以及对要调用的函数进行
第章 用函数实现模块化程序设计
声明见小节等内容。利用“zxyxy”语句求出z的值z为x与y中大者，returnz的作用是指定将z的值作为函数值称函数返回值带回到主调函数。在函数定义时已指定 max函数为整型，即指定函数的值是整型的，今在函数体中定义z为整型，并将z的值作为函数值返回，这是一致的。此时，函数 max的值等于z。
定义有参函数的一般形式为
类型名 函数名形式参数表列
函数体
函数体包括声明部分和语句部分。
定义空函数
在程序设计中有时会用到空函数，它的形式为
类型名 函数名
例如：
void dummy
函数体是空的。调用此函数时，什么工作也不做，没有任何实际作用。在主调函数中如果有调用此函数的语句：
dummy
表明“要调用 dummy函数”，而现在这个函数没有起作用。那么为什么要定义一个空函数呢 在程序设计中往往根据需要确定若干个模块，分别由一些函数来实现。而在第阶段只设计最基本的模块，其他一些次要功能或锦上添花的功能则在以后需要时陆续补上。在编写程序的开始阶段，可以在将来准备扩充功能的地方写上一个空函数函数名取将来采用的实际函数名如用 merge matproduct concatenate和 shell等分别代表合并、矩阵相乘、字符串连接和希尔法排序等，只是这些函数暂时还未编写好，先用空函数占一个位置，等以后扩充程序功能时用一个编好的函数代替它。这样做，程序的结构清楚，可读性好，以后扩充新功能方便，对程序结构影响不大。空函数在程序设计中常常是有用的。
调 用 函 数
定义函数的目的是为了调用此函数，以得到预期的结果。因此，应当熟练掌握调用函数的方法和有关概念。
函数调用的形式
调用一个函数的方法很简单，如前面已见过的：
C程序设计第五版
print star 调用无参函数
c maxab 调用有参函数
函数调用的一般形式为
函数名实参表列
如果是调用无参函数，则“实参表列”可以没有，但括号不能省略，见例。如果实参表列包含多个实参，则各参数间用逗号隔开。
按函数调用在程序中出现的形式和位置来分，可以有以下种函数调用方式。
函数调用语句
把函数调用单独作为一个语句。如例中的“printf star；”，这时不要求函数带回值，只要求函数完成一定的操作。
函数表达式
函数调用出现在另一个表达式中如“c maxab” maxab是一次函数调用它是赋值表达式中的一部分。这时要求函数带回一个确定的值以参加表达式的运算。例如：
c maxab
函数参数
函数调用作为另一个函数调用时的实参。例如：
m maxa maxbc
其中， maxb，c是一次函数调用，它的值是 b和c二者中的“大者”，把它作为 max另一次调用的实参。经过赋值后，m的值是a，b，c三者中的最大者。又如：
printfd maxab
也是把 maxab作为 printf函数的一个参数。
说明： 调用函数并不一定要求包括分号如print star；，只有作为函数调用语句才需要有分号。如果作为函数表达式或函数参数，函数调用本身是不必有分号的。不能写成
printfd maxab maxab后面多了一个分号
函数调用时的数据传递
形式参数和实际参数
在调用有参函数时，主调函数和被调用函数之间有数据传递关系。从前面已知：在定义函数时函数名后面括号中的变量名称为“形式参数”简称“形参”或“虚拟参数”。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”简称“实参”。实际参数可以是常量、变量或表达式。
第章 用函数实现模块化程序设计
实参和形参间的数据传递
在调用函数过程中，系统会把实参的值传递给被调用函数的形参。或者说，形参从实参得到一个值。该值在函数调用期间有效，可以参加该函数中的运算。
在调用函数过程中发生的实参与形参间的数据传递称为“虚实结合”。
【例】 输入两个整数，要求输出其中值较大者。要求用函数来找到大数。
解题思路：从两个数中找出其中的大者，算法是再简单不过的了，不必再讨论了。现在的关键是要用一个函数来实现它。在定义函数时，要确定几个问题：
函数名。应是见名知义，反映函数的功能，今定名为 max。
函数的类型。由于给定的两个数是整数，显然其中大者也是整数，也就是说 max函数的值即返回主调函数的值应该是整型。
max函数的参数个数和类型。 max函数应当有两个参数，以便从主函数接收两个整数，显然，参数的类型应当是整型。
在调用 max函数时，应当给出两个整数作为实参，传给 max函数中的两个形参。
编写程序：
先编写 max函数
int max int x int y 定义 max函数，有两个参数
int z 定义临时变量z
zxy xy 把x和y中的大者赋给z
returnz 把z作为 max函数的值带回 main函数
再编写主函数
include stdio h
int main
int max int x int y 对 max函数的声明
int abc
printfplease enter two integer numbers 提示输入数据
scanfddab 输入两个整数
c maxab 调用 max函数，有两个实参。大数赋给变量c
printfmax is dnc 输出大数c
return
把二者组合为一个程序文件，主函数在前面， max函数在下面。
运行结果：
please enter two integer numbers
max is
程序分析： 先定义 max函数注意第行的末尾没有分号。第行定义了一个函数，名为 max，函数类型为 int。指定两个形参x和y，形参的类型为 int。
主函数中包含了一个函数调用 maxa，b。 max后面括号内的a和b是实参。a和b
C程序设计第五版
是在 main函数中定义的变量，x和y是函数 max的形式参数。通过函数调用，在两个函数之间发生数据传递，实参a和b的值传递给形参x和y，在max函数中把x和y中的大者赋给变量z，z的值作为函数值返回 main函数，赋给变量c。见图。
说明：
实参可以是常量、变量或表达式，例如： max，ab，但要求它们有确定的值。在调用时将实参的值赋给形参。
实参与形参的类型应相同或赋值兼容。例中实参和形参的类型相同，都是 int型，这是合法的、正确的。如果实参为 int型而形参x为 float型，或者相反，则按不同类型数值的赋值规则进行转换。例如实参a为 float型变量，其值为，而形参x为 int型，则在传递时先将实数转换成整数，然后送到形参x。字符型与 int 型可以互相通用。
c maxab
main 函数
int max int x int y
max
函数
a
b
a
b
int z
zxyxy
returnz
x
y
x
y
图
图
图
函数调用的过程
在定义函数中指定的形参，在未出现函数调用时，它们并不占内存中的存储单元。在发生函数调用时，函数 max的形参才被临时分配内存单元。
将实参的值传递给对应形参。如图所示，实参的值为，把传递给相应的形参x，这时形参x就得到值，同理，形参y得到值。
在执行 max函数期间，由于形参已经有值，就可以利用形参进行有关的运算例如把 x和y 比较，把x或y的值赋给z等。
通过 return语句将函数值带回到主调函数。例中在 return 语句中指定的返回值是z，这个z就是函数 max的值又称返回值。执行return语句就把这个函数返回值带回主调函数 main。应当注意返回值的类型与函数类型一致。现在， max函数为int型，返回值是变量z，也是 int型。二者一致。
如果函数不需要返回值，则不需要 return语句。这时函数的类型应定义为 void 类型。
调用结束，形参单元被释放。注意：实参单元仍保留并维持原值，没有改变。如果在执行一个被调用函数时，形参的值发生改变，不会改变主调函数的实参的值。例如，若在执行 max函数过程中x和y的值变为和，但 a和b仍为和，见图。这是因为实参与形参是两个不同的存储单元。
注意： 实参向形参的数据传递是“值传递”，单向传递，只能由实参传给形参，而不能由形参传给实参。实参和形参在内存中占有不同的存储单元，实参无法得到形参的值。
函数的返回值
通常，希望通过函数调用使主调函数能得到一个确定的值，这就是函数值函数的返回
第章 用函数实现模块化程序设计
值。例如，在例的主函数中有
c maxab
从 max函数的定义中可以知道函数调用 max的值是 max的值是和就是这两个函数的返回值，赋值语句把函数的返回值赋给变量c。
下面对函数值作一些说明。
函数的返回值是通过函数中的 return语句获得的。 return 语句将被调用函数中的一个确定值带回到主调函数中去见图中从 return 语句返回的箭头。如果需要从被调用函数带回一个函数值供主调函数使用，被调用函数中必须包含 return 语句。如果不需要从被调用函数带回函数值可以不要 return语句。
一个函数中可以有一个以上的 return语句，执行到哪一个 return语句，哪一个 return语句就起作用。 return 语句后面的括号可以不要如“return z”与“returnz”等价。 return 后面的值可以是一个表达式。例如，例中的函数 max可以改写如下：
max int x int y
returnxyxy
这样的函数体更为简短，只用一个 return语句就把求值和返回都解决了。
函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。例如下面是个函数的首行：
int max float x float y 函数值为整型
char letter char c char c 函数值为字符型
double min int x int y 函数值为双精度型
注意：在定义函数时要指定函数的类型①。
在定义函数时指定的函数类型一般应该和 return 语句中的表达式类型一致。例如，例中指定 max函数值为整型，而变量 z也被指定为整型，通过 return 语句把z的值作为 max的函数值，由 max带回主调函数。z的类型与max函数的类型是一致的，是正确的。
如果函数值的类型和 return语句中表达式的值不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。
【例】 将例稍作改动，将在 max函数中定义的变量z改为 float型。函数返回值的类型与指定的函数类型不同，分析其处理方法。
解题思路： 如果函数返回值的类型与指定的函数类型不同，按照赋值规则处理。
编写程序：
include stdio h
int main
① 过去的C标准允许在定义函数时不指定函数类型，此时，编译系统默认它为 int型。现在有的编译系统包括 VisualC 仍然按此处理。但是不应提倡这样写程序，应当养成在定义函数时一律指定函数类型的习惯。这样的程序规范、易读、易于检查维护。
C程序设计第五版
int max float x float y
float ab
int c
scanfff ab
c maxab
printfmax is dnc
return
int max float x float y
float z z为实型变量
zxyxy
returnz
运行结果：
max is
程序分析： max函数的形参是 float型，今实参也是 float型，在 main函数中输入给a和b的值是 和。在调用 maxab时把a和b的值 和传递给形参x和y。执行函数 max中的条件表达式“zxyx：y”，使得变量z得到的值为。现在出现了矛盾： 函数定义为 int型，而 return语句中的 z为 float 型，要把z的值作为函数的返回值，二者不一致。怎样处理呢 按赋值规则处理，先将z的值转换为 int型，得到，它就是函数得到的返回值。最后 maxx，y带回一个整型值返回主调函数 main。
如果将 main 函数中的 c 改为 float 型用f格式符输出输出 。因为调用 max函数得到的是 int型，函数值为整数。
有时，可以利用这一特点进行类型转换，如在函数中进行实型运算，希望返回的是整型量，可让系统自动完成类型转换。但这种做法往往使程序不清晰，可读性降低，容易弄错，而且并不是所有的类型都能互相转换的。因此建议初学者不要采用这种方法，而应做到使函数类型与 return返回值的类型一致。
对于不带回值的函数，应当用定义函数为“void 类型”或称“空类型”。这样，系统就保证不使函数带回任何值，即禁止在调用函数中使用被调用函数的返回值。此时在函数体中不得出现 return 语句。
对被调用函数的声明和函数原型
在一个函数中调用另一个函数即被调用函数需要具备如下条件：
首先被调用的函数必须是已经定义的函数是库函数或用户自己定义的函数。但仅有这一条件还不够。
如果使用库函数，应该在本文件开头用 include指令将调用有关库函数时所需用到的信息“包含”到本文件中来。例如，前几章中已经用过的指令：
include stdio h
第章 用函数实现模块化程序设计
其中， “stdio h”是一个“头文件”。在 stdio h文件中包含了输入输出库函数的声明。如果不包含“stdio h”文件，就无法使用输入输出库中的函数。同样，使用数学库中的函数应该用 include math h。h是头文件所用的后缀表示是头文件 header file。
如果使用用户自己定义的函数，而该函数的位置在调用它的函数即主调函数的后面在同一个文件中，应该在主调函数中对被调用的函数作声明 declaration。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。在前面的例子中已出现过对被调用函数的声明，下面再作进一步的说明。
【例】 输入两个实数，用一个函数求出它们之和。
解题思路： 两个数相加的算法很简单。现在用 add函数实现它。首先要定义 add函数，它为 float型，它应有两个参数，也应为 float型。特别要注意的是：要对 add函数进行声明。
编写程序： 分别编写 add函数和 main函数，它们组成一个源程序文件， main 函数的位置在 add 函数之前。在 main函数中对 add函数进行声明。
include stdio h
int main
float add float x float y 对 add函数作声明
float abc
printfPlease enter a and b 提示输入
scanfffab 输入两个实数
c addab 调用 add函数
printfsum is fnc 输出两数之和
return
float add float x float y 定义 add函数
float z
zxy
returnz 把变量z的值作为函数值返回
运行结果：
Please enter a and b
sum is
这是一个很简单的函数调用，函数 add的作用是求两个实数之和，得到的函数值也是实型。程序第行是对被调用的 add函数作声明：
float add float x float y
从程序可以看到： main函数的位置在 add函数的前面，而程序进行编译时是从上到下逐行进行的，如果没有对函数 add的声明，当编译到程序第行时，编译系统无法确定 add 是不是函数名，也无法判断实参a和b的类型和个数是否正确，因而无法进行正确性的检查。
C程序设计第五版
如果不作检查，在运行时才发现实参与形参的类型或个数不一致，出现运行错误。但是在运行阶段发现错误并重新调试程序，是比较麻烦的，工作量也较大。应当在编译阶段尽可能多地发现错误，随之纠正错误。
现在，在函数调用之前对 add作了函数声明。因此编译系统记下了 add函数的有关信息，在对“c adda，b；”进行编译时就“有章可循”了。编译系统根据 add函数的声明对调用 add函数的合法性进行全面的检查。如果发现函数调用与函数声明不匹配，就会发出出错信息，它属于语法错误。用户根据屏幕显示的出错信息很容易发现和纠正错误。
读者可以发现，函数的声明和函数定义中的第行函数首部基本上是相同的，只差一个分号函数声明比函数定义中的首行多一个分号。因此写函数声明时，可以简单地照写已定义的函数的首行，再加一个分号，就成了函数的“声明”。函数的首行即函数首部称为函数原型 function prototype。为什么要用函数的首部来作为函数声明呢 这是为了便于对函数调用的合法性进行检查。因为在函数的首部包含了检查调用函数是否合法的基本信息它包括了函数名、函数值类型、参数个数、参数类型和参数顺序，在检查函数调用时要求函数名、函数类型、参数个数和参数顺序必须与函数声明一致，实参类型必须与函数声明中的形参类型相同或赋值兼容，如实型数据可以传递给整型形参，按赋值规则进行类型转换。否则就按出错处理。这样就能保证函数的正确调用。
说明：使用函数原型作声明是C的一个重要特点。用函数原型来声明函数，能减少编写程序时可能出现的错误。由于函数声明的位置与函数调用语句的位置比较近，因此在写程序时便于就近参照函数原型来书写函数调用，不易出错。
实际上，在函数声明中的形参名可以省写，而只写形参的类型，如上面的声明可以写为
float add float float 不写参数名，只写参数类型
编译系统只关心和检查参数个数和参数类型，而不检查参数名，因为在调用函数时只要求保证实参类型与形参类型一致，而不必考虑形参名是什么。因此在函数声明中，形参名可写可不写，形参名是什么都无所谓，如：
float add float a float b 参数名不用xy而用ab。合法
根据以上的介绍，函数声明的一般形式有两种，分别为
函数类型 函数名参数类型 参数名，参数类型 参数名，…，
参数类型 n 参数名 n；
函数类型 函数名参数类型，参数类型，…，参数类型n；
有些专业人员喜欢用不写参数名的第种形式，显得精练。有些人则愿意用第种形式，只须照抄函数首部就可以了，不易出错，而且用了有意义的参数名有利于理解程序，如：
void print int num char sex float score
大体上可猜出这是一个输出学号、性别和成绩的函数，而若写成
void print int float char
则无从知道形参的含义。
第章 用函数实现模块化程序设计
注意： 对函数的“定义”和“声明”不是同一回事。函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位。而函数的声明的作用则是把函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查例如，函数名是否正确，实参与形参的类型和个数是否一致，它不包含函数体。
如果已在文件的开头在所有函数之前，已对本文件中所调用的函数进行了声明，则在各函数中不必对其所调用的函数再作声明。例如：
char letter char char 以下行在所有函数之前，且在函数外部
float f float float
int i float float
int main 在 main 函数中要调用 letterf和i函数
不必再对所调用的这个函数进行声明
⋮
下面定义被 main函数调用的个函数
char letter char c char c 定义 letter函数
⋮
float f float x float y 定义f函数
⋮
int i float j float k 定义i函数
⋮
由于在文件的开头在函数的外部已对要调用的函数进行了声明这些称为“外部的声明”，因此在程序编时，编译系统已从外部声明中知道了函数的有关信息，所以不必在主调函数中再重复进行声明。写在所有函数前面的外部声明在整个文件范围中有效。
函数的嵌套调用
C语言的函数定义是互相平行、独立的，也就是说，在定义函数时，一个函数内不能再定义另一个函数，即不能嵌套定义，但可以嵌套调用函数，即在调用一个函数的过程中，又调用另一个函数，见图。
调用a函数
调用b函数
图 表示的是两层嵌套连 main 函数共层函数，其执行过程是：
⑨
⑦
⑧
⑥
① 执行 main函数的开头部分；
结束
②遇函数调用语句，调用函数a，流程转去 a函数；
图
C程序设计第五版
③执行a函数的开头部分；
④ 遇函数调用语句，调用函数 b，流程转去函数 b；
⑤执行b函数，如果再无其他嵌套的函数，则完成b函数的全部操作；
⑥返回到a函数中调用b函数的位置；
⑦继续执行a函数中尚未执行的部分，直到a函数结束；
⑧返回 main 函数中调用a 函数的位置；
⑨继续执行 main 函数的剩余部分直到结束。
【例】 输入个整数，找出其中最大的数。用函数的嵌套调用来处理。
解题思路：这个问题并不复杂，完全可以只用一个主函数就可以得到结果。现在根据题目的要求，用函数的嵌套调用来处理。在main 函数中调用 max 函数，max函数的作用是找出个数中的最大者。在 max函数中再调用另一个函数 max。max函数用来找出两个数中的大者。在max中通过多次调用max函数，可以找出个数中的大者，然后把它作为函数值返回 main函数，在 main函数中输出结果。以此例来说明函数的嵌套调用的用法。
编写程序： 根据此思路写出程序。
include stdio h
int main
int max int a int b int c int d 对 max的函数声明
int abcd max
printfPlease enter interger numbers 提示输入个数
scanfd d d dabcd 输入个数
maxmaxabcd 调用 max 函数，得到个数中的最大者
printfmaxdn max 输出个数中的最大者
return
int max int a int b int c int d 定义max 函数
int max int a int b 对 max的函数声明
int m
m max ab 调用 max函数，得到 a和b两个数中的大者，放在m中
m max mc 调用 max函数得到 abc 个数中的大者放在m中
mmaxmd 调用max函数得到 abcd个数中的大者放在m中
returnm 把 m作为函数值带回 main 函数
int max int a int b 定义 max函数
ifab
return a 若a≥b，将a作为函数返回值
else
return b 若ab，将b作为函数返回值
第章 用函数实现模块化程序设计
运行结果：
Please enter interger numbers max
程序分析：可以清楚地看到，在主函数中要调用 max函数，因此在主函数的开头要对 max函数作声明。在 max 函数中次调用max 函数，因此在 max 函数的开头要对 max函数作声明。由于在主函数中没有直接调用 max函数，因此在主函数中不必对max函数作声明，只须在 max 函数中作声明即可。
max 函数执行过程是这样的： 第次调用 max 函数得到的函数值是a和b中的大者，把它赋给变量m，第次调用 max得到m和c中的大者，也就是a，b，c中的最大者，再把它赋给变量m。第次调用max得到 m和d中的大者，也就是a，b，c，d中的最大者，再把它赋给变量m。这是一种递推方法，先求出个数的大者；再以此为基础求出个数的大者；再以此为基础求出个数的大者。m的值一次一次地变化，直到实现最终要求。
程序改进：
可以将 max函数的函数体改为只用一个 return语句，返回一个条件表达式的值：
int max int a int b 定义 max 函数
returnabab 返回条件表达式的值，即a和b中的大者
在 max 函数中个调用 max的语句如 m max ab可以用以下一行代替：
m max max max abcd 把函数调用作为函数参数
甚至可以取消变量 m，max 函数可写成
int max int a int b int c int d
int max int a int b 对 max的函数声明
return max max max abcd
先调用“max ab”得到a和b中的大者。再调用“maxmaxabc”其中 maxab为已知得到abc三者中的大者。最后由“max max max abcd”求得abcd四者中的大者。
请读者上机显示完整的程序，并运行之。通过此例，可以知道，不仅要写出正确的程序，还要学习怎样使程序更加精练、专业和易读。
函数的递归调用
在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用。C语言的特点之一就在于允许函数的递归调用。例如：
int f int x
int yz
zfy 在执行f函数的过程中又要调用f函数
C程序设计第五版
returnz
在调用函数f的过程中，又要调用f函数本函数，这是直接调用本函数，见图。
如果在调用f函数过程中要调用f 函数，而在调用f函数过程中又要调用 f函数，就是间接调用本函数，见图。
f函数
f函数
f函数
调用f函数
调用f函数
调用f函数
图
图
可以看到，图和图这两种递归调用都是无终止的自身调用。显然，程序中不应出现这种无终止的递归调用，而只应出现有限次数的、有终止的递归调用，这可以用 if语句来控制，只有在某一条件成立时才继续执行递归调用；否则就不再继续。
关于递归的概念，有些初学者感到不好理解，下面用一个通俗的例子来说明。
【例】 有个学生坐在一起，问第个学生多少岁，他说比第个学生大岁。问第个学生岁数，他说比第个学生大岁。问第个学生，又说比第个学生大岁。问第个学生，说比第个学生大岁。最后问第个学生，他说是岁。请问第个学生多大。
解题思路： 要求第个学生的年龄，就必须先知道第个学生的年龄，而第个学生的年龄也不知道，要求第个学生的年龄必须先知道第个学生的年龄，而第个学生的年龄又取决于第个学生的年龄，第个学生的年龄取决于第个学生的年龄。而且每一个学生的年龄都比其前个学生的年龄大。即：
age age
age age
age age
age age
age
可以用数学公式表述如下：
agen n
agen agen n
可以看到，当n时，求每位学生的年龄的公式是相同的。因此可以用一个函数表示上述关系。图表示求第个学生年龄的过程。
显然，这是一个递归问题。由图可知，求解可分成两个阶段：第阶段是“回溯”，即将第个学生的年龄表示为第个学生年龄的函数，表示为 age age。而第个学生的年龄仍然不知道，还要“回溯”到第个学生的年龄，表示为 ageage……直到第个学生的年龄。此时 age已知等于，不必再向前回溯了。然后开始第阶段，采用递推方法，从第个学生的已知年龄推算出第个学生的年龄岁，从第个学生的年龄推算出第个学生的年龄岁……一直推算出第个学生的年龄岁为
第章 用函数实现模块化程序设计
止。也就是说，一个递归的问题可以分为“回溯”和“递推”两个阶段。要经历若干步才能求出最后的值。显而易见，如果要求递归过程不是无限制进行下去，必须具有一个结束递归过程的条件。例如， age，就是使递归结束的条件。
age
age
age
age
age
age
age
age
age
图
编写程序： 可以用一个函数来描述上述递归过程：
int age int n 求年龄的递归函数
int c c用作存放函数的返回值的变量
ifn
c
else
c agen
returnc
用一个主函数调用 age函数，求得第个学生的年龄。整个程序如下：
include stdio h
int main
int age int n 对 age函数的声明
printfNO agedn age 输出第个学生的年龄
return
int age int n 定义递归函数
int c
ifn 如果 n等于
c 年龄为
else 如果 n不等于
c agen
年龄是前一个学生的年龄加如第个学生年龄是第个学生年龄加
C程序设计第五版
returnc 返回年龄
运行结果：
NO age
程序分析： main函数中除了 return语句外只有一个语句。整个问题的求解全靠一个 age函数调用来解决。对 age函数的递归调用过程如图所示。
agen
agen
agen
agen
agen
main
n
n
n
n
n
age
c age
c age
c age
c age
c
输出 age
age
age
age
age
age
图
从图 可以看到 age函数共被调用 次即 age、 age、 age、 age、 age。其中 age是 main函数调用的其余次是在 age函数中调用自己的即递归调用次。请读者仔细分析调用的过程。应当强调说明的是：在某一次调用 age函数时并不是立即得到 agen的值，而是一次又一次地进行递归调用，到 age时才有确定的值，然后再递推出 age、 age、 age、 age。请读者将程序和图和图 结合起来认真分析。
注意分析递归的终止条件。当n等于时应执行“c agen”由于 n它相当于“c age”。注意 age的值是什么 此时n应执行“c”即不再递归调用 age函数了，递归调用结束。将作为 age的值返回 age函数中的”处此时n得到c即。再把作为 age的值返回 age函数中的“c agen”处此时n得到c即。依此类推可以得到 age的值为。
【例】 用递归方法求 n。
解题思路： 求n！可以用递推方法，即从开始，乘，再乘……一直乘到n。这种方法容易理解，也容易实现。递推法的特点是从一个已知的事实如！出发，按一定规律推出下一个事实如！！，再从这个新的已知的事实出发，再向下推出一个新的事实。nnn。
求n也可以用递归方法即等于×而×…。 可用下面的递归公式表示：
有了例的基础，可以很容易写出本题的程序。
编写程序：
include stdio h
int main
int fac int n fac 函数声明
第章 用函数实现模块化程序设计
int n
int y
printfinput an integer number
scanfdn 输入要求阶乘的数
y facn
printfddnny
return
int fac int n 定义 fac函数
int f
ifn n不能小于
printfn data error
else ifnn n或时n
f
else f facnn n时nnn
returnf
运行结果：
input an integer number
程序分析： 调用递归函数 fac的过程见图。请注意每次调用 fac函数后，其返回值f应返回到调用 fac函数处，例如，当n时，从函数体中可以看到“f fac”，再调用 fac返回值为。这个就取代了“f fac”中的 fac从而f。其余类似。递归终止条件为n或n。
facn
facn
facn
facn
facn
main
n
n
n
n
n
fac
f fac×
f fac×
f fac×
f fac×
f
输出 fac
fac
fac
fac
fac
fac
图
注意程序中的变量是 int 型如果用 Visual C、GCC 以及多数C编译系统为 int型数据分配个字节能表示的最大数为 当 n时运行正常输出为
input an integer number
如果输入，企图求！，是得不到预期结果的，因为求出的结果超过了 int 型数据的最大值。可将fy 和 fac 函数定义为 float或 double型。
【例】 Hanoi汉诺塔问题。这是一个古典的数学问题，是一个用递归方法解题的典型例子。问题是这样的：古代有一个梵塔，塔内有个座A，B，C。开始时A座上有个盘子，盘子大小不等，大的在下，小的在上见图。有一个老和尚想把这个盘子从A座移到C座，但规定每次只允许移动一个盘，且在移动过程中在个座上都始
C程序设计第五版
终保持大盘在下，小盘在上。在移动过程中可以利用B座。要求编程序输出移动盘子的步骤。
A
B
C
图
解题思路： 要把个盘子从A 座移动到C座，需要移动大约⁶⁴次盘子。一般人是不可能直接确定怎样移动盘子的每一个具体步骤的。读者可以试验一下，按上面的规定将个盘子从 A座移到C座，能否直接写出每一步骤
需要找到一个解决问题的思路，把看似复杂的问题简单化，使问题得以迎刃而解。老和尚会这样想： 假如有另外一个和尚能有办法将上面个盘子从一个座移到另一座。那么，问题就解决了。此时老和尚只须这样做：
命令第个和尚将个盘子从 A 座移到 B座；
自己将个盘子最底下的、最大的盘子从A座移到C座；
再命令第个和尚将个盘子从B座移到C座。
见图。
②个盘子从A→C
①个盘子从A→B
③个盘子从B→C
个盘子
A
B
C
图
至此，全部任务完成了。这就是递归方法，把移动个盘子简化为移动个盘子，难度减小了一些。但是，有一个问题实际上未解决：第个和尚怎样才能将个盘子从A座移到 B座
为了解决将个盘子从A座移到 B座，第个和尚又想：如果有人能将个盘子从一个座移到另一座，我就能将个盘子从 A 座移到 B座，他是这样做的：
命令第个和尚将个盘子从A 座移到C座；
自己将个盘子从 A 座移到 B座；
再命令第个和尚将个盘子从C座移到B座。
第章 用函数实现模块化程序设计
再进行一次递归。如此“层层下放”，直到后来找到第个和尚，让他完成将个盘子从一个座移到另一座，进行到此，问题就接近解决了。最后找到第个和尚，让他完成将个盘子从一个座移到另一座，至此，全部工作都已落实，是可以执行的。
可以看出，递归的结束条件是最后一个和尚只须移一个盘子；否则递归还要继续进行下去。
应当说明，只有第个和尚的任务完成后，第个和尚的任务才能完成。只有第个和尚任务都完成后，第个和尚的任务才能完成。这是一个典型的递归的问题。
为便于理解，先分析将A座上个盘子移到C座上的过程，移动前的情况见图a。
将A座上个盘子移到 B座上借助C座见图b。
将 A座上个盘子移到C座上见图c。
将B座上个盘子移到C座上借助A座见图d。
A
B
C
a
A
B
C
b
A
B
C
c
A
B
C
d
图
其中第步可以直接实现。第步又可用递归方法分解为
· 将A座上个盘子从 A 座移到C座；
· 将 A座上个盘子从A座移到 B座；
· 将C座上个盘子从C座移到 B座。
第步可以分解为
· 将B座上个盘子从 B座移到 A 座上；
· 将B座上个盘子从 B座移到 C座上；
· 将A座上个盘子从 A座移到 C座上。
将以上综合起来，可得到移动个盘子的步骤为
A→CA→BC→BA→CB→AB→CA→C
C程序设计第五版
共经历步。由此可推出：移动n个盘子要经历步。如移个盘子经历步，移个盘子经历步，移个盘子经历⁶⁴步。
由上面的分析可知：将n个盘子从A座移到C座可以分解为以下个步骤：
将A座上n个盘借助C座先移到 B座上；
把A 座上剩下的一个盘移到 C座上；
将n个盘从B座借助于 A 座移到C座上。
上面第步和第步，都是把 n个盘从一个座移到另一个座上，采取的办法是一样的，只是座的名字不同而已。为使之一般化，可以将第步和第步表示为：
将 one座上n个盘移到 two座借助 three座。只是在第步和第步中 one two three和ABC的对应关系不同。对第步对应关系是 one 对应A two 对应B three对应C。对第步是 one对应B two对应C three对应A。
因此，可以把上面个步骤分成两类操作：
将n个盘从一个座移到另一个座上n。这就是大和尚让小和尚做的工作，它是一个递归的过程，即和尚将任务层层下放，直到第个和尚为止。
将个盘子从一个座上移到另一座上。这是大和尚自己做的工作。
编写程序： 分别用两个函数实现以上的两类操作，用hanoi函数实现上面第类操作即模拟小和尚的任务，用move函数实现上面第类操作模拟大和尚自己移盘，函数调用 hanoin one two three表示将 n个盘子从 one 座移到 three 座的过程借助 two座。函数调用 movex，y表示将个盘子从x座移到y座的过程。x和y是代表A，B，C座之一，根据每次不同情况分别取A，B，C代入。
include stdio h
int main
void hanoi int n char one char two char three 对 hanoi函数的声明
int m
printfinput the number of diskes
scanfdm
printfThe step to move d diskesnm
hanoimABC
void hanoi int n char one char two char three 定义 hanoi函数
将n个盘从 one座借助 two座移到 three座
void move char x char y 对 move函数的声明
ifn
move one three
else
hanoin one three two
move one three
hanoin two one three
第章 用函数实现模块化程序设计
void move char x char y 定义 move函数
printfccnxy
运行结果：
input the number of diskes
The step to move diskes
AC
AB
CB
AC
BA
BC
AC
C 程序分析： 在本程序中，调用递归函数 hanoi，其终止条件为hanoi函数的参数 n的值等于。显然，此时不必再调用 hanoi函数了，直接执行 move函数即可。
在本程序中 move函数并未真正移动盘子，而只是输出移盘的方案表示从哪一个座移到哪一个座。
前已说明，将个盘子从A座移到C座需要移次，假设和尚每次移动一个盘子用一秒钟，则移动次需要秒，大约相当于年，即大约 亿年。所以有人戏称，当老和尚移完个盘子之时， “世界末日”也到了。
以上对递归函数作了比较详细和通俗易懂的说明，希望读者弄清楚递归的概念，区分嵌套与递归，比较递推与递归，能编写简单的递归程序。
数组作为函数参数
调用有参函数时需要提供实参。例如 sinx sqrt maxab等。实参可以是常量、变量或表达式。数组元素的作用与变量相当，一般来说，凡是变量可以出现的地方，都可以用数组元素代替。因此，数组元素也可以用作函数实参，其用法与变量相同，向形参传递数组元素的值。此外，数组名也可以作实参和形参，传递的是数组第一个元素的地址。
数组元素作函数实参
数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配存储单元的，不可能为一个数组元素单独分配存储单元数组是一个整体，在内存中占连续的一段存储单元。在用数组元素作函数实参时，把实参的值传给形参，是“值传递”方式。数据传递的方向是从实参传到形参，单向传递。
【例】 输入个数，要求输出其中值最大的元素和该数是第几个数。
解题思路：可以定义一个数组a，长度为，用来存放个数。设计一个函数 max，用来求两个数中的大者。在主函数中定义一个变量 m，m的初值为a，每次调用 max函数
C程序设计第五版
后的返回值存放在m中。用“打擂台”算法，依次将数组元素aa与m 比较，最后得到的 m值就是个数中的最大者。
编写程序：
include stdio h
int main
int max int x int y 函数声明
int amni
printfenter integer numbers
foriii 输入个数给aa
scanfdai
printfn
forimanii
if maxmaim 若 max函数返回的值大于 m
m maxmai max函数返回的值取代 m原值
ni 把此数组元素的序号记下来，放在n中
printfThe largest number is d nit is the dth numbernmn
int max int x int y 定义 max函数
returnxy xy 返回x和y中的大者
运行结果：
enter integer numbers
The largest number is
it is the th number
程序分析：从键盘输入个数给aa。变量 m用来存放当前已比较过的各数中的最大者。开始时设m的值为a，然后将m与a比，如果a大于m，就以a的值此时也就是 maxma的值取代 m的原值。下一次以m的新值与a比较 maxma的值是aaa中最大者其余类推。经过轮循环的比较m最后的值就是个数的最大数。
请注意分析怎样得到最大数是个数中第几个数。当每次出现以 maxm，ai的值取代m的原值时，就把i的值保存在变量n中。n最后的值就是最大数的序号注意序号从开始，如果要输出“最大数是个数中第几个数”，应为n。例如n时表示数组元素a是最大数，由于序号从开始，因此它是数中第个数，故应输出的是n。
当然，本题可以不用 max函数求两个数中的大数，而在主函数中直接用 ifmai来判断和处理。本题的目的是介绍如何用数组元素作为函数实参。
第章 用函数实现模块化程序设计
一维数组名作函数参数
除了可以用数组元素作为函数参数外，还可以用数组名作函数参数包括实参和形参。
注意： 用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数实参时，向形参数组名或指针变量 传递的是数组首元素的地址。
【例】 有一个一维数组 score，内放个学生成绩，求平均成绩。
解题思路：用一个函数 average来求平均成绩，不用数组元素作为函数实参，而是用数组名作为函数实参，形参也用数组名，在average函数中引用各数组元素，求平均成绩并返回 main函数。
编写程序：
include stdio h
int main
float average float array 函数声明
float score aver
int i
printfinput scoresn
foriii
scanff scorei
printfn
aver average score 调用 average函数
printfaverage score is fn aver
return
float average float array 定义 average函数
int i
float aver sum array
foriii
sum sum arrayi 累加学生成绩
aver sum
return aver
运行结果：
input scores
average score is
程序分析：
用数组名作函数参数，应该在主调函数和被调用函数分别定义数组，例中 array是形参数组名， score是实参数组名，分别在其所在函数中定义，不能只在一方定义。
实参数组与形参数组类型应一致今都为 float型，如不一致，结果将出错。
在定义 average函数时，声明形参数组的大小为，但在实际上，指定其大小是不
C程序设计第五版
起任何作用的，因为C语言编译系统并不检查形参数组大小，只是将实参数组的首元素的地址传给形参数组名。形参数组名获得了实参数组的首元素的地址，前已说明，数组名代表数组的首元素的地址，因此，可以认为，形参数组首元素 array和实参数组首元素 score具有同一地址它们共占同一存储单元 scoren和 arrayn指的是同一单元。 scoren和 arrayn具有相同的值。
形参数组可以不指定大小，在定义数组时在数组名后面跟一个空的方括号，如：
float average float array 定义 average函数，形参数组不指定大小
效果是相同的。
说明：在学习了第章指针以后，可以知道在对源程序编译时，编译系统把形参数组处理为指针变量例如把例中的 float array转换为 float array该指针变量用来接收从实参数组传过來的地址。C语言允许用指针变量如floatarray或数组如 floatarray作为形参，二者是等价的。对数组元素的访问，用下标法和指针法也是完全等价的。用形参数组是为了便于理解，形参数组与实参数组各元素一一对应，比较形象好懂，即使未学过指针，也能方便地使用。在学习了指针后会对形参数组的本质有更深入的理解。
【例】 有两个班级，分别有名和名学生，调用一个 average函数，分别求这两个班的学生的平均成绩。
解题思路：例已解决了求一个有确定长度的数组的平均值的问题。现在需要解决的是怎样用同一个函数求两个不同长度的数组的平均值的问题。在定义 average 函数时不必指定数组的长度，在形参表中增加一个整型变量i，从主函数把数组的实际长度分别从实参传递给形参i。这个i用来在 average函数中控制循环的次数。这就解决了用同一个函数求两个不同长度的数组的平均值问题。
为简化，设两个班的学生数分别为 和。
编写程序：
include stdio h
int main
float average float array int n
float scorel 定义长度为的数组
float score 定义长度为的数组
printfThe average of class A is fn average scorel
用数组名 scorel 和作实参
printfThe average of class B is fn averagescore
用数组名 score和作实参
return
float average float array int n 定义 average 函数，未指定形参数组长度
int i
float aver sum array
foriini
sum sum arrayi 累加n个学生成绩
第章 用函数实现模块化程序设计
aver sumn
return aver
运行结果：
The average of class A is
The average of class B is
程序分析： 程序的作用是分别求出数组 scorel有个元素和数组 score有个元素各元素的平均值。两次调用 average函数时需要处理的数组元素个数是不同的，在第一次调用时将实参值为传递给形参n，表示求个学生的平均分。第次调用时，求个学生的平均分。
注意： 用数组名作函数实参时，不是把数组元素的值传递给形参，而是把实参数组的首元素的地址传递给形参数组，这样两个数组就共占同一段内存单元。如果实参数组为a，形参数组为b见图，若a的首元素的地址为，则b数组首元素的地址也是，显然，a与b同占一个单元……假如改变了b的值，也就意味着a的值也改变了。也就是说，形参数组中各元素的值如发生变化会使实参数组元素的值同时发生变化，从图看是很容易理解的。这一点是与变量作函数参数的情况不同的，务请注意。在程序中常有意识地利用这一特点改变实参数组元素的值如排序。
a
a
a
a
a
a
a
a
a
a
起始地址
bbbbb bbbb
b
图
【例】 用选择法对数组中个整数按由小到大排序。
解题思路：所谓选择法就是先将个数中最小的数与a对换；再将aa中最小的数与a对换······每比较一轮，找出一个未经排序的数中最小的一个。共比较轮。
下面以个数为例说明选择法的步骤。
a a a a a
未排序时的情况
将个数中最小的数与a对换
将余下的后面个数中最小的数与a对换
将余下的个数中最小的数与a对换
将余下的个数中最小的数与a对换，至此完成排序
编写程序： 根据此思路编写程序如下：
include stdio h
int main
void sort int array int n
int ai
printfenter arrayn
C程序设计第五版
foriii
scanfdai
sorta 调用 sort函数a为数组名大小为
printfThe sorted arrayn
foriii
printfdai
printfn
return
void sort int array int n
int ijkt
foriini
ki
forjijnj
if arrayj arrayk
kj
t arrayk arrayk arrayi arrayit
运行结果：
enter array
The sorted array
程序分析： 可以看到在执行函数调用语句“sorta，；”之前和之后，a数组中各元素的值是不同的。原来是无序的，执行“sorta，；”后，a数组已经排好序了，这是由于形参数组 array已用选择法进行排序了，形参数组改变也使实参数组随之改变。
请读者自己画出调用 sort 函数前后实参数组中各元素的值。
多维数组名作函数参数
多维数组元素可以作函数参数，这点与前述的情况类似。
可以用多维数组名作为函数的实参和形参，在被调用函数中对形参数组定义时可以指定每一维的大小，也可以省略第一维的大小说明。例如：
int array
或
int array
二者都合法而且等价。但是不能把第维以及其他高维的大小说明省略。如下面的定义是不合法的：
int array
第章 用函数实现模块化程序设计
这是为什么呢 前已说明，二维数组是由若干个一维数组组成的，在内存中，数组是按行存放的，因此，在定义二维数组时，必须指定列数即一行中包含几个元素 ，由于形参数组与实参数组类型相同，所以它们是由具有相同长度的一维数组所组成的。不能只指定第维行数而省略第维列数，下面的写法是错误的：
int array
在第维大小相同的前提下，形参数组的第维可以与实参数组不同。例如，实参数组定义为
int score
而形参数组定义为
int array
或
int array
均可以。这时形参数组和实参数组都是由相同类型和大小的一维数组组成的。C语言编译系统不检查第一维的大小。在学习指针以后，对此会有更深入的认识。
【例】 有一个× 的矩阵，求所有元素中的最大值。
解题思路： 先使变量 max的初值等于矩阵中第个元素的值，然后将矩阵中各个元素的值与 max相比，每次比较后都把“大者”存放在 max中，全部元素比较完后， max的值就是所有元素的最大值。
编写程序：
include stdio h
int main
int max value int array 函数声明
int a 对数组元素赋初值
printfMax value is dn max valuea max valuea为函数调用
return
int max value int array 函数定义
int ij max
max array
foriii
forjjj
if arrayij max max arrayij 把大者放在 max中
return max
运行结果：
Max value is
程序分析： 形参数组 array第维的大小省略，第维大小不能省略，而且要和实
C程序设计第五版
参数组a的第维的大小相同。在主函数调用 max value函数时，把实参二维数组a的第行的起始地址传递给形参数组 array，因此 array数组第行的起始地址与a数组的第行的起始地址相同。由于两个数组的列数相同，因此 array数组第行的起始地址与a数组的第行的起始地址相同。aij与arrayij同占一个存储单元，它们具有同一个值。实际上 arrayij就是aij在函数中对 arrayij的操作就是对aij的操作。
局部变量和全局变量
在本章以前所见到的程序大多数是一个程序只包含一个 main函数，变量是在函数的开头处定义的。这些变量在本函数范围内有效，即在本函数开头定义的变量，在本函数中可以被引用。在本章中见到的一些程序，包含两个或多个函数，分别在各函数中定义变量。有的读者自然会提出一个问题：在一个函数中定义的变量，在其他函数中能否被引用 在不同位置定义的变量，在什么范围内有效
这就是变量的作用域问题。每一个变量都有一个作用域问题，即它们在什么范围内有效。本节专门讨论这个重要问题。
局部变量
定义变量可能有种情况：
在函数的开头定义；
在函数内的复合语句内定义；
在函数的外部定义。
在一个函数内部定义的变量只在本函数范围内有效，也就是说只有在本函数内才能引用它们，在此函数以外是不能使用这些变量的。在复合语句内定义的变量只在本复合语句范围内有效，只有在本复合语句内才能引用它们。在该复合语句以外是不能使用这些变量的，以上这些称为“局部变量”。
例如在 funl 函数中定义了变量ab在 fun函数中定义了变量ac。 funl 函数中的变量a 和 fun函数中的变量a不是同一个对象。它们分别有自己的有效范围。正如高一甲班有一学生叫王建国，高一乙班也有一学生叫王建国，二者不是同一个人。不同的班允许有同名的学生，互不干扰。高一甲班点名时，只有该班的王建国喊“到”，乙班的王建国不在甲班活动，不会同时喊“到”的。他们的活动范围局限在本班，或者说这些名字的有效范围是局部的只在本班有效。
分析下面的变量的作用范围。
float fl int a 定义函数f
int bc 在函数f中定义b c
⋮ abc有效
char f int x int y 定义函数f
第章 用函数实现模块化程序设计
int ij
xyij有效
、
int main 主函数
int mn
mn有效
return
说明：
主函数中定义的变量如m，n也只在主函数中有效，并不因为在主函数中定义而在整个文件或程序中有效。主函数也不能使用其他函数中定义的变量。
不同函数中可以使用同名的变量，它们代表不同的对象，互不干扰。例如，上面在f函数中定义了变量b和c，倘若在f函数中也定义变量b和c，它们在内存中占不同的单元，不会混淆。
形式参数也是局部变量。例如上面f函数中的形参a，也只在f函数中有效。其他函数可以调用f函数，但不能直接引用f函数的形参a例如想在其他函数中输出a的值是不行的。
在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序”或“程序块”。
int main
int ab
⋮
c在此复合语句内有效
a，b在此范围内有效
⋮
变量c只在复合语句分程序内有效，离开该复合语句该变量就无效，系统会把它占用的内存单元释放。
全局变量
前已介绍，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量称为外部变量，外部变量是全局变量也称全程变量。全局变量可以为本文件中其他函数所共用。它的有效范围为从定义变量的位置开始到本源文件结束。
注意：在函数内定义的变量是局部变量，在函数外定义的变量是全局变量。
分析下面的程序段：
C程序设计第五版
int pq
定义外部变量
float f int a
定义函数 f
int bc
定义局部变量
⋮
char cc
定义外部变量
char f int x int y
定义函数f
全局变量p，q的
int ij
作用范围
⋮
int main
主函数
全局变量c，c的作用范围
int mn
⋮
return
p，q，c，c都是全局变量，但它们的作用范围不同，在 main 函数和f函数中可以使用全局变量p，q，c，c，但在函数f中只能使用全局变量p，q，而不能使用c和 c。
在一个函数中既可以使用本函数中的局部变量，也可以使用有效的全局变量。打个通俗的比方：国家有统一的法律和法规，各省还可以根据需要制定地方的法律和法规。在甲省，国家统一的法律法规和甲省的法律法规都是有效的，而在乙省，则国家统一的法律法规和乙省的法律法规有效。显然，甲省的法律法规在乙省无效。
说明：设置全局变量的作用是增加了函数间数据联系的渠道。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其他函数中全局变量的值。相当于各个函数间有直接的传递通道。由于函数的调用只能带回一个函数返回值，因此有时可以利用全局变量来增加函数间的联系渠道，通过函数调用能得到一个以上的值。
为了便于区别全局变量和局部变量，在C程序设计人员中有一个习惯但非规定，将全局变量名的第个字母用大写表示。
【例】 有一个一维数组，内放个学生成绩，写一个函数，当主函数调用此函数后，能求出平均分、最高分和最低分。
解题思路： 调用一个函数可以得到一个函数返回值，现在希望通过函数调用能得到个结果。可以利用全局变量来达到此目的。
编写程序：
include stdio h
float Max Min 定义全局变量 Max Min
int main
float average float array int n
float ave score
第章 用函数实现模块化程序设计
int i
printfPlease enter scores
foriii
scanff scorei
ave average score
printfmaxf nminf naveragefn Max Min ave
return
float average float array int n 定义函数，有一形参是数组
int i
float aver sum array
Max Min array
foriini
if arrayi Max Max arrayi
else if arrayi Min Min arrayi
sum sum arrayi
aver sumn
return aver
运行结果：
Please enter scores
max
min
average
程序分析： 函数 average中和外界有联系的变量与外界的联系如图 所示。可以看出： main 函数在调用 average函数时，把实参数组 score的首元素地址和整数传递给形参数组 array和形参变量 n函数 average的值是 return 语句带回的 aver 的值在主函数中赋给了变量 ave。这样，在main函数中就得到了平均分。而最高分和最低分是通过全局变量 Max 和 Min获得的。由于 Max 和 Min 是全局变量，是公用的，各函数都可以直接引用它们，也可以向它们赋值。现在在 average 函数中，改变了它们的值，最后把最高分和最低分存放在 Max和Min中。在主函数可以使用这两个变量的值。因此在 main函数中输出的 Max 和Min就是希望得到的最高分和最低分。
全局变量
Max
Min
ave
score
Max
Min
main
函数
average
aver
array
n
Max
Min
函数
图
C程序设计第五版
但是，建议不在必要时不要使用全局变量，原因如下：
①全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。
②它使函数的通用性降低了，因为如果在函数中引用了全局变量，那么执行情况会受到有关的外部变量的影响，如果将一个函数移到另一个文件中，还要考虑把有关的外部变量及其值一起移过去。但是若该外部变量与其他文件的变量同名时，就会出现问题。这就降低了程序的可靠性和通用性。在程序设计中，在划分模块时要求模块的“内聚性”强、与其他模块的“耦合性”弱。即模块的功能要单一不要把许多互不相干的功能放到一个模块中，与其他模块的相互影响要尽量少，而用全局变量是不符合这个原则的。一般要求把C程序中的函数做成一个相对的封闭体，除了可以通过“实参一形参”的渠道与外界发生联系外，没有其他渠道。这样的程序移植性好，可读性强。
③使用全局变量过多，会降低程序的清晰性，人们往往难以清楚地判断出每个瞬时各个外部变量的值。由于在各个函数执行时都可能改变外部变量的值，程序容易出错。因此，要限制使用全局变量。
注意：如果在同一个源文件中，全局变量与局部变量同名，这时会出现什么情况呢 请考虑是按哪一种情况处理：出错；局部变量无效，全局变量有效；在局部变量的作用范围内，局部变量有效，全局变量被“屏蔽”，即它不起作用。请先分析下面的程序。
【例】 若外部变量与局部变量同名，分析结果。
编写程序：
include stdio h
int ab a，b是全局变量
int main
int max int a int b
函数声明。a，b是形参
int a
a是局部变量
局部变量a的作用范围
printfmaxdn maxab
全局变量b的作用范围
return
int max int a int b a，b是函数形参
int c
cab ab 把a和b中的大者存放在c中 形参a，b的作用范围
returnc
运行结果：
max
程序分析：在此例中，故意重复使用a和b作变量名，请读者区别不同的a和b的含义及作用范围。程序第行定义了全局变量a和b，并对其初始化。第行是 main函数，在main函数中第行定义了一个局部变量a。局部变量a的作用范围为第行。
第章 用函数实现模块化程序设计
在此范围内全局变量a被局部变量a屏蔽，相当于全局变量a在此范围内不存在即它不起作用，而全局变量b在此范围内有效。因此第行中 maxa，b的实参a应是局部变量a，所以 maxab相当于 max。它的值为。
第行起定义 max函数，形参a和b是局部变量。全局变量a和 b在 max函数范围内不起作用，所以函数 max中的a和b不是全局变量a和b，而是形参a和b，它们的值是由实参传给形参的，即和。从运行结果看， maxa，b的返回值为，而不是。验证了以上的分析。
·变量的存储方式和生存期
动态存储方式与静态存储方式
从节已知，从变量的作用域即从空间的角度来观察，变量可以分为全局变量和局部变量。
还可以从另一个角度，即从变量值存在的时间即生存期来观察。有的变量在程序运行的整个过程都是存在的，而有的变量则是在调用其所在的函数时才临时分配存储单元，而在函数调用结束后该存储单元就马上释放了，变量不存在了。也就是说，变量的存储有两种不同的方式： 静态存储方式和动态存储方式。静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式，而动态存储方式则是在程序运行期间根据需要进行动态的分配存储空间的方式。
先看一下内存中的供用户使用的存储空间的情况。这个存储空间可以分为部分：
程序区
用户区
静态存储区；
程序区
动态存储区。
静态存储区
见图。
动态存储区
数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。
图
在动态存储区中存放以下数据：
①函数形式参数。在调用函数时给形参分配存储空间。
②函数中定义的没有用关键字 static声明的变量，即自动变量详见后面的介绍。
③函数调用时的现场保护和返回地址等。
对以上这些数据，在函数调用开始时分配动态存储空间，函数结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的，如果在一个程序中两次调用同一函数，而在此函数中定义了局部变量，在两次调用时分配给这些局部变量的存储空间的地址可能是不相同的。
如果一个程序中包含若干个函数，每个函数中的局部变量的生存期并不等于整个程序的执行周期，它只是程序执行周期的一部分。在程序执行过程中，先后调用各个函数，此时
C程序设计第五版
会动态地分配和释放存储空间。
在C语言中，每一个变量和函数都有两个属性： 数据类型和数据的存储类别。对数据类型，读者已经熟知如整型、浮点型等。存储类别指的是数据在内存中存储的方式如静态存储和动态存储。
在定义和声明变量和函数时，一般应同时指定其数据类型和存储类别，也可以采用默认方式指定即如果用户不指定，系统会隐含地指定为某一种存储类别。
C的存储类别包括种 自动的 auto、静态的 statis、寄存器的 register、外部的 extern。根据变量的存储类别，可以知道变量的作用域和生存期。下面分别作介绍。
局部变量的存储类别
自动变量 auto变量
函数中的局部变量，如果不专门声明为 static静态存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的局部变量包括在复合语句中定义的局部变量，都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间。因此这类局部变量称为自动变量。自动变量用关键字 auto作存储类别的声明。例如：
int f int a 定义f函数，a为形参
auto int bc 定义b，c为自动变量
⋮
其中，a是形参，b和c是自动变量，对c赋初值。执行完f函数后，自动释放a，b，c所占的存储单元。
实际上，关键字 auto可以省略，不写 auto则隐含指定为“自动存储类别”，它属于动态存储方式。程序中大多数变量属于自动变量。前面几章中介绍的例子，在函数中定义的变量都没有声明为 auto，其实都隐含指定为自动变量。例如，在函数体中：
int bc
与
auto int bc
等价。
静态局部变量 static 局部变量
有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值就是上一次函数调用结束时的值。这时就应该指定该局部变量为“静态局部变量”，用关键字 static进行声明。通过下面简单的例子可以了解它的特点。
【例】 考察静态局部变量的值。
第章 用函数实现模块化程序设计
编写程序：
include stdio h
int main
int f int 函数声明
int ai 自动局部变量
foriii
printfdnfa 输出fa的值
return
int f int a
auto int b 自动局部变量
static c 静态局部变量
bb
cc
returnabc
运行结果：
b
c
第一次
调用开始
第一次
调用结束
程序分析： main函数第次调用f函数时，实参a的值 为，它传递给形参a。f函数中的局部变量b的初值为，c的初值为第次调用结束时bcabc。由于c被定义为静态局部变量，在函数调用结束后，它并不释放，仍保留c的值为。在第次调用f函数时，b的初值为，而c的初值为上次调用结束时的值，见图。先后次调用f函数时，b和c的值如表 所示。
第二次
调用开始
图
表静态变量与自动变量的值的比较分析
第几次调用 调用时初值 调用结束时的值 b c b c abc 第次 第次 第次
注：c是静态局部变量，函数调用结束后，它并不释放，保留其当前值。
说明：
静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整个运行期间都不释放。而自动变量即动态局部变量属于动态存储类别，分配在动态存储区空间而不在静态存储区空间，函数调用结束后即释放。
C程序设计第五版
对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值对数值型变量或空字符对字符变量。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可知的。
虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。因为它是局部变量，只能被本函数引用，而不能被其他函数引用。
什么情况下需要用局部静态变量呢 需要保留函数上一次调用结束时的值时，例如可以用下面方法求n！。
【例】 输出到 的阶乘值。
解题思路：可以编一个函数用来进行连乘，如第次调用时进行乘，第次调用时再乘以，第次调用时再乘以，依此规律进行下去。
编写程序：
include stdio h
int main
int fac int n
int i
foriii 先后 次调用 fac函数
printfddni faci 每次计算并输出i！的值
return
int fac int n
static int f f保留了上次调用结束时的值
ffn 在上次的f值的基础上再乘以 n
returnf 返回值f是n！的值
运行结果：
说明：
每次调用 faci输出一个i同时保留这个i的值以便下次再乘i。
如果函数中的变量只被引用而不改变值，则定义为静态局部变量同时初始化比较方便，以免每次调用时重新赋值。
但是应该看到，用静态存储要多占内存长期占用不释放，而不能像动态存储那样一个存储单元可以先后为多个变量使用，节约内存，而且降低了程序的可读性，当调用次
第章 用函数实现模块化程序设计
数多时往往弄不清静态局部变量的当前值是什么。因此，若非必要，不要多用静态局部变量。
寄存器变量 register变量
一般情况下，变量包括静态存储方式和动态存储方式的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放见图。
如果有一些变量使用频繁例如，在一个函数中执行次循环，每次循环中都要引用某局部变量，则为存取变量的值要花费不少时间。为提高执行效率，允许将局部变量的值放在CPU 中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量叫做寄存器变量，用关键字 register 作声明。如
register int f 定义f为寄存器变量
由于现在的计算机的速度愈来愈快，性能愈来愈高，优化的编译系统能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，现在实际上用 register声明变量的必要性不大。在此不详细介绍它的使用方法和有关规定，读者只需要知道有这种变量即可，以便在阅读他人写的程序时遇到 register时不会感到困惑。
注意：种局部变量的存储位置是不同的：自动变量存储在动态存储区；静态局部变量存储在静态存储区；寄存器存储在CPU 中的寄存器中。
全局变量的存储类别
全局变量都是存放在静态存储区中的。因此它们的生存期是固定的，存在于程序的整个运行过程。但是，对全局变量来说，还有一个问题尚待解决，就是它的作用域究竟从什么位置起，到什么位置止。作用域是包括整个文件范围还是文件中的一部分范围 是在一个文件中有效还是在程序的所有文件中都有效 这就需要指定不同的存储类别。
一般来说，外部变量是在函数的外部定义的全局变量，它的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为程序中各个函数所引用。但有时程序设计人员希望能扩展外部变量的作用域。有以下几种情况。
在一个文件内扩展外部变量的作用域
如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从“声明”处起，合法地使用该外部变量。例如：
【例】 调用函数，求个整数中的大者。
C程序设计第五版
解题思路： 用extern声明外部变量，扩展外部变量在程序文件中的作用域。
编写程序：
include stdio h
int main
int max
extern int ABC 把外部变量A，B，C的作用域扩展到从此处开始
printfPlease enter three integer numbers
scanfd d dABC 输入个整数给 ABC
printfmax is dn max
return
int A B C 定义外部变量ABC
int max
int m
mABAB 把A 和B中的大者放在m中
ifCmmC 将A，B，C三者中的大者放在m中
returnm 返回m的值
运行结果：
Please enter three integer numbers
max is
这个例子很简单，主要用来说明使用外部变量的方法。由于定义外部变量A，B，C的位置在函数 main之后，本来在 main函数中是不能引用外部变量A，B，C的。现在，在 main函数的开头用 extern对 A，B，C进行“外部变量声明”，把A，B，C的作用域扩展到该位置。这样在 main函数中就可以合法地使用全局变量A，B，C了，用 scanf函数给外部变量A，B，C输入数据。如果不作 extern声明，编译 main函数时就会出错，系统无从知道 A，B，C是后来定义的外部变量。
由于 A，B，C是外部变量，所以在调用 max函数时用不到参数传递。在 max函数中可直接使用外部变量A，B，C的值。
注意： 提倡将外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个 extern声明。
用 extern声明外部变量时类型名可以写也可以省写。例如 “extern int ABC”也可以写成“extern A，B，C；”。因为它不是定义变量，可以不指定类型，只须写出外部变量名即可。
将外部变量的作用域扩展到其他文件
一个C程序可以由一个或多个源程序文件组成。如果程序只由一个源文件组成，使用外部变量的方法前面已经介绍。如果程序由多个源程序文件组成，那么在一个文件中想引用另一个文件中已定义的外部变量，有什么办法呢
第章 用函数实现模块化程序设计
如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量 Num，不能分别在两个文件中各自定义一个外部变量 Num，否则在进行程序的连接时会出现“重复定义”的错误。正确的做法是： 在任一个文件中定义外部变量 Num，而在另一文件中用 extern对 Num作“外部变量声明”即“extern Num”。在编译和连接时系统会由此知道 Num 有“外部链接”，可以从别处找到已定义的外部变量 Num，并将在另一文件中定义的外部变量 Num 的作用域扩展到本文件，在本文件中可以合法地引用外部变量 Num。
下面举一个简单的例子来说明这种引用。
【例】 给定b的值输入a和m求ab和a的值。
解题思路： 分别编写两个文件模块，其中文件file包含主函数，另一个文件 file包含求a的函数。在 filel 文件中定义外部变量A在 file中用 extern声明外部变量 A把 A的作用域扩展到 file文件。
编写程序：
文件 file c
include stdio h
int A 定义外部变量
int main
int power int 函数声明
int bcdm
printfenter the number a and its power mn
scanfddAm
cAb
printfdddnAbc
d powerm
printfdddnAmd
return
文件file c
extern A 把在 filel文件中已定义的外部变量的作用域扩展到本文件
int power int n
int iy
foriini
yA
returny
运行结果：
enter the number a and its power m
从键盘输入a的值为，m的值为，程序输出：由于计算机无法输出上角，故以“”代表幂次，表示³。这是借用FORTRAN语言表示乘方的
C程序设计第五版
方法。
关于怎样编译和运行包括多个文件的程序，可参考《C程序设计第五版学习辅导》清华大学出版社出版一书的“C语言上机指南”部分。
程序分析： file c文件的开头有一个 extern声明，它声明在本文件中出现的变量A是一个“在其他文件中定义过的外部变量”。本来外部变量A的作用域是 filel c，但现在用 extern声明将其作用域扩大到 file c文件。假如某一程序包括了个源文件模块，在一个文件中定义外部整型变量A，其他个文件都可以引用A，但必须在每一个文件中都加上一个“extern A；”声明。在各文件经过编译后，将各目标文件连接成一个可执行的目标文件。
说明： 用这种方法扩展全局变量的作用域应十分慎重，因为在执行一个文件中的操作时，可能会改变该全局变量的值，会影响到另一文件中全局变量的值，从而影响该文件中函数的执行结果。
有的读者可能会问： extern既可以用来扩展外部变量在本文件中的作用域，又可以使外部变量的作用域从一个文件扩展到程序中的其他文件，那么系统怎么区别处理呢 实际上，在编译时遇到 extern时，先在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；如果找不到，就在连接时从其他文件中找外部变量的定义。如果从其他文件中找到了，就将作用域扩展到本文件；如果再找不到，就按出错处理。
将外部变量的作用域限制在本文件中
有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其他文件引用。这时可以在定义外部变量时加一个 static声明。
例如：
filel c file c
static int A extern A
int main void fun int n
⋮ ⋮
AAn 出错
⋮
在 filel c中定义了一个全局变量A，但它用了 static声明，把变量A的作用域限制在本文件范围内虽然在file中用了“extern A”但仍然不能使用file c中的全局变量A。
这种加上 static声明、只能用于本文件的外部变量称为静态外部变量。在程序设计中，常由若干人分别完成各个模块，各人可以独立地在其设计的文件中使用相同的外部变量名而互不相干。只须在每个文件中定义外部变量时加上 static 即可。这就为程序的模块化、通用性提供方便。如果已确认其他文件不需要引用本文件的外部变量，就可以对本文件中的外部变量都加上 static，成为静态外部变量，以免被其他文件误用。这就相当于把本文件的外部变量对外界“屏蔽”起来，从其他文件的角度看，这个静态外部变量是“看不见，不能用”的。至于在各文件中在函数内定义的局部变量，本来就不能被函数外引用，更不能被其
第章 用函数实现模块化程序设计
他文件引用，因此是安全的。
说明： 不要误认为对外部变量加 static声明后才采取静态存储方式存放在静态存储区中，而不加 static的是采取动态存储存放在动态存储区。声明局部变量的存储类型和声明全局变量的存储类型的含义是不同的。对于局部变量来说，声明存储类型的作用是指定变量存储的区域静态存储区或动态存储区以及由此产生的生存期的问题，而对于全局变量来说，由于都是在编译时分配内存的，都存放在静态存储区，声明存储类型的作用是变量作用域的扩展问题。
用 static声明一个变量的作用是：
对局部变量用 static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在。
对全局变量用 static声明，则该变量的作用域只限于本文件模块即被声明的文件中。
注意 用 auto register 和 static声明变量时是在定义变量的基础上加上这些关键字，而不能单独使用。下面的用法不对：
int a 先定义整型变量a
static a 企图再将变量a声明为静态变量
编译时会被认为“重新定义”。
存储类别小结
从以上可知，对一个数据的定义，需要指定两种属性：数据类型和存储类别，分别使用两个关键字。例如：
static int a 静态局部整型变量或静态外部整型变量
auto char c 自动变量，在函数内定义
register int d 寄存器变量，在函数内定义
此外，可以用 extern声明已定义的外部变量，例如：
extern b 将已定义的外部变量b的作用域扩展至此
下面从不同角度做些归纳：
从作用域角度分，有局部变量和全局变量。它们采用的存储类别如下：
自动变量，即动态局部变量离开函数，值就消失
局部变量
静态局部变量离开函数，值仍保留
寄存器变量离开函数，值就消失
按作用域角度分
形式参数可以定义为自动变量或寄存器变量
全局变量
静态外部变量只限本文件引用
外部变量即非静态的外部变量，允许其他文件引用
从变量存在的时间生存期来区分，有动态存储和静态存储两种类型。静态存储是程序整个运行时间都存在，而动态存储则是在调用函数时临时分配单元。
C程序设计第五版
自动变量本函数内有效
动态存储
寄存器变量本函数内有效
形式参数本函数内有效
按变量的生存期分
静态局部变量函数内有效
静态存储
静态外部变量本文件内有效
外部变量用extern声明后，其他文件可引用
从变量值存放的位置来区分，可分为：
静态局部变量
静态外部变量函数外
内存中静态存储区
部静态变量
外部变量可为其他文
按变量值存
件引用
放的位置分
内存中动态存储区：自动变量和形式参数
CPU 中的寄存器：寄存器变量
关于作用域和生存期的概念。从前面叙述可以知道，对一个变量的属性可以从两个方面分析，一是变量的作用域，一是变量值存在时间的长短，即生存期。前者是从空间的角度，后者是从时间的角度。二者有联系但不是同一回事。图是作用域的示意图，图是生存期的示意图。
文件 filel c
int a
int main
⋮
f
⋮
f
void f
auto int b
a作用域
⋮
f
b作用域
⋮
void f
main
f₂
main
f₁
f₂
f₁
main
a生存期
static int cc作用域
b生存期
c生存期
图
图
如果一个变量在某个文件或函数范围内是有效的，就称该范围为该变量的作用域，在此作用域内可以引用该变量，在专业书中称变量在此作用域内“可见”，这种性质称为变量的可见性。例如图中变量a和b在函数f中“可见”。如果一个变量值在某一时刻是存在
第章 用函数实现模块化程序设计
的，则认为这一时刻属于该变量的生存期，或称该变量在此时刻“存在”。表表示各种类型变量的作用域和存在性的情况。
表各种类型变量的作用域和存在性的情况
变量存储类别 函 数 内 函 数 外 作用域 存在性 作用域 存在性 自动变量和寄存器变量 ✔ ✔ × × 静态局部变量 ✔ ✔ × ✔ 静态外部变量 ✔ ✔ ✔只限本文件 ✔外部变量✔✔✔✔
表 中“✔”表示“是”， “×”表示“否”。可以看到自动变量和寄存器变量在函数内外的“可见性”和“存在性”是一致的，即离开函数后，值不能被引用，值也不存在。静态外部变量和外部变量的可见性和存在性也是一致的，在离开函数后变量值仍存在，且可被引用，而静态局部变量的可见性和存在性不一致，离开函数后，变量值存在，但不能被引用。
static对局部变量和全局变量的作用不同。对局部变量来说，它使变量由动态存储方式改变为静态存储方式。而对全局变量来说，它使变量局部化局部于本文件，但仍为静态存储方式。从作用域角度看，凡有 static声明的，其作用域都是局限的，或者局限于本函数内静态局部变量，或者局限于本文件内静态外部变量。
关于变量的声明和定义
在第章中介绍了如何定义一个变量。在本章中又介绍了如何对一个变量作声明。可能有些读者弄不清楚定义与声明有什么区别，它们是否是一回事。有人认为声明就是定义，有人认为只有赋了值的才是定义。在C语言的学习中，关于定义与声明这两个名词的使用上始终存在着混淆。不仅许多初学者没有搞清楚，连不少介绍C语言的教材也没有给出准确的介绍。
从第章已经知道，一个函数一般由两部分组成： 声明部分和执行语句。声明部分的作用是对有关的标识符如变量、函数、结构体、共用体等的属性进行声明。对于函数而言，声明和定义的区别是明显的，在本章节中已说明，函数的声明是函数的原型，而函数的定义是对函数功能的定义。对被调用函数的声明是放在主调函数的声明部分中的，而函数的定义显然不在声明部分的范围内，它是一个独立的模块。
对变量而言，声明与定义的关系稍微复杂一些。在声明部分出现的变量有两种情况：一种是需要建立存储空间的如“int a；”，另一种是不需要建立存储空间的如“externa”。前者称为定义性声明 defining declaration或简称定义 definition后者称为引用性声明 referencing declaration。广义地说声明包括定义但并非所有的声明都是定义。对“int a；”而言，它既是声明，又是定义；而对“extern a；”而言，它是声明而不是定义。一般为了叙述方便，把建立存储空间的声明称定义，而把不需要建立存储空间的声明称为声明。
C程序设计第五版
显然这里指的声明是狭义的，即非定义性声明。例如：
int main
extern A 是声明，不是定义。声明将已定义的外部变量A的作用域扩展到此
⋮
return
int A 是定义，定义 A 为整型外部变量
外部变量定义和外部变量声明的含义是不同的。外部变量的定义只能有一次，它的位置在所有函数之外。在同一文件中，可以有多次对同一外部变量的声明，它的位置可以在函数之内哪个函数要用就在哪个函数中声明，也可以在函数之外。系统根据外部变量的定义而不是根据外部变量的声明分配存储单元。对外部变量的初始化只能在“定义”时进行，而不能在“声明”中进行。所谓“声明”，其作用是声明该变量是一个已在其他地方已定义的外部变量，仅仅是为了扩展该变量的作用范围而作的“声明”。
注意： 有一个简单的结论，在函数中出现的对变量的声明除了用 extern声明的以外都是定义。在函数中对其他函数的声明不是函数的定义。
内部函数和外部函数
变量有作用域，有局部变量和外部变量之分，那么函数有没有类似的问题呢 答案是有的。有的函数可以被本文件中的其他函数调用，也可以被其他文件中的函数调用，而有的函数只能被本文件中的其他函数调用，不能被其他文件中的函数调用。
函数本质上是全局的，因为定义一个函数的目的就是要被另外的函数调用。如果不加声明的话，一个文件中的函数既可以被本文件中其他函数调用，也可以被其他文件中的函数调用。但是，也可以指定某些函数不能被其他文件调用。根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。
内部函数
如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即：
static 类型名 函数名形参表
例如，函数的首行：
static int fun int a int b
表示 fun是一个内部函数，不能被其他文件调用。
内部函数又称静态函数，因为它是用 static声明的。使用内部函数，可以使函数的作用域只局限于所在文件。这样，在不同的文件中即使有同名的内部函数，也互不干扰，不必担心所用函数是否会与其他文件模块中的函数同名。
通常把只能由本文件使用的函数和外部变量放在文件的开头，前面都冠以 static使之
第章 用函数实现模块化程序设计
局部化，其他文件不能引用。这就提高了程序的可靠性。
外部函数
如果在定义函数时，在函数首部的最左端加关键字 extern，则此函数是外部函数，可供其他文件调用。
如函数首部可以为
extern int fun int a int b
这样，函数 fun就可以为其他文件调用。C语言规定，如果在定义函数时省略 extern，则默认为外部函数。本书前面所用的函数都是外部函数。
在需要调用此函数的其他文件中，需要对此函数作声明不要忘记，即使在本文件中调用一个函数，也要用函数原型进行声明。在对此函数作声明时，要加关键字 extern，表示该函数“是在其他文件中定义的外部函数”。
通过下面的例子，可以具体地了解怎样使用外部函数。
【例】 有一个字符串，内有若干个字符，现输入一个字符，要求程序将字符串中该字符删去。用外部函数实现。
解题思路： 算法是这样的： 用一个字符数组 str存放一个字符串，然后对 str数组中的字符逐个检查，如果不是指定要删除的字符就仍将它存放在数组中，见图设删除空格。
T
h
i
s
i
a
C
p
r
g
r
a
m
T
h
i
s
i
、
a
c
p
r
o
g
a
m
r
a
m
图
从 str开始逐个检查数组元素值是否等于指定要删除的字符，若不是就依次留在数 组中若是就不保留。从图中可以看到应将 str赋给 str str⇒str str⇒str str⇒str str是要删除的字符，不应存放在 str数组中，然后 str⇒ str……
可分别定义个函数用来输入字符串、删除字符、输出字符串。按题目要求把以上个函数分别放在个文件中。 main函数在另一文件中， main函数调用以上个函数，实现题目的要求。
编写程序：
file c文件
include stdio h
int main
extern void enter string char str□ 对函数的声明
extern void delete string char str□ char ch 对函数的声明
extern void print string char str 对函数的声明
以上行声明了在本函数中将要调用的已在其他文件中定义的个函数
char c str
C程序设计第五版
enter string str 调用在其他文件中定义的 enter string函数
scanfcc 输入要求删去的字符
delete string strc 调用在其他文件中定义的 delete string函数
print string str 调用在其他文件中定义的 print string函数
return
file c文件
void enter string char str 定义外部函数 enter string
gets str 向字符数组输入字符串
file c文件
void delete string char str char ch 定义外部函数 delete string
int ij
forij strii
if stri ch
strj stri
strj
file c文件
void print string char str 定义外部函数 print string
printfsn str
运行结果：
This is a C program
ThisisaCprogram
输入字符串This is a C program给字符数组 str再输入要删去的字符空格字符程序输出已删去空格的字符串ThisisaCprogram。
程序分析：整个程序由个文件组成。每个文件包含一个函数。主函数是主控函数，在主函数中除了声明部分外，只由个函数调用语句组成。其中 scanf是库函数，另外个是用户自己定义的函数。函数 dedele string的作用是根据给定的字符串和要删除的字符 ch，对字符串作删除处理。
程序中个函数都是外部函数。在 main函数中用 extern声明在 main函数中用到的 enter string delete string 和 print string 是在其他文件中定义的外部函数。
读者注意分析如何控制循环变量i和j的变化，以便使被删除的字符，不保留在原数组中。
这个题目当然可以设两个数组，把不删除的字符一一赋给新数组。但我们只用一个数组，只把不被删除的字符保留下来。由于i总是大于或等于j，因此最后保留下来的字符不
第章 用函数实现模块化程序设计
会覆盖未被检测处理的字符。注意：最后要将结束符也复制到被保留的字符后面。
通过这个简单的例子可知：使用 extern声明就能够在本文件中调用在其他文件中定义的函数，或者说把该函数的作用域扩展到本文件。 extern声明的形式就是在函数原型基础上加关键字 extern见本例 main函数中的个函数声明形式。
由于函数在本质上是外部的，在程序中经常要调用其他文件中的外部函数，为方便编程，C语言允许在声明函数时省写 extern。例程序中 main函数中对 power函数的声明就没有用 extern但作用相同。一般都省写 extern例如例程序中 main 函数中的第一个函数声明可写成
void enter string char str□
这就是多次用过的函数原型。
说明： 由此可以进一步理解函数原型的作用。用函数原型能够把函数的作用域扩展到定义该函数的文件之外不必使用 extern。只要在使用该函数的每一个文件中包含该函数的函数原型即可。函数原型通知编译系统：该函数在本文件中稍后定义，或在另一文件中定义。
利用函数原型扩展函数作用域最常见的例子是 include 指令的应用。在前面几章中曾多次使用过 include 指令，并提到过： 在 include 指令所指定的“头文件”中包含调用库函数时所需的信息。例如，在程序中需要调用 sin函数，但三角函数并不是由用户在本文件中定义的，而是存放在数学函数库中的。按以上的介绍，必须在本文件中写出 sin函数的原型，否则无法调用 sin函数。sin函数的原型是
double sin double x
显然，要求程序设计者在调用库函数时先从手册中查出所用的库函数的原型，并在程序中一一写出来是十分麻烦而困难的。为减少程序设计者的困难，在头文件 math h中包括了所有数学函数的原型和其他有关信息，用户只须用以下 include指令：
include math h
在该文件中就能合法地调用系统提供的各种数学库函数了。
说明： 在本章中接触到一些重要的概念和方法，这些对于一个程序工作者来说，是必须了解和掌握的。尤其在完成一定规模和深度的程序设计任务时，会用到本章介绍的知识和方法。由于篇幅的关系，本章只介绍了最基本的内容。希望读者能认真消化这些内容，尽量多做一些习题，多上机实践，为以后的深入学习和编程打下良好的基础。
习 题
写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果。两个整数由键盘输入。
求方程的根，用个函数分别求当：大于、等于和小于时的根并输出结果。从主函数输入a，b，c的值。
写一个判素数的函数，在主函数输入一个整数，输出是否为素数的信息。
C程序设计第五版
写一个函数，使给定的一个×的二维整型数组转置，即行列互换。
写一个函数，使输入的一个字符串按反序存放，在主函数中输入和输出字符串。
写一个函数，将两个字符串连接。
写一个函数，将一个字符串中的元音字母复制到另一字符串，然后输出。
写一个函数，输入一个位数字，要求输出这个数字字符，但每两个数字间空一个空格。如输入应输出“ ”。
编写一个函数，由实参传来一个字符串，统计此字符串中字母、数字、空格和其他字符的个数，在主函数中输入字符串以及输出上述的结果。
写一个函数，输入一行字符，将此字符串中最长的单词输出。
写一个函数，用“起泡法”对输入的个字符按由小到大顺序排列。
用牛顿迭代法求根。方程为 系数abcd的值依次为，，由主函数输入。求x在附近的一个实根。求出根后由主函数输出。
用递归方法求n阶勒让德多项式的值，递归公式为
输入 个学生 门课的成绩，分别用函数实现下列功能：
①计算每个学生的平均分；
②计算每门课的平均分；
③找出所有个分数中最高的分数所对应的学生和课程；
④计算平均分方差：
其中，x₁为某一学生的平均分。
写几个函数：
①输入个职工的姓名和职工号；
②按职工号由小到大顺序排序，姓名顺序也随之调整；
③要求输入一个职工号，用折半查找法找出该职工的姓名，从主函数输入要查找的职工号，输出该职工姓名。
写一个函数，输入一个十六进制数，输出相应的十进制数。
用递归法将一个整数n转换成字符串。例如，输入，应输出字符串n的位数不确定，可以是任意位数的整数。
给出年、月、日，计算该日是该年的第几天。
第章 善于利用指针
指针是C语言中的一个重要概念，也是C语言的一个重要特色。正确而灵活地运用它，可以使程序简洁、紧凑、高效。每一个学习和使用C语言的人，都应当深入地学习和掌握指针。可以说，不掌握指针就是没有掌握C的精华。
指针的概念比较复杂，使用也比较灵活，因此初学时常会出错，务请在学习本章内容时十分小心，多思考、多比较、多上机，在实践中掌握它。本书在叙述时也力图用通俗易懂的方法使读者易于理解。
指针是什么
为了说清楚什么是指针，必须先弄清楚数据在内存中是如何存储的，又是如何读取的。
如果在程序中定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据程序中定义的变量类型，分配一定长度的空间。例如， VisualC为整型变量分配个字节，为单精度浮点型变量分配个字节，为字符型变量分配个字节。内存区的每一个字节有一个编号，这就是“地址”，它相当于旅馆中的房间号。在地址所标志的内存单元中存放的数据则相当于旅馆房间中居住的旅客。
由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。打个比方，一个房间的门口挂了一个房间号，这个就是房间的地址，或者说，“指向”该房间。因此，将地址形象化地称为“指针”。意思是通过它能找到以它为地址的内存单元。
说明： 对计算机存储单元的访问比旅馆要复杂一些，在C语言中，数据是分类型的，对不同类型的数据，在内存中分配的存储单元大小字节数和存储方式是不同的如整数以补码形式存放，实数以指数形式存放。如果只是指定了地址，希望从该单元中调出数据，这是做不到的，虽然能找到所指定的存储单元，但是，无法确定是从个字节中取信息字符数据，还是从个字节取信息短整型，抑或是从个字节取信息整型。也没有说明按何种存储方式存取数据整数和单精度实数都是个字节，但存储方式是不同的。因此，为了有效地存取一个数据，除了需要位置信息外，还需要有该数据的类型信息如果没有该数据的类型信息，只有位置信息是无法对该数据进行存取的。C语言中的地址包括位置信息内存编号，或称纯地址和它所指向的数据的类型信息，或者说它是“带类型的地址”。如a，一般称它为“变量a的地址”，确切地说，它是“整型变量a的地址”。后面提到的“地址”，都是这个意思。
请思考： 若有 int 型变量a和 float 型变量b，如果先后把它们分配在开始的存储单元中，a和b的信息完全相同吗 答案是不相同的，虽然存储单元的编号相同，但它们的数据类型不同。
C程序设计第五版
请务必弄清楚存储单元的地址和存储单元的内容这两个概念的区别，假设程序已定义了个整型变量i，j，k，在程序编译时，系统可能分配地址为的个字节给变量i的个字节给j的个字节给k不同的编译系统在不同次的编译中，分配给变量的存储单元的地址是不相同的见图。在程序中一般是通过变量名来引用变量的值，例如：
printfdni
由于在编译时，系统已为变量i分配了按整型存储方式的个字节，并建立了变量名和地址的对应表，因此在执行上面语句时，首先通过变量名找到相应的地址，从该个字节中按照整型数据的存储方式读出整型变量i的值，然后按十进制整数格式输出。
注意：对变量的访问都是通过地址进行的。
假如有输入语句
scanfdi
在执行时，把键盘输入的值送到地址为开始的整型存储单元中。如果有语句
kij
则从字节取出i的值再从字节取出j的值将它们相加后再将其和送到k所占用的字节单元中。
这种直接按变量名进行的访问，称为“直接访问”方式。
还可以采用另一种称为“间接访问”的方式，即将变量i的地址存放在另一变量中，然后通过该变量来找到变量i的地址，从而访问i变量。
在C语言程序中，可以定义整型变量、浮点型实型变量、字符变量等，也可以定义一种特殊的变量，用它存放地址。假设定义了一个变量i pointer变量名可任意取，用来存放整型变量的地址。可以通过下面语句将i的地址存放到i pointer中。
i pointeri 将i的地址存放到 i pointer中
这时，i pointer的值就是即变量i所占用单元的起始地址。
要存取变量i的值，既可以用直接访问的方式，也可以采用间接访问的方式：先找到存放“变量i的地址”的变量i pointer，从中取出i的地址，然后到字节开始的存储单元中取出i的值，见图。
打个比方，为了开一个A抽屉，有两种办法，一种是将A 钥匙带在身上，需要时直接找出该钥匙打开抽屉，取出所需的东西。另一种办法是：为安全起见，将该A钥匙放到另一抽屉B中锁起来。如果需要打开A抽屉，就需要先找出B钥匙，打开B抽屉，取出A钥匙，再打开 A 抽屉，取出 A 抽屉中之物，这就是“间接访问”。
图a表示直接访问，根据变量名直接向变量i赋值，由于变量名与变量的地址有一一对应的关系，因此就按此地址直接对变量i的存储单元进行访问如把数值存放到变量i的存储单元中。
图b表示间接访问，先找到存放变量i地址的变量 i pointer，从其中得到变量i的地址，从而找到变量i的存储单元，然后对它进行存取访问。
第章 善于利用指针
内存用户数据区
⋮
变量i
i
赋值
变量j
变量k
⋮
a
i pointer
i pointer
变量i pointer
赋值
指向
b
图
图
为了表示将数值送到变量中，可以有两种表达方法：
将直接送到变量i所标识的单元中，例如“i；”。
将送到变量i pointer所指向的单元即变量i的存储单元例如“i pointer”其中i pointer表示i pointer指向的对象。
指向就是通过地址来体现的。假设i pointer中的值是变量i的地址，这样就在i pointer和变量i之间建立起一种联系，即通过i pointer能知道i的地址，从而找到变量i的内存单元。图中以单箭头表示这种“指向”关系。
由于通过地址能找到所需的变量单元，因此说，地址指向该变量单元如同说，一个房间号“指向”某一房间一样。将地址形象化地称为“指针”。意思是通过它能找到以它为地址的内存单元如同根据地址就能找到变量i的存储单元一样。
如果有一个变量专门用来存放另一变量的地址即指针，则它称为“指针变量”。上述的i pointer就是一个指针变量。指针变量就是地址变量，用来存放地址，指针变量的值是地址即指针。
注意： 区分“指针”和“指针变量”这两个概念。例如，可以说变量i的指针是 ，而不能说i的指针变量是。指针是一个地址，而指针变量是存放地址的变量。
指 针 变 量
从上节已知：存放地址的变量是指针变量，它用来指向另一个对象如变量、数组、函数等。那么，怎样定义和使用指针变量呢
使用指针变量的例子
先分析一个例子。
【例】 通过指针变量访问整型变量。
解题思路： 先定义个整型变量，再定义个指针变量，分别指向这两个整型变量，通过访问指针变量，可以找到它们所指向的变量，从而得到这些变量的值。
C程序设计第五版
编写程序：
include stdio h
int main
int ab 定义整型变量a，b，并初始化
int pointer pointer 定义指向整型数据的指针变量 pointer pointer
pointer a 把变量a的地址赋给指针变量 pointer
pointer b 把变量 b的地址赋给指针变量 pointer
printfadbdnab 输出变量a和b的值
printf pointer d pointer dn pointer pointer
输出变量a和b的值
return
运行结果：
ab
pointer pointer
程序分析：
在开头处定义了两个指针变量 pointer 和 pointer 。但此时它们并未指向任何一个变量，只是提供两个指针变量，规定它们可以指向整型变量，至于指向哪一个整型变量，要在程序语句中指定。程序第 两行的作用就是使 pointer 指向a pointer 指向b此时 pointer 的值为a即a的地址 pointer 的值为b见图。
a
pointer
pointer
b
第行输出变量a和b的值和。第行输出 pointer 和 pointer 的值。其中的“”表示“指向”。 pointer 表示“指针变量 pointer 所指向的变量”也就是变量a。 pointer 表示“指针变量 pointer 所指向的变量”，也就是变量b。从运行结果看到，它们的
b
pointer
图
值也是 和。
程序中有两处出现 pointer 和 pointer 二者的含义不同。程序第行的 pointer 和 pointer 表示定义两个指针变量 pointer 和 pointer 。它们前面的“”只是表示该变量是指针变量。程序最后一行 printf函数中的 pointer 和 pointer 则代表指针变量 pointer 和 pointer 所指向的变量。
注意：定义指针变量时，左侧应有类型名，否则就不是定义指针变量。例如：
pointer 企图定义 pointer 为指针变量。出错
int pointer 正确，必须指定指针变量的基类型
怎样定义指针变量
在例中已看到怎样定义指针变量，定义指针变量的一般形式为
类型名 指针变量名；
如：
第章 善于利用指针
int pointer pointer
左端的 int是在定义指针变量时必须指定的“基类型”。指针变量的基类型用来指定此指针变量可以指向的变量的类型。例如，上面定义的、基类型为 int 的指针变量 pointer 和 pointer ，可以用来指向整型的变量i和j，但不能指向浮点型变量a和b。
说明： 前面介绍过基本的数据类型如 int， char， float等，既然有这些类型的变量，就可以有指向这些类型变量的指针，因此，指针变量是基本数据类型派生出来的类型，它不能离开基本类型而独立存在。
下面都是合法的定义：
float pointer pointer 是指向 float型变量的指针变量简称 float 指针
char pointer pointer 是指向字符型变量的指针变量简称 char指针
可以在定义指针变量时，同时对它初始化，如：
int pointer a pointer b 定义指针变量 pointer pointer 并分别指向 ab
说明： 在定义指针变量时要注意：
指针变量前面的“”表示该变量为指针型变量。指针变量名是 pointer 和 pointer 而不是 pointer 和 pointer 。这是与定义整型或实型变量的形式不同的。上面程序第行不应写成“ pointer a”和“ pointer b”。因为 a 的地址是赋给指针变量 pointer 而不是赋给 pointer 即变量a。
在定义指针变量时必须指定基类型。有的读者认为既然指针变量是存放地址的，那么只须指定其为“指针型变量”即可，为什么还要指定基类型呢 要知道不同类型的数据在内存中所占的字节数和存放方式是不同的。
指向一个整型变量和指向一个实型变量，其物理上的含义是不同的。
从另一角度分析，指针变量是用来存放地址的，前已介绍，C的地址信息包括存储单元的位置内存编号和类型信息。指针变量的属性应与之匹配。例如：
int ap
pa
a不仅包含变量a的位置如编号为的存储单元，还包括“存储的数据是整型”的信息。现在定义指针变量p的基类型为 int，即它所指向的只能是整型数据。这时p能接受a的信息。如果改为
float p
pa
a是“整型变量a的地址”。在用 Vicual C 编译时就会出现一个警告 warning：“把一个 int型数据转换为 float数据”。在赋值时，系统会把a的基类型自动改换为 float型，然后赋给p。但是p不能用这个地址指向整型变量。
从以上可以知道指针或地址是包含有类型信息的。应该使赋值号两侧的类型一致，以避免出现意外结果。
在本章的稍后将要介绍指针的移动和指针的运算加、减，例如“使指针移动个位置”
C程序设计第五版
或“使指针值加”，这个代表什么呢 如果指针是指向一个整型变量的，那么“使指针移动个位置”意味着移动个字节， “使指针加”意味着使地址值加个字节。如果指针是指向一个字符变量的，则增加的不是而是。因此必须指定指针变量所指向的变量的类型，即基类型。一个指针变量只能指向同一个类型的变量，不能忽而指向一个整型变量，忽而指向一个实型变量。在前面定义的 pointer 和 pointer 只能指向整型数据。
一个变量的指针的含义包括两个方面，一是以存储单元编号表示的纯地址如编号为的字节一是它指向的存储单元的数据类型如 int char float等。
在说明变量类型时不能一般地说“a是一个指针变量”，而应完整地说：“a是指向整型数据的指针变量，b是指向单精度型数据的指针变量，c是指向字符型数据的指针变量”。
如何表示指针类型。指向整型数据的指针类型表示为“int”，读作“指向 int的指针”或简称“int指针”。可以有 int char float等指针类型如上面定义的指针变量 pointer 的类型是“float” pointer 的类型是“char”。 int float char是种不同的类型，不能混淆。
指针变量中只能存放地址指针，不要将一个整数赋给一个指针变量。如：
pointer pointer 是指针变量是整数不合法
原意是想将地址赋给指针变量 pointer ，但是系统无法辨别它是地址，从形式上看 是整常数，而整常数只能赋给整型变量，而不能赋给指针变量，判为非法。在程序中是不能用一个数值代表地址的，地址只能用地址符“”得到并赋给一个指针变量，如‘“pa”。
怎样引用指针变量
在引用指针变量时，可能有种情况：
给指针变量赋值。如：
pa 把a的地址赋给指针变量p
指针变量 p的值是变量a的地址，p指向 a。
引用指针变量指向的变量。
如果已执行“pa” 即指针变量p指向了整型变量a，则
printfdp
其作用是以整数形式输出指针变量p所指向的变量的值，即变量a的值。
如果有以下赋值语句：
p
表示将整数赋给 p当前所指向的变量，如果 p指向变量a，则相当于把 赋给 a，即“a”。
引用指针变量的值。如：
printfop
作用是以八进制数形式输出指针变量p的值，如果p指向了a，就是输出了a的地址，即a。
注意：要熟练掌握两个有关的运算符。
第章 善于利用指针
取地址运算符。a是变量a的地址。
指针运算符或称“间接访问”运算符，p代表指针变量p指向的对象。
下面是一个指针变量应用的例子。
【例】 输入a和b两个整数，按先大后小的顺序输出a和b。
解题思路：用指针方法来处理这个问题。不交换整型变量的值，而是交换两个指针变量的值。
编写程序：
include stdio h
int main
int pppab plp的类型是 int类型
printfplease enter two integer numbers
scanfddab 输入两个整数
pa 使 pl指向变量a
pb 使 p 指向变量b
ifab 如果ab
pppppp 使 pl与 p的值互换
输出ab
printfmaxd mindnpp 输出 pl 和p所指向的变量的值
return
运行结果：
please enter two integer numbers
ab
max min
程序分析 输入ab由于ab将 pl和p交换。交换前的情况见图a交换后的情况见图 b。
注意：a和b的值并未交换，它们仍保持原值，但pl和p的值改变了。 pl的值原为a，后来变成b，p原值为b，后来变成a。这样在输出p和p时，实际上是输出变量b和a的值，所以先输出，然后输出。
p
a
p
a
a
b
p
p
p
b
p
b
b
a
a
b
图
程序第行采用的是以前介绍过的方法： 两个变量的值交换要利用第个变量。实际上，第行可以改为
C程序设计第五版
pbpa
即直接对 p和p 赋以新值，这样可以不必定义中间变量p，使程序更加简练。
这个问题的算法是不交换整型变量的值，而是交换两个指针变量的值即a 和b的地址。
指针变量作为函数参数
函数的参数不仅可以是整型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。
下面通过一个例子来说明。
【例】 题目要求同例，即对输入的两个整数按大小顺序输出。现用函数处理，而且用指针类型的数据作函数参数。
解题思路： 例直接在主函数内交换指针变量的值，本题是定义一个函数 swap，将指向两个整型变量的指针变量内放两个变量的地址作为实参传递给 swap函数的形参指针变量，在函数中通过指针实现交换两个变量的值。
编写程序：
include stdio h
int main
void swap int p int p 对 swap函数的声明
int ab
int pointer pointer 定义两个 int型的指针变量
printfplease enter a and b
scanfddab 输入两个整数
pointer a 使 pointer 指向 a
pointer b 使 pointer 指向 b
ifab swap pointer pointer 如果 ab调用 swap函数
printfmaxd mindnab 输出结果
return
void swap int pl int p 定义 swap函数
int temp
tempp 使p和p互换
pp
p temp
运行结果：
please enter a and b
max min
程序分析： swap是用户自定义函数，它的作用是交换两个变量a和b的值。 swap函数的两个形参 pl和p是指针变量。程序运行时，先执行 main函数，输入a和b的值现
第章 善于利用指针
输入 和。然后将a 和b的地址分别赋给 int变量 pointer 和 pointer 使 pointer 指向a pointer 指向b见图a。接着执行 if语句由于ab因此执行 swap函数。注意实参 pointer 和 pointer 是指针变量，在函数调用时，将实参变量的值传送给形参变量，采取的依然是“值传递”方式。因此虚实结合后形参p的值为a，p的值为b，见图b。这时 pl和 pointer 都指向变量ap 和 pointer 都指向b。接着执行 swap函数的函数体，使 pl 和p的值互换，也就是使a和b的值互换。互换后的情况见图c。函数调用结束后，形参p和p不复存在已释放，情况如图d所示。最后在 main函数中输出的a和b的值已是经过交换的值a，b。
p
p
a
a
a
a
pointer
a
pointer
pointer
pointer
a
a
a
a
a
pointer
b
p
p
pointer
b
b
b
b
b
b
b
pointer
pointer
b
b
a
b
c
d
图
请注意交换p和p的值是如何实现的。如果写成以下这样就有问题了：
void swap int p int p
int temp
tempp 此语句有问题
pp
p temp
p就是a，是整型变量。而 temp是指针变量 temp所指向的变量。但由于未给 temp赋值，因此 temp中并无确定的值它的值是不可预见的，所以 temp所指向的单元也是不可预见的。所以，对 temp赋值就是向一个未知的存储单元赋值，而这个未知的存储单元中可能存储着一个有用的数据，这样就有可能破坏系统的正常工作状况。应该将 pl的值赋给与p相同类型的变量，在本例中用整型变量 temp作为临时辅助变量实现 pl和p 的交换。
注意：本例采取的方法是交换a和b的值，而pl和p的值不变。这恰和例相反。
可以看到，在执行 swap函数后，变量a和b的值改变了。请仔细分析，这个改变是怎么
C程序设计第五版
实现的。这个改变不是通过将形参值传回实参来实现的。请读者考虑一下能否通过下面的函数实现a和b互换。
void swap int x int y
int temp
tempx
xy
y temp
如果在 main函数中调用 swap函数
swapab
会有什么结果呢 如图所示。在函数调用时，a的值传送给 x，b的值传送给 y，见图a。执行完 swap函数后x和 y的值是互换了，但并未影响到a 和b的值。在函数结束时，变量x和 y释放了， main函数中的a 和b并未互换，见图b。也就是说，由于“单向传送”的“值传递”方式，形参值的改变不能使实参的值随之改变。
为了使在函数中改变了的变量值能被主调函数 main所用，不能采取上述把要改变值的变量作为参数的办法，而应该用指针变量作为函数参数，在函数执行过程中使指针变量所指向的变量值发生变化，函数调用结束后，这些变量值的变化依然保留下来，这样就实现了“通过调用函数使变量的值发生变化，在主调函数如main 函数中可以使用这些改变了的值”的目的。
如果想通过函数调用得到 n个要改变的值，可以这样做：
①在主调函数中设n个变量，用n个指针变量指向它们；
②设计一个函数，有n个指针形参。在这个函数中改变这 n个形参的值；
③在主调函数中调用这个函数，在调用时将这 n个指针变量作实参，将它们的值，也就是相关变量的地址传给该函数的形参；
④在执行该函数的过程中，通过形参指针变量，改变它们所指向的 n个变量的值；
⑤主调函数中就可以使用这些改变了值的变量。
请读者按此思路仔细理解例程序。
注意： 不能企图通过改变指针形参的值而使指针实参的值改变。请看下面的程序。
【例】 对输入的两个整数按大小顺序输出。
解题思路： 尝试调用 swap函数来实现题目要求。在函数中改变形参指针变量的值，希望能由此改变实参指针变量的值。
编写程序：
include stdio h
int main
第章 善于利用指针
void swap int p int p
int ab
int pointer pointer pointer pointer 是 int型变量
printfplease enter two integer numbers
scanfddab
pointer a
pointer b
ifab swap pointer pointer 调用 swap函数，用指针变量作实参
printfmaxd mindn pointer pointer
return
void swap int p int p 形参是指针变量
int p
p pl 下面行交换 pl 和 p的指向
pp
pp
运行结果：
please enter two integer numbers
max min
程序分析： 从运行结果看，显然与原意不符。程序编写者的意图是： 交换指针变量 pointer 和 pointer 的值使 pointer 指向值大的变量。其设想是
①先使 pointer 指向 a pointer 指向 b见图a。
②调用 swap函数将 pointer 的值传给 pl pointer 的值传给p见图b。
③在 swap函数中使 p与p 的值交换见图c。
④形参 pl与p将它们的值是地址传回实参 pointer 和 pointer 使 pointer 指向b pointer 指向a见图d。然后输出 pointer 和 pointer 想得到输出“max min”。
pointer
a
p
a
p
a
pointer
a
a
a
b
b
pointer
b
p
b
p
b
pointer
b
b
b
a
a
a
b
c
d
图
但是，这是办不到的，在输入“，”之后程序实际输出为“max， min”。问题出在第④步。C语言中实参变量和形参变量之间的数据传递是单向的“值传递”方式。用指针变量作函数参数时同样要遵循这一规则。不可能通过执行调用函数来改变实参指针变量的
C程序设计第五版
值，但是可以改变实参指针变量所指变量的值。
注意： 函数的调用可以而且只可以得到一个返回值即函数值，而使用指针变量作参数，可以得到多个变化了的值。如果不用指针变量是难以做到这一点的。要善于利用指针法。
【例】 输入个整数a，b，c，要求按由大到小的顺序将它们输出。用函数实现。
解题思路：采用例的方法在函数中改变这个变量的值。用swap函数交换两个变量的值，用 exchange函数改变这个变量的值。
编写程序：
include stdio h
int main
void exchange int q int q int q 函数声明
int abcppp
printfplease enter three numbers
scanfdddabc
papbpc
exchangeppp
printfThe order isdddnabc
return
void exchange int q int q int q 定义将个变量的值交换的函数
void swap int ptl int pt 函数声明
ifqq swapqq 如果ab交换a和b的值
ifqq swapqq 如果ac交换a和c的值
ifqq swapqq 如果bc交换b和c的值
void swap int ptl int pt 定义交换个变量的值的函数
int temp
temp ptl 交换pt和pt变量的值
ptlpt
pt temp
运行结果：
please enter three numbers
The order is
C 程序分析： exchange函数的作用是对个数按大小排序，在执行 exchange函数过程中，要嵌套调用 swap函数， swap函数的作用是对两个数按大小排序，通过调用 swap函数最多调用次实现个数的排序。
请读者自己画出如图那样的图，仔细分析变量的值变化的过程。
请思考： main函数中的个指针变量的值也就是它们的指向改变了没有。
第章 善于利用指针
通过指针引用数组
数组元素的指针
一个变量有地址，一个数组包含若干元素，每个数组元素都在内存中占用存储单元，它们都有相应的地址。指针变量既然可以指向变量，当然也可以指向数组元素把某一元素的地址放到一个指针变量中。所谓数组元素的指针就是数组元素的地址。
可以用一个指针变量指向一个数组元素。例如：
int a 定义a为包含个整型数据的数组
int p 定义p为指向整型变量的指针变量
pa 把a元素的地址赋给指针变量 p
以上是使指针变量p指向a数组的第号元素，见图。
p
a
a
引用数组元素可以用下标法如a，也可以用指针法，即通过指向数组元素的指针找到所需的元素。使用指针法能使目标程序质量高占内存少，运行速度快。
在C语言中，数组名不包括形参数组名代表数组中首元素即序号为的元素的地址。因此，下面两个语句等价：
pa p的值是a的地址
a
pa p的值是数组a首元素即a的地址
图
注意： 程序中的数组名不代表整个数组，只代表
数组首元素的地址。上述“pa；”的作用是“把a数组的首元素的地址赋给指针变量p”，而不是“把数组a各元素的值赋给p”。
在定义指针变量时可以对它初始化，如：
int pa
它等效于下面两行：
int p
pa 不应写成pa
当然定义时也可以写成
int pa
它的作用是将a数组首元素即a的地址赋给指针变量p而不是赋给p。
在引用数组元素时指针的运算
在引用数组元素时常常会遇到指针的算术运算。有人会提出问题： 对数值型数据进行算术运算加、减、乘、除等的目的和含义是清楚的，而在什么情况下需要用到对指针型数据的算术运算呢 其含义是什么
C程序设计第五版
前已反复说明指针就是地址。对地址进行赋值运算是没有问题的，但是对地址进行算术运算是什么意思呢 显然对地址进行乘和除的运算是没有意义的，实际上也无此必要。那么，能否进行加和减的运算 答案是： 在一定条件下允许对指针进行加和减的运算。
那么，在什么情况下需要而且可以对指针进行加和减的运算呢 回答是：当指针指向数组元素的时候。譬如，指针变量p指向数组元素a，我们希望用p表示指向下一个元素a。如果能实现这样的运算，就会对引用数组元素提供很大的方便。
在指针已指向一个数组元素时，可以对指针进行以下运算：
加一个整数用或如p
减一个整数用或如p
自加运算如pp
自减运算如pp。
两个指针相减，如pp只有p和p都指向同一数组中的元素时才有意义。
分别说明如下：
如果指针变量p已指向数组中的一个元素，则p指向同一数组中的下一个元素，p指向同一数组中的上一个元素。注意：执行p时并不是将p的值地址简单地加，而是加上一个数组元素所占用的字节数。例如，数组元素是 float型，每个元素占个字节，则p意味着使p的值是地址加个字节，以使它指向下一元素。p所代表的地址实际上是p×dd是一个数组元素所占的字节数在 Visual C中对 int型d对 float 和 long型d对 char型d。若p的值是则 p的值不是而是。
有的读者问： 系统怎么知道要把这个转换为，然后与p的值相加呢 不要忘记，在定义指针变量时必须要指定基类型，如：
float p 指针变量p的基类型为 float
现在p指向 float型的数组元素，在执行p时，系统会根据p的基类型为 float 型而将其值加，这样，p就指向 float 型数组的下一个元素。
如果p原来指向a，执行p后p的值改变了，在p的原值基础上加d，这样p就指向数组的下一个元素a。
P
a数组
pa
a
a
如果p的初值为a则pi和ai就是数组元素ai的地址，或者说，它们指向a数组序号为i的元素，见图。这里需要注意的是a代表数组首元素的地址，a也是地址，它的计算方法同p，即它的实际地址为a×d。例如，p和a的值是a它指向a如图所示。
a
ai
pi或ai是pi或ai所指向的数组元素即ai。例如p或a就是a。即 p，a和a三者等价。实际上，在编译时，对数组元素ai就是按ai处理的，即按数组首元素的地址加上相对位移量得到要找的元素的地址，然后找出该单元中的内容。若数
pa
a
图
第章 善于利用指针
组a的首元素的地址为设数组为 float 型则a的地址是这样计算的×然后从地址所指向的 float 型单元取出元素的值即a的值。
说明：□实际上是变址运算符，即将ai按ai计算地址，然后找出此地址单元中的值。
如果指针变量p和p 都指向同一数组中的元素，如执行 pp，结果是pp的值两个地址之差除以数组元素的长度。假设，p指向实型数组元素a，p的值为p指向a其值为则 pp的结果是。这个结果是有意义的，表示p所指的元素与 p所指的元素之间差个元素。这样，人们就不需要具体地知道p和p 的值，然后去计算它们的相对位置，而是直接用pp就可知道它们所指元素的相对距离。
注意： 两个地址不能相加，如 pp 是无实际意义的。
通过指针引用数组元素
根据以上叙述，引用一个数组元素，可以用下面两种方法：
下标法如ai形式
指针法，如ai或pi。其中a是数组名，p是指向数组元素的指针变量，其初值 pa。
【例】 有一个整型数组a，有个元素，要求输出数组中的全部元素。
解题思路： 引用数组中各元素的值有种方法：下标法，如a；通过数组名计算数组元素地址，找出元素的值；用指针变量指向数组元素。分别写出程序并比较分析。
编写程序：
下标法。
include stdio h
int main
int a
int i
printfplease enter integer numbers
foriii
scanfdai
foriii
printfdai 数组元素用数组名和下标表示
printfn
return
运行结果：
please enter integer numbers
通过数组名计算数组元素地址，找出元素的值。
include stdio h
C程序设计第五版
int main
int a
int i
printfplease enter integer numbers
foriii
scanfdai
foriii
printfdai 通过数组名和元素序号计算元素地址，再找到该元素
printfn
return
运行结果： 与相同。
程序分析：第行中ai是a数组中序号为i的元素的地址，ai是该元素的值。第行中用ai表示ai元素的地址，也可以改用ai表示，即：
scanfdai
读者可以上机试一下。
用指针变量指向数组元素。
include stdio h
int main
int a
int pi
printfplease enter integer numbers
foriii
scanfdai
forpapap
printfdp 用指针指向当前的数组元素
printfn
return
运行结果： 与相同。
程序分析： 第行先使指针变量 p指向a数组的首元素序号为的元素，即a，接着在第行输出p，p就是p当前指向的元素即a的值。然后执行p，使p指向下一个元素a，再输出p，此时p是a的值，依此类推，直到pa，此时停止执行循环体。
第，行可以改为
forpapap
scanfdp
用指针变量表示当前元素的地址。
种方法的比较：
· 例的第和第种方法执行效率是相同的。C编译系统是将ai转换为
第章 善于利用指针
ai处理的，即先计算元素地址。因此用第和第种方法找数组元素费时较多。
·第种方法比第、第种方法快，用指针变量直接指向元素，不必每次都重新计算地址，像p这样的自加操作是比较快的。这种有规律地改变地址值p能大大提高执行效率。
·用下标法比较直观，能直接知道是第几个元素。例如，a是数组中序号为的元素注意序号从算起。用地址法或指针变量的方法不直观，难以很快地判断出当前处理的是哪一个元素。例如，例第种方法所用的程序，要仔细分析指针变量p的当前指向，才能判断当前输出的是第几个元素。有经验的专业人员往往喜欢用第种形式，用p进行控制，程序简洁、高效。初学者在开始时可用第种形式，直观、不易出错。
注意： 在使用指针变量指向数组元素时，有以下几个问题要注意：
可以通过改变指针变量的值指向不同的元素。例如，上述第种方法是用指针变量p来指向元素，用p使p的值不断改变从而指向不同的元素。
如果不用p变化的方法而用数组名a变化的方法例如，用a行不行呢 假如将上述第种方法中的程序的第、两行改为
forpaapa
printfda
是不行的。因为数组名a代表数组首元素的地址，它是一个指针型常量，它的值在程序运行期间是固定不变的。既然a是常量，所以a是无法实现的。
要注意指针变量的当前值。请看下面的例子。
【例】 通过指针变量输出整型数组a的个元素。
解题思路：用指针变量p指向数组元素，通过改变指针变量的值，使p先后指向aa各元素。
编写程序：
include stdio h
int main
int pia
pa p指向a
printfplease enter integer numbers
foriii
scanfdp 输入个整数给aa
foriiip
printfdp 想输出aa
printfn
return
运行结果：
please enter numbers
C程序设计第五版
在不同的环境中运行时显示的数据可能与上面的有所不同。
程序分析：显然输出的数值并不是a数组中各元素的值。需要检查和分析程序。
① P
a数组
a
有的人觉得上面的程序没有什么问题，即使已被告知此程序有问题，还是找不出问题出在哪里。问题出在指针变量 p的指向。请仔细分析p的值的变化过程。指针变量p的初始值为a数组首元素即a的地址，见图中的①，经过第个 for循环读入数据后，p已指向a数组的末尾见图中②。因此，在执行第个 for循环时p的起始值不是a了而是a。由于执行第个 for循环时，每次要执行p，因此p指向的是a数组下面的个存储单元图中以虚线表示，而这些存储单元中的值是不可预料的。
② P
a
解决这个问题的办法是，只要在第个 for循环之前加一个赋值语句：
pa
使p的初始值重新等于a，这样结果就对了。程序为
include stdio h
int main
图
int iapa p的初值是ap指向a
printfplease enter integer numbers
foriii
scanfdp
pa 重新使 p指向a
foriiip
printfdp
printfn
return
运行结果：
please enter integer numbers
显然结果正确。
从例可以看到，虽然定义数组时指定它包含个元素，并用指针变量 p指向某一数组元素，但是实际上指针变量 p可以指向数组以后的存储单元。如果在程序中引用数组元素a，虽然并不存在这个元素最后一个元素是a，但C编译程序并不认为它非法。系统把它按a处理，即先找出a的值是一个地址，然后找出它指向的单元a的内容。这样做虽然在编译时不出错，但运行结果不是预期的，应避免出现这样的情况。这是程序逻辑上的错误，这种错误比较隐蔽，初学者往往难以发现。在使用指针变量指向数组元素时，应切实保证指向数组中有效的元素。
指向数组元素的指针变量也可以带下标，如pi。有些读者可能想不通，因为只有
第章 善于利用指针
数组才能带下标，表示数组某一元素。带下标的指针变量是什么含义呢 当指针变量指向数组元素时，指针变量可以带下标。因为在程序编译时，对下标的处理方法是转换为地址的对pi处理成pi如果p是指向一个整型数组元素a则pi代表ai。但是必须弄清楚p的当前值是什么 如果当前p指向a，则p并不代表a，而是，即a。建议少用这种容易出错的用法。
利用指针引用数组元素，比较方便灵活，有不少技巧。在专业人员中常喜欢用一些技巧，以使程序简洁。读者在看别人写的程序时可能会遇到一些容易使人混淆的情况，要仔细分析。请分析下面几种情况设p开始时指向数组a的首元素即pa：
①分析：
p
p
p使p指向下一元素a。然后若再执行p，则得到下一个元素 a的值。
②p
由于和同优先级，结合方向为自右而左，因此它等价于 先引用p的值，实现p的运算，然后再使p自增。
例 的第个程序中最后一个 for语句
foriiip
printfdp
可以改写为
foriii
printfdp
作用完全一样。它们的作用都是先输出p的值，然后使 p值加。这样下一次循环时，p就是下一个元素的值。
③p与p作用是否相同 不相同。前者是先取p值然后使p加。后者是先使p加再取p。若p初值为a即a若输出p得到a的值而输出p得到a的值。
④p。表示p所指向的元素值加如果pa则p相当于a若a的值为则在执行p即a后a的值为。注意是元素a的值加，而不是指针p的值加。
⑤ 如果 p当前指向a数组中第i个元素 ai，则：
p相当于ai先对p进行“”运算求p所指向的元素的值再使p自减。
p相当于ai先使p自加再进行“”运算。
p相当于ai先使p自减再进行“”运算。
将和运算符用于指针变量十分有效，可以使指针变量自动向前或向后移动，指向下一个或上一个数组元素。例如，想输出a数组的个元素，可以用下面的方法：
pa
C程序设计第五版
whilepa
printfdp
或
pa
whilepa
printfdpp
但如果不小心，很容易弄错。因此在用p形式的运算时，一定要十分小心，弄清楚先取p值还是先使p加。对初学者不建议多用，但应当知道有关的知识，以上这段内容初学者可以选学。
用数组名作函数参数
在第章中介绍过可以用数组名作函数的参数。例如：
int main
void fun int arr int n 对 fun函数的声明
int array 定义 array数组
⋮
fun array 用数组名作函数的参数
return
void fun int arr int n 定义 fun函数
⋮
array是实参数组名， arr为形参数组名。由节已知，当用数组名作参数时，如果形参数组中各元素的值发生变化，实参数组元素的值随之变化。这究竟是什么原因呢 在学习指针以后，对此问题就容易理解了。
先看数组元素作实参时的情况。如果已定义一个函数，其原型为
void swap int x int y
假设函数的作用是将两个形参x，y的值交换，今有以下的函数调用：
swapaa
用数组元素a和a作实参的情况，与用变量作实参时一样，是“值传递”方式，将a和a的值单向传递给x和y。当x和y的值改变时a和a的值并不改变。
再看用数组名作函数参数的情况。前已介绍，实参数组名代表该数组首元素的地址，而形参是用来接收从实参传递过来的数组首元素地址的。因此，形参应该是一个指针变量只有指针变量才能存放地址。实际上，C编译都是将形参数组名作为指针变量来处理的。例如，本小节开头给出的函数 fun的形参是写成数组形式的：
fun int arr□ int n
但在程序编译时是将 arr按指针变量处理的，相当于将函数 fun的首部写成
第章 善于利用指针
fun int arr int n
以上两种写法是等价的。在该函数被调用时，系统会在 fun函数中建立一个指针变量 arr，用来存放从主调函数传递过来的实参数组首元素的地址。如果在 fun 函数中用运算符 sizeof测定 arr所占的字节数可以发现 sizeof arr的值为用 Visual C时。这就证明了系统是把 arr作为指针变量来处理的指针变量在 Visual C中占个字节。
array
arr
array
arr
arr
array
arr
当 arr接收了实参数组的首元素地址后， arr就指向实参数组首元素也就是指向 array。因此 arr 就是 array。 arr 指向 array arr 指向 array arr 指向 array。也就是说 arr arr arr分别是 array array array。根据前面介绍过的知识 arri和 arri是无条件等价的。因此在调用函数期间 arr和 arr以及 array都代表数组 array序号为的元素依此类推 arr arr array都代表 array数组序号为的元素，见图。这个道理与小节中的叙述是类似的。
图
常用这种方法通过调用一个函数来改变实参数组的值。
下面把用变量名作为函数参数和用数组名作为函数参数做一比较，见表。
表以变量名和数组名作为函数参数的比较
实参类型 变量名 数组名 要求形参的类型 变量名 数组名或指针变量 传递的信息 变量的值 实参数组首元素的地址通过函数调用能否改变实参的值不能改变实参变量的值能改变实参数组的值
说明： C语言调用函数时虚实结合的方法都是采用“值传递”方式，当用变量名作为函数参数时传递的是变量的值，当用数组名作为函数参数时，由于数组名代表的是数组首元素地址，因此传递的值是地址，所以要求形参为指针变量。
在用数组名作为函数实参时，既然实际上相应的形参是指针变量，为什么还允许使用形参数组的形式呢 这是因为在C语言中用下标法和指针法都可以访问一个数组如果有一个数组a，则ai和ai无条件等价，用下标法表示比较直观，便于理解。因此许多人愿意用数组名作形参，以便与实参数组对应。从应用的角度看，用户可以认为有一个形参数组，它从实参数组那里得到起始地址，因此形参数组与实参数组共占同一段内存单元，在调用函数期间，如果改变了形参数组的值，也就是改变了实参数组的值。在主调函数中就可以利用这些已改变的值。对C语言比较熟练的专业人员往往喜欢用指针变量作形参。
注意：实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。
在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它可以再被赋值。例如：
C程序设计第五版
void fun arr int n
printfdn arr 输出 array的值
arr arr 形参数组名可以被赋值
printfdn arr 输出 array的值
【例】 将数组a中n个整数按相反顺序存放，见图示意。
解题思路 将a与an对换再将a与an对换……直到将 a intn与 an intn对换。今用循环处理此问题设两个“位置指示变量” i 和 ji的初值为j的初值为 n。将ai与aj交换，然后使i的值加，j的值减，再将ai与aj对换直到in为止。
m
图
用一个函数 inv来实现交换。实参用数组名a，形参可用数组名，也可用指针变量名。
编写程序：
include stdio h
int main
void inv int x int n inv函数声明
int ia
printfThe original arrayn
foriii
printfdai 输出未交换时数组各元素的值
printfn
inva 调用 inv函数，进行交换
printfThe array has been invertedn
foriii
printfdai 输出交换后数组各元素的值
printfn
return
void inv int x int n 形参x是数组名
int tempijmn
foriimi
jni
tempxixixjxj temp 把 xi和xj交换
return
运行结果：
The original array
The array has been inverted
第章 善于利用指针
程序分析： 在main函数中定义整型数组a，并赋予初值。函数 inv的形参数组名为x。在定义 inv函数时，可以不指定形参数组x的大小元素的个数。因为形参数组名实际上是一个指针变量，并不是真正地开辟一个数组空间定义实参数组时必须指定数组大小，因为要开辟相应的存储空间。inv函数的形参n用来接收需要处理的元素的个数。在main函数中有函数调用语句“inva，；”，表示要求对a数组的个元素实行题目要求的颠倒排列。如果改为“inva，；”，则表示要求将a数组的前个元素实行颠倒排列，此时，函数 inv只处理个数组元素。函数 inv中的m是i值的上限，当i≤m时，循环继续执行；当im时，则结束循环过程。例如若n则m最后一次ai与aj的交换是a与a交换。
运行结果表明程序是正确的。
图
对这个程序可以作一些改动。将函数 inv中的形参x改成指针变量。相应的实参仍为数组名a，即数组a首元素的地址，将它传给形参指针变量 x，这时x就指向a。xm是am元素的地址。设i和j以及p都是指针变量，用它们指向有关元素。i的初值为xj的初值为xn见图。使i与j交换就是使ai与aj交换。
修改程序：
include stdio h
int main
void inv int x int n
int ia
printfThe original arrayn
foriii
printfdai
printfn
inva
printfThe array has been invertedn
foriii
printfdai
printfn
return
void inv int x int n 形参x是指针变量
int p tempijmn
ixjxnpxm
foripij
tempiijj temp i与j交换
return
C程序设计第五版
运行结果与前一程序相同。
归纳分析： 如果有一个实参数组，要想在函数中改变此数组中的元素的值，实参与形参的对应关系有以下种情况。
形参和实参都用数组名，例如：
int main int f int x□ int n
int a
⋮ ⋮
fa
⋮
由于形参数组名x接收了实参数组首元素a的地址，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元，这种形式比较好理解，见图。例第个程序即属此情况。
实参用数组名，形参用指针变量。例如：
int main void f int x int n
ax
int a
⋮ ⋮
图
fa
⋮
实参a为数组名，形参x为 int型的指针变量，调用函数开始后，形参x指向a，即 xa见图。通过x值的改变，可以指向a数组的任一元素。例的第个程序就属于此类。
a
实参形参都用指针变量。例如：
⋮
int main void f int x int n
a
int apa
⋮ ⋮
图
fp
⋮
实参p和形参x都是 int型的指针变量。先使实参指针变量 p指向数组a，p的值是a。然后将p的值传给形参指针变量 x，x的初始值也是a，见图。通过x值的改变可以使x指向数组a的任一元素。
实参为指针变量，形参为数组名。例如：
int main void f int x int n
int a pa
⋮ ⋮
fp
⋮
第章 善于利用指针
实参p为指针变量，它指向a。形参为数组名 x，编译系统把 x作为指针变量处理，今将a的地址传给形参x，使x也指向a。也可以理解为形参数组 x和a数组共用同一段内存单元，见图。在函数执行过程中可以使xi的值发生变化，而xi就是ai。这样， main函数可以使用变化了的数组元素值。例的程序可以改写为例。
p x
数组a
P
a
ax
a
ax
图
图
【例】 改写例，用指针变量作实参。
编写程序：
include stdio h
int main
void inv int x int n inv函数声明
int i arrp arr 指针变量 p指向 arr
printfThe original arrayn
foriiip
scanfdp 输入 arr数组的元素
printfn
p arr 指针变量 p重新指向 arr
invp 调用 inv函数，实参p是指针变量
printfThe array has been invertedn
forp arrp arrp
printfdp
printfn
return
void inv int x int n 定义 inv函数，形参x是指针变量
int pm tempij
mn
ixjxnpxm
foripij
tempiijj temp
return
注意：上面的 main 函数中的指针变量p是有确定值的。如果在 main函数中不设数组，只设指针变量，就会出错，假如把主函数修改如下：
include stdio h
int main
C程序设计第五版
void inv int x int n inv函数声明
int i arr 指针变量 arr未指向数组元素
printfThe original arrayn
foriii
scanfd arri
printfn
inv arr 调用 inv函数，实参 arr是指针变量，但无指向
printfThe array has been invertedn
foriii
printfd arri
printfn
return
编译时出错，原因是指针变量 arr没有确定值，谈不上指向哪个变量。
下面的使用是不正确的：
int main fx int n
int p
⋮ …
fp
⋮
注意： 如果用指针变量作实参，必须先使指针变量有确定值，指向一个已定义的对象。
以上种方法，实质上都是地址的传递。其中和两种只是形式上不同，实际上形参都是使用指针变量。
【例】 用指针方法对个整数按由大到小顺序排序。
解题思路： 在主函数中定义数组a存放个整数，定义 int 型指针变量 p并指向a。定义函数 sort 使数组a中的元素按由大到小的顺序排列。在主函数中调用 sort函数，用指针变量 p作实参。 sort 函数的形参用数组名。用选择法进行排序，选择排序法的算法前已介绍。
编写程序：
include stdio h
int main
void sort int x□ int n sort函数声明
int ipa
pa 指针变量 p指向 a
printfplease enter integer numbers
foriii
scanfdp 输入个整数
pa 指针变量p重新指向a
sortp 调用 sort 函数
第章 善于利用指针
forpaiii
printfdp 输出排序后的个数组元素
p
printfn
return
void sort int x int n 定义 sort函数，x是形参数组名
int ijkt
foriini
ki
forjijnj
ifxjxk kj
ifki
txixixkxkt
运行结果：
please enter integer numberes
程序分析： 为了便于理解，函数 sort中用数组名作为形参，用下标法引用形参数组元素，这样的程序很容易看懂。当然也可以改用指针变量，这时 sort 函数的首部可以改为
sort int x int n
其他不改，程序运行结果不变。
可以看到，即使在函数 sort 中将x定义为指针变量，在函数中仍可用xi和xj这样的形式表示数组元素，它就是xi和xj所指的数组元素。
上面的 sort函数等价于：
void sort int x int n 形参x是指针变量
int ijkt
foriini
ki
forjijnj
ifxjxkkj xj就是xj其他亦然
ifki
txixixkxkt
请读者自己理解消化程序。
通过指针引用多维数组
指针变量可以指向一维数组中的元素，也可以指向多维数组中的元素。但在概念上和
C程序设计第五版
使用方法上，多维数组的指针比一维数组的指针要复杂一些。
多维数组元素的地址
为了说清楚指向多维数组元素的指针，先回顾一下多维数组的性质，以二维数组为例。设有一个二维数组a，它有行列。
它的定义为
int a
a是二维数组名。a数组包含行，即个行元素：a，a，a。而每一个行元素又是一个一维数组，它包含个元素即个列元素。例如，a所代表的一维数组又包含个元素：a，aaa见图。可以认为二维数组是“数组的数组”，即二维数组a是由个一维数组所组成的。
从二维数组的角度来看，a代表二维数组首元素的地址，现在的首元素不是一个简单的整型元素，而是由个整型元素所组成的一维数组，因此a代表的是首行即序号为的行的起始地址。a代表序号为的行的起始地址。如果二维数组的首行的起始地址为，一个整型数据占个字节，则a的值应该是×因为第行有个整型数据。a 指向a或者说a的值是a的起始地址。a代表a的起始地址它的值是见图。
a，a，a既然是一维数组名，从前面已知，数组名代表数组首元素地址，因此 a代表一维数组a中第列元素的地址即a。同理a的值是aa的值是 a。
请考虑a数组行列元素的地址怎么表示 a是一维数组名，该一维数组中序号 为的元素的地址显然应该用a来表示，见图。此时“a”中的代表个列元素的字节数即个字节。a的值是a的值是而不是。这是因为现在是在一维数组范围内讨论问题的，正如有一个一维数组x，x是其第个元素x的地址一样。aaaa分别是aaaa元素的地址即 a。
a
a数组
a
a
a
a
图
图
第章 善于利用指针
前已述及a和a等价a和a等价ai和ai等价。因此 a和a都是a即图中的。a和a的值都是a即图中的。请注意不要将a错写成a后者变成a了相当于a。
进一步分析欲得到a的值用地址法怎么表示呢 既然a和a是a的地址那么a就是a的值。同理a或a也是a的值。aij或aij是aij的值。务请记住ai和ai是等价的。
有必要对ai的性质作进一步说明。ai从形式上看是a数组中序号为i的元素。如果a是一维数组名，则ai代表a数组序号为i的元素的存储单元。ai是一个有确定地址的存储单元。但如果a是二维数组，则ai是一维数组名，它只是一个地址，并不代表一个存储单元，也不代表存储单元中的值如同一维数组名只是一个指针常量一样。a，ai，aiaiaijaij都是地址。而aij和aij是二维数组元素 aij的值见表。
有些读者可能不理解，为什么a和a的值都是 呢 他们认为：a是地址，a是该地址指向的存储单元中的内容，怎么会是同一个值呢 的确，二维数组中有些概念比较复杂难懂，要仔细消化，反复思考。
表二维数组a的有关指针
表 示 形 式 含 义 值 a 二维数组名，指向一维数组 a，即行起 始地址 aaa 行列元素地址 aa 行起始地址 aa 行列元素 a的地址 aaa行列元素 a的地址aaa行列元素 a的值是元素值，为
首先说明，a是二维数组a中序号为的行的起始地址序号从起算，而a并不是a单元的内容值，因为a并不是一个数组元素的地址，也就谈不上存储单元的内容了。a就是a而a是一维数组名所以也是地址它指向a。a和a都是二维数组元素a的地址的不同的表示形式。
为了说明这个容易搞混的问题，可以举一个日常生活中的例子来说明。在军训中，一个排分个班，每个班站成一行，个班为行，相当于一个二维数组。为方便比较，班和战士的序号也从开始。请思考： 班长点名和排长点名的方法有什么不同。班长从第个战士开始逐个检查本班战士是否在队列中，班长每移动一步，走过一个战士。而排长点名则是以班为单位，排长先站在第班的起始位置，检查该班是否到齐，然后走到第班的起始位置，检查该班是否到齐。班长移动的方向是横向的，而排长移动的方向是纵向的。排长看起来只走了一步，但实际上他跳过了一个班的个战士。这相当于从a移到a见图。
C程序设计第五版
班长“指向”的是战士，排长“指向”的是班，班长相当于列指针，排长相当于行指针。
a
a
第班第个战士
第班第个战士
☆
班
a
班
a
aij
班
图
为了找到某一班内某一个战士，必须给两个参数，即第i班第j个战士，先找到第i班， 然后由该班班长在本班范围内找第j个战士。这个战士的位置就是aij这是一个地址。开始时班长面对第个战士。注意，排长和班长的初始位置是相同的如图中的a和a都是，但他们面对的对象是不同的，班长面向的对象是战士，排长面向的对象是班。排长“指向”班，在图上是“纵向管理”，他纵向走一步就跳过一个班，而班长“指向”战士，在图上是“横向管理”，横向走一步只是指向下一个战士。
二维数组a相当于排长，而每一行即一维数组a，a，a相当于班长，每一行中的元素如a相当于战士。
说明： 前面已介绍过，C语言的地址信息中既包含位置信息如内存编号，还包含它所指向的数据的类型信息。现在a是一维数组名，它是一维数组中起始元素的地址，a是二维数组名，它是二维数组的首行起始地址，二者的纯地址是相同的；即，但它们的基类型不同，即它们指向的数据的类型不同，前者是整型数据，后者是一维数组。如果用一个指针变量 pt来指向此一维数组，应当这样定义：
int pt
表示 pt指向由个整型元素组成的一维数组，此时指针变量 pt的基类型是由个整型元素组成的一维数组。详见下一小节。
a与a是不同的，a是序号为的行的起始地址，a指向序号为的行相当于排长走到第班的开头，而a或a或a都指向行列元素相当于第班第个战士，二者地址虽相同，但指向的数据类型不同。a和a的值虽然相同等于，但是由于指针的基类型不同相当于排长和班长面对的对象不同，a指向一维数组a，而a指向列元素a。因此，对不同的指针进行加的运算，得到的结果是不同的①。
再次强调： 二维数组名如a是指向行一维数组的。因此a中的“”代表一行中全部元素所占的字节数图表示为个字节。一维数组名如a，a是指向列
① aaa的类型为 int型指向整型变量而a的类型为 int指向含个元素的一维数组关于指向一维数组的指针，详见下一小节。
第章 善于利用指针
元素的。a中的代表一个a元素所占的字节数图表示为个字节。在指向行的指针前面加一个，就转换为指向列的指针。例如，a和a是指向行的指针，在它们前面加一个就是a和a，它们就成为指向列的指针，分别指向a数组行列的元素和行列的元素。反之，在指向列的指针前面加 ，就成为指向行的指针。例如a是指向行列元素的指针在它前面加一个得a由于a与a等价，因此a与a等价，也就是与a等价，它指向二维数组的行。
注意： 不要把 ai简单地理解为 ai元素的存储单元的地址，因为并不存在ai这样一个实际的数据存储单元。它只是一种地址的计算方法，能得到第i行的起始地址，ai和ai的值是一样的 但它们的基类型是不同的。ai或ai指向行而ai或ai指向列。当列下标j为时ai和ai即aij值相等即它们的纯地址相同，但应注意它们所指向的对象的类型是不同的，即指针的基类型是不同的。ai只是ai的另一种表示形式，不要简单地认为ai是“ai所指单元中的内容”。在一维数组中ai所指的是一个数组元素的存储单元，在该单元中有具体值，上述说法是正确的。而对二维数组，ai不是指向具体存储单元而是指向行即指向一维数组。在二维数组中，ai、aiaiaiai的值相等即它们都代表同一地址但基类型不同。请读者仔细琢磨其概念。
为了加深印象，更好地理解以上的概念，请分析和消化下面的例子。
【例】 输出二维数组的有关数据地址和元素的值。
include stdio h
int main
int a
printfddnaa 行起始地址和行列元素地址
printfddnaa 行列元素地址
printfddnaa 行起始地址和行列元素地址
printfddnaa 行列元素地址和行起始地址
printfddnaa 行列元素地址
printfddnaa 行列元素地址
printfddnaa 行起始地址
printfddnaa 行列元素的值
printfddnaa 行列元素的值
return
运行结果：
程序分析： 二维数组a的结构与图 所示相同，只是a数组的起始地址是
C程序设计第五版
。上面是在 Visual C 环境下的一次运行记录。在不同的计算机、不同的编译环境、不同的时间运行以上程序时，由于分配内存情况不同，所显示的地址可能是不同的。但是上面显示的地址是有共同规律的，如上面显示行起始地址和行列元素地址为，前行显示的地址是相同的。第，行是行列元素地址和行起始地址，它的值应当比上面显示的行起始地址和行列元素地址大个字节一行有个元素，每个元素个字节和之差是。同样第行是行列元素地址和行起始地址，它的值应当比行起始地址和行列元素地址大个字节，和之差是。最后两行显示的是a和a的值。
指向多维数组元素的指针变量
在了解了以上的概念后，可以用指针变量指向多维数组的元素。
指向数组元素的指针变量
【例】 有一个×的二维数组，要求用指向元素的指针变量输出二维数组各元素的值。
解题思路： 二维数组中的所有元素都是整型的，它相当于整型变量，可以用 int型指针变量指向它。二维数组中的各元素在内存中是按行顺序存放的，即存放完序号为的行中的全部元素后，接着存放序号为的行中的全部元素，依此类推。因此可以用一个指向整型元素的指针变量，依次指向各个元素。
编写程序：
include stdio h
int main
int a
int p p是 int型指针变量
forpapap 使p依次指向下一个元素
ifpa printfn p移动次后换行
printfdp 输出 p指向的元素的值
printfn
return
运行结果：
程序分析： p是一个 int型指向整型数据的指针变量，它可以指向一般的整型变量，也可以指向整型的数组元素。每次使p值加，使p指向下一元素。第行 if语句的作用是使输出个数据后换行。
本例是顺序输出数组中各元素之值，比较简单。如果要输出某个指定的数值元素例如a，则应事先计算该元素在数组中的相对位置即相对于数组起始位置的相对位移量。计算 aij在数组中的相对位置的计算公式为
第章 善于利用指针
imj
其中，m为二维数组的列数二维数组大小为 n×m。例如，对上述的二维数组，它的行列元素a对a的相对位移量为×元素。如果一个元素占个字节则a对a的地址差为×字节。若开始时指针变量 p指向aaij的地址为“aimj”或“pimj”。a的地址是p即p。a的值为p。
n
下面来说明上述“aimj”中的imj 的含义。从图 可以看到在aij元素之前有i行元素每行有 m 个元素，在aij所在行aij的前面还有j个元素因此aij之前共有i×mj个元素。例如a的前面有两行，共×个元素，在它本行内还有个元素在它前面，故共有个元素在它之前。可用p表示其相对位置。
i
a
j
图
可以看到，C语言规定数组下标从开始，对计算上述相对位置比较方便，只要知道i和j的值，就可以直接用i×mj公式计算出aij相对于数组开头的相对位置。如果规定下标从开始如FORTRAN语言，则为计算aij的相对位置所用的公式就要改为
i×mj
这就使表达式复杂，而且不直观。
指向由 m个元素组成的一维数组的指针变量
上例的指针变量p是用“int p；”定义的，它是指向整型数据的，p所指向的元素是p所指向的列元素的下一元素按在内存中存储的下一个整型元素。
可以改用另一方法，使p不是指向整型变量，而是指向一个包含 m个元素的一维数组。 这时，如果 p先指向a即 pa则p不是指向a而是指向ap的增值以一维数组的长度为单位，见图。
p
a
【例】 输出二维数组任一行任一列元素的值。
p
a
解题思路： 假设仍然用例程序中的二维数组，例中定义的指针变量是指向变量或数组元素的，现在改用指向一维数组的指针变量。
a
图
编写程序：
include stdio h
int main
int a 定义二维数组a并初始化
intpij 指针变量p指向包含个整型元素的一维数组
pa p指向二维数组的行
printfplease enter row and colum
scanfddij 输入要求输出的元素的行列号
printfadddnijpij 输出 aij的值
C程序设计第五版
return
运行结果：
please enter row and colum
a
程序分析： 程序第行中“intp”表示定义p为一个指针变量，它指向包含个整型元素的一维数组。注意，p两侧的括号不可缺少，如果写成p，由于方括号运算级别高，因此p先与结合，p是定义数组的形式，然后再与前面的结合，p就是指针数组见节。有的读者感到“p”这种形式不好理解。可以对下面二者做比较：
① int a a有个元素，每个元素为整型
② intp
第②种形式表示p有个元素，每个元素为整型。也就是p所指的对象是有个整型元素的数组，即p是指向一维数组的指针，见图。应该记住，此时 p 只能指向一个包含个元素的一维数组，不能指向一维数组中的某一元素。p的值是该一维数组的起始地址。虽然这个地址指纯地址与该一维数组首元素的地址相同，但它们的基类型是不同的。不要混淆。
p数组
p
p
p
p
p
图
请分析以下小程序：
include stdio h
int main
int a 定义一维数组a，包含个元素
intp 定义指向包含个元素的一维数组的指针变量中
pa 使p指向一维数组
printfdnp 输出a输出整数
return
注意第行不应写成“pa；”，因为这样写表示 p的值是a，指向首元素a。”表示 p 指向一维数组行，p是p所指向的行中序号为 的元素。
p
由于例中的指针变量 p指向二维数组的行，因此 pi是二维数组a的i行的起始地址由于 p是指向一维数组的指针变量因此 p加就指向下一行见图。请分析p是什么 由于pa因此p 就是ap就是a而a的值是a数组中行列元素a的地址即a因此p就是a数组行列元素的地
图
第章 善于利用指针
址这是指向列元素的指针由此不难理解 p是a的值。
有的读者可能会想，p是a数组行列元素的地址，而p是a数组行起始地址，二者的值相同，p能否写成p呢 显然不行。不能作简单的数值替换。p就成了p了，是a数组行的起始地址了。
说明：要注意指针变量的类型，从“intp；”可以看到，p的类型不是 int型，而是 int型，p被定义为指向一维整型数组的指针变量，一维数组有个元素，因此p的基类型是一维数组，其长度是字节。“p”括号中的是以p的基类型一维整型数组的长度为单位的，即p每加，地址就增加个字节个元素，每个元素个字节，而“p”括号外的数字，不是以p的基类型的长度为单位的。由于经过p的运算，得到a，即a ，它已经转化为指向列元素的指针了，因此加是以元素的长度为单位的，加就是加×个字节。虽然p和p具有相同的值，但由于它们所指向的对象的长度不同，因此p和p的值就不相同了。这和上一节所叙述的概念是一致的。
用指向数组的指针作函数参数
一维数组名可以作为函数参数，多维数组名也可作函数参数。用指针变量作形参，以接受实参数组名传递来的地址。可以有两种方法：①用指向变量的指针变量；②用指向一维数组的指针变量。
【例】 有一个班，个学生，各学门课，计算总平均分数以及第n个学生的成绩。
解题思路： 这个题目是很简单的。本例用指向数组的指针作函数参数。用函数 average求总平均成绩，用函数 search找出并输出第i个学生的成绩。
编写程序：
include stdio h
int main
void average float p int n
void search floatp int n
float score
average score 求个分数的平均分
search score 求序号为的学生的成绩
return
void average float p int n 定义求平均成绩的函数
float p end
float sum aver
p endpn n的值为时p end的值是 p扌 指向最后一个元素
forpp endp
sum sump
aver sumn
printfaveragefn aver
C程序设计第五版
void search floatp int n p是指向具有个元素的一维数组的指针
int i
printfThe score of Nod arenn
foriii
printffpni
printfn
运行结果：
average
The score of No are
程序分析 在 main 函数中先调用 average函数以求总平均值。在函数 average中形参p被声明为 float类型指向 float型变量的指针变量。它的基类型为 float型实参用 score即 score也就是 score即 score的地址。把 score的地址传给 p使 p 指向 score。然后在 average函数中使 p先后指向二维数组的各个元素，p每加 就改为指向 score数组的下一个元素，见图。形参n代表需要求平均值的元素的个数，实参表示要求个元素值的平均值。p end是最后一个元素的地址。 sum是累计总分， aver是平均值。在函数中输出 aver的值，函数无需返回值。
函数 search的形参p的类型是 float它不是指向整型变量的指针变量，而是指向包含个元素的一维数组的指针变量。函数调用开始时，将实参 score的值代表该数组行起始地址传给 p，使 p也指向 score。pn是 scoren的起始地址pni是 scoreni的地址pni是 scoreni的值。现在实参传给形参 n的值是，即想找序号为的学生的成绩个学生的序号分别为，，。
图
调用 search函数时，实参是 score二维数组名，代表该数组中行起始地址传给 p，使 p也指向 score。pn是 scoren的起始地址pni是 scoreni的地址pni是 scoreni的值。现在 ni由变到 for循环输出 score到 score的值。
注意：实参与形参如果是指针类型，应当注意它们的基类型必须一致。不应把 int型的指针即数组元素的地址传给 int型指向一维数组的指针变量，反之亦然。正如不应把“班长”传给“排长”一样，应当是“门当户对”。
例如在 main函数中调用 search函数时，实参是 score，形参p指向包含个整型元素的一维数组，二者类型是一致的，程序中调用 search函数的形式是正确的，即：
search score 用 score即 score的起始地址作为实参
如果写成下面这样就不对了：
search score 用 score即 core的地址作为实参
第章 善于利用指针
虽然 score和 score都是地址，但后者的类型与形参p的类型不匹配。
【例】 在例的基础上，查找有一门以上课程不及格的学生，输出他们的全部课程的成绩。
解题思路： 在主函数中定义二维数组 score，定义search函数实现输出有一门以上课程不及格的学生的全部课程的成绩，形参p的类型是 float，p是指向包含个元素的一维数组的指针变量。在调用 search 函数时用 score作为实参它指向 score把 score的地址传给形参 p。
编写程序：
include stdio h
int main
void search float p int n 函数声明
float score
定义二维数组函数 score
search score 调用 search函数
return
void search float p int n 形参p是指向包含个 float 型元素的一维数组的指针变量
int ij flag
forjjnj
flag
foriii
ifpji flag pji就是 scoreji
if flag
printfNod fails his scores arenj
foriii
printffpji
输出pji就是输出 scoreji的值
printfn
运行结果：
No fails his scores are
No fails his scores are
程序分析： 实参 score和形参p的类型是相同的。在调用 search函数时，p得到实 参 score的值即 score的起始地址也就是说 p也指向 score数组的第行。然后p先后指向各行每行包括该学生几门课的成绩。pj是 core数组第j行的起始地址，pj是 scorej元素的地址即 scorejpji是 scoreji的地址即 scoreji search函数中的pji就是 scoreji。先后检查各学生每门课
C程序设计第五版
的成绩，如有不及格的就记录下来。
在函数 search中，变量 flag用来表示有无不及格的课程。若 flag的值为表示有不及格的课程，若flag的值为表示没有不及格的课程。开始时先使 flag，若发现某一学生有一门不及格，就使 flag变为。最后用 if语句检查 flag，如为，则表示该学生有不及格的记录，输出该学生全部课程成绩。变量j代表学生号，i代表课程号。 scoreji是序号为j的学生第i门课的成绩。
请读者仔细阅读和分析本程序，通过本例可以深入理解指针与数组的联系，正确使用指针方法引用数组元素，其中有不少概念和技巧。关于多维数组的指针，有一些概念是必须弄清楚的，不能一知半解。在学习和使用时，头脑要清楚，使用要小心。其实其基本的道理并不复杂，只要掌握住要领，就可迎刃而解。
通过指针变量存取数组元素速度快，程序简明。用指针变量作形参，所处理的数组大小可以改变。因此数组与指针常常是紧密联系的，使用熟练的话可以使程序质量提高，编写程序方便灵活。
通过指针引用字符串
在前面几章中已大量地使用了字符串，如在 printf函数中输出一个字符串。这些字符串都是以直接形式字面形式给出的，在一对双撇号中包含若干个合法的字符。在本节中将介绍使用字符串的更加灵活方便的方法——通过指针引用字符串。
字符串的引用方式
在C程序中，字符串是存放在字符数组中的。想引用一个字符串，可以用以下两种方法。
用字符数组存放一个字符串，可以通过数组名和下标引用字符串中一个字符，也可以通过数组名和格式声明“s”输出该字符串。
【例】定义一个字符数组，在其中存放字符串I love China！，输出该字符串和第个字符。
解题思路：定义字符数组 string，对它初始化，由于在初始化时字符的个数是确定的，因此可不必指定数组的长度。用数组名 string和输出格式s可以输出整个字符串。用数组名和下标可以引用任一数组元素。
编写程序：
include stdio h
int main
char stringI love China 定义字符数组 sting
printfsn string 用s格式声明输出 string，可以输出整个字符串
printfcn string 用c格式输出一个字符数组元素
return
第章 善于利用指针
运行结果：
I love China
c
程序分析：在定义字符数组 string时未指定长度，由于对它初始化，因此它的长度 是确定的长度应为其中个字节存放I love China个字符，最后一个字节存放字符串结束符。数组名 string代表字符数组首元素的地址见图。题目要求输出该字符串第个字符，由于数组元素的序号从起算，所以应当输出 string，它代表数组中序号的元素的值它的值是字母C。实际上 string就是 string string是一个地址，它指向字符“C”。
C
string
h
string
用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。
i
string
string
【例】 通过字符指针变量输出一个字符串。
n
a
string
string
解题思路： 可以不定义字符数组，只定义一个字符指针变量，用它指向字符串常量中的字符。通过字符指针变量输出该字符串。
string
图
编写程序：
include stdio h
int main
char stringI love China 定义字符指针变量 string并初始化，
printfsn string 输出字符串
return
运行结果：
string
I
I love China
。
v
七 程序分析： 在程序中没有定义字符数组，只定义了一个 char型的指针变量字符指针变量 string用字符串常量I love China对它初始化。C语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串常量，但是这个字符数组是没有名字的，因此不能通过数组名来引用，只能通过指针变量来引用。
e
C
h
i
n
a
对字符指针变量 string初始化，实际上是把字符串第个元素的地址即存放字符串的字符数组的首元素地址赋给指针变量 string，使 string指向字符串的第个字符，由于字符串常量” I love China！已由系统分配在内存中连续的个字节中，因此， string就指向了该字符串的第一个字符见图。在不致引起误解的情况下，为了简便，有时也可说 string指向字符串I love China！，但应当理解为“指向字符串的第个字符”。
图
C程序设计第五版
说明：有人误认为 string是一个字符串变量，以为在定义时把I love China！这几个字符赋给该字符串变量，这是不对的。在C语言中只有字符变量，没有字符串变量。
分析定义 string 的行
char stringI love China
等价于下面两行：
char string 定义一个 char型变量
stringI love China 把字符串第个元素的地址赋给字符指针变量 string
注意： string被定义为一个指针变量，基类型为字符型。请注意它只能指向一个字符类型数据，而不能同时指向多个字符数据，更不是把Ilove China！这些字符存放到 string 中指针变量只能存放地址也不是把字符串赋给 string。只是把I love China的第个字符的地址赋给指针变量 string。
不要认为上述定义行等价于
char string
stringI love China 多了一个号， string才是指针变量名
可以对指针变量进行再赋值，如：
stringI am a student 对指针变量 string 重新赋值
把字符串I am a student 的第一个字符的地址赋给指针变量 string。此后 string 就指向I am a student 的第一个字符不再指向I love China的第一个字符了因此不能再通过 string 引用字符串I love China。
可以通过字符指针变量输出它所指向的字符串，如：
printfsn string
s是输出字符串时所用的格式符，在输出项中给出字符指针变量名 string，则系统会输出 string 所指向的字符串第个字符，然后自动使 string加，使之指向下一个字符，再输出该字符⋯⋯如此直到遇到字符串结束标志为止。注意，在内存中，字符串的最后被自动加了一个如图 所示，因此在输出时能确定输出的字符到何时结束。可以看到，用s可以对一个字符串进行整体的输入输出。
说明：通过字符数组名或字符指针变量可以输出一个字符串，而对一个数值型数组，是不能企图用数组名输出它的全部元素的。例如：
int a
⋮
printfdna
是不行的，它输出的是数组首元素的地址。对于数值型数组的元素值只能逐个输出。
对字符串中字符的存取，可以用下标方法，也可以用指针方法。
【例】 将字符串a复制为字符串b，然后输出字符串b。
解题思路定义两个字符数组a 和b用I am a student 对a数组初始化。将a数组中
第章 善于利用指针
的字符逐个复制到 b数组中。可以用不同的方法引用并输出字符数组元素，今用地址法算出各元素的值。
编写程序：
include stdio h
int main
char a I am a student b 定义字符数组
int i
foriaii
biai 将ai的值赋给 bi
bi 在b数组的有效字符之后加
printfstring a issna 输出a数组中全部有效字符
printfstring b is
foribii
printfcbi 逐个输出b数组中全部有效字符
printfn
return
运行结果：
string a isI am a student
string b isI an a student
程序分析： 程序中 a 和b 都定义为字符数组，今通过地址访问其数组元素。在for语句中先检查ai是否为ai是以ai形式表示的。如果不等于表示字符串尚未处理完，就将ai的值赋给 bi，即复制一个字符。在for循环中将a串中的有效字符全部复制给了b数组。最后还应将复制过去，作为字符串结束标志。故有
在第个 for循环中输出b数组中的元素，在 printf函数中用下标法表示一个数组元素即一个字符。也可以用输出a数组的方法输出b数组。用以下一行代替程序的行。
printfstring b issnb
程序中用逐个字符输出的方法只是为了表示可以用不同的方法输出字符串。
也可以用另一种方法——用指针变量访问字符串。通过改变指针变量的值使它指向字符串中的不同字符，见例。
【例】 用指针变量来处理例问题。
解题思路：定义两个指针变量 p和 p，分别指向字符数组a和b。改变指针变量 p和p的值，使它们顺序指向数组中的各元素，进行对应元素的复制。
编写程序：
include stdio h
int main
char aI am a boy bpp
papb p，p分别指向a数组和b数组中的第一个元素
C程序设计第五版
forppp pp每次自加
pp 将p所指向的元素的值赋给p 所指向的元素
p 在复制完全部有效字符后加
printfstring a issna 输出a数组中的字符
printfstring b issnb 输出 b数组中的字符
return
运行结果：
p
a
p
b
string a isI am a boy
I
string b isI am a boy
a
m
p
p
a
b
程序分析： p和p是指向字符型数据的指针变量。先使p和p分别指向字符串a 和b 的第个字符。p最初的值是字母I。赋值语句“pp；”的作用是将字符Ia串中第个字符赋给 p 所指向的元素即 b。然后 p和p 分别加，分别指向其下面的一个元素，直到p的值为止。注意p 和 p 的值是不断在改变的见图 的虚线和 pp。在 for 语句中的 p和p使 p和p同步移动。
。
y
图
字符指针作函数参数
如果想把一个字符串从一个函数“传递”到另一个函数，可以用地址传递的办法，即用字符数组名作参数，也可以用字符指针变量作参数。在被调用的函数中可以改变字符串的内容，在主调函数中可以引用改变后的字符串。
【例】 用函数调用实现字符串的复制。
解题思路：定义一个函数 copy string用来实现字符串复制的功能，在主函数中调用此函数，函数的形参和实参可以分别用字符数组名或字符指针变量。分别编程，以供分析比较。
编写程序：
用字符数组名作为函数参数
include stdio h
int main
void copy string char from char to
char aI am a teacher
char bYou are a student
printfstring as nstring bsnab
printfcopy string a to string bn
copy stringab 用字符数组名作为函数实参
printf nstring as nstring bsnab
return
、
void copy string char from char to 形参为字符数组
第章 善于利用指针
int i
while fromi
toi fromii
toi
运行结果：
string aI am a teacher
string b You are a student
copy string a to string b
string aI an a teacher
string bI an a teacher
程序分析 a和b 是字符数组。初值如图a所示。 copy string 函数的作用是将 fromi赋给 toi直到 fromi的值等于为止。在调用 copy string 函数时将a和b第个字符的地址分别传递给形参数组名 from和 to。因此 fromi和ai是同一个单元 toi和bi是同一个单元。程序执行完以后，b数组的内容如图b所示。可以看到，由于 b数组原来的长度大于a数组，因此在将a数组复制到b数组后，未能全部覆盖b数组原有内容。b数组最后个元素仍保留原状。在输出b时由于按s字符串输出，遇o即告结束，因此第一个后的字符不输出。如果不采取s格式输出而用c逐个字符输出是可以输出后面这些字符的。
用字符型指针变量作实参
a
b
copy string函数不变在 main 函数中定义字符指针变量 from 和 to，分别指向两个字符数组ab。
图
程序改写如下：
include stdio h
int main
void copy string char from char to 函数声明
char aI am a teacher 定义字符数组a并初始化
char bYou are a student 定义字符数组b并初始化
char froma tob from指向 a数组首元素 to指向 b数组首元素
printfstring as nstring bsnab
printf ncopy string a to string bn
copy string from to 实参为字符指针变量
printfstring as nstring bsnab
return
C程序设计第五版
void copy string char from char to 形参为字符数组
int i
while fromi
toi fromii
toi
运行结果与程序相同。
程序分析： 指针变量 from的值是a数组首元素的地址，指针变量to的值是b数组首元素的地址。它们作为实参，把a数组首元素的地址和b数组首元素的地址传递给形参数组名 from和 to它们实质上也是指针变量。其他与程序相同。
用字符指针变量作形参和实参
include stdio h
int main
void copy string char from char to
char aI am a teacher a是 char型指针变量
char bYou are a student b是字符数组
char pb 使指针变量 p指向 b数组首元素
printfstring as nstring bsnab 输出 a串和b串
printf ncopy string a to string bn
copy stringap 调用 copy string函数实参为指针变量
printfstring as nstring bsnab 输出改变后的a 串和 b串
return
void copy string char from char to 定义函数，形参为字符指针变量
for from from to
to from
to
运行结果同上。
程序分析：形参改用 char型变量即字符指针变量。在程序和中 copy string 函数的形参用字符数组名，其实编译系统是把字符数组名按指针变量处理的，只是表示形式不同。 copy string函数中不是用下标法引用数组元素，而是通过移动指针变量的指向，找到并引用数组元素。
main 函数中的a是字符指针变量指向字符串I am a teacher 的首字符。b 是字符数 组在其中存放了字符串You are a student 。p是字符指针变量它的值是 b数组第一个元素的地址因此也指向字符串You are a student 的首字符。 copy string 函数的形参 from和 to是字符指针变量。在调用 copy string 时将数组a首元素的地址传给 from把指针变量p的值即数组 b 首元素的地址传给 to。因此from 指向 a 串的第一个字符a to指向b。在 for循环中先检查 from当前所指向的字符是否为如果不是表示需要复制此字符就执行“ to from”每次将 from的值赋给 to第次就是将
第章 善于利用指针
a串中第个字符赋给b数组的第个字符。每次循环中都执行“from”和“to”，使 from 和 to分别指向a 串和b数组的下一个元素。下次再执行“ to from”时就将a串中第个字符赋给b……最后将赋给 to，注意此时 to指向哪个单元。
程序改进：
对 copy string函数还可以改写得更精练一些，可以作以下一些改动：
将 copy string函数改写为
void copy string char from char to
while to from
to from
请与上面程序对比。在本程序中将“ to from”的操作放在 while语句括号内的表达式中，而且把赋值运算和判断是否为的运算放在一个表达式中，先赋值后判断。在循环体中使 to 和 form增值指向下一个元素……直到 from的值为为止。
copy string函数的函数体还可改为
while to from
把上面程序的 to和 from运算与 to from合并它的执行过程是先将 from赋给 to，然后使 to和 from增值。显然这又简化了。
copy string 函数的函数体还可写成
to from
当 from不等于时将 from赋给 to然后使 to 和 from 增值。
由于字符可以用其 ASCII 码来代替例如，可用代替，’可以用“while ch”代替。因此”可以用“while from”代替的 ASCII代码为。而关系表达式“ from”又可简化为“ from”这是因为若 from的值不等于则表达式“ from”为真同时也为真。因此“while from”和“while from”是等价的。所以函数体可简化为
while from
to from
上面的 while语句还可以进一步简化为下面的 while语句：
while to from
它与下面语句等价：
将 from赋给 to如果赋值后的 to值等于则循环终止已赋给
C程序设计第五版
函数体中也可以改为只用一个 for语句：
for to from
或
for to from
也可以用字符数组名作函数形参，在函数中另定义两个指针变量 p，p。函数 copy string 可写为
void copy string char from char to
char pp
p fromp to
whilepp
以上各种用法，变化多端，使用十分灵活，程序精练，比较专业，初学者看起来不太习惯，觉得含义不直观。初学者要很快地写出它们可能会有些困难，也容易出错。但应能看懂以上的用法。在对C熟练后，以上形式的使用是比较多的，读者应逐渐熟悉和掌握。
归纳起来，用字符指针作为函数参数时，实参与形参的类型有以下几种对应关系，见表。
表调用函数时实参与形参的对应关系
实 参 形 参 实 参 形 参 字符数组名 字符数组名 字符指针变量 字符指针变量 字符数组名 字符指针变量字符指针变量字符数组名
使用字符指针变量和字符数组的比较
用字符数组和字符指针变量都能实现字符串的存储和运算，但它们二者之间是有区别的，不应混为一谈，主要有以下几点。
字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址字符串第个字符的地址，绝不是将字符串放到字符指针变量中。
赋值方式。可以对字符指针变量赋值，但不能对数组名赋值。
可以采用下面方法对字符指针变量赋值：
char a a为字符指针变量
aI love China 将字符串首元素地址赋给指针变量，合法。但赋给a的不是
字符串，而是字符串第一个元素的地址。
不能用以下办法对字符数组名赋值：
char str
对字符数组元素赋值，合法
数组名是地址，是常量，不能被赋值，非法
初始化的含义。对字符指针变量赋初值：
定义字符指针变量a，并把字符串第一个元素的地址赋给a
第章 善于利用指针
等价于
char a 定义字符指针变量a
aI love China 把字符串第一个元素的地址赋给a
而对数组的初始化：
char strI love China 定义字符数组 str，并把字符串赋给数组中各元素
不等价于
char str 定义字符数组 str
str□I love China 企图把字符串赋给数组中各元素，错误
数组可以在定义时对各元素赋初值，但不能用赋值语句对字符数组中全部元素整体赋值。
存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元 VisualC为指针变量分配个字节。
如果定义了字符数组，但未对它赋值，这时数组中的元素的值是不可预料的。可以引用如输出这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和改正。
如果定义了字符指针变量，应当及时把一个字符变量或字符数组元素的地址赋给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量所指向的对象输入数据，可能会出现严重的后果。常有人用下面的方法：
char a 定义字符指针变量a
scanfsa 企图从键盘输入一个字符串，使a指向该字符串，错误
在 VisualC中编译时会发出“警告”信息，提醒未给指针变量指定初始值未指定其指向，虽然也能勉强运行，但这种方法是危险的。因为编译时给指针变量a分配了存储单元，变量a的地址即a是已指定了，但a并未被赋值，在a的存储单元中是一个不可预料的值。在执行 scanf函数时，要求将一个字符串输入到 a 所指向的一段存储单元即以a的值是一个地址开始的一段内存单元中。而a的值如今却是不可预料的，它可能指向内存中空白的未用的用户存储区中这是好的情况，也有可能指向已存放指令或数据的有用内存段，这就会破坏了程序或有用数据，甚至破坏了系统，会造成严重的后果。应当绝对防止这种情况的出现。应当在定义指针变量后，及时指定其指向。如：
char a str 定义了字符指针变量a 和字符数组 str
a str 使 a指向 str数组的首元素
scanfsa 从键盘输入一个字符串存放到a所指向的一段存储单元中，正确
先使a有确定值，使a指向一个数组元素，然后输入一个字符串，把它存放在以该地址开始的若干单元中。
指针变量的值是可以改变的，而字符数组名代表一个固定的值数组首元素的地址，不能改变。
【例】 改变指针变量的值。
include stdio h
int main
C程序设计第五版
aa 改变指针变量的值，即改变指针变量的指向
printfsna 输出从a指向的字符开始的字符串
return
运行结果：
China
程序分析： 指针变量a的值是可以变化的。 printf函数输出字符串时，从指针变量a当时所指向的元素开始，逐个输出各个字符，遇到为止。而数组名虽然代表地址，但它是常量，它的值是不能改变的。下面作法是错误的：
char strI love China
str str
printfs str
字符数组中各元素的值是可以改变的可以对它们再赋值，但字符指针变量指向的字符串常量中的内容是不可以被取代的不能对它们再赋值。如：
字符数组a初始化
字符指针变量b指向字符串常量的第一个字符
合法，r取代a数组元素a的原值u
非法，字符串常量不能改变
引用数组元素。对字符数组可以用下标法用数组名和下标引用一个数组元素如a，也可以用地址法如a引用数组元素a。如果定义了字符指针变量p，并使它指向数组a的首元素，则可以用指针变量带下标的形式引用数组元素如p，同样，可以用地址法如p引用数组元素a。
但是，如果指针变量没有指向数组，则无法用p或p这样的形式引用数组中的元素。这时若输出p或p，系统将输出指针变量p所指的字符后面个字节的内容。显然这是没有意义的，应当避免出现这种情况。
若字符指针变量p指向字符串常量，就可以用指针变量带下标的形式引用所指的字符串中的字符。如有：
定义指针变量a，指向字符串常量
则a的值是a所指向的字符串I love China中第个字符序号为即字母e。
虽然并未定义数组a，但字符串在内存中是以字符数组形式存放的。a按a处理，即从a当前所指向的元素下移个元素位置，取出其单元中的值。
用指针变量指向一个格式字符串，可以用它代替 printf函数中的格式字符串。例如：
char format
使 format 指向一个字符串
printf formatab
第章 善于利用指针
它相当于
因此只要改变指针变量 format所指向的字符串，就可以改变输入输出的格式。这种 printf函数称为可变格式输出函数。
也可以用字符数组实现。例如：
printf formatab
但使用字符数组时，只能采用在定义数组时初始化或逐个对元素赋值的方法，而不能用赋值语句对数组整体赋值，例如：
char format
非法
因此，用指针变量指向字符串的方式更为方便。
指向函数的指针
什么是函数的指针
如果在程序中定义了一个函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段内存空间有一个起始地址，也称为函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。函数名代表函数的起始地址。调用函数时，从函数名得到函数的起始地址，并执行函数代码。
函数名就是函数的指针，它代表函数的起始地址。
可以定义一个指向函数的指针变量，用来存放某一函数的起始地址，这就意味着此指针变量指向该函数。例如：
intp int int
定义p是一个指向函数的指针变量，它可以指向函数类型为整型且有两个整型参数的函数。此时指针变量 p的类型用 int int int表示。
用函数指针变量调用函数
如果想调用一个函数，除了可以通过函数名调用以外，还可以通过指向函数的指针变量来调用该函数。
先通过一个简单的例子来回顾一下函数的调用情况。
【例】 用函数求整数a和 b中的大者。
解题思路：定义一个函数 max，实现求两个整数中的大者。这是以前已做过的，比较简单。在主函数调用 max函数，除了可以通过函数名调用外，还可以通过指向函数的指针变量来实现。分别编程并作比较。
C程序设计第五版
通过函数名调用函数
include stdio h
int main
int max int int 函数声明
int abc
printfplease enter a and b
scanfddab
c maxab 通过函数名调用 max函数
printfad nbd nmaxdnabc
return
int max int x int y 定义 max函数
int z
ifxy zx
else zy
returnz
运行结果：
please enter a and b
a
b
max
这个程序是很容易理解的。
通过指针变量调用它所指向的函数
将程序改写为
include stdio h
int main
int max int int 函数声明
intp int int 定义指向函数的指针变量 p
int abc
p max 使p指向 max函数
printfplease enter a and b
scanfddab
cpab 通过指针变量调用 max函数
printfad nbd nmaxdnabc
return
int max int x int y 定义 max函数
int z
ifxy zx
else zy
returnz
第章 善于利用指针
运行结果同程序。
e程序分析： 可以看到，程序和的max函数是相同的。不同的只是在 main函数中调用 max函数的方法。
程序的第行“intp int int”用来定义p是一个指向函数的指针变量最前面的 int 表示这个函数值即函数返回的值是整型的。最后面的括号中有两个 int，表示这个函数有两个 int型参数。注意p两侧的括号不可省略，表示 p先与结合，是指针变量，然后再与后面的结合，表示是函数，即该指针变量不是指向一般的变量而是指向函数。如果写成“intp int int”由于优先级高于它相当于“intp int int”就成了声明一个p函数了这个函数的返回值是指向整型变量的指针。
赋值语句“p max”的作用是将函数 max的入口地址赋给指针变量p。和数组名代表数组首元素地址类似，函数名代表该函数的入口地址。这样，p就是指向函数 max的指针变量，此时 p和 max都指向函数的开头，见图。调用p就是调用 max函数。请注意p是指向函数的指针变量，它只能指向函数的入口处而不可能指向函数中间的某一条指令处，因此不能用p来表示函数的下一条指令。
图
在 main函数中有一个赋值语句：
cpab
它和
c maxab
等价。这就是用指针实现函数的调用。
以上用两种方法实现函数的调用，结果是一样的。
怎样定义和使用指向函数的指针变量
从例已看到定义指向函数的指针变量的例子。定义指向函数的指针变量的一般形式为
类型名指针变量名函数参数表列；
如“intp int int” 这里的“类型名”是指函数返回值的类型。
请读者熟悉指向函数的指针变量的定义形式，怎样判定指针变量是指向函数的指针变量呢 首先看变量名的前面有无“”号，如p。如果有，肯定是指针变量而不是普通变量。其次，看变量名的后面有无圆括号，内有形参的类型。如果有，就是指向函数的指针变量，这对圆括号是函数的特征。要注意的是：由于优先级的关系， “指针变量名”要用圆括号括起来。
说明：
定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指 向在定义时指定的类型的函数。如“intp int int”表示指针变量 p可以指向函数返回值为整型且有两个整型参数的函数。在程序中把哪一个函数该函数的值是整型的且有
C程序设计第五版
两个整型参数的地址赋给它，它就指向哪一个函数。在一个程序中，一个指针变量可以先后指向同类型的不同函数。
如果要用指针调用函数，必须先使指针变量指向该函数。如：
p max
这就把 max函数的入口地址赋给了指针变量 p。
在给函数指针变量赋值时，只须给出函数名而不必给出参数，例如：
p max 将函数入口地址赋给p
因为是将函数入口地址赋给p，而不牵涉实参与形参的结合问题。如果写成
p maxab
就错了。p maxa，b的作用是将调用 max函数所得到的函数值赋给p，而不是将函数入口地址赋给 p。
用函数指针变量调用函数时，只须将p代替函数名即可p为指针变量名，在p之后的括号中根据需要写上实参。例如：
cpab
表示“调用由p指向的函数，实参为a，b。得到的函数值赋给c”。
请注意函数返回值的类型。从指针变量p的定义中可以知道，函数的返回值应是整型的，因此将其值赋给整型变量c是合法的。
对指向函数的指针变量不能进行算术运算，如 pnpp等运算是无意义的。
用函数名调用函数，只能调用所指定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数。见例。
【例】输入两个整数，然后让用户选择或，选时调用 max函数，输出二者中的大数，选时调用 min函数，输出二者中的小数。
解题思路： 这是一个示意性的简单例子，说明怎样使用指向函数的指针变量。定义两个函数 max和 min，分别用来求大数和小数。在主函数中根据用户输入的数字是或，使指针变量指向 max函数或 min函数。
编写程序：
include stdio h
int main
int max int int 函数声明
int min int x int y 函数声明
intp int int 定义指向函数的指针变量
int abcn
printfplease enter a and b
scanfddab
printfplease choose or
scanfdn 输入 或
ifn p max 如输入使 p指向 max函数
第章 善于利用指针
else ifn p min 如输入使 p指向 min函数
cpab 调用 p指向的函数
printfadbdnab
else printfmindnc
return
int max int x int y
int z
ifxy zx
else zy
returnz
int min int x int y
int z
ifxy zx
else zy
returnz
运行结果：
输入ab的值 和选择模式
please enter a and b
please choose or
ab
max
输入ab的值和选择模式
please enter a and b
please choose or
ab
min
程序分析： 在程序中，调用函数的语句是“cpa，b；”。从这个语句本身看不出是调用哪一个函数，在程序执行过程中由用户进行选择，输入一个数字，程序根据输入的数字决定指针变量 p指向哪一个函数，然后调用相应的函数。
这个例子是比较简单的，只是示意性的，但它很有实用价值。在许多应用程序中常用菜单提示输入一个数字，然后根据输入的不同值调用不同的函数，实现不同的功能，就可以用此方法。当然，也可以不用指针变量，而用 if语句或 switch语句进行判断，调用不同的函数。但是显然用指针变量使程序更简洁和专业。
用指向函数的指针作函数参数
指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数。
指向函数的指针可以作为函数参数，把函数的入口地址传递给形参，这样就能够在被调
C程序设计第五版
用的函数中使用实参函数。它的原理可以简述如下：有一个函数假设函数名为 fun，它有两个形参 xl和x，定义x和x为指向函数的指针变量。在调用函数fun时，实参为两个函数名f和f，给形参传递的是函数f和f的入口地址。这样在函数fun中就可以调用 f和f函数了。例如：
实参函数名 fl f
void fun intx int int x int int 定义 fun函数形参是指向函数的指针变量
int abij
axi 调用f函数，i是实参
bxij 调用f函数ij是实参
在 fun函数中声明形参x和 x为指向函数的指针变量， xl 指向的函数有一个整型形参，x指向的函数有两个整型形参。i和j是调用f和f函数时所要求的实参。函数 fun的形参 xl和x指针变量在函数fun未被调用时并不占内存单元，也不指向任何函数。在主函数调用 fun函数时，把实参函数f和f的入口地址传给形参指针变量 xl 和 x使 x 和 x指向函数 f和 f见图。这时在函数 fun中用 xl 和x就可以调用函数 f和f。xi就相当于fixij就相当于fij。
有人可能会问，既然在 fun函数中要调用 f和f函数，为什么不直接调用f和f而要用函数指针变量呢 何必绕这样一个圈子呢 的确，如果只是用到f和f 函数，完全可以在 fun函数中直接调用f和f，而不必设指针变量 x 和x。但是，如果在每次调用 fun函数时，要调用的函数不是固定的，这次调用f和f，而下次要调用f和f，第次要调用的是f和f。这时，用指针变量就比较方便了。只要在每次调用 fun 函数时给出不同的函数名作为实参即可， fun函数不必做任何修改。这种方法是符合结构化程序设计方法原则的，是程序设计中常使用的。
下面通过一个简单的例子来说明这种方法的应用。
【例】有两个整数a和b，由用户输入，或。如输入，程序就给出a和b中的大者，输入，就给出a和b中的小者，输入，则求a与b之和。
解题思路： 与例相似，但现在用一个函数 fun来实现以上功能。
编写程序：
include stdio h
int main
int fun int x int y intp int int fun函数声明
int max int int max函数声明
int min int int min函数声明
int add int int add函数声明
int abn
printfplease choose or
scanfdn 输入或之一
第章 善于利用指针
ifn funab max 输入时调用 max函数
else if n funab min 输入时调用 min 函数
else if n funab add 输入时调用 add函数
return
…
int fun int x int y intp int int 定义 fun函数
int result
resultpxy
printfdn result 输出结果
int max int x int y 定义 max函数
int z
ifxyzx
else zy
printfmax
returnz 返回值是两数中的大者
int min int x int y 定义 min函数
int z
ifxyzx
else zy
printfmin
returnz 返回值是两数中的小者
int add int x int y 定义 add函数
int z
zxy
printfsum
returnz 返回值是两数之和
运行结果：
选择调用 max函数
please choose or
max
选择调用 min 函数
please choose or
min
选择调用 add函数
please choose or
sum
C程序设计第五版
程序分析 在定义 fun函数时在函数首部用“intp int int”声明形参 p是指向函数的指针，该函数是整型函数，有两个整型形参。 max， min 和 add是已定义的个函数，分别用来实现求大数、求小数和求和的功能。
当输入时n，调用 fun函数，除了将a和b作为实参，将两个整数传给 fun 函数的形参x和y外，还将函数名 max作为实参将其入口地址传送给 fun 函数中的形参pp是指向函数的指针变量见图a。这时 fun函数中的pxy相当于 maxxy调用 maxxy就输出a和b中的大者。
p
p
min
p
add
max
函数
函数
函数
a
b
c
图
若输入n调用 fun 函数时以函数名 min作实参此时 fun 函数的形参p 指向函数 min见图b在 fun函数中的函数调用pxy相当于 minxy。调用 minxy就输出a和b中的小者。同理若n调用 fun函数时以函数名 add作实参 fun函数中的pxy相当于 addxy调用 addxy就输出a和b之和。情况见图c。
本例的思路与例相似，但具体做法不同。在例 中定义了一个指向函数的指针变量p，根据不同情况，使p指向不同的函数，然后通过该指针变量调用不同的函数。本例程序没有定义指针变量，而是根据不同情况，将不同的函数名作为调用 fun函数的实参，把函数入口地址传送给传给函数 fun中的形参该形参是指向函数的指针变量，调用 fun 函数就分别执行不同的函数。
从本例可以清楚地看到，不论调用 max， min或 add，函数 fun 都没有改变，只是改变实参函数名而已。在fun函数中输出 result，由于在不同的情况下调用了不同的函数，因此 result的值是不同的。这就增加了函数使用的灵活性。
可以编写一个通用的函数来实现各种专用的功能。需要注意的是，对作为实参的函数如 max， min， add，应在主调函数中用函数原型作函数声明。例如， main 函数中第行到第行的函数声明是不可少的。
有了以上基础，就可以编写出较为复杂的程序。例如，编写一个求定积分的通用函数，用它分别求以下个函数的定积分：
可以看出，每次需要求定积分的函数是不一样的。可以编写一个求定积分的通用函数 integral它有个形参下限a上限b以及指向函数的指针变量 fun。 integral 函数原型可写为
float integral float a float b float fun float
分别定义个函数fffff代表上面个函数然后先后调用 integral 函数次每次调用时把ab以及一个函数名fffff之一
第章 善于利用指针
作为实参，即把上限、下限以及有关函数的入口地址传送给形参 fun。分别执行 integral函数，可以求出不同函数的定积分。请读者根据以上思路，编写出完整的程序。
指向函数的指针作为函数参数，是C语言实际应用中的一个比较深入的部分，本节只作很初步的介绍，使读者对此有一定的了解，为以后进一步的学习和应用打下初步的基础。
返回指针值的函数
一个函数可以返回一个整型值、字符值、实型值等，也可以返回指针型的数据，即地址。其概念与以前类似，只是返回的值的类型是指针类型而已。
例如“int a int x int y”a是函数名调用它以后能得到一个 int型指向整型数据的指针，即整型数据的地址。x和y是函数a的形参，为整型。
请注意在“a”两侧没有括号，在a的两侧分别为运算符和运算符。而优先级高于，因此a先与结合，显然这是函数形式。这个函数前面有一个，表示此函数是指针型函数函数值是指针。最前面的 int 表示返回的指针指向整型变量。
定义返回指针值的函数的原型的一般形式为：
类型名 函数名参数表列；
对初学C语言的人来说，这种定义形式可能不大习惯，容易弄错，使用时要十分小心。通过下面的例子可以初步了解怎样使用返回指针的函数。
【例】 有 a个学生，每个学生有b门课程的成绩。要求在用户输入学生序号以后，能输出该学生的全部成绩。用指针函数来实现。
解题思路：定义一个二维数组 score，用来存放学生成绩为简便，设学生数 a为，课程数b为。定义一个查询学生成绩的函数 search，它是一个返回指针的函数，形参是指向一维数组的指针变量和整型变量 n，从主函数将数组名 score和要找的学生号k传递给形参。函数的返回值是 scorek即存放序号为k的学生的序号为的课程的数组元素的地址。然后在主函数中输出该生的全部成绩。
编写程序：
include stdio h
int main
float search float pointer int n
函数声明
float p
int ik
printfenter the number of student
scanfdk 输入要找的学生的序号
printfThe scores of Nod arenk
p search scorek 调用 search 函数返回 scorek的地址
foriii
printfftpi 输出 scorek scorek的值
printfn
C程序设计第五版
return
float search float pointer int n 形参 pointer是指向一维数组的指针变量
float pt
pt pointern pt的值是 scorek
return pt
运行结果：
enter the number of student
The scores of No are
程序分析： 函数 search定义为指针型函数，它的形参 pointer 是指向包含个元素的一维数组的指针变量。 pointer指向 score数组序号为 的行学生序号是从号算起的见图。 pointer指向行列元素对 pointer加了“”号后，指针从行控制转化为列控制了。 search函数中的 pt是指针变量它指向 float型变量而不是指向一维数组。 main函数调用 search函数将 score数组首行地址传给形参 pointer注意 score也是指向行的指针，而不是指向列元素的指针。k是要查找的学生序号。调用 search函数后， main函数得到一个地址 scorek指向第k个学生第门课程，，赋给p。然后将此学生的门课程的成绩输出。注意p是指向 float型数据的指针变量，pi表示该学生第i门课程的成绩。
请注意指针变量 p pt 和 pointer的区别。如果将 search函数中的语句
pt pointern
改为
pt pointern
运行结果：
enter the number of student
The scores of No are
得到的不是第个学生的成绩，而是二维数组中 score开始的个元素的值。为什么 请读者分析。
【例】 对例中的学生，找出其中有不及格的课程的学生及其学生号。
解题思路：在例 程序基础上修改。 main函数不是只调用一次 search 函数，而是先后调用次 search 函数，在 search函数中检查个学生有无不及格的课程，如果有，就返回该学生的号课程的地址 scorei否则返回 NULL。在 main 函数中检查返回值输出有不及格学生门课的成绩。
第章 善于利用指针
编写程序：
include stdio h
int main
float score 定义数组存放成绩 float search float pointer函数声明
float p
int ij
foriii 循环次
p search scorei
调用 search函数如有不及格返回 scorei的地址否则返回 NULL
ifp scorei 如果返回的是 scorei的地址表示 p的值不是 NULL
printfNod scorei
forjjj
printffpj 输出 scorei scorei的值
printfn
return
float search float pointer 定义函数，形参 pointer是指向一维数组的指针变量
int i
float pt
ptNULL 先使 pt的值为 NULL
forii
if pointeri pt pointer 如果有不及格课程使 pt 指向 scorei return pt
运行结果：
No score
No score
程序分析：函数 search的作用是检查一个学生有无不及格的课程。在 search 函数中的 pointer 是指向一维数组有个元素的指针变量。 pt为指向 float 型变量的指针变量。从实参传给形参 pointer的是 scorei它是 score第i行的首地址见图a。
在 search函数中先使 ptNULL即 pt。用 pt 作为区分有无不及格课程的标志。若经检查门课中有不及格的就使 pt指向本行列元素即 pt scorei若无不及格则保持 pt的值为NULL见图b。将 pt返回 main函数。在 main函数中把调用 search得到的函数值指针变量 pt 的值赋给 p。用 if语句判断p是否等于 scorei若相等，表示所查的序号为i的学生有不及格课程p的值为scorei，即 p指向 i行列元素，就输出该学生有不及格课程的学生门课成绩。若无不及格，p的值是 NULL，不输出。
请读者仔细消化本例中指针变量的含义和用法。
C程序设计第五版
pt
pt
当有不及格时
当无不及格时
Ⅱ
Ⅱ
pointer
NULL
pointer
pointer
a
b
图
指针数组和多重指针
什么是指针数组
一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。下面定义一个指针数组：
int p
由于□比优先级高，因此p先与结合，形成p形式，这显然是数组形式，表示 p数组有个元素。然后再与p前面的“”结合， “”表示此数组是指针类型的，每个数组元素相当于一个指针变量都可指向一个整型变量。
注意不要写成
intp 这是指向一维数组的指针变量
定义一维指针数组的一般形式为
类型名数组名数组长度；
类型名中应包括符号“”，如“int ”表示是指向整型数据的指针类型。
什么情况下要用到指针数组呢 指针数组比较适合用来指向若干个字符串，使字符串处理更加方便灵活。例如，图书馆有若干本书，想把书名放在一个数组中见图a，然后要对这些书目进行排序和查询。按一般方法，字符串本身就是一个字符数组。因此要设计一个二维的字符数组才能存放多个字符串。但在定义二维数组时，需要指定列数，也就是说二维数组中每一行中包含的元素个数即列数相等。而实际上各字符串书名长度一般是不相等的。如按最长的字符串来定义列数，则会浪费许多内存单元，见图b。
可以分别定义一些字符串，然后用指针数组中的元素分别指向各字符串，如图c中所示 在 name中存放字符串Follow me的首字符的地址。 name中存放字符串BASIC的首字符的地址……如果想对字符串排序，不必改动字符串的位置，只须改动指针数组中各元素的指向即改变各元素的值，这些值是各字符串的首地址。这样，各字符串的长度可以不同，而且移动指针变量的值地址要比移动字符串所花的时间少得多。
【例】 将若干字符串按字母顺序由小到大输出。
第章 善于利用指针
字符串
Follow meBASIC Great WallFORTRAN Computer design
F o 。 w m e B A S I C G r e a t w a F O R T R A N C o m p u t e r d e sign
a b
name
指针数组
字符串
name
Follow me
name
BASIC
name
Great Wall
name
FORTRAN
name
Computer design
c
图
解题思路：定义一个指针数组 name，用各字符串对它进行初始化，即把各字符串中第个字符的地址赋给指针数组的各元素。然后用选择法排序，但不是移动字符串，而是改变指针数组的各元素的指向。
编写程序：
include stdio h
include string h
int main
void sort char name int n 函数声明
void print char name int n 函数声明
char name Follow me BASIC Great Wall FORTRAN Computer design
定义指针数组，它的元素分别指向个字符串
int n
sort namen 调用 sort函数，对字符串排序
print namen 调用 print函数，输出字符串
return
void sort char name int n 定义 sort函数
char temp
int ijk
foriini 用选择法排序
ki
forjijnj
if strcmp namek namej kj
ifki
C程序设计第五版
temp namei namei namek namek temp
void print char name int n 定义 print函数
int i
foriini
printfsn namei 按指针数组元素的顺序输出它们所指向的字符串
运行结果：
BASIC
Computer design
FORTRAN
Follow me
Great Wall
程序分析： 在 main函数中定义指针数组 name，它有个元素，其初值分别是Follow me BASIC Great Wall FORTRAN和Computer design这 个字符串的首字符的地址见图c。这些字符串是不等长的。
sort函数的作用是对字符串排序。 sort 函数的形参 name也是指针数组名，接受实参传过来的 name数组首元素即 name的地址因此形参 name数组和实参 name数组指的是同一数组。用选择法对字符串排序。 strcmp是系统提供的字符串比较函数， namek和 namej是第k个和第j个字符串首字符的地址。 strcmp namek namej的值为如果 namek所指的字符串大于 namej所指的字符串，则此函数值为正值；若相等，则函数值为；若小于，则函数值为负值。 if语句的作用是将两个串中“小”的那个串的序号k或j之一保留在变量k中。当执行完内循环 for语句后，从第i串到第 n串这些字符串中，第k串最“小”。若k≠i就表示最小的串不是第 i串。故将 namei和 namek对换也就是将指向第i个字符串的数组元素是指针型元素的值与指向第k个字符串的数组元素的值对换，也就是把它们的指向互换。执行完 sort 函数后指针数组的情况如图 所示。
name
FORTRAN
print函数的作用是输出各字符串。 name name分别是各字符串按从小到大顺序排好序的各字符串的首字符的地址按字符串从小到大顺序， name指向最小的串，用“s”格式符输出，就得到
name
Computer design
图
这些字符串。
注意： sort函数中的第一个 if 语句中的逻辑表达式的正确用法。不能写成以下形式：
if namek namej kj
这样只比较 namek和 namej所指向的字符串中的第个字符。字符串比较应当用 strcmp函数。
第章 善于利用指针
程序改进：
print函数也可改写为以下形式：
void print char name int n
int i
char p
p name
whilein
p namei
printfsnp
其中 “ namei”表示先求 namei的值即 namei它是一个地址然后使i加。在输出时，按字符串形式输出从 p地址开始的字符串。
指向指针数据的指针变量
在了解了指针数组的基础上，需要了解指向指针数据的指针变量，简称为指向指针的指针。从图可以看到， name是一个指针数组，它的每一个元素是一个指针型的变量，其值为地址。 name既然是一个数组，它的每一元素都应有相应的地址。数组名 name 代表该指针数组首元素的地址。 namei是 namei的地址。 namei就是指向指针型数据的指针。还可以设置一个指针变量 p，它指向指针数组的元素见图。p就是指向指针型数据的指针变量。
怎样定义一个指向指针数据的指针变量呢 下面定义一个指向指针数据的指针变量：
char p
p的前面有两个号。从附录C可以知道，运算符的结合性是从右到左，因此p相当于p，显然p是指针变量的定义形式。如果没有最前面的，那就是定义了一个指向字符数据的指针变量。现在它前面又有一个号，即char p。可以把它分为两部分看，即 char和p后面的p表示 p是指针变量前面的 char表示 p指向的是 char型的数据。也就是说，p指向一个字符指针变量这个字符指针变量指向一个字符型数据。如果引用p，就得到p所指向的字符指针变量的值，如果有：
p name
printfdnp
printfsnp
第个 printf函数语句输出 name的值它是一个地址第个 printf函数语句以字符串形式s输出字符串Great Wall。
【例】 使用指向指针数据的指针变量。
解题思路：定义一个指针数组 name，并对它初始化，使 name数组中每一个元素分别指
C程序设计第五版
向个字符串。定义一个指向指针型数据的指针变量 p，使p先后指向 name 数组中各元素，输出这些元素所指向的字符串。
编写程序：
include stdio h
int main
char nameFollow me BASIC Great Wall FORTRAN Computer design
charp
int i
foriii
p namei
printfsnp
return
运行结果：
Follow me
BASIC
Great Wall
FORTRAN
Computer design
程序分析： p是指向 char型数据的指针变量，即指向指针的指针。在第次执行 for循环体时，赋值语句”使 p 指向 name 数组的 号元素 name p是 name的值，即第个字符串首字符的地址，用 printf函数输出第个字符串格式符为s。执行次循环体，依次输出个字符串。
指针数组
整型数组
说明： 指针数组的元素也可以不指向字符串，而指向整型数据或实型数据等，例如：
num
a
p
num
a
int a
num
a
int numi
num
a
intp p是指向 int型数据的指针变量
num
a
foriii
numiai
图
为了得到a中的数据可以先使 p num然后输出p。注意p是 num的值而 num的值是a的地址因此p是a的值见图。
【例】 有一个指针数组，其元素分别指向一个整型数组的元素，用指向指针数据的指针变量，输出整型数组各元素的值。这是一个简单例子，目的是为了说明它的用法。
include stdio h
int main
int a
int numaaaaa
int pi p是指向指针型数据的指针变量
第章 善于利用指针
p num 使 p指向 num
foriii
printfdp
p
printfn
return
运行结果：
程序分析： 程序中定义p是指向指针型数据的指针变量，开始时指向指针数组 num的首元素 num，而num是一个指针型的元素，它指向整型数组a的首元素 a。开始时p的值是 nump是 num的值即ap是a的值。因此第个输出的是a的值。然后执行pp就指向 num再输出p就是a的值了。
请不要把第和第行错写为
int num
指针数组的元素只能存放地址，不能存放整数。
读者可在此例基础上实现对各数排序。
在本章开头已经提到了“间接访问”变量的方式。利用指针变量访问另一个变量就是“间接访问”。如果在一个指针变量中存放一个目标变量的地址，这就是“单级间址”，见图a。指向指针数据的指针用的是“二级间址”方法，见图b。从理论上说，间址方法可以延伸到更多的级，即多重指针，见图c。但实际上在程序中很少有超过二级间址的。级数愈多，愈难理解，容易产生混乱，出错机会也多。
指针变量
变量
地址
值
a
指针变量
指针变量
变量
地址
地址
值
b
指针变量
指针变量
指针变量n
变量
地址
地址
地址n
值
c
图
指针数组作 main 函数的形参
指针数组的一个重要应用是作为 main函数的形参。在以往的程序中， main 函数的第
C程序设计第五版
行一般写成以下形式：
int main
或
int main void
括号中是空的或有“void”，表示 main函数没有参数，调用 main 函数时不必给出实参。这是一般程序常采用的形式。实际上，在某些情况下， main函数可以有参数，即：
int main int argc char argv
其中 argc和 argv就是 main 函数的形参它们是程序的“命令行参数”。 argc argument count的缩写意思是参数个数 argv argument vector缩写意思是参数向量它是一个 char指针数组，数组中每一个元素其值为指针指向命令行中的一个字符串的首字符。
注意： 如果用带参数的 main函数，其第一个形参必须是 int型，用来接收形参个数，第二个形参必须是字符指针数组，用来接收从操作系统命令行传来的字符串中首字符的地址。
通常 main函数和其他函数组成一个文件模块，有一个文件名。对这个文件进行编译和连接，得到可执行文件后缀为 exe。用户执行这个可执行文件，操作系统就调用 main函数，然后由 main函数调用其他函数，从而完成程序的功能。
什么情况下 main函数需要参数 main函数的形参是从哪里传递给它们的呢 显然形参的值不可能在程序中得到。 main函数是操作系统调用的，实参只能由操作系统给出。在操作命令状态下，实参是和执行文件的命令一起给出的。例如在 DOS，UNIX 或 Linux等系统的操作命令状态下，在命令行中包括了命令名和需要传给 main函数的参数。
命令行的一般形式为
命令名 参数 参数…参数n
命令名和各参数之间用空格分隔。命令名是可执行文件名此文件包含 main函数，假设可执行文件名为 filel exe今想将两个字符串China Beijing作为传送给 main 函数的参数。命令行可以写成以下形式：
file l China Beijing
file为可执行文件名 China 和 Beijing是调用 main函数时的实参。实际上文件名应包括盘符、路径，今为简化起见，用f ile 来代表。
请注意以上参数与 main函数中形参的关系。 main 函数中形参 argc是指命令行中参数的个数注意，文件名也作为一个参数。例如，本例中“file ”也算一个参数，现在，argc的值等于有个命令行参数 file China Beijing。 main函数的第个形参 argv是一个指向字符串的指针数组，也就是说，带参数的 main函数原型是：
int main int argc char argv
命令行参数必须都是字符串例如上面命令行中的filel China Beijing都是字符串，这些字符串的首地址构成一个指针数组，见图。
指针数组 argv中的元素 argv指向字符串file的首字符或者说 argv的值是字符串file的首地址 argv指向字符串China的首字符 argv指向字符串Beijing的
第章 善于利用指针
argv
argv
f
i
e
l
argv
C
h
i
n
a
argv
B
e
i
j
i
n
g
图
首字符。
如果有一个名为 file l 的文件，它包含以下的 main函数：
int main int argc char argv
while argc
argv
printfsn argv
—— argc
return
在 Visual C环境下对程序编译和连接后，选择“工程”→“设置”→“调试”→“程序变量”命令输入China Beijing再运行程序将会输出以下信息
China
Beijing
上面 main函数可以改写为
int main int argc char argv
while argc
printfsn argv
其中 “ argv”是先进行 argv的运算使 argv指向下一个元素然后进行的运算，找到 argv当前指向的字符串，输出该字符串。在开始时， argv指向字符串filel， argv使之指向China所以第次输出的是China第 次输出Beijing。
许多操作系统提供了 echo命令，它的作用是实现“参数回送”，即将 echo后面的各参数各字符串在同一行上输出。实现“参数回送”的C程序文件名为 echo c如下：
include stdio h
int main int argc char argv
whileargc 当命令行的参数多于
printfsc argv argcn 从第个参数开始输出各字参数字符串
return
如果用 UNIX 系统的命令行输入：
echo Computer and C Language↓ echo是可执行的文件名
C程序设计第五版
会在显示屏上输出：
Computer and C Language
这个程序与前面的差别在于①将 while语句中的 argc改为argc作用显然是一样的。②当 argc时，在输出的两个字符串间输出一个空格，当 argc时输出一个换行。程序不输出命令名echo。
为便于理解， echo程序也可写成以下形式：
include stdio h
int main int argc char argv
int i
forii argci
printfsc argvii argcn
return
其实， main函数中的形参不一定命名为 argc和 argv，可以是任意的名字，只是人们习惯用 argc 和 argv而已。
利用指针数组作 main函数的形参，可以向程序传送命令行参数这些参数是字符串，这些字符串的长度事先并不知道，而且各参数字符串的长度一般并不相同，命令行参数的数目也是可以任意的。用指针数组能够较好地满足上述要求。
关于指向指针的指针是C语言中比较深入的概念，在此只作简单的介绍，以便为读者提供今后进一步学习的基础。
动态内存分配与指向它的指针变量
什么是内存的动态分配
第章介绍过全局变量和局部变量，全局变量是分配在内存中的静态存储区的，非静态的局部变量包括形参是分配在内存中的动态存储区的，这个存储区是一个称为栈 stack的区域。除此以外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆 heap区。可以根据需要，向系统申请所需大小的空间。由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。
怎样建立内存的动态分配
对内存的动态分配是通过系统提供的库函数来实现的，主要有 malloc， calloc， free， realloc这个函数。
用 malloc函数开辟动态存储区
其函数原型为
第章 善于利用指针
void malloc unsigned int size
其作用是在内存的动态存储区中分配一个长度为 size的连续空间。形参 size的类型定为无符号整型不允许为负数。此函数的值即“返回值”是所分配区域的第一个字节的地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的第一个字节。如：
malloc 开辟字节的临时分配域，函数值为其第个字节的地址
注意指针的基类型为 void，即不指向任何类型的数据，只提供一个纯地址。如果此函数未能成功地执行例如内存空间不足，则返回空指针NULL。
用 calloc函数开辟动态存储区
其函数原型为
void calloc unsigned n unsigned size
其作用是在内存的动态存储区中分配n个长度为 size的连续空间，这个空间一般比较大，足以保存一个数组。
用 calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是动态数组。函数返回指向所分配域的第一个字节的指针；如果分配不成功，返回 NULL。如
p calloc 开辟×个字节的临时分配域，把首地址赋给指针变量p
用 realloc函数重新分配动态存储区
其函数原型为
void realloc void p unsigned int size
如果已经通过 malloc函数或 calloc函数获得了动态空间，想改变其大小，可以用 recalloc函数重新分配。
用 realloc函数将 p 所指向的动态空间的大小改变为 size。p的值不变。如果重分配不成功返回 NULL。如
reallocp 将p所指向的已分配的动态空间改为字节
用 free函数释放动态存储区
其函数原型为
void free void p
其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用 calloc或 malloc函数时得到的函数返回值。如：
freep 释放指针变量 p所指向的已分配的动态空间
free函数无返回值。
以上个函数的声明在 stdlib h 头文件中，在用到这些函数时应当用“ include stdlib h”指令把 stdlib h头文件包含到程序文件中。
C程序设计第五版
void 指针类型
C允许使用基类型为 void的指针类型。可以定义一个基类型为 void 的指针变量即 void型变量，它不指向任何类型的数据。请注意：不要把“指向 void类型”理解为能指向“任何的类型”的数据，而应理解为“指向空类型”或“不指向确定的类型”的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。例如：
int a 定义a为整型变量
int pa pl 指向 int型变量
char p p指向 char型变量
void p p为无类型指针变量基类型为 void型
p void p 将p的值转换为 void类型然后赋值给 p
p charp 将p的值转换为 char类型，然后赋值给p
printfd p 合法，输出整型变量a的值
pa printfd p 错误，p是无指向的，不能指向a
说明： 前已说明，地址应包含基类型的信息，即存放在以此地址标志的存储单元中的数据的类型，否则无法实现对数据的存取。现在为什么又允许用 void类型的指针呢这种指针没有指向。显然，在这种无指向的地址所标志的存储单元中是不能存储任何数据的，也就是说，无法通过这种地址对内存存取数据。
那么，什么情况下会用到这种地址呢 在本节可以看到，这种情况是在调用动态存储分配函数如 maloc， caloc， realoc函数时出现的。用户用这些函数开辟动态存储区，显然希望获得此动态存储区的起始地址，以便利用该动态存储区。在以前的C版本包括C中，函数返回的地址一律指向字符型数据，即得到 char型指针。例如 malloc函数的原型为：
char malloc unsigned int size
但是，人们开辟的动态存储区并不是一定用来存放字符型数据的，例如想用来存放一批整型型据。为此，在向该存储区存放整型数据前就需要进行地址的类型转换，如：
pt int malloc 假设已定义 int pt
系统会将指向字符数据的指针转换为指向整型数据的指针，然后赋给 pt。这样pt就指向存储区的首字节，可以通过 pt对该动态存储区进行存取操作。要说明的是： 上面的类型转换只是产生一个临时的中间值赋给了 pt，但没有改变 malloc函数本身的类型。
可以看到： 在上面的处理中，程序只利用了该函数带回来的纯地址，并没有用到指向字符型数据这一属性。既然用不到，又何必作此规定呢 C对此作了修改，这些函数不是返回 char指针，而是使其“无指向”，函数返回 void指针。这种指针称为“空类型指针 typeless pointer”，它不指向任一种具体的类型数据，只提供一个纯地址。这是C有关地址应用的一种特殊情况。
要注意的是：这种空类型指针在形式上和其他指针一样，遵循C语言对指针的有关规定，它也有基类型，只是它的基类型是 void。可以这样定义：
void p 定义p是 void型的指针变量
第章 善于利用指针
void型指针代表“无指向的地址”，这种指针不指向任何类型的数据。不能企图通过它存取数据，在程序中它只是过渡性的，只有转换为有指向的地址，才能存取数据。
C这样处理，更加规范，更容易理解，概念也更清晰。
现在所用的一些编译系统在进行地址赋值时，会自动进行类型转换。例如：
int pt
pt int mcaloc mcaloc是 void型把它转换为 int型
可以简化为
pt mcaloc 自动进行类型转换
赋值时 系统会先把 mcaloc转换为的 pt的类型即 int型然后赋给 pt这样 pt 就指向存储区的首字节，在其指向的存储单元中可以存放整型数据。
通过下面这个简单的程序可以初步了解怎样建立内存动态分配区和使用 void 指针。
【例】 建立动态数组，输入个学生的成绩，另外用一个函放数检查其中有无低于分的，输出不合格的成绩。
解题思路：用malloc函数开辟一个动态自由区域，用来存个学生的成绩，会得到这个动态域第个字节的地址，它的基类型是 void型。用一个基类型为 int 的指针变量 p来指向动态数组的各元素，并输出它们的值。但必须先把 malloc函数返回的void 指针转换为整型指针，然后赋给 p。
编写程序：
include stdio h
include stdlib h 程序中用了 malloc函数应包含 stdlib h
int main
void check int 函数声明
intpi p是 int型指针
p int malloc sizeof int开辟动态内存区将地址转换成 int 型然后放在 pl中
foriii
scanfdpi 输入个学生的成绩
checkp 调用 check函数
return
void check int p 定义 check函数形参是 int指针
int i
printfThey are fail
foriii
ifpi printfdpi 输出不合格的成绩
printfn
运行结果：
They are fail
C程序设计第五版
程序分析： 在程序中没有定义数组，而是开辟一段动态自由分配区，作为动态数组使用。在调用 malloc函数时没有给出具体的数值，而是用 sizeof int，因为有个学生的成绩，每个成绩是一个整数，但在不同的系统中存放一个整数的字节数是不同的，为了使程序具有通用性，故用 sizeof运算符测定在本系统中整数的字节数。调用 malloc函数的返回值是 void型的，要把它赋给 pl，应先进行类型转换，把该指针转换成 int型。用 for循环输入个学生的成绩，注意不是用数组名，而是按地址法计算出相应的存储单元的地址，然后分别赋值给动态数组的个元素。开始时 pl指向第个整型数据， pl指向第个整型数据……调用 check函数时把 pl的值传给形参p，因此形参p也指向动态区的第个数据，可以认为形参数组与实参数组共享同一段动态分配区。都在 check 函数中，用下标形式使用指针变量 p，逐个检查个数据，输出不合格的成绩。最后用 free函数释放动态分配区。
实际上，第行可以直接写成
pl malloc sizeof int pl为整型指针，自动转换
因为在进行编译时，系统可以自动进行隐式的转换，而不必人为地进行显式的强制类型转换。但是有的程序员仍然习惯于进行显式的强制转换他们认为这样规范、清晰。因此，读者应当知道转换的方法，能看懂别人的程序。
内存的动态分配主要应用于建立程序中的动态数据结构如链表中，在第章中将会看到对其的实际应用。
有关指针的小结
由于指针一章介绍的内容较多，指针的概念和应用比较复杂，初学者不易掌握，为了帮助读者建立清晰的概念，本节对有关指针的知识和应用作简单的归纳小结。
首先要准确理解指针的含义。“指针”是C语言中一个形象化的名词，形象地表示“指向”的关系，其在物理上的实现是通过地址来完成的。正如高级语言中的“变量”，在物理上是“命名的存储单元”。 Windows中的“文件夹”实际上是“目录”。离开地址就不可能弄清楚什么是指针。明确了“指针就是地址”，就比较容易理解了，许多问题也迎办而解了。例如：
· a是变量a的地址，也可称为变量a的指针。
· 指针变量是存放地址的变量，也可以说，指针变量是存放指针的变量。
· 指针变量的值是一个地址，也可以说，指针变量的值是一个指针。
· 指针变量也可称为地址变量，它的值是地址。
·是取地址运算符，a是a的地址，也可以说，是取指针运算符。a是变量a的指针即指向变量a的指针。
·数组名是一个地址，是数组首元素的地址，也可以说，数组名是一个指针，是数组首元素的指针。
·函数名是一个指针指向函数代码区的首字节，也可以说函数名是一个地址函数代码区首字节的地址。
· 函数的实参如果是数组名，传递给形参的是一个地址，也可以说，传递给形参的是一个指针。
第章 善于利用指针
在C语言中，所有的数据都是有类型的，例如常量 并不是数学中的常数，数学中的是没有类型的，和是一样的，而在C语言中，所有数据都要存储在内存的存储单元中，若写成，则认为是整数，按整型的存储形式存放，如果写成，则认为是单精度实数，按单精度实型的存储形式存放。此外，不同类型数据有不同的运算规则。可以说，C语言中的数据都是“有类型的数据”，或称“带类型的数据”。
对地址而言，也是同样的，它也有类型，首先，它不是一个数值型数据，不是按整型或浮点型方式存储，它是按指针型数据的存储方式存储的虽然在 VisualC中也为指针变量分配个字节，但不同于整型数据的存储形式。指针型存储单元是专门用来存放地址的，指针型数据的存储形式就是地址的存储形式。
其次，它不是一个简单的纯地址，还有一个指向的问题，也就是说它指向的是哪种类型的数据。如果没有这个信息，是无法通过地址存取存储单元中的数据的。所以，一个地址型的数据实际上包含个信息：
① 表示内存编号的纯地址。
②它本身的类型，即指针类型。
③以它为标识的存储单元中存放的是什么类型的数据，即基类型。
例如：已知变量为a为 int型，a为a的地址，它就包括以上个信息，它代表的是一个整型数据的地址， int是a的基类型即它指向的是 int型的存储单元。可以把②和③两项合成一项，如“指向整型数据的指针类型”或“基类型为整型的指针类型”，其类型可以表示为“int”型。这样，对地址数据来说，也可以说包含两个要素： 内存编号纯地址和类型指针类型和基类型。这样的地址是“带类型的地址”而不是纯地址。
要区别指针和指针变量。指针就是地址，而指针变量是用来存放地址的变量。有人认为指针是类型名，指针的值是地址。这是不对的。类型是没有值的，只有变量才有值，正确的说法是指针变量的值是一个地址。不要杜撰出“地址的值”这样莫须有的名词。地址本身就是一个值。
什么叫“指向” 地址就意味着指向，因为通过地址能找到具有该地址的对象。对于指针变量来说，把谁的地址存放在指针变量中，就说此指针变量指向谁。但应注意： 并不是任何类型数据的地址都可以存放在同一个指针变量中的，只有与指针变量的基类型相同的数据的地址才能存放在相应的指针变量中。例如：
int ap p是int×型的指针变量，基类型是 int型
float b
pa a是 int 型合法
pb b是 float 型类型不匹配
既然许多数据对象如变量、数组、字符串和函数等都在内存中被分配存储空间，就有了地址，也就有了指针。可以定义一些指针变量，分别存放这些数据对象的地址，即指向这些对象。
void 指针是一种特殊的指针，不指向任何类型的数据。如果需要用此地址指向某类型的数据，应先对地址进行类型转换。可以在程序中进行显式的类型转换，也可以由编译系统自动进行隐式转换。无论用哪种转换，读者必须了解要进行类型转换。
要深入掌握在对数组的操作中正确地使用指针，搞清楚指针的指向。一维数组名代表数组首元素的地址，如：
C程序设计第五版
int pa
pa
p是指向 int型类型的指针变量，显然，p只能指向数组中的元素 int型变量，而不是指向整个数组。在进行赋值时一定要先确定赋值号两侧的类型是否相同，是否允许赋值。
对“pa” 准确地说应该是： p指向a数组的首元素，在不引起误解的情况下，有时也简称为： p指向a数组，但读者对此应有准确的理解。同理，p指向字符串，也应理解为p 指向字符串中的首字符。
有关指针变量的归纳比较，见表。
表指针变量的类型及含义
变量定义 类型表示 含 义 int i int 定义整型变量i int p int 定义 p为指向整型数据的指针变量 int a int 定义整型数组 a，它有个元素 int p int 定义指针数组 p，它由个指向整型数据的指针元素组成 int p int p为指向包含 个元素的一维数组的指针变量 int f int f为返回整型函数值的函数 int p int p为返回一个指针的函数，该指针指向整型数据 int p int p为指向函数的指针，该函数返回一个整型值 int p int p是一个指针变量，它指向一个指向整型数据的指针变量 void p void p是一个指针变量，基类型为 void空类型，不指向具体的对象
为便于比较，在表中包括了其他一些类型的定义。
指针运算。
① 指针变量加减一个整数。
例如 pppipipipi 等均是指针变量加减一个整数。
将该指针变量的原值是一个地址和它指向的变量所占用的存储单元的字节数相加减。
②指针变量赋值。
将一个变量地址赋给一个指针变量。例如：
pa 将变量a的地址赋给p
a
p array 将数组 array首元素地址赋给 p
p
a
p arrayi 将数组 array第i个元素的地址赋给p
a
p max max为已定义的函数，将 max的入口地址赋给 p
a
plp p和 p是基类型相同指针变量，将p 的值赋给 pl
p
a
注意： 不应把一个整数赋给指针变量。
a
③ 两个指针变量可以相减。
a
如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之
图
第章 善于利用指针
差是两个指针之间的元素个数，见图。
④两个指针变量比较。
若两个指针指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量“小于”指向后面元素的指针变量。如果 p和p 不指向同一数组则比较无意义。
指针变量可以有空值，即该指针变量不指向任何变量，可以这样表示：
pNULL
其中，NULL是一个符号常量，代表整数。在 stdio h头文件中对 NULL 进行了定义：
define NULL
它使p指向地址为的单元。系统保证使该单元不作它用不存放有效数据。
应注意，p的值为 NULL 与未对p赋值是两个不同的概念。前者是有值的值为，不指向任何变量，后者虽未对p赋值但并不等于 p无值，只是它的值是一个无法预料的值，也就是p可能指向一个事先未指定的单元。这种情况是很危险的。因此，在引用指针变量之前应对它赋值。
任何指针变量或地址都可以与 NULL 作相等或不相等的比较，例如：
ifpNULL…
本章介绍了指针的基本概念和初步应用。指针是C语言中很重要的概念，是C的一个重要特色。使用指针的优点：①提高程序效率；②在调用函数时当指针指向的变量的值改变时，这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值；③可以实现动态存储分配。
同时应该看到，指针使用实在太灵活，对熟练的程序人员来说，可以利用它编写出颇有特色、质量优良的程序，实现许多用其他高级语言难以实现的功能，但也十分容易出错，而且这种错误往往比较隐蔽。指针运用的错误可能会使整个程序遭受破坏，比如由于未对指针变量p赋值就向p赋值，就可能破坏了有用的单元的内容。如果使用指针不当，会出现隐蔽的、难以发现和排除的故障。因此，使用指针要十分小心谨慎，要多上机调试程序，以弄清一些细节，并积累经验。
习 题
本章习题均要求用指针方法处理。
输入个整数，按由小到大的顺序输出。
输入个字符串，按由小到大的顺序输出。
输入个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。写个函数：①输入个数；②进行处理；③输出个数。
nm
m
有n个整数，使前面各数顺序向后移 m个位置，最后 m 个数变成最前面m个数，见图。写一函数实现以上功能，在主函数中输入 n个整数和输出调整后的n个数。
有n个人围成一圈，顺序排号。从第个人开始报数
图
C程序设计第五版
从到报数，凡报到的人退出圈子，问最后留下的是原来第几号的那位。
写一函数，求一个字符串的长度。在main函数中输入字符串，并输出其长度。
有一字符串，包含n个字符。写一函数，将此字符串中从第 m个字符开始的全部字符复制成为另一个字符串。
输入一行文字，找出其中大写字母、小写字母、空格、数字以及其他字符各有多少。
写一函数，将一个×的整型矩阵转置。
将一个×的矩阵中最大的元素放在中心，个角分别放个最小的元素顺序为从左到右，从上到下依次从小到大存放，写一函数实现之。用main函数调用。
在主函数中输入个等长的字符串。用另一函数对它们排序。然后在主函数输出这个已排好序的字符串。
用指针数组处理上一题目，字符串不等长。
写一个用矩形法求定积分的通用函数，分别求
∫。 sinxdx ∫。 cosxdx ∫e dx
说明 sin cos exp函数已在系统的数学函数库中程序开头要用 include math h。
将n个数按输入时顺序的逆序排列，用函数实现。
有一个班个学生，门课程。①求第门课程的平均分；②找出有两门以上课程不及格的学生，输出他们的学号和全部课程成绩及平均成绩；③找出平均成绩在分以上或全部课程成绩在分以上的学生。分别编个函数实现以上个要求。
输入一个字符串，内有数字和非数字字符，例如：
Ax tab
将其中连续的数字作为一个整数，依次存放到一数组a中。例如，放在a，放在a……统计共有多少个整数，并输出这些数。
写一函数，实现两个字符串的比较。即自己写一个 strcmp函数，函数原型为
int strcmp char p char p
设 pl指向字符串sp指向字符串s。要求当ss时返回值为若sl≠s返回它们二者第个不同字符的ASCⅡ码差值如BOY与BAD，第个字母不同，O与 A 之差为。如果ss则输出正值如果ss则输出负值。
编一程序，输入月份号，输出该月的英文月名。例如，输入，则输出March，要求用指针数组处理。
编写一个函数 new，对n个字符开辟连续的存储空间，此函数应返回一个指针地址，指向字符串开始的空间。 newn表示分配n个字节的内存空间。
写一函数 free将前面用 new函数占用的空间释放。 freep表示将p地址指向的单元以后的内存段释放。
用指向指针的指针的方法对个字符串排序并输出。
用指向指针的指针的方法对n个整数排序并输出。要求将排序单独写成一个函数。n个整数在主函数中输入，最后在主函数中输出。
第章 用户自己建立数据类型
C语言提供了一些由系统已定义好的数据类型，如： int， float， char等，用户可以在程序中用它们定义变量，解决一般的问题，但是人们要处理的问题往往比较复杂，只有系统提供的类型还不能满足应用的要求，C语言允许用户根据需要自己建立一些数据类型，并用它来定义变量。
定义和使用结构体变量
自己建立结构体类型
在前面所见到的程序中，所用的变量大多数是互相独立、无内在联系的。例如定义了整型变量a，b，c，它们都是单独存在的变量，在内存中的地址也是互不相干的，但在实际生活和工作中，有些数据是有内在联系的，成组出现的。例如，一个学生的学号、姓名、性别、年龄、成绩、家庭地址等项，是属于同一个学生的，见图。可以看到性别 sex、年龄age、成绩 score、地址 addr是属于学号为 和名为 Li Fang 的学生的。如果将 num name sex age score和 addr分别定义为互相独立的简单变量难以反映它们之间的内在联系。人们希望把这些数据组成一个组合数据，例如定义一个名为 student 的变量，在这个变量中包括学生的学号、姓名、性别、年龄、成绩、家庭地址等项。这样，使用起来就方便多了。
num name sex age score addr
Li Fang M Beijing
图
有人可能想到数组，能否用一个数组来存放这些数据呢 显然不行，因为一个数组中只能存放同一类型的数据。例如整型数组可以存放学号或成绩，但不能存放姓名、性别、地址等字符型的数据。C语言允许用户自己建立由不同类型数据组成的组合型的数据结构，它称为结构体 structure。在其他一些高级语言中称为“记录” record。
如果程序中要用到图所表示的数据结构，可以在程序中自己建立一个结构体类型。例如：
struct Student
int num 学号为整型
char name 姓名为字符串
char sex 性别为字符型
int age 年龄为整型
float score 成绩为实型
C程序设计第五版
char addr 地址为字符串
注意最后有一个分号
上面由程序设计者指定了一个结构体类型 struct Student struct 是声明结构体类型时必须使用的关键字，不能省略①，经过上面的指定， struct Student 就是一个在本程序中可以使用的合法类型名，它向编译系统声明：这是一个“结构体类型”，它包括 num， name，sex， age score addr等不同类型的成员。它和系统提供的标准类型如 int char float double等具有相似的作用，都可以用来定义变量，只不过 int等类型是系统已声明的，而结构体类型是由用户根据需要在程序中指定的。
声明一个结构体类型的一般形式为
struct 结构体名
成员表列；
注意：结构体类型的名字是由一个关键字 struct 和结构体名组合而成的例如 struct Student。结构体名是由用户指定的又称“结构体标记” structure tag以区别于其他结构体类型。上面的结构体声明中 Student就是结构体名结构体标记。
花括号内是该结构体所包括的子项，称为结构体的成员 member。上例中的 num，name， sex等都是成员。对各成员都应进行类型声明，即
类型名 成员名；
“成员表列” member list也称为“域表” field list每一个成员是结构体中的一个域。成员名命名规则与变量名相同。
说明：
结构体类型并非只有一种，而是可以设计出许多种结构体类型，例如除了可以建立上面的 struct Student 结构体类型外还可以根据需要建立名为 struct Teacher struct Worker 和 struct Date等结构体类型各自包含不同的成员。
成员可以属于另一个结构体类型。例如：
struct Date 声明一个结构体类型 struct Date
int month 月
int day 日
int year 年
struct Student 声明一个结构体类型 struct Student
int num
char name
char sex
int age
struct Date birthday 成员 birthday属于 struct Date类型
char addr
① 在本书中将结构体名、共用体名和枚举名的第个字母用大写表示，以表示和系统提供的类型相区别。这不是规定，只是常用的习惯。
第章 用户自己建立数据类型
先声明一个 struct Date类型它代表“日期”包括个成员 month月、 day日、 year年。然后在声明 struct Student类型时将成员 birthday指定为 struct Date类型。 struct Student的结构如图所示。已声明的类型 struct Date与其他类型如 int char一样可以用来声明成员的类型。
num name sex age birthday addr month day year
图
定义结构体类型变量
前面只是建立了一个结构体类型，它相当于一个模型，并没有定义变量，其中并无具体数据，系统对之也不分配存储单元。相当于设计好了图纸，但并未建成具体的房屋。为了能在程序中使用结构体类型的数据，应当定义结构体类型的变量，并在其中存放具体的数据。可以采取以下种方法定义结构体类型变量。
先声明结构体类型，再定义该类型的变量
在节的开头已声明了一个结构体类型 struct Student，可以用它来定义变量。例如：
struct Student studentstudent
结构体类型名
结构体变量名
这种形式和定义其他类型的变量形式如 int a，b；是相似的。上面定义了 studentl和student为 struct Student类型的变量这样 student 和 student就具有 struct Student类型的结构，如图所示。
studentl
Zhang Xin
M
Shanghai
student
Wang Li
F
Beijing
图
在定义了结构体变量后，系统会为之分配内存单元。根据结构体类型中包含的成员情况在 Visual C中占个字节①。
这种方式是声明类型和定义变量分离，在声明类型后可以随时定义变量，比较灵活。
① 计算机对内存的管理是以“字”为单位的许多计算机系统以个字节为一个“字”。如果在一个“字”中只存放了一个字符，虽然只占一个字节，但该“字”中的其他个字节不会接着存放下一个数据，而会从下一个“字”开始存放其他数据。因此在用 sizeof运算符测量 studentl 的长度时，得到的不是理论值，而是，是的倍数。不同的编译系统对结构体变量在内存中分配空间有不同的规定。
C程序设计第五版
在声明类型的同时定义变量
例如：
struct Student
int num
char name
char sex
int age
float score
char addr
studentlstudent
它的作用与第一种方法相同，但是在定义 struct Student 类型的同时定义两个 struct Student 类型的变量 student和 student。这种定义方法的一般形式为
struct 结构体名
成员表列
变量名表列；
声明类型和定义变量放在一起进行，能直接看到结构体的结构，比较直观，在写小程序时用此方式比较方便，但写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以使程序结构清晰，便于维护，所以一般不多用这种方式。
不指定类型名而直接定义结构体类型变量
其一般形式为
struct
成员表列
变量名表列；
指定了一个无名的结构体类型 ，它没有名字不出现结构体名。显然不能再以此结构体类型去定义其他变量。这种方式用得不多。
说明：
结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。
结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。例如程序中可以另定义一个变量 num它与 struct Student 中的 num是两回事互不干扰。
对结构体变量中的成员即“域”，可以单独使用，它的作用与地位相当于普通变量。关于对成员的引用方法见下节。
结构体变量的初始化和引用
在定义结构体变量时，可以对它初始化，即赋予初始值。然后可以引用这个变量，例如
第章 用户自己建立数据类型
输出它的成员的值。
【例】 把一个学生的信息包括学号、姓名、性别、住址放在一个结构体变量中，然后输出这个学生的信息。
解题思路：先在程序中自己建立一个结构体类型，包括有关学生信息的各成员。然后用它来定义结构体变量，同时赋予初值学生的信息。最后输出该结构体变量的各成员即该学生的信息。
编写程序：
include stdio h
int main
struct Student 声明结构体类型 struct Student
long int num 以下行为结构体的成员
char name
char sex
char addr
a Li LinM Beijing Road 定义结构体变量a并初始化
printfNO ld nnames nsexc naddresssna numa namea sexa addr
return
运行结果：
NO
name Li Lin
sexM
address Beijing Road
程序分析： 程序中声明了一个结构体名为 Student的结构体类型，有个成员。在声明类型的同时定义了结构体变量a，这个变量具有 struct Student类型所规定的结构。在定义变量的同时，进行初始化。在变量名a后面的花括号中提供了各成员的值，将，Li LinM Beijing Road按顺序分别赋给 a 变量中的成员 num name 数组 sex addr数组。最后用 printf函数输出变量中各成员的值。a num表示变量a中的 num成员同理a name代表变量a中的 name成员。
在定义结构体变量时可以对它的成员初始化。初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。注意：是对结构体变量初始化，而不是对结构体类型初始化。
C标准允许对某一成员初始化，如：
struct Student b nameZhang Fang 在成员名前有成员运算符””
“ name”隐含代表结构体变量b中的成员 b name。其他未被指定初始化的数值型成员被系统初始化为，字符型成员被系统初始化为，指针型成员被系统初始化为 NULL。
可以引用结构体变量中成员的值，引用方式为
结构体变量名成员名
例如已定义了 studentl为 student类型的结构体变量则 student num表示 studentl变
C程序设计第五版
量中的 num 成员即 student的 num学号成员。
在程序中可以对变量的成员赋值，例如：
studentl num
“”是成员运算符，它在所有的运算符中优先级最高，因此可以把 studentl num作为一个整体来看待，相当于一个变量。上面赋值语句的作用是将整数 赋给 student变量中的成员 num。
注意：不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值。
下面用法不正确：
printfsn studentl 企图用结构体变量名输出所有成员的值
只能对结构体变量中的各个成员分别进行输入和输出。
如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。如果在结构体 struct Student 类型的成员中包含另一个结构体 struct date类型的成员 birthday见 节最后介绍的结构体，则引用成员的方式为
studentl num 结构体变量 student中的成员 num
studentl birthday month 结构体变量 studentl中的成员 birthday中的成员 month
不能用 student birthday来访问 student变量中的成员 birthday因为 birthday本身是一个结构体成员。
对结构体变量的成员可以像普通变量一样进行各种运算根据其类型决定可以进行的运算。例如：
student score studentl score 赋值运算
sumstudent scorestudent score 加法运算
student age 自加运算
由于“”运算符的优先级最高因此 student age是对 studentl age进行自加运算而不是先对 age进行自加运算。
同类的结构体变量可以互相赋值，如：
studentstudent 假设 student和 student 已定义为同类型的结构体变量
可以引用结构体变量成员的地址，也可以引用结构体变量的地址。例如：
scanfd studentl num 输入 studentl num的值
printfo studentl 输出结构体变量 student 的起始地址
但不能用以下语句整体读入结构体变量，例如：
scanfdscdfsnstudent
说明： 结构体变量的地址主要用作函数参数，传递结构体变量的地址。
【例】 输入两个学生的学号、姓名和成绩，输出成绩较高的学生的学号、姓名和成绩。
第章 用户自己建立数据类型
解题思路：
定义两个结构相同的结构体变量 student和 student
分别输入两个学生的学号、姓名和成绩；
比较两个学生的成绩，如果学生的成绩高于学生的成绩，就输出学生的全部信息，如果学生的成绩高于学生的成绩，就输出学生的全部信息。如果二者相等，输出两个学生的全部信息。
编写程序：
include stdio h
int main
struct Student 声明结构体类型 struct Student
int num
char name
float score
studentlstudent 定义两个结构体变量 studentstudent
scanfdsfstudent numstudent name studentl score 输入学生的数据
scanfdsfstudent numstudent name student score 输入学生的数据
printfThe higher score isn
if studentl scorestudent score
printfd s fnstudent numstudent name studentl score
else if studentl scorestudent score
printfd s fnstudent numstudent name student score
else
printfd s fn studentl numstudent name student score
printfd s fnstudent numstudent name student score
return
运行结果：
Wang
Ling
The higher score is
Ling
程序分析：
student和 student是 struct Student类型的变量。在个成员中分别存放学号、姓名和成绩。
用scanf函数输入结构体变量时，必须分别输入它们的成员的值，不能在 scanf函数中使用结构体变量名一揽子输入全部成员的值。注意在 scanf函数中在成员 student num和 studentl score的前面都有地址符而在 studentl name 前面没有这是因为name是数组名，本身就代表地址，故不能画蛇添足地再加一个。
根据student score 和 student score的比较结果输出不同学生的信息。从这里可以看到利用结构体变量的好处： 由于 student是一个“组合项”，内放有关联的一组数据，student score是属于student变量的一部分因此如果确定了 student score是成绩较
C程序设计第五版
高的，则输出student的全部信息是轻而易举的，因为它们本来是互相关联，捆绑在一起的。如果用普通变量则难以方便地实现这一目的。
使用结构体数组
一个结构体变量中可以存放一组有关联的数据如一个学生的学号、姓名、成绩等数据。如果有个学生的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与以前介绍过的数值型数组的不同之处在于每个数组元素都是一个结构体类型的数据，它们都分别包括各个成员项。
定义结构体数组
下面举一个简单的例子来说明怎样定义和引用结构体数组。
【例】 有个候选人，每个选民只能投票选一人，要求编一个统计选票的程序，先后输入被选人的名字，最后输出各人得票结果。
解题思路： 显然，需要设一个结构体数组，数组中包含个元素，每个元素中的信息应包括候选人的姓名字符型和得票数整型。输入被选人的姓名，然后与数组元素中的“姓名”成员比较，如果相同，就给这个元素中的“得票数”成员的值加。最后输出所有元素的信息。
编写程序：
include string h
include stdio h
struct Person 声明结构体类型 struct Person
char name 候选人姓名
int count 候选人得票数
leaderLi Zhang Sun 定义结构体数组并初始化
int main
int ij
char leader name 定义字符数组
foriii
scanfs leader name 输入所选的候选人姓名
forjjj
if strcmp leader name leaderj name leaderj count
printfnResultn
foriii
printfsdn leaderi name leaderi count
return
第章 用户自己建立数据类型
运行结果：
Li
Li
Sun
Zhang
Zhabg
Sun
Li
Sun
Zhang
Li
Result
Li
Zhang
Sun
先输入张选票上所写的被选人的名字，然后系统输出各人得票数
程序分析：定义一个全局的结构体数组 leader，它有个元素，每一个元素包含两个成员 name姓名和 count票数。在定义数组时使之初始化，将Li赋给 leader name 赋给 leader count Zhang赋给 leader name 赋给 leader count Sun赋给 leader name赋给 leader count。这样位候选人的票数全部先置零，见图。
在主函数中定义字符数组 leader name，用它存放被选人的姓名。在每次循环中输入一个被选人姓名，然后把它与结构体数组中个候选人姓名相比，看它和哪一个候选人的名字相同。注意 leader name是和 leader数组第j个元素的 name成员相比。若j为某一值时输入的姓名与 leaderj name相等就执行“leaderj count”由于成员运算符“”优先于自增运算符“”因此它相当于 leaderj count使 leaderj成员 count的值加。在输入和统计结束之后，将人的名字和得票数输出。
说明：
定义结构体数组一般形式是
① struct 结构体名
成员表列数组名数组长度；
②先声明一个结构体类型如 struct Person，然后再用此类型定义结构体数组：
结构体类型 数组名数组长度；
如：
struct Person leader leader是结构体数组名
对结构体数组初始化的形式是在定义数组的后面加上：
初值表列；
如：
struct Person leader Li Zhang Sun
结构体数组的应用举例
【例】 有 n个学生的信息包括学号、姓名、成绩，要求按照成绩的高低顺序输出
C程序设计第五版
各学生的信息。
解题思路：用结构体数组存放n个学生信息，采用选择法对各元素进行排序进行比较的是各元素中的成绩。选择排序法已在第章介绍。
编写程序：
include stdio h
struct Student 声明结构体类型 struct Student
int num
char name
float score
int main
struct Student stu Zhang Wang Li Ling Sun定义结构体数组并初始化
struct Student temp 定义结构体变量 temp，用作交换时的临时变量
const int n 定义常变量n
int ijk
printfThe order isn
foriini
ki
forjijnj
if stuj score stuk score 进行成绩的比较
kj
temp stuk stuk stui stui temp stuk和 stui元素互换
foriini
printfd s fn stui num stui name stui score
printfn
return
运行结果：
The order is
Sun
Wang
Li
Zhang
Ling
程序分析：
程序中第行定义了常变量n，在程序运行期间它的值不能改变。如果学生数改为人，只须把第行改为下行即可，其余各行不必修改。
const int n
也可以不用常变量，而用符号常量，可以取消第行，同时在第行前加一行：
define N
第章 用户自己建立数据类型
在定义结构体数组时进行初始化，为清晰起见，将每个学生的信息用一对花括号包起来，这样做，阅读和检查比较方便，尤其当数据量多时，这样是有好处的。
在执行第次外循环时i的值为，经过比较找出个成绩中最高成绩所在的元素的序号为k，然后将 stuk与 stui对换对换时借助临时变量 temp。执行第次外循环时i的值为，参加比较的只有个成绩了，然后将这个成绩中最高的所在的元素与 stu对换。其余类推。注意临时变量 temp也应定义为 struct Student 类型，只有同类型的结构体变量才能互相赋值。程序行是将 stuk元素中所有成员和 stui元素中所有成员整体互换而不必人为地指定一个一个成员地互换。从这点也可以看到使用结构体类型的好处。
结构体指针
所谓结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。如果把一个结构体变量的起始地址存放在一个指针变量中，那么，这个指针变量就指向该结构体变量。
指向结构体变量的指针
指向结构体对象的指针变量既可指向结构体变量，也可指向结构体数组中的元素。指针变量的基类型必须与结构体变量的类型相同。例如：
struct Student pt pt可以指向 struct Student 类型的变量或数组元素
先通过一个例子了解什么是指向结构体变量的指针变量以及怎样使用它。
【例】 通过指向结构体变量的指针变量输出结构体变量中成员的信息。
解题思路： 在已有的基础上，本题要解决两个问题：
怎样对结构体变量成员赋值；
怎样通过指向结构体变量的指针访问结构体变量中成员。
编写程序：
include stdio h
include string h
int main
struct Student 声明结构体类型 struct Student
long num
char name
char sex
float score
struct Student stu 定义 struct Student类型的变量 stu
struct Studentp 定义指向 struct Student 类型数据的指针变量 p
p stu p指向 stu
stu num 对结构体变量的成员赋值
strcpy stu name Li Lin 用字符串复制函数给 stu name赋值
C程序设计第五版
stu score
printfNo ld nnames nsexc nscorefn
stu num stu name stu sex stu score 输出结果
printfnNo ld nnames nsexc nscorefn
p nump namep sexp score
return
运行结果：
No
name Li Lin
sexM
score
No
name Li Lin
sexM
score
两个 printf函数输出的结果是相同的。
程序分析在主函数中声明了 struct Student类型然后定义一个 struct Student类型的变量 stu 。又定义一个指针变量p它指向一个 struct Student 类型的对象。将结构体变量 stu 的起始地址赋给指针变量p，也就是使p指向 stu 见图。然后对 stu 的各成员赋值。
第个 printf函数是通过结构体变量名 stu 访问它的成员，输出 stu 的各个成员的值。用 stu num 表示 stu 中的成员 num，依此类推。第个 printf函数是通过指向结构体变量的指针变量访问它的成员，输出 stu 各成员的值，使用的是pnum这样的形式。p表示p指向的结构体变量，pnum是p所指向的结构体变量中的成员 num。注意p两侧的括号不可省，因为成员运算符“”优先于“”运算符p num就等价于p num了。
说明 为了使用方便和直观C语言允许把p num 用p num代替 “”代表一个箭头p num表示 p所指向的结构体变量中的 num成员。同样p name等价于p name。“”称为指向运算符。
如果 p指向一个结构体变量 stu，以下种用法等价：
① stu成员名如 stu num
②p成员名如p num
③p成员名如 p num。
指向结构体数组的指针
可以用指针变量指向结构体数组的元素。请分析下面的例子。
【例】 有个学生的信息，放在结构体数组中，要求输出全部学生的信息。
解题思路： 用指向结构体变量的指针来处理：
声明结构体类型 struct Student，并定义结构体数组，同时使之初始化；
第章 用户自己建立数据类型
定义一个指向 struct Student类型数据的指针变量 p
使p指向结构体数组的首元素，输出它指向的元素中的有关信息；
使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息；
再使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息。
编写程序：
include stdio h
struct Student 声明结构体类型 struct Student
int num
char name
char sex
int age
struct Student stu Li LinM Zhang FangM
Wang MinF 定义结构体数组并初始化
int main
struct Studentp 定义指向 struct Student 结构体变量的指针变量
printfNo Name sex agen
forp stup stup
printfd s c dnp num p namep sex p age
输出结果
return
运行结果：
No Name sex age
Li Lin M
Zhang Fang M
Wang Min F
程序分析： p是指向 struct Student结构体类型数据的指针变量。在 for语句中先使p的初值为 stu，也就是数组 stu中序号为 的元素即 stu的起始地址见图 中 p的指向。在第 次循环中输出 stu的各个成员值。然后执行p，使p自加。p加意味着p所增加的值为结构体数组 stu的一个元素所占的字节数在VisualC环境下，本例中一个元素所占的字节数理论上为字节，实际分配字节。执行p后 p的值等于 stup指向 stu见图中p的指向。在第次循环中输出 stu的各成员值。在执行p后p的值等于 stu它的指向见图中的p”再输出 stu的各成员值。在执行 p后p的值变为 stu，已不再小于 stu了，不再执行循环。
注意：
图
如果p的初值为 stu，即指向 stu的序号为 的元
C程序设计第五版
素，p加后，p就指向下一个元素。例如：
p num 先使p自加然后得到p指向的元素中的 num成员值即
p num 先求得 p num的值即然后再使 p自加指向 stu
请注意以上二者的不同。
程序定义了 p 是一个指向 struct Student 类型对象的指针变量，它用来指向一个 struct Student类型的对象在例中的p的值是 stu数组的一个元素如 stu或 stu的起始地址，不应用来指向 stu数组元素中的某一成员。例如，下面的用法是不对的：
p stu name stu name是 stu元素中的成员 name的首字符的地址
编译时将给出“警告”信息，表示地址的类型不匹配。不要认为反正p是存放地址的，可以将任何地址赋给它。如果一定要将某一成员的地址赋给p，可以用强制类型转换，先将成员的地址转换成p的类型。例如：
p struct Student stu name
此时，p的值是 stu元素的 name成员的起始地址。可以用 “printfsp” 输出 stu中成员 name 的值。但是p仍保持原来的类型。如果执行“printfsp”则会输出 stu中 name的值。执行p时p的值的增量是结构体 struct Student的长度。
用结构体变量和结构体变量的指针作函数参数
将一个结构体变量的值传递给另一个函数，有个方法：
用结构体变量的成员作参数。例如用 stu num或 stu name作函数实参将实参值传给形参。用法和用普通变量作实参是一样的，属于“值传递”方式。应当注意实参与形参的类型保持一致。
用结构体变量作实参。用结构体变量作实参时，采取的也是“值传递”的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参也是结构体变量的值，该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。
用指向结构体变量或数组元素的指针作实参，将结构体变量或数组元素的地址传给形参。
【例】 有n个结构体变量，内含学生学号、姓名和门课程的成绩。要求输出平均成绩最高的学生的信息包括学号、姓名、门课程成绩和平均成绩。
解题思路： 将n个学生的数据表示为结构体数组有n个元素。按照功能函数化的思想，分别用个函数来实现不同的功能：
用input 函数来输入数据和求各学生平均成绩。
用max函数来找平均成绩最高的学生。
用print函数来输出成绩最高学生的信息。
在主函数中先后调用这个函数，用指向结构体变量的指针作实参。最后得到结果。
第章 用户自己建立数据类型
为简化操作，本程序只设个学生n。在输出时使用中文字符串，以方便阅读。
编写程序：
include stdio h
define N 学生数为
struct Student 建立结构体类型 struct Student
int num 学号
char name 姓名
float score 门课成绩
float aver 平均成绩
int main
void input struct Student stu 函数声明
struct Student max struct Student stu 函数声明
void print struct Student stu 函数声明
struct Student stuNp stu 定义结构体数组和指针
inputp 调用 input函数
print maxp 调用 print函数，以 max函数的返回值作为实参
return
void input struct Student stu 定义 input 函数
int i
printf请输入各学生的信息 学号、姓名、门课成绩n
foriiNi
scanfd s f f f stui num stui name stui score
stui score stui score 输入数据
stui aver stui score stui score stui score 求平均成绩
struct Student max struct Student stu 定义 max函数
int im 用m存放成绩最高的学生在数组中的序号
foriiNi
if stui aver stum aver mi 找出平均成绩最高的学生在数组中的序号
return stum 返回包含该生信息的结构体元素
void print struct Student stud 定义 print函数
printfn成绩最高的学生是n
printf学号dn姓名sn三门课成绩fffn平均成绩fn stud num stud name stud score stud score stud score stud aver
C程序设计第五版
运行结果：
请输入各学生的信息： 学号、姓名、门课成绩：
Li
Wang
Sun
成绩最高的学生是：
学号
姓名 Li
三门课成绩
平均成绩
程序分析：
结构体类型 struct Student中包括 num学号、 name姓名、数组 score门课成绩和aver平均成绩。在输入数据时只输入学号、姓名和 门课成绩，未给 aver 赋值。 aver的值是在 input函数中计算出来的。
在主函数中定义了结构体 struct Student类型的数组 stu 和指向 struct Student类型数据的指针变量 p，使p指向 stu数组的首元素 stu。在调用 input函数时，用指针变量 p 作为函数实参， input函数的形参是 struct Student 类型的数组 stu注意形参数组 stu和主函数中的数组 stu都是局部数据，虽然同名，但在调用函数进行虚实结合前二者代表不同的对象，互相间没有关系。在调用 input 函数时，将主函数中的stu数组的首元素的起始地址传给形参数组 stu，使形参数组 stu与主函数中的 stu数组具有相同的地址，见图 。因此在 input函数中向形参数组 stu 输入数据就等于向主函数中的 stu数组输入数据。
stu
在用 scanf函数输入数据后，立即计算出该学生的平均成绩， stui aver代表序号为i的学生的平均成绩。请注意 for循环体的范围。
图
input 函数无返回值，它的作用是给 stu数组各元素赋
予确定的值。
在主函数中调用 print函数，实参是 maxp。其调用过程是先调用 max函数以p为实参得到 maxp的值此值是一个 strct Student类型的数据。然后用它调用 print函数。
现在先分析调用 max函数的过程： 与前相同，指针变量p将主函数中的 stu数组的首元素的起始地址传给形参数组 stu，使形参数组 stu与主函数中的stu数组具有相同的地址。在max函数中对形参数组的操作就是对主函数中的 stu数组的操作。在 max函数中，将各人平均成绩与当前的“最高平均成绩”比较，将平均成绩最高的学生在数组 stu中的序号存放在变量m中，通过 return语句将 stum的值返回主函数。请注意： stum是一个结构体数组的元素。 max函数的类型为 struct Student类型。
用 maxp的值是结构体数组的元素作为实参调用 print函数。 print函数的形参 stud 是 struct Student类型的变量而不是 struct Student类型的数组。在调用时进行
第章 用户自己建立数据类型
虚实结合，把stum的值是结构体元素传递给形参 stud，这时传递的不是地址，而是结构体变量中的信息。在print函数中输出结构体变量中各成员的值。
以上个函数的调用，情况各不相同：
· 调用 input 函数时，实参是指针变量 p，形参是结构体数组，传递的是结构体元素的起始地址，函数无返回值。
· 调用 max函数时，实参是指针变量p，形参是结构体数组，传递的是结构体元素的起始地址，函数的返回值是结构体类型数据。
· 调用 print 函数时，实参是结构体变量结构体数组元素，形参是结构体变量，传递的是结构体变量中各成员的值，函数无返回值。
请读者仔细分析，掌握各种用法。
· 用指针处理链表
什么是链表
链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。由前面的介绍中已知：用数组存放数据时，必须事先定义固定的数组长度即元素个数。如果有的班级有人，而有的班级只有人，若用同一个数组先后存放不同班级的学生数据，则必须定义长度为的数组。如果事先难以确定一个班的最多人数，则必须把数组定得足够大，以便能存放任何班级的学生数据，显然这将会浪费内存。链表则没有这种缺点，它根据需要开辟内存单元。图表示最简单的一种链表单向链表的结构。
head
A
B
C
D
NULL
图
链表有一个“头指针”变量，图中以 head表示，它存放一个地址，该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：用户需要用的实际数据；下一个结点的地址。可以看出， head指向第个元素，第个元素又指向第个元素⋯⋯直到最后一个元素，该元素不再指向其他元素，它称为“表尾”，它的地址部分放一个“NULL”表示“空地址”链表到此结束。
可以看到链表中各元素在内存中的地址可以是不连续的。要找某一元素，必须先找到上一个元素，根据它提供的下一元素地址才能找到下一个元素。如果不提供“头指针” head，则整个链表都无法访问。链表如同一条铁链一样，一环扣一环，中间是不能断开的。
为了理解什么是链表，打一个通俗的比方：幼儿园的老师带领孩子出来散步，老师牵着第个小孩的手，第个小孩的另一只手牵着第个孩子……这就是一个“链”，最后一个孩子有一只手空着，他是“链尾”。要找这个队伍，必须先找到老师，然后顺序找到每一个孩子。
显然，链表这种数据结构，必须利用指针变量才能实现，即一个结点中应包含一个指针变量，用它存放下一结点的地址。
前面介绍了结构体变量，用它去建立链表是最合适的。一个结构体变量包含若干成员，
C程序设计第五版
这些成员可以是数值类型、字符类型、数组类型，也可以是指针类型。用指针类型成员来存放下一个结点的地址。例如，可以设计这样一个结构体类型：
struct Student
int num
float score
struct Student next next是指针变量，指向结构体变量
其中，成员 num和 score用来存放结点中的有用数据用户需要用到的数据，相当于图结点中的ABCD。 next是指针类型的成员它指向 struct Student类型数据就是 next所在的结构体类型。一个指针类型的成员既可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型的数据。现在 next 是 struct Student 类型中的一个成员它又指向 struct Student类型的数据。用这种方法就可以建立链表见图。
图中每一个结点都属于 struct Student类型，它的成员 next用来存放下一结点的地址，程序设计人员可以不必知道各结点的具体地址，只要保证将下一个结点的地址放到前一结点的成员 next 中即可。
注意： 上面只是定义了一个 struct Student类型，并未实际分配存储空间，只有定义了变量才分配存储单元。
建立简单的静态链表
下面通过一个例子来说明怎样建立和输出一个简单链表。
【例】 建立一个如图所示的简单链表，它由个学生数据的结点组成，要求输出各结点中的数据。
解题思路：声明一个结构体类型，其成员包括 num学号、 score成绩和 next指针变量。将第个结点的起始地址赋给头指针 head，将第个结点的起始地址赋给第个结点的 next 成员，将第个结点的起始地址赋给第个结点的 next 成员。第个结点的 next成员赋予 NULL。这就形成了链表。
编写程序：
include stdio h
struct Student 声明结构体类型 struct Student
int num
float score
struct Student next
int main
struct Student abc headp 定义个结构体变量a，b，c作为链表的结点
a num a score 对结点 a 的 num和 score成员赋值
b numb score 对结点 b的 num和 score成员赋值
第章 用户自己建立数据类型
c num c score 对结点 c的 num 和 score成员赋值
heada 将结点 a的起始地址赋给头指针 head
a nextb 将结点b的起始地址赋给a结点的 next 成员
b nextc 将结点c的起始地址赋给a结点的 next 成员
c nextNULL c结点的 next成员不存放其他结点地址
p head 使p指向a结点
do
printf ld fnp nump score 输出 p指向的结点的数据
pp next 使p指向下一结点
whilepNULL 输出完c结点后 p的值为 NULL，循环终止
return
运行结果：输出个结点中的数据。
程序分析： 请读者分析：①各个结点是怎样构成链表的。②没有头指针 head 行不行。③p起什么作用，没有它行不行
为了建立链表使 head指向 a 结点a next 指向 b 结点b next 指向c结点这就构成链表关系。“c nextNULL”的作用是使c next不指向任何有用的存储单元。
在输出链表时要借助p，先使p指向a结点，然后输出a结点中的数据， “pp next”是为输出下一个结点作准备。p next的值是 b结点的地址因此执行“pp next”后 p就指向b结点，所以在下一次循环时输出的是 b结点中的数据。
本例是比较简单的，所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。
建立动态链表
所谓建立动态链表是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。
【例】 写一函数建立一个有名学生数据的单向动态链表。
解题思路： 先考虑实现此要求的算法见图。在用程序处理时要用到第章介绍的动态内存分配的知识和有关函数 malloc calloc realloc 和 free函数。
定义个指针变量 headp和p它们都是用来指向 struct Student类型数据的。先用 malloc函数开辟第个结点，并使 p和p指向它。然后从键盘读入一个学生的数据给p所指的第个结点。在此约定学号不会为零，如果输入的学号为，则表示建立链表的过程完成，该结点不应连接到链表中。先使 head 的值为 NULL即等于，这是链表为“空”时的情况即head 不指向任何结点，即链表中无结点，当建立第个结点就使 head 指向该结点。
如果输入的 pl num不等于则输入的是第个结点数据n令 headp即把p的值赋给 head，也就是使 head也指向新开辟的结点图。p所指向的新开辟的结
C程序设计第五版
点就成为链表中第个结点。然后再开辟另一个结点并使 pl指向它，接着输入该结点的数据见图a。
开辟一个新结点， 并使p、p指向它 读入一个学生数据给p所指的结点 headNULLn 当读入的p num不是零 nn 真 n等于 假 headp 把p所指的结点作为第一个结点p nextp把p所指的结点连接到表尾ppp移到表尾再开辟一个新结点， 使p指向它读入一个学生数据给p所指结点表尾结点的指针变量置NULL
head
n
p
p
图
图
p
p
p
head
head
head
n
n
p
p
p
a
b
c
图
如果输入的 plnum≠则应链入第个结点n由于n≠则将 p的值赋给 p next此时p 指向第个结点因此执行“p nextp”就将新结点的地址赋给第个结点的 next 成员，使第个结点的 next 成员指向第个结点见图b。接着使pp也就是使 p指向刚才建立的结点见图c。
接着再开辟个结点并使 pl指向它，并输入该结点的数据见图a。在第次循环中由于 nn≠又将 p的值赋给 p next也就是将第 个结点连接到第个结点之后并使 pp使p指向最后一个结点见图b。
再开辟一个新结点，并使 pl指向它，输入该结点的数据见图a。由于pnum的值为，不再执行循环，此新结点不应被连接到链表中。此时将 NULL 赋给p next，见图b。建立链表过程至此结束，p最后所指的结点未链入链表中，第个结点的 next成员的值为 NULL，它不指向任何结点。虽然 pl指向新开辟的结点，但从链表中无法找到该结点。
第章 用户自己建立数据类型
pl
pl
head
head
p
p
a
b
图
pl
p
head
head
NULL
p
p
a
b
图
编写程序： 先写出建立链表的函数：
include stdio h
include stdlib h
define LEN sizeof struct Student
struct Student
long num
float score
struct Student next
int n n为全局变量，本文件模块中各函数均可使用它
struct Student creat void 定义函数。此函数返回一个指向链表头的指针
struct Student head
struct Studentpp
n
pp struct Student mallocLEN 开辟一个新单元
scanf ldfp nump score 输入第个学生的学号和成绩
headNULL
whilep num
nn
ifn headp
else p nextp
pp
p struct Student mallocLEN 开辟动态存储区，把起始地址赋给 pl
scanf ldfp nump score 输入其他学生的学号和成绩
C程序设计第五版
p nextNULL
return head
可以写一个 main函数调用这个 creat 函数
int main
struct Student pt
pt creat 函数返回链表第一个结点的地址
printf nnum ld nscorefn pt num pt score 输出第个结点的成员值 return
运行结果：
num
score
程序分析：
调用 creat 函数后，先后输入所有学生的数据，若输入“，”，表示结束。函数的返回值是所建立的链表的第个结点的地址请查看 return 语句，在主函数中把它赋给指针变量 pt。为了验证各结点中的数据，在 main函数中输出了第个结点中的信息。
第行令 LEN代表 struct Student类型数据的长度 sizeof是“求字节数运算符”。
第行定义一个 creat函数，它是指针类型，即此函数带回一个指针值，它指向一个 struct Student 类型数据。实际上此 creat 函数带回一个链表起始地址。
第行 mallocLEN的作用是开辟一个长度为 LEN的内存区LEN已定义为 sizeof struct Student即结构体 struct Student的长度。 malloc带回的是不指向任何类型数据的指针 void类型。而 pp是指向 struct Student类型数据的指针变量可以用强制类型转换的方法使指针的基类型改变为 struct Student类型在 mallocLEN之前加了“ struct Student”它的作用是使 malloc返回的指针转换为 struct Student类型数据的指针。注意括号中的“”号不可省略，否则变成转换成 struct Student 类型了，而不是指针类型了。
由于编译系统能实现隐式的类型转换，因此行也可以直接写为
p mallocLEN
creat函数最后一行 return后面的参数是 head head已定义为指针变量指向 struct Student类型数据。因此函数返回的是 head的值，也就是链表中第个结点的起始地址。
n是结点个数。
这个算法的思路是让 pl指向新开辟的结点，p指向链表中最后一个结点，把 pl所指的结点连接在 p所指的结点后面用“p nextp”来实现。
以上对建立链表过程做了比较详细的介绍，读者如果对建立链表的过程比较清楚的话，对链表的其他操作过程如链表的输出、结点的删除和结点的插入等也就比较容易理解了。
第章 用户自己建立数据类型
输出链表
将链表中各结点的数据依次输出。这个问题比较容易处理。
【例】 编写一个输出链表的函数 print。
解题思路：从例已经初步了解输出链表的方法。首先要知道链表第个结点的地址，也就是要知道 head的值。然后设一个指针变量 p，先指向第个结点，输出p所指的结点，然后使p后移一个结点，再输出，直到链表的尾结点。
根据上面的思路，写出算法如图所示。
输出p所指向的结点
编写程序： 根据流程图写出以下函数：
p指向下一个结点
当p指向的不是表尾
include stdio h
include stdlib h
图
define LEN sizeof struct Student
struct Student 声明结构体类型 struct Student
long num
float score
struct Student next
int n 全局变量n
void print struct Student head 定义 print函数
struct Studentp 在函数中定义 struct Student类型的变量 p
printfnNow These d records arenn
p head 使p指向第个结点
if headNULL 若不是空表
do
printf ld fnp nump score 输出一个结点中的学号与成绩
pp next p指向下一个结点
whilepNULL 当p不是“空地址”
程序分析： 以上只是一个函数，可以单独编译，但不能单独运行。其中的外部声明类型声明和定义变量n是与其他函数共享的。如果把它和例的程序组成一个文件模块，则例中的第行可以不要。
print函数的操作过程可用图 表示。头指针 head从实参接收了链表的第个结点的起始地址，把它赋给p，于是p指向第个结点，输出p指向的结点第个结点的数据然后执行“pp next”p next是 p指向的结点中的 next 成员即第个结点中的 next 成员p next中存放了第个结点的地址执行“pp next”后p就指向第个结点p移到图中 p虚线位置指向第个结点。“pp next；”的作用是将 p原来所指向的结点中 next的值赋给p，使 p指向下一个结点。 print函数从 head所指的第个结点出发顺序输出各个
C程序设计第五版
结点。
可以把例和例合起来加上一个主函数，组成一个程序，即：
include stdio h
include malloc h
define LEN sizeof struct Student
struct Student
long num
float score
struct Student next
int n
struct Student creat 建立链表的函数
struct Student head
struct Studentpp
n
pp struct Student mallocLEN
scanf ldfp nump score
headNULL
whilep num
nn
ifn headp
else p nextp
p pl
p struct Student mallocLEN
scanf ldfp nump score
p nextNULL
return head
void print struct Student head 输出链表的函数
struct Studentp
printfnNow These d records arenn
p head
if headNULL
do
printf ld fnp nump score
pp next
whilepNULL
int main
struct Student head
head creat 调用 creat函数，返回第个结点的起始地址
print head 调用 print函数
第章 用户自己建立数据类型
return
运行结果：
Now These records are
说明：链表是一个比较深入的内容，初学者有一定难度，计算机专业人员是应该掌握的，非专业的初学者对此有一定了解即可，在以后需要用到时再进一步学习。
对链表中结点的删除和结点的插入等操作，在此不作详细介绍，如读者有需要或感兴趣，可以自己完成。如果想详细了解，可参考作者所著的《C程序设计第五版学习辅导》中的习题解答第章题，其中给出了全部的程序和说明。
结构体和指针的应用领域很宽广，除了单向链表之外，还有环形链表和双向链表。此外还有队列、树、栈、图等数据结构。有关这些问题的算法可以学习“数据结构”课程，在此不作详述。
共用体类型
什么是共用体类型
有时想用同一段内存单元存放不同类型的变量。例如，把一个短整型变量、一个字符型变量和一个实型变量放在同一个地址开始的内存单元中见图。以上个变量在内存中占的字节数不同，但都从同一地址开始图中设地址为存放，也就是使用覆盖技术，后一个数据覆盖了前面的数据。这种使几个不同的变量共享同一段内存的结构，称为“共用体”类型的结构。
定义共用体类型变量的一般形式为
实
型变
量
f
union 共用体名
成员表列
图
变量表列；
例如：
union Data
int i 表示不同类型的变量i， ch，f可以存放到同一段存储单元中
char ch
float f
abc 在声明类型同时定义变量
也可以将类型声明与变量定义分开：
C程序设计第五版
union Data 声明共用体类型
int I
char ch
float f
union Data abc 用共用体类型定义变量
即先声明一个 union Data类型再将 abc定义为 union Data类型的变量。当然也可以直接定义共用体变量，例如：
union 没有定义共用体类型名
int i
char ch
float f
abc
可以看到， “共用体”与“结构体”的定义形式相似。但它们的含义是不同的。
结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。例如，上面定义的“共用体”变量a，b，c各占个字节因为一个 float型变量占个字节，而不是各占个字节。
国内有些C语言的书把 union直译为“联合”。作者认为，译为“共用体”更能反映这种结构的特点，即几个变量共用一个内存区。而“联合”这一名词，在一般意义上容易被理解为“将两个或若干个变量联结在一起”，难以表达这种结构的特点。但是读者应当知道“共用体”在一些书中也被称为“联合”。在阅读其他书籍时如遇“联合”一词，应理解为“共用体”。
引用共用体变量的方式
只有先定义了共用体变量才能引用它，但应注意，不能引用共用体变量，而只能引用共用体变量中的成员。例如，前面定义了a，b，c为共用体变量，下面的引用方式是正确的：
a i 引用共用体变量中的整型变量i
a ch 引用共用体变量中的字符变量 ch
a f 引用共用体变量中的实型变量f
不能只引用共用体变量，例如下面的引用是错误的：
printfda
因为a的存储区可以按不同的类型存放数据，有不同的长度，仅写共用体变量名a，系统无法知道究竟应输出哪一个成员的值。应该写成
printfda i
或
printfca ch
第章 用户自己建立数据类型
共用体类型数据的特点
在使用共用体类型数据时要注意以下一些特点：
同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。其道理是显然的，因为在每一个瞬时，存储单元只能有唯一的内容，也就是说，在共用体变量中只能存放一个值。如果有以下程序段：
union Date
int i
char ch
float f
a
a i
表示将整数存放在共用体变量中，可以用以下的输出语句：
printfda i 输出整数
printfca ch 输出字符a
printffa f 输出实数
其执行情况是： 由于是赋给a i的，因此按整数形式存储在变量单元中，最后一个字节是“”。如果用“d”格式符输出a i就会输出整数。如果想用“c”格式符输出a ch，系统会把存储单元中的信息按字符输出a。如果想用“f”格式符输出a f，系统会将存储单元中的信息按浮点数形式来处理，其数值部分为，故输出。
可以对共用体变量初始化，但初始化表中只能有一个常量。下面用法不对：
union Data
int i
char ch
float f
aa 不能初始化个成员，它们占用同一段存储单元
union Data a 正确，对第个成员初始化
union Data a chj C允许对指定的一个成员初始化
共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就取代。如果执行以下赋值语句：
a f
a i
在完成以上个赋值运算以后，变量存储单元存放的是最后存入的，原来的a和都被覆盖了。此时如用“printfda i”输出 a i的值是。而用“printfca ch”输出的不是字符a，而是字符。因为在共用的存储单元中，按整数形式存放了，现在要按c格式输出a ch，系统就到共用的存储单元去读数据，将存储单元中的内容按存储字符数据的规则解释，是字符的ASCⅡ码，因此输出字符。
因此在引用共用体变量时应十分注意当前存放在共用体变量中的究竟是哪个成员
C程序设计第五版
的值。
共用体变量的地址和它的各成员的地址都是同一地址。例如，a i，a c，a f都是同一值，其原因是显然的。
不能对共用体变量名赋值，也不能企图引用变量名来得到一个值。例如，下面这些都是不对的：
①a 不能对共用体变量赋值，赋给谁
②ma 企图引用共用体变量名以得到一个值赋给整型变量m
C允许同类型的共用体变量互相赋值。如：
ba a和b是同类型的共用体变量，合法
以前的C规定不能把共用体变量作为函数参数，但可以使用指向共用体变量的指针作函数参数。C允许用共用体变量作为函数参数。
共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员。
在什么情况下会用到共用体类型的数据呢 往往在数据处理中，有时需要对同一段空间安排不同的用途，这时用共用体类型比较方便，能增加程序处理的灵活性。请分析下例。
【例】 有若干个人员的数据，其中有学生和教师。学生的数据中包括： 姓名、号码、性别、职业、班级。教师的数据包括： 姓名、号码、性别、职业、职务。要求用同一个表格来处理。
解题思路：可以看出： 学生和教师的数据的项目大多数是相同的，但有一项不同。现要求把它们放在同一表格中，见图。如果 job项为s学生，则第项为 class班。即 Li是班的。如果 job项是t教师则第项为 position职务。 Wang 是 prof教授。显然对第项可以用共用体来处理将 class 和 position放在同一段存储单元中。
先输入人员的数据，然后再输出。可以写出算法见图。按此写出程序，为简化起见，只设两个人一个学生、一个教师。
循环n次
读入号码、姓名、性别、职业
职业 job等于s
真
假
num
name
sex
job
job等于t
class班 position职务
真
假
读入 class
读入
输出
position
“输入错”
Li
f
s
循环n次
真
job等于s
假
Wang
t
prof
输出： 号码、姓名、
输出： 号码、姓名、
m
性别、职业、班级
性别、职业、职务
图
图
第章 用户自己建立数据类型
编写程序：
include stdio h
struct 声明无名结构体类型
int num 成员 num编号
char name 成员 name姓名
char sex 成员 sex性别
char job 成员 job职业
union 声明无名共用体类型
int clas 成员 clas班级
char position 成员 position职务
category 成员 category是共用体变量
person 定义结构体数组 person，有两个元素
int main
int i
foriii
printfplease enter the data of personn
scanfd s c c personi num personi name
personi sex personi job 输入前项
if personi jobs
scanfd personi category clas 如是学生输入班级
else if personi jobt
scanfs personi category position 如是教师输入职务
else
printfInput error 如 job不是s和t显示“输入错误”
printfn
printfNo name sex job class positionn
foriii
if personi job s 若是学生
printfdsccdn personi num personi name
personi sex personi job personi category clas
else 若是教师
printfdsccsn personi num personi name
personi sex personi job personi category position
return
运行结果：
please enter the data of person
Li f s
please enter the data of person
Wang n t prof
No name
sex job class position
Li
f
Wang
m
t
prof
C程序设计第五版
程序分析： main函数之前定义了外部的结构体数组 person，在结构体类型声明中包括了共用体类型 category分类成员，在这个共用体成员中又包括两个成员：成员 clas由于 class是C的关键字用 Visual C时不应该用 class作成员名故用 clas代表和成员 position，前者为整型，后者为字符数组存放“职位”的内容——字符串。
也可以不在结构体类型的声明中声明共用体类型，而把它放在结构体类型的声明之前，即：
union Categ 声明有名共用体类型 union Categ
int banji
char position
struct 声明无名结构体类型
int num
char name
char sex
char job
union Categ category 成员 category是共用体 union Categ类型的数据
person
在程序运行过程中需要输入数据，在输入前项数据编号、姓名、性别、职业时，对于学生和教师来说，输入的数据类型是一样的，但在输入第项数据人员类别时二者就有区别了，对于学生应输入班级号整数，对于教师则应输入职位字符串，程序应作分别处理。
在程序中是这样处理的：先输入前 项数据，然后用 if语句检查刚才输入的职业 job成员，如果是s，表示是学生，则第项应输入一个班级号整数，用输入格式符d把一个整数送到共用体数组元素中的成员 category clas中。如果职业是t，表示是教师，则输入第项时应该用输入格式符s把一个字符串职位送到共用体数组元素中的成员 category position中。请注意这样处理后结构体数组元素 person中的共用体成员 category的存储空间中存放的是整数而 person中的共用体成员 category的存储空间中，存放的是字符串。
在输出数据时的处理方法是类似的，如果是学生，第 项以整数形式输出班号，如果是教师，则第 项以字符串形式输出职位。在printf语句中，格式符“d”表示以十进制整数形式输出占列数据向左对齐其他如sccs的含义与此类似。
在数据处理中，用同一个栏目来表示不同内容的情况是不少的。这个例子是比较简单的，但通过此例可以看到，如果善于利用共用体，会使程序的功能更加丰富和灵活。
使用枚举类型
如果一个变量只有几种可能的值，则可以定义为枚举 enumeration类型，所谓“枚举”就是指把可能的值一一列举出来，变量的值只限于列举出来的值的范围内。
第章 用户自己建立数据类型
声明枚举类型用 enum开头。例如：
enum Weekday sun mon tue wed thu fri sat
以上声明了一个枚举类型 enum Weekday。然后可以用此类型来定义变量。例如：
enum Weekday workday weekend
枚举类型
枚举变量
workday和 weekend 被定义为枚举变量花括号中的 sun mon… sat 称为枚举元素或枚举常量。它们是用户指定的名字。枚举变量和其他数值型量不同，它们的值只限于花括号中指定的值之一。例如枚举变量 workday 和 weekend的值只能是 sun 到 sat之一。
workday mon 正确， mon是指定的枚举常量之一
weekend sun 正确， sunon 是指定的枚举常量之一
weekday monday 不正确， monday不是指定的枚举常量之一
枚举常量是由程序设计者命名的，用什么名字代表什么含义，完全由程序员根据自己的需要而定，并在程序中作相应处理。
也可以不声明有名字的枚举类型，而直接定义枚举变量，例如：
enum sun mon tue wed thu fri sat workday weekend
声明枚举类型的一般形式为
enum枚举名枚举元素列表
其中，枚举名应遵循标识符的命名规则，上面的 Weekday就是合法的枚举名。
说明：
C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符有名字而把它们看作变量，不能对它们赋值。例如：
sun mon 错误，不能对枚举元素赋值
每一个枚举元素都代表一个整数，C语言编译按定义时的顺序默认它们的值为，…。在上面的定义中 sun的值自动设为 mon的值为… sat的值为。如果有赋值语句：
workday mon
相当于
workday
枚举常量是可以引用和输出的。例如：
printfd workday
将输出整数。
也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：
C程序设计第五版
enum Weckday sun mon tue wed thu fri sat workday week end
指定枚举常量 sun的值为mon为以后顺序加 sat为。
由于枚举型变量的值是整数，因此C把枚举类型也作为整型数据中的一种，即用户自行定义的整数类型。
枚举元素可以用来作判断比较。例如：
if workday mon…
if workday sun…
枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。如果定义时未人为指定则按上面的默认规则处理即第个枚举元素的值为故 mon sun sat fri。
通过下面的例子可以了解怎样使用枚举型数据。
【例】 口袋中有红、黄、蓝、白、黑种颜色的球若干个。每次从口袋中先后取出个球，问得到种不同颜色的球的可能取法，输出每种排列的情况。
解题思路：球只能是种颜色之一，而且要判断各球是否同色，可以用枚举类型变量处理。
设某次取出的个球的颜色分别为i，j，k。根据题意，i，j，k分别是种色球之一，并要求球颜色各不相同，即： i≠j，i≠k，j≠k。可以用穷举法，即把每一种组合都试一下，看哪一组符合条件，就输出i，j，k。
算法可用图表示。
用n累计得到种不同色球的次数。外循环使第个球的颜色i从 red变到 black。中循环使第个球的颜色j也从 red变到 black。如果i和j同色则显然不符合条件。只有i和j不同色i≠j时才需要继续找第个球，此时第个球的颜色k也有 种可能 red到 black，但要求第个球不能与第个球或第个球同色，即k≠i，k≠j。满足此条件就得到了种不同色的球。输出这种色组合的方案。然后使 n加，表示又得到一次球不同色的组合。外循环全部执行完后，全部方案就已输出完了。最后输出符合条件的总数n。
下面的问题是如何实现图 中的“输出一种取法”。这里有一个问题： 如何输出 red black等颜色的单词。不能写成“printf“s” red”来输出字符串red。可以采用图的方法。
n
i从 red变到 black
j从 red变到 black
loop由到
i≠j
真
假
loop的值
k从 red变到 black
k≠i和k≠j
i⇒pri
j⇒pri
真
假
pri的值
输出一种取法
red
yellow
blue
white
black
nn
输出
输出
输出
输出
输出
输出取法的总数n
red
yellow
blue
white
black
图
图
第章 用户自己建立数据类型
为了输出个球的颜色，显然应经过次循环，第次输出i的颜色，第次输出j的颜色，第次输出k的颜色。在次循环中先后将i，j，k赋予 pri。然后根据 pri的值输出颜色信息。在第次循环时， pri的值为i，如果i的值为 red，则输出字符串red，其他类推。
编写程序：
include stdio h
int main
enum Color red yellow blue white black 声明枚举类型 enum Color
enum Color ijk pri 定义枚举变量ijk pri
int n loop
n
fori redi blacki 外循环使i的值从 red变到 black
forj redj blackj 中循环使j的值从 red变到 black
ifij 如果二球不同色
fork redk blackk 内循环使 k的值从 red变到 black
ifki kj 如果球不同色
nn 符合条件的次数加
printfdn 输出当前是第几个符合条件的组合
for loop loop loop 先后对个球分别处理
switch loop loop的值从变到
case prii break loop的值为时把第球的颜色赋给 pri
case prij break loop的值为时把第球的颜色赋给 pri
case prik break loop的值为时把第球的颜色赋给 pri
default break
switch pri 根据球的颜色输出相应的文字
case red printfs red break
pri的值等于枚举常量 red时输出red
case yellow printfs yellow break
pri的值等于枚举常量 yellow 时输出yellow
case blue printfs blue break
pri的值等于枚举常量 blue时输出blue
case white printfs white break
pri的值等于枚举常量 white时输出white
case black printfs black break
pri的值等于枚举常量 black时输出black
default break
printfn
printf ntotaldnn
return
C程序设计第五版
运行结果：
red
yellow
blue
red
yellow
white
red
yellow
black
red
blue
yellow
red
blue
white
red
blue
black
…
⋮
⋮
⋮
black
yellow
white
black
blue
red
black
blue
yellow
black
blue
white
black
white
red
black
white
yellow
black
white
blue
total
程序分析： 在程序各行的注释中已说明了各语句的作用，请仔细分析。请弄清楚在输出时怎样输出red yellow等文字。要注意 输出的字符串red与枚举常量 red 并无内在联系，输出red等字符完全是人为指定的。
枚举常量的命名完全为了使人易于理解，它们并不自动地代表什么含义。例如，不因为命名为 red，就代表“红色”，用其他名字也可以。用什么标识符代表什么含义，完全由程序设计者决定，以便于理解为原则。
有人说，不用枚举常量而用常数代表“红”，代表“黄”……不也可以吗 是的，完全可以。但显然用枚举变量 red， yellow等更直观，因为枚举元素都选用了令人“见名知义”的名字。此外，枚举变量的值限制在定义时规定的几个枚举元素范围内，如果赋予它其他值，就会出现出错信息，便于检查。
用 typedef 声明新类型名
除了可以直接使用C提供的标准类型名如 int char float double和 long等和程序编写者自己声明的结构体、共用体、枚举类型外，还可以用 typedef指定新的类型名来代替已有的类型名。有以下两种情况：
简单地用一个新的类型名代替原有的类型名
例如：
typedef int Integer 指定用 Integer为类型名作用与 int 相同
typedef float Real 指定用 Real为类型名作用与 float 相同
指定用 Integer代表 int类型 Real代表 float。这样以下两行等价
①int ij float ab
②Integer ij Real ab
这样可以使熟悉FORTRAN的人能用 Integer 和 Real定义变量，以适应他们的习惯。
又如在一个程序中，用一个整型变量来计数，则可以命名 Count为新的类型名，代表 int类型：
第章 用户自己建立数据类型
typedef int Count 指定 Count代表 int
Count ij 用 Count定义变量i和j相当于 int ij
将变量ij定义为 Count类型而 Count等价于 int因此ij是整型。在程序中将ij定义为 Count类型，可以使人更一目了然地知道它们是用于计数的。
命名一个简单的类型名代替复杂的类型表示方法
从前面已知，除了简单的类型如int， float等、C程序中还会用到许多看起来比较复杂的类型，包括结构体类型、共用体类型、枚举类型、指针类型、数组类型等，如：
float 指针数组
float 指向个元素的一维数组的指针
double double 定义函数，函数的参数是 double型数据，即指向 double数据的指
针，函数返回值也是指向 double数据的指针
double 指向函数的指针，函数返回值类型为 double
int void 指向包含个元素的一维数组的指针，数组元素的类型为函数指
针函数的地址，函数没有参数，函数返回值是 int指针
有些类型形式复杂，难以理解，容易写错。C允许程序设计者用一个简单的名字代替复杂的类型形式。例如：
命名一个新的类型名代表结构体类型：
typedef struct
int month
int day
int year
Date
以上声明了一个新类型名 Date，代表上面的一个结构体类型。然后可以用新的类型名 Date去定义变量，如：
Date birthday 定义结构体类型变量 birthday不要写成 struct Date birthday
Datep 定义结构体指针变量 p，指向此结构体类型数据
命名一个新的类型名代表数组类型
typedef int Num 声明 Num为整型数组类型名
Num a 定义a为整型数组名，它有个元素
命名一个新的类型名代表指针类型
typedef char String 声明 String为字符指针类型
String ps 定义p为字符指针变量，s为字符指针数组
命名一个新的类型名代表指向函数的指针类型
typedef int Pointer 声明 Pointer为指向函数的指针类型，该函数返回整型值
Pointer plp pp为 Pointer类型的指针变量
归纳起来，声明一个新的类型名的方法是：
C程序设计第五版
①先按定义变量的方法写出定义体如： inti；。
②将变量名换成新类型名例如： 将i换成 Count。
③在最前面加 typedef例如 typedef int Count。
④然后可以用新类型名去定义变量。
简单地说，就是按定义变量的方式，把变量名换上新类型名，并且在最前面加 typedef，就声明了新类型名代表原来的类型。
以定义上述的数组类型为例来说明：
①先按定义数组变量形式书写 int a。
②将变量名a换成自己命名的类型名 int Num。
③在前面加上 typedef得到 typedef int Num。
④用来定义变量：
Num a
相当于定义了：
int a
同样，对字符指针类型，也是：
①charp 定义变量 p的方式
②char String 用新类型名 String取代变量名 p
③ typedef char String 加 typedef
④ String p 用新类型名 String定义变量相当 charp
习惯上，常把用 typedef声明的类型名的第个字母用大写表示，以便与系统提供的标准类型标识符相区别。
以上的方法实际上是为特定的类型指定了一个同义字 synonyms。例如：
① typedef int Num
Num a Num 是 int的同义词代表有个元素的整型数组
②typedef int Pointer
Pointer pl Pointer是 int的同义词。代表指向函数的指针类型，函数值为整型
用 typedef声明的新类型称为原有类型的 typedef名称。
用typedef只是对已经存在的类型指定一个新的类型名，而没有创造新的类型。例如，前面声明的整型类型 Count，它无非是对 int 型另给一个新名字。又如：
typedef int Num
无非是把原来用“int a；”定义的数组类型用一个新的名字 Num 表示。无论用哪种方式定义变量，效果都是一样的。
用tyoedef声明数组类型、指针类型，结构体类型、共用体类型、枚举类型等，使得编程更加方便。例如定义数组，原来是用
int abcd
第章 用户自己建立数据类型
由于都是一维数组，大小也相同，可以先将此数组类型命名为一个新的名字 Arr，即： typedef int Arr
然后用 Arr去定义数组变量：
Arr abcd 定义个一维整型数组，各含个元素
Arr为数组类型，它包含个元素。因此，a，b，c，d都被定义为一维数组，各含个元素。
可以看到，用typedef可以将数组类型和数组变量分离开来，利用数组类型可以定义多个数组变量。同样可以定义字符串类型、指针类型等。
typedef与 define表面上有相似之处例如
typedef int Count
和
define Count int
从表面看它们的作用都是用 Count代表 int。但事实上，它们二者是不同的。 define是在预编译时处理的，它只能作简单的字符串替换，而typedef是在编译阶段处理的。实际上它并不是作简单的字符串替换，例如：
typedef int Num
Num a
并不是用“Num”去代替“int”，而是采用如同定义变量的方法那样先生成一个类型名就是前面介绍过的将原来的变量名换成类型名，然后用它去定义变量。
当不同源文件中用到同一类型数据尤其是像数组、指针、结构体、共用体等类型数据时，常用 typedef声明一些数据类型。可以把所有的 typedef名称声明单独放在一个头文件中，然后在需要用到它们的文件中用 include 指令把它们包含到文件中。这样编程者就不需要在各文件中自己定义 typedef名称了。
使用 typedef名称有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 类型就便于移植。例如，有的计算机系统 int型数据占用两个字节，数值范围为 ，而另外一些机器则以个字节存放一个整数，数值范围为±亿。如果把一个C程序从一个以个字节存放整数的计算机系统移植到以个字节存放整数的系统按一般办法需要将定义变量中的每个 int 改为 long将“int abc”改为“long ab，c；”，如果程序中有多处用 int定义变量，则要改动多处。现可以用一个 Integer 来代替 int
typedef int Integer
在程序中所有整型变量都用 Integer定义。在移植时只须改动 typedef定义体即可：
typedef long Integer
说明：本节介绍的内容，在初学时可能用不到，可以先了解一下，有个印象，以后需要时再来查阅一下。
C程序设计第五版
习 题
定义一个结构体变量包括年、月、日。计算该日在本年中是第几天，注意闰年问题。
写一个函数 days，实现第题的计算。由主函数将年、月、日传递给days函数，计算后将日子数传回主函数输出。
编写一个函数 print，打印一个学生的成绩数组，该数组中有个学生的数据记录，每个记录包括 num name score用主函数输入这些记录用 print 函数输出这些记录。
在第题的基础上，编写一个函数 input，用来输入个学生的数据记录。
有个学生，每个学生的数据包括学号、姓名、门课程的成绩，从键盘输入个学生数据，要求输出门课程总平均成绩，以及最高分的学生的数据包括学号、姓名、门课程成绩、平均分数。
个人围成一圈，从第个人开始顺序报号，，。凡报到者退出圈子。找出最后留在圈子中的人原来的序号。要求用链表实现。
在第章例和例的基础上，写一个函数 del，用来删除动态链表中指定的结点。
写一个函数 insert，用来向一个动态链表插入结点
综合本章例建立链表的函数 creat、例输出链表的函数 print和本章习题第题删除链表中结点的函数 dei、第题插入结点的函数 insert，再编写一个主函数，先后调用这些函数。用以上个函数组成一个程序，实现链表的建立、输出、删除和插入，在主函数中指定需要删除和插入的结点的数据。
已有a，b两个链表，每个链表中的结点包括学号、成绩。要求把两个链表合并，按学号升序排列。
有两个链表a和b，设结点中包含学号、姓名。从a链表中删去与b链表中有相同学号的那些结点。
建立一个链表，每个结点包括： 学号、姓名、性别、年龄。输入一个年龄，如果链表中的结点所包含的年龄等于此年龄，则将此结点删去。
第章 对文件的输入输出
C文件的有关基本知识
凡是用过计算机的人都不会对“文件”感到陌生，大多数人都接触过或使用过文件，例如：写好一篇文章把它存放到磁盘上以文件形式保存；编写好一个程序，以文件形式保存在磁盘中；用数码相机照相，每一张照片就是一个文件；随电子邮件发送的“附件”就是以文件形式保存的信息。需要时就从文件读取信息。在程序中使用文件之前应了解有关文件的基本知识。
什么是文件
文件有不同的类型，在程序设计中，主要用到两种文件：
程序文件。包括源程序文件后缀为 c、目标文件后缀为 obj、可执行文件后缀为 exe等。这种文件的内容是程序代码。
数据文件。文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输出到磁盘或其他外部设备的数据，或在程序运行过程中供读入的数据。如一批学生的成绩数据、货物交易的数据等。
本章主要讨论的是数据文件。
在以前各章中所处理的数据的输入和输出，都是以终端为对象的，即从终端的键盘输入数据，运行结果输出到终端显示器上。实际上，常常需要将一些数据运行的最终结果或中间数据输出到磁盘上保存起来，以后需要时再从磁盘中输入到计算机内存。这就要用到磁盘文件。
为了简化用户对输入输出设备的操作，使用户不必去区分各种输入输出设备之间的区别，操作系统把各种设备都统一作为文件来处理。从操作系统的角度看，每一个与主机相连的输入输出设备都看作一个文件。例如，终端键盘是输入文件，显示屏和打印机是输出文件。
文件 file是程序设计中一个重要的概念。所谓“文件”一般指存储在外部介质上数据的集合。一批数据是以文件的形式存放在外部介质如磁盘上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存放在外部介质上的数据，必须先按文件名找到所指定的文件，然后再从该文件中读取数据。要向外部介质上存储数据也必须先建立一个文件以文件名作为标志，才能向它输出数据。
输入输出是数据传送的过程，数据如流水一样从一处流向另一处，因此常将输入输出形象地称为流 stream，即数据流。流表示了信息从源到目的端的流动。在输入操作时，数据从文件流向计算机内存，在输出操作时，数据从计算机流向文件如打印机、磁盘文件。文件是由操作系统进行统一管理的，无论是用 Word打开或保存文件，还是C程序中的输入输出都是通过操作系统进行的。“流”是一个传输通道，数据可以从运行环境有关设备流入
C程序设计第五版
程序中，或从程序流至运行环境。
C语言把文件看作一个字符或字节的序列，即由一个一个字符或字节的数据顺序组成。一个输入输出流就是一个字符流或字节内容为二进制数据流。
C的数据文件由一连串的字符或字节组成，而不考虑行的界限，两行数据间不会自动加分隔符，对文件的存取是以字符字节为单位的。输入输出数据流的开始和结束仅受程序控制而不受物理符号如回车换行符控制，这就增加了处理的灵活性。这种文件称为流式文件。
文件名
一个文件要有一个唯一的文件标识，以便用户识别和引用。文件标识包括部分：文件路径；文件名主干；文件后缀。
文件路径表示文件在外部存储设备中的位置。如：
DCC temp filel dat
文件路径 文件名主干 文件后缀
表示 file dat 文件存放在 D盘中的CC目录下的 temp子目录下面。
为方便起见，文件标识常被称为文件名，但应了解此时所称的文件名，实际上包括以上部分内容，而不仅是文件名主干。文件名主干的命名规则遵循标识符的命名规则。后缀用来表示文件的性质如 doc Word生成的文件 txt文本文件 dat数据文件cC语言源程序文件 cppC源程序文件 forFORTRAN 语言源程序文件 pas Pascal语言源程序文件 obj目标文件 exe可执行文件 ppt电子幻灯文件 bmp图形文件等。
文件的分类
根据数据的组织形式，数据文件可分为 ASCII文件和二进制文件。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件 image file。如果要求在外存上以ASCⅡ代码形式存储，则需要在存储前进行转换。ASCII文件又称文本文件 text file，每一个字节存放一个字符的ASCⅡ代码。
一个数据在磁盘上怎样存储呢 字符一律以 ASCII形式存储，数值型数据既可以用ASCⅡ形式存储，也可以用二进制形式存储。如有整数，如果用ASCⅡ码形式输出到磁盘，则在磁盘中占个字节每一个字符占一个字节，而用二进制形式输出，则在磁盘上只占个字节用 Visual C时见图。
ASCII形式
内存中
存储形式
二进制形式
图
第章 对文件的输入输出
用ASCⅡ码形式输出时字节与字符一一对应，一个字节代表一个字符，因而便于对字符进行逐个处理，也便于输出字符。但一般占存储空间较多，而且要花费转换时间二进制形式与ASCⅡ码间的转换。用二进制形式输出数值，可以节省外存空间和转换时间，把内存中的存储单元中的内容原封不动地输出到磁盘或其他外部介质上，此时每一个字节并不一定代表一个字符。如果程序运行过程中有的中间数据需要保存在外部介质上，以便在需要时再输入到内存，一般用二进制文件比较方便。在事务管理中，常有大批数据存放在磁盘上，随时调入计算机进行查询或处理，然后又把修改过的信息再存回磁盘，这时也常用二进制文件。
文件缓冲区
ANSI C标准采用“缓冲文件系统”处理数据文件，所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区充满缓冲区，然后再从缓冲区逐个地将数据送到程序数据区给程序变量，见图。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的C编译系统确定。
说明： 每一个文件在内存中只有一个缓冲区，在向文件输出数据时，它就作为输出缓冲区，在从文件输入数据时，它就作为输入缓冲区。
输出文件缓冲区
程序数据区
输出 磁盘
输出
输入文件缓冲区
输入
输入
图
文件类型指针
缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息如文件的名字、文件状态及文件当前位置等。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为 FILE。例如有一种C编译环境提供的 stdio h头文仵中有以下的文件类型声明：
typedef struct
short level 缓冲区“满”或“空”的程度
unsigned flags 文件状态标志
char fd 文件描述符
unsigned char hold 如缓冲区无内容不读取字符
short bsize 缓冲区的大小
unsigned char buffer 数据缓冲区的位置
unsigned char curp 文件位置标记指针当前的指向
unsigned istemp 临时文件指示器
C程序设计第五版
short token 用于有效性检查
FILE
不同的C编译系统的FILE类型包含的内容不完全相同，但大同小异。对以上结构体中的成员及其含义可不深究，只须知道其中存放文件的有关信息即可。可以看到： FILE是以上结构体类型的自己命名的类型名称，FILE与上面的结构体类型等价。
以上声明FILE结构体类型的信息包含在头文件“stdio h”中。在程序中可以直接用FILE类型名定义变量。每一个FILE类型变量对应一个文件的信息区，在其中存放该文件的有关信息。例如，可以定义以下 FILE类型的变量：
FILE f
以上定义了一个结构体变量f，用它来存放一个文件的有关信息。这些信息是在打开一个文件时由系统根据文件的情况自动放入的，在读写文件时需要用到这些信息，也会修改某些信息。例如在读一个字符后，文件信息区中的位置标记指针的指向就要改变。
一般不定义FILE类型的变量命名，也就是不通过变量的名字来引用这些变量，而是设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。这样使用起来方便。
下面定义一个指向文件型数据的指针变量：
FILE fp
定义 fp是一个指向 FILE类型数据的指针变量。可以使fp指向某一个文件的文件信息区是一个结构体变量，通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。如果有n个文件，应设n个指针变量，分别指向 n个FILE类型变量，以实现对 n个文件的访问，见图。
fpl
fp
fp
文件 fl的
文件f的
文件f的
文件信息区
文件信息区
文件信息区
图
为方便起见，通常将这种指向文件信息区的指针变量简称为指向文件的指针变量。
注意：指向文件的指针变量并不是指向外部介质上的数据文件的开头，而是指向内存中的文件信息区的开头。
打开与关闭文件
对文件读写之前应该“打开”该文件，在使用结束之后应“关闭”该文件。“打开”和“关闭”是形象的说法，好像打开门才能进入房子，门关闭就无法进入一样。实际上，所谓“打开”
第章 对文件的输入输出
是指为文件建立相应的信息区用来存放有关文件的信息和文件缓冲区用来暂时存放输入输出的数据。
在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系，这样，就可以通过该指针变量对文件进行读写了。所谓“关闭”是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法进行对文件的读写了。
用 fopen函数打开数据文件
ANSI C规定了用标准输入输出函数 fopen 来实现打开文件。
fopen函数的调用方式为
fopen文件名使用文件方式
例如：
fopena r
表示要打开名字为 al 的文件，使用文件方式为“读入”r代表 read，即读入。 fopen函数的返回值是指向 al 文件的指针即 al文件信息区的起始地址。通常将fopen 函数的返回值赋给一个指向文件的指针变量。如：
FILE fp 定义一个指向文件的指针变量 fp
fp fopena r 将 fopen函数的返回值赋给指针变量 fp
这样 fp就和文件 al 相联系了，或者说，fp指向了 al文件。可以看出，在打开一个文件时，通知编译系统以下个信息：①需要打开文件的名字，也就是准备访问的文件的名字；②使用文件的方式“读”还是“写”等；③让哪一个指针变量指向被打开的文件。
使用文件方式见表。
表 使用文件方式
文件使用方式 含 义 如果指定的文件不存在 r只读 为了输入数据，打开一个已存在的文本文件 出错 w只写 为了输出数据，打开一个文本文件 建立新文件 a追加 向文本文件尾添加数据 出错 rb只读 为了输入数据，打开一个二进制文件 出错 wb只写 为了输出数据，打开一个二进制文件 建立新文件 ab追加 向二进制文件尾添加数据 出错 “r”读写 为了读和写，打开一个文本文件 出错 “w”读写 为了读和写，建立一个新的文本文件 建立新文件“a”读写为了读和写，打开一个文本文件出错“rb”读写为了读和写，打开一个二进制文件出错“wb”读写为了读和写，建立一个新的二进制文件建立新文件“ab”读写为读写打开一个二进制文件出错
C程序设计第五版
用r方式打开的文件只能用于向计算机输入而不能用作向该文件输出数据，而且该文件应该已经存在，并存有数据，这样程序才能从文件中读数据。不能用r方式打开一个并不存在的文件，否则出错。
用w方式打开的文件只能用于向该文件写数据即输出文件，而不能用来向计算机输入。如果原来不存在该文件，则在打开文件前新建立一个以指定的名字命名的文件。如果原来已存在一个以该文件名命名的文件，则在打开文件前先将该文件删去，然后重新建立一个新文件。
如果希望向文件末尾添加新的数据不希望删除原有数据，则应该用a方式打开。但此时应保证该文件已存在；否则将得到出错信息。打开文件时，文件读写位置标记移到文件末尾①。
用“r”“w”“a”方式打开的文件既可用来输入数据，也可用来输出数据。用“r”方式时该文件应该已经存在，以便计算机从中读数据。用“w”方式则新建立一个文件，先向此文件写数据，然后可以读此文件中的数据。用“a”方式打开的文件，原来的文件不被删去，文件读写位置标记移到文件末尾，可以添加，也可以读。
如果不能实现“打开”的任务， fopen函数将会带回一个出错信息。出错的原因可能是：用r方式打开一个并不存在的文件；磁盘出故障；磁盘已满无法建立新文件等。此时 fopen函数将带回一个空指针值 NULL在 stdio h头文件中NULL已被定义为。
常用下面的方法打开一个文件：
if fp fopenfilel rNULL
printfcannot open this filen
exit
即先检查打开文件的操作有否出错如果有错就在终端上输出 cannot open this file。 exit函数的作用是关闭所有文件，终止正在执行的程序，待用户检查出错误，修改后重新运行。
C标准建议用表列出的文件使用方式打开文本文件或二进制文件，但目前使 用的有些C编译系统可能不完全提供所有这些功能例如，有的只能用r，w，a方式，有的C版本不用“r”“w”“a”而用 rw，wr，ar等，请读者注意所用系统的规定。
在表中，有种文件使用方式，其中有种是在第一个字母后面加了字母b的如 rb wb ab rb wb abb表示二进制方式。其实带b和不带b只有一个区别，即对换行的处理。由于在C语言用一个n即可实现换行，而在 Windows系统中为实现换行必须要用“回车”和“换行”两个字符，即r和n。因此，如果使用的是文本文件并且用w方式打开，在向文件输出时，遇到换行符n时，系统就把它转换为r和n两个字符，否则在 Windows系统中查看文件时，各行连成一片，无法阅读。同样，如果有文本文件
① 程序往往要向数据文件读写数据，但是究竟读哪一个数据，或者把数据写到哪个位置上呢 在每个数据文件中自动设置了一个隐式的“文件读写位置标记”，它指向的位置就是当前进行读写的位置。如果“文件读写位置标记”在文件开头，则下一次的读写就是文件开头的数据。然后“文件读写位置标记”自动移到下一个读写位置，以便读写下一个数据。
第章 对文件的输入输出
且用r方式打开，从文件读入时，遇到r和n两个连续的字符，就把它们转换为n一个字符。如果使用的是二进制文件，在向文件读写时，不需要这种转换。加b表示使用的是二进制文件，系统就不进行转换。
如果用 wb的文件使用方式，并不意味着在文件输出时把内存中按ASCⅡ形式保存的数据自动转换成二进制形式存储。输出的数据形式是由程序中采用什么读写语句决定的。例如用 fscanf和 fprintf函数是按ASCII 方式进行输入输出而 fread和 fwrite 函数是按二进制进行输入输出。各种对文件的输入输出语句，详见节。
在打开一个输出文件时，是选 w还是 wb方式，完全根据需要，如果需要对回车符进行转换的，就用w，如果不需要转换的，就用 wb。带b只是通知编译系统： 不必进行回车符的转换。如果是文本文件例如一篇文章，显然需要转换，应该用 w方式。如果是用二进制形式保存的一批数据，并不准备供人阅读，只是为了保存数据，就不必进行上述转换。可以用 wb方式。一般情况下，带b的用于二进制文件，常称为二进制方式，不带b的用于文本文件，常称为文本方式，从理论上说，文本文件也可以 wb方式打开，但无必要。
程序中可以使用个标准的流文件——标准输入流、标准输出流和标准出错输出流。系统已对这个文件指定了与终端的对应关系。标准输入流是从终端的输入，标准输出流是向终端的输出，标准出错输出流是当程序出错时将出错信息发送到终端。
程序开始运行时系统自动打开这个标准流文件。因此，程序编写者不需要在程序中用 fopen函数打开它们。所以以前我们用到的从终端输入或输出到终端都不需要打开终端文件。系统定义了个文件指针变量 stdin， stdout 和 stderr，分别指向标准输入流、标准输出流和标准出错输出流，可以通过这个指针变量对以上种流进行操作，它们都以终端作为输入输出对象。例如程序中指定要从 stdin所指的文件输入数据，就是指从终端键盘输入数据。
用 fclose函数关闭数据文件
在使用完一个文件后应该关闭它，以防止它再被误用。“关闭”就是撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，也就是文件指针变量与文件“脱钩”，此后不能再通过该指针对原来与其相联系的文件进行读写操作，除非再次打开，使该指针变量重新指向该文件。
关闭文件用 fclose函数。 fclose函数调用的一般形式为
fclose文件指针
例如：
fclose fp
前面曾把打开文件用fopen函数时函数返回的指针赋给了 fp，现在把 fp指向的文件关闭，此后 fp不再指向该文件。
如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。用fclose 函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撤销文件信息区。有的编译系统在程序结束前会
C程序设计第五版
自动先将缓冲区中的数据写到文件，从而避免了这个问题，但还是应当养成在程序终止之前关闭所有文件的习惯。
fclose 函数也带回一个值，当成功地执行了关闭操作，则返回值为；否则返回EOF。
顺序读写数据文件
文件打开之后，就可以对它进行读写了。在顺序写时，先写入的数据存放在文件中前面的位置，后写入的数据存放在文件中后面的位置。在顺序读时，先读文件中前面的数据，后读文件中后面的数据。也就是说，对顺序读写来说，对文件读写数据的顺序和数据在文件中的物理顺序是一致的。顺序读写需要用库函数实现。
怎样向文件读写字符
对文本文件读入或输出一个字符的函数见表。
表读写一个字符的函数
函数名 调用形式 功 能 返 回 值 fgetc fgetcfp 从 fp指向的文件读入一个字符 读成功，带回所读的字符，失败则返回文 件结束标志 EOF即 fputc fputcch fp 把字符 ch写到文件指针变量 fp 所指向的文件中输出成功，返回值就是输出的字符；输出失败则返回 EOF即
说明 fgetc的第个字母f代表文件 file中间的 get表示“获取”最后一个字母c表示字符 character fgetc的含义很清楚从文件读取一个字符。 fputc也类似。
【例】从键盘输入一些字符，并逐个把它们送到磁盘上去，直到用户输入一个“”为止。
解题思路： 用fgetc函数从键盘逐个输入字符，然后用 fputc函数写到磁盘文件即可。
编写程序：
include stdio h
include stdlib h
int main
FILE fp 定义文件指针 fp
church filename
printf请输入所用的文件名
scanfs filename 输入文件名
getchar 用来消化最后输入的回车符
if fp fopen filename wNULL 打开输出文件并使 fp指向此文件
printfcannot open filen 如果打开出错就输出“打不开”，
exit 终止程序
printf请输入一个准备存储到磁盘的字符串以结束：；
第章 对文件的输入输出
ch getchar 接收从键盘输入的第一个字符
while ch 当输入时结束循环
fputc ch fp 向磁盘文件输出一个字符
putchar ch 将输出的字符显示在屏幕上
ch getchar 再接收从键盘输入的一个字符
fclose fp 关闭文件
putchar 向屏幕输出一个换行符
return
运行结果：
请输入所用的文件名 file dat
请输入一个准备存储到磁盘的字符串以结束 computer and c
computer and c
程序分析：
用来存储数据的文件名可以在 fopen函数中直接写成字符串常量形式如指定 al，也可以在程序运行时由用户临时指定。本程序采取的方法是由键盘输入文件名。为此设立一个字符数组 filename，用来存放文件名。运行时，从键盘输入磁盘文件名 file dat，操作系统就新建立一个磁盘文件file dat，用来接收程序输出的数据。
用fopen函数打开一个“只写”的文件w表示只能写入不能从中读数据，如果打开文件成功，函数的返回值是该文件所建立的信息区的起始地址，把它赋给指针变量 fpfp已定义为指向文件的指针变量。如果不能成功地打开文件，则在显示器的屏幕上显示“无法打开此文件”，然后用 exit函数终止程序运行。
exit是标准C 的库函数，作用是使程序终止，用此函数时在程序的开头应包含 stdlib h头文件。
用getchar函数接收用户从键盘输入的字符。注意每次只能接收一个字符。注意程序第行的作用： 用scanf函数输入文件名时，最后加了一个“回车”，它表示输入的字符串结束，它前面输入的字符作为文件名，但是“回车”符仍保留在缓冲区中。为了避免其后把它作为有效数据读取，用第行的 getchar 函数把它读取了，但并不赋给任何变量，只是把回车符“消化”了。第 行“ch getchar”是接收从键盘输入的一个字符并赋给 ch，并在循环体中不断重复此操作。今从键盘连续输入字符串computer and c， 是用来向程序表示“输入的字符串到此结束”。用什么字符作为结束标志是人为的，由程序指定的，也可以用别的字符如”！”， 或其他字符作为结束标志。但应注意： 如果字符串中包含，就不能用作结束标志。
执行过程是：先从键盘读入一个字符，检查它是否为，如果是，表示字符串已结束，不执行循环体。如果不是，则执行一次循环体，将该字符输出到磁盘文件file dat。然后在屏幕上显示出该字符，接着再从键盘读入一个字符。如此反复，直到读入字符为止。这时程序已将 computer and c写到以 file dat命名的磁盘文件中了同时在屏幕上也显示出了这些字符，以便核对。
C程序设计第五版
为了检查磁盘文件 filel dat中是否确实存储了这些内容，可以在 Windows的资源管理器中，按记事本的打开方式打开文件，在屏幕上会显示：
Computer and c 显示出此文件中的信息
这就证明了在 file dat文件中已存入了 computer and c的信息。
【例】 将一个磁盘文件中的信息复制到另一个磁盘文件中。今要求将上例建立的 file dat文件中的内容复制到另一个磁盘文件file dat 中。
解题思路： 处理此问题的算法是： 从filel dat 文件中逐个读入字符，然后逐个输出到file dat 中。
编写程序：
include stdio h
include stdlib h
int main
FILE in out 定义指向 FILE类型文件的指针变量
char ch infile outfile 定义两个字符数组，分别存放两个数据文件名
printf输入读入文件的名字
scanfs infile 输入一个输入文件的名字
printf输入输出文件的名字
scanfs outfile 输入一个输出文件的名字
if in fopen infile rNULL 打开输入文件
printf无法打开此文件n
exit
if out fopen outfile wNULL 打开输出文件
printf无法打开此文件n
exit
ch fgetc in 从输入文件读入一个字符，赋给变量 ch
while feof in 如果未遇到输入文件的结束标志
fputc ch out 将ch写到输出文件
putchar ch 将ch显示到屏幕上
ch fgetc in 再从输入文件读入一个字符，赋给变量 ch
putchar 显示完全部字符后换行
fclose in 关闭输入文件
fclose out 关闭输出文件
return
运行结果：
输入读入文件的名字file dat
输入输出文件的名字file dat
computer and c
第章 对文件的输入输出
程序分析：
在访问磁盘文件时，是逐个字符字节进行的，为了知道当前访问到第几个字节，系统用“文件读写位置标记”来表示当前所访问的位置。开始时“文件读写位置标记”指向第个字节，每访问完一个字节后，当前读写位置就指向下一个字节，即当前读写位置自动后移。
为了知道对文件的读写是否完成，只须看文件读写位置是否移到文件的末尾。
说明： 在文件的所有有效字符后有一个文件尾标志。当读完全部字符后，文件读写位置标记就指向最后一个字符的后面，即指向了文件尾标志。如果再执行读取操作，则会读出不要理解为最后有一个结束字节，在其中存放了数值。它只是一种处理方法。文件尾标志用标识符 EOF end of file表示EOF 在 stdio h头文件中被定义为。
用 feof函数可以检测文件尾标志是否已被读取过。如果文件尾标志已被读出，则表示文件已结束，此时 feof函数值为真以表示，否则 feof函数值为假以表示。不要把 feof函数值的真和假与文件尾标志的假设值相混淆。前者为函数值，后者为尾标志的假设值。
程序第行中的 feof in用来判断 in所指向的文件是否结束了。开始时显然没有读到文件尾标志故“feof in”为假 “ feof in”为真所以要执行 while循环体。直到读取完最后一个字符并输出到磁盘文件和屏幕后，还再执行一次 fgetc函数第行，即读取文件尾标志了。再返回 while语句检查循环条件此时 feof in为真了因此“ feof in”为假不再执行 while循环体了。
请读者考虑： 第行的 while语句能否改为
while ch 或 while chEOF
实际上是可以的，EOF 就是—。本例用 feof函数，是为了使读者了解文件尾标志和 feof函数的使用。
运行结果是将 file dat文件中的内容复制到 file dat中去。
也可以在 Windows的资源管理器中，按记事本的打开方式打开这两个文件，可以看到 file dat 和 file dat 的内容都是
computer and c
以上程序是按文本文件方式处理的。也可以用此程序来复制一个二进制文件，此时只须将两个 fopen 函数中的“r”和“w”分别改为“rb”和“wb”即可。
C系统已在头文件中把 fputc和 fgetc函数定义为宏名 putc 和 getc
define pute ch fp fputc ch fp
define getc fp fgetc fp
这是在 stdio h中定义的。因此在程序中用 pute 和 fputc作用是一样的用 getc 和 fgetc作用是一样的。在使用的形式上，可以把它们当作相同的函数对待。
怎样向文件读写一个字符串
前面已掌握了向磁盘文件读写一个字符的方法，有的读者很自然地提出一个问题，如果
C程序设计第五版
字符个数多，一个一个读和写太麻烦，能否一次读写一个字符串。
C语言允许通过函数 fgets和 fputs一次读写一个字符串，例如：
fgets strn fp
作用是从 fp所指向的文件中读入一个长度为 n的字符串，并在最后加一个字符，然后把这 n个字符存放到字符数组 str中。
读写一个字符串的函数见表。
表读写一个字符串的函数
函数名 调用形式 功 能 返 回值 fgets fgetsstrn fp 从 fp指向的文件读入一个长度为n 的字符串，存放到字符数组 str中。 读成功，返回地址 str，失败则 返回 NULL fputs fputsstr fp 把 str所指向的字符串写到文件指针变 量 fp所指向的文件中输出成功，返回；否则返回非值
fgets中最后一个字母s表示字符串 string。见名知义， fgets的含义是：从文件读取一个字符串。
说明：
fgets函数的函数原型为
char fgets char str int n FILE fp
其作用是从文件读入一个字符串。调用时可以写成下面的形式：
fgets strn fp
其中，n是要求得到的字符个数，但实际上只从 fp所指向的文件中读入 n个字符，然后在最后加一个字符，这样得到的字符串共有n个字符，把它们放到字符数组 str中。如果在读完 n个字符之前遇到换行符“n”或文件结束符EOF，读入即结束，但将所遇到的换行符“n”也作为一个字符读入。若执行 fgets函数成功，则返回值为 str数组首元素的地址，如果一开始就遇到文件尾或读数据出错，则返回NULL。
fputs函数的函数原型为
int fputs char str FILE fp
其作用是将 str所指向的字符串输出到 fp所指向的文件中。调用时可以写成
fputsChina fp
把字符串China输出到 fp指向的文件中。fputs函数中第一个参数可以是字符串常量、字符数组名或字符型指针。字符串末尾的不输出。若输出成功，函数值为；失败时，函数值为EOF即。
fgets和 fgets这两个函数的功能类似于 gets和 puts 函数只是 gets和 puts 以终端为读写对象，而 fgets和 fputs函数以指定的文件作为读写对象。
【例】 从键盘读入若干个字符串，对它们按字母大小的顺序排序，然后把排好序的字符串送到磁盘文件中保存。
解题思路： 为解决问题，可分为个步骤：
第章 对文件的输入输出
从键盘读入 n个字符串，存放在一个二维字符数组中，每个一维数组存放一个字符串；
对字符数组中的 n个字符串按字母顺序排序，排好序的字符串仍存放在字符数组中；
将字符数组中的字符串顺序输出。
编写程序：
include stdio h
include stdlib h
include string h
int main
FILE fp
char str temp str是用来存放字符串的二维数组， temp是临时数组
int ijkn
printfEnter stringsn 提示输入字符串
foriini
gets stri 输入字符串
foriini 用选择法对字符串排序
ki
forjijnj
if strcmp strk strj kj
ifki
strcpy temp stri
strcpy stri strk
strcpy strk temp
if fp fopenDCC string dat wNULL 打开磁盘文件
printfcant open filen
exit
printfnThe new sequencen
foriini
fputs stri fp fputsn fp 向磁盘文件写一个字符串，然后输出一个换行符
printfsn stri 在屏幕上显示
return
运行结果：
Enter strings
CHINA
CANADA
INDIA
The new sequence
CANADA
CHINA
INDIA
C程序设计第五版
程序分析：
程序第行用 fopen函数打开文件时，指定了文件路径，假设想在D盘的CC子目录下建立一个名为 string dat的数据文件，用来存放已排好序的字符串。本来应该写成“D：CC string dat”，但由于在C语言中把作为转义字符的标志，因此在字符串或字符中要表示时应当在之前再加一个即“DCC string dat”。注意 只在双撇号或单撇号中的才需要写成“”，其他情况下则不必。如果读者上机运行此程序，应改为自己选定的文件路径，而不要简单照搬以上程序。
在向磁盘文件写数据时，只输出字符串中的有效字符，并不包括字符串结束标志 。这样前后两次输出的字符串之间无分隔，连成一片。当以后从磁盘文件读回数据时就无法区分各个字符串了。为了避免出现此情况，在输出一个字符串后，人为地输出一个n，作为字符串之间的分隔，见程序第行中的 fputsn fp。
为运行简单起见，本例只输入个字符串，如果有个字符串，只须把第行的n改为 n即可。
可以编写出以下的程序，从文件 string dat中读回字符串，并在屏幕上显示。
include stdio h
include stdlib h
int main
FILE fp
char str
int i
if fp fopenDCC string dat rNULL 注意文件路径必须与前相同
printfcant open filen
exit
while fgets stri fpNULL
printfs stri
i
fclose fp
return
执行此程序，得到以下输出结果：
CANADA
CHINA
INDIA
程序分析：
在打开文件时要注意，指定的文件路径和文件名必须和上次写入时指定的一致，现在都是“DCC string dat”否则找不到该文件。读写方式要改为r。
在第行中用 fgets函数读字符串时，指定一次读入个字符，但按 fgets函数的规定，如果遇到n就结束字符串输入，n作为最后一个字符也读入到字符数组。
由于读入到字符数组中的每个字符串后都有一个n，因此在向屏幕输出时不必再
第章 对文件的输入输出
加n而只写“printfs stri”即可。
用格式化的方式读写文本文件
前面进行的是字符的输入输出，而实际上数据的类型是丰富的。大家已很熟悉用 printf函数和 scanf函数向终端进行格式化的输入输出，即用各种不同的格式以终端为对象输入输出数据。其实也可以对文件进行格式化输入输出，这时就要用 fprintf函数和fscanf函数，从函数名可以看到，它们只是在 printf和scanf的前面加了一个字母f。它们的作用与 printf函数和 scanf函数相仿都是格式化读写函数。只有一点不同 fprintf和 fscanf函数的读写对象不是终端而是文件。它们的一般调用方式为
fprintf文件指针，格式字符串，输出表列；
fscanf文件指针，格式字符串，输入表列；
例如：
fprintf fp dfif
它的作用是将 int型变量i和 float型变量f的值按d和f 的格式输出到 fp指向的文件中。若i，f，则输出到磁盘文件上的是以下的字符：
这是和输出到屏幕的情况相似的，只是它没有输出到屏幕而是输出到文件而已。
同样，用以下 fsanf函数可以从磁盘文件上读入 ASCII字符：
fscanf fp dfif
磁盘文件上如果有字符“，，”，则从磁盘文件中读取整数送给整型变量i，读取实数送给 float型变量f。
用 fprint和fcanf函数对磁盘文件读写，使用方便，容易理解，但由于在输入时要将文件中的ASCII码转换为二进制形式再保存在内存变量中，在输出时又要将内存中的二进制形式转换成字符，要花费较多时间。因此，在内存与磁盘频繁交换数据的情况下，最好不用 fprintf和 fscanf函数而用下面介绍的 f read 和 fwrite 函数进行二进制的读写。
用二进制方式向文件读写一组数据
在程序中不仅需要一次输入输出一个数据，而且常常需要一次输入输出一组数据如数组或结构体变量的值，C语言允许用 fread函数从文件中读一个数据块，用 fwrite 函数向文件写一个数据块。在读写时是以二进制形式进行的。在向磁盘写数据时，直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上，在读入时也是将磁盘文件中若干字节的内容一批读入内存。
它们的一般调用形式为
fread buffer size count fp
fwrite buffer size count fp
其中：
buffer： 是一个地址。对fread来说，它是用来存放从文件读入的数据的存储区的地址。
C程序设计第五版
对 fwrite来说，是要把此地址开始的存储区中的数据向文件输出以上指的是起始地址。
size：要读写的字节数。
count：要读写多少个数据项每个数据项长度为 size。
fp FILE 类型指针。
在打开文件时指定用二进制文件，这样就可以用 fread和fwrite 函数读写任何类型的信息，例如：
freadf fp
其中，f是一个 float型数组名代表数组首元素地址。这个函数从 fp所指向的文件读入个个字节的数据，存储到数组f中。
如果有一个 Struct student type 结构体类型
struct Student type
char name
int num
int age
char addr
stud
定义了一个结构体数组 stud，有个元素，每一个元素用来存放一个学生的数据包括姓名、学号、年龄、地址。假设学生的数据已存放在磁盘文件中，可以用下面的 for语句和fread函数读入个学生的数据：
foriii
fread studi sizeof struct Student type fp
执行次循环，每次从 fp指向的文件中读入结构体数组 stu的一个元素。
同样，以下 for语句和 fwrite函数可以将内存中的学生数据输出到磁盘文件中去：
foriii
fwrite studi sizeof struct Student type fp
fread或 fwrite 函数的类型为 int型如果 fread或 fwrite 函数执行成功则函数返回值为形参 count的值一个整数，即输入或输出数据项的个数今为。
【例】 从键盘输入个学生的有关数据，然后把它们转存到磁盘文件上去。
解题思路：定义一个有个元素的结构体数组，用来存放个学生的数据。从main函数输入个学生的数据。用save函数实现向磁盘输出学生数据。用 fwrite函数一次输出一个学生的数据。
编写程序：
include stdio h
define SIZE
struct Student type
char name
int num
int age
第章 对文件的输入输出
char addr
studSIZE 定义全局结构体数组 stud，包含个学生数据
void save 定义函数 save，向文件输出 SIZE个学生的数据
FILE fp
int i
if fp fopenstu dat wbNULL 打开输出文件 stu dat
printfcannot open filen
return
foriiSIZEi
if fwrite studi sizeof struct Student type fp
printf file write errorn
fclose fp
int main
int i
printfPlease enter data of studentsn
foriiSIZEi 输入 SIZE个学生的数据，存放在数组 stud中
scanfsdds studi name studi num studi age studi addr
save
return
运行结果输入个学生的姓名、学号、年龄和地址：
Please enter data of students
Zhang room
Sun roon
Tan room
Ling room
Li room
Wang room
Zhen room
Fu room
Qin room
Liu room
程序分析：
在main函数中，从终端键盘输入个学生的数据，然后调用save函数，将这些数据输出到以 stu dat命名的磁盘文件中。 fwrite函数的作用是将一个长度为节的数据块送到 stu dat文件中一个 struct student type 类型结构体变量的长度为它的成员长度之和即实际上占字节是的倍数。
在 fopen 函数中指定读写方式为 wb，即二进制写方式。在向磁盘文件 stu dat写的时候，将内存中存放 stud数组元素 studi的内存单元中的内容原样复制到磁盘文件，所建立的 stu dat文件是一个二进制文件。这个文件可以为其他程序所用在本章例的程序中将从这个文件读取数据。
在本程序中，用 fopen函数打开文件时没有指定路径，只写了文件名 stu dat，系统
C程序设计第五版
默认其路径为当前用户所使用的子目录即源文件所在的目录，在此目录下建立一个新文件 stu dat，输出的数据存放在此文件中。
程序运行时，屏幕上并无输出任何信息，只是将从键盘输入的数据送到磁盘文件上。
为了验证在磁盘文件 stu dat中是否已存在此数据，可以用以下程序从 stu dat文件中读入数据，然后在屏幕上输出。
include stdio h
include stdlib h
define SIZE
struct Student type
char name
int num
int age
char addr
studSIZE
int main
int i
FILE fp
if fp fopenstu dat rbNULL 打开输入文件 stu dat
printfcannot open filen
exit
foriiSIZEi
fread studi sizeof struct Student type fp 从 fp指向的文件读入一组数据
printfs ddsn studi name studi num studi age studi addr
在屏幕上输出这组数据
fclose fp 关闭文件 stu list
return
运行结果不需从键盘输入任何数据。屏幕上显示出以下信息：
Zhang room
Sun room
Tan room
Ling room
Li room
Wang room
Zhen room
Fu room
Qin room
Liu room
程序分析： 注意输入输出数据的状况。在前面一个程序中，从键盘输入个学生的数据是ASCⅡ码，也就是文本文件。在送到计算机时，回车和换行符转换成一个换行符。再用 fwrite函数以二进制形式输出到 stu dat文件，此时不发生字符转换，按内存中存储形
第章 对文件的输入输出
式原样输出到磁盘文件上。在其后的验证程序中，又用 fread函数从 stu dat文件向内存读入数据，注意此时用的是 rb方式，即二进制方式，数据按原样输入，也不发生字符转换。也就是这时候内存中的数据恢复到第个程序向 stu dat输出以前的情况。最后在验证程序中，用 printf函数输出到屏幕， printf是格式输出函数，输出 ASCII码，在屏幕上显示字符。换行符又转换为回车加换行符。
如果企图从 stu dat文件中以“r”方式读入数据就会出错。
f read 和fwrite 函数用于二进制文件的输入输出。因为它们是按数据块的长度来处理输入输出的，不出现字符转换。
如果有字符转换，很可能出现与原设想的情况不同。例如，若写出
fread studi sizeof struct student type stdin
企图从终端键盘输入数据 stdin是指向标准输入流的指针变量，这在语法上并不存在错误，编译能通过。如果用以下形式输入数据：
Zhang room ✔
⋮
由于 fread函数要求一次输入个字节而不问这些字节的内容，因此输入数据中的空格也作为输入数据而不作为数据间的分隔符了。连空格也存储到 stui中了，显然是不对的。
这个题目要求的是从键盘输入数据，如果已有的数据已经以二进制形式存储在一个磁盘文件 stu list中，要求从其中读入数据并输出到 stu dat文件中，可以编写一个如下的 load 函数从磁盘文件 stu list中读二进制数据并存放在 stud数组中。
void load
FILE fp
int i
if fp fopenstu list rbNULL 打开输入文件 stu list
printfcannot open infilen
return
foriiSIZEi
if fread studi sizeof struct Student type fp 从 stu list文件中读数据
if feof fp
fclose fp
return
printffile read errorn
fclose fp
将 load 函数加到本例第一个程序文件中，并将 main函数改为 int main
load
C程序设计第五版
save
return
注意：请区分下面几个概念每个都有文本和二进制两种方式：
数据的存储方式
文本方式： 数据以字符方式ASCⅡ代码存储到文件中。如整数，送到文件时占个字节，而不是个字节。以文本方式保存的数据便于阅读。
二进制方式：数据按在内存的存储状态原封不动地复制到文件。如整数，送到文件时和在内存中一样占个字节。
文件的分类
文本文件ASCⅡ文件： 文件中全部为 ASCⅡ字符。
二进制文件：按二进制方式把在内存中的数据复制到文件的，称为二进制文件，即映像文件。
文件的打开方式
文本方式： 不带b的方式，读写文件时对换行符进行转换。
二进制方式： 带b的方式，读写文件时对换行符不进行转换。
文件读写函数
文本读写函数 用来向文本文件读写字符数据的函数如 fgetc fgets fputc fputs fscanf fprintf等。
二进制读写函数：用来向二进制文件读写二进制数据的函数如 getw， putw， fread， fwrite等。
说明： C语言不禁止文本方式与二进制方式之间出现某些交叉，例如用二进制方式存储的一个整数，也可以用文本读写函数如fscanf画函数读取；用二进制方式也可以打开文本文件。这些虽然合法，但往往会导致结果出错。不提倡这种随意的、不规范的用法。提倡用文本方式打开文本文件，用文本读写函数进行读写。对二进制文件亦然。
随机读写数据文件
对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高，例如文件中有个数据，若只查第个数据，必须先逐个读入前面个数据，才能读入第个数据。如果文件中存放一个城市几百万人的资料，若按此方法查某一人的情况，等待的时间可能是不能忍受的。
随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数据进行访问，显然这种方法比顺序访问效率高得多。
文件位置标记及其定位
文件位置标记
前已介绍，为了对读写进行控制，系统为每个文件设置了一个文件读写位置标记简称
第章 对文件的输入输出
文件位置标记或文件标记，用来指示“接下来要读写的下一个字符的位置”①。
一般情况下，在对字符文件进行顺序读写时，文件位置标记指向文件开头，这时如果对文件进行读的操作，就读第个字符，然后文件位置标记向后移一个位置，在下一次执行读的操作时，就将位置标记指向的第个字符读入。依此类推，遇到文件尾结束。见图示意。
文件头
读写当前位置
文件尾
图
如果是顺序写文件，则每写完一个数据后，文件位置标记顺序向后移一个位置，然后在下一次执行写操作时把数据写入位置标记所指的位置。直到把全部数据写完，此时文件位置标记在最后一个数据之后。
可以根据读写的需要，人为地移动文件位置标记的位置。文件位置标记可以向前移、向后移，移到文件头或文件尾，然后对该位置进行读写，显然这就不是顺序读写了，而是随机读写。
对流式文件既可以进行顺序读写，也可以进行随机读写。关键在于控制文件的位置标记。如果文件位置标记是按字节位置顺序移动的，就是顺序读写。如果能将文件位置标记按需要移动到任意位置，就可以实现随机读写。所谓随机读写，是指读写完上一个字符字节后，并不一定要读写其后续的字符字节，而可以读写文件中任意位置上所需要的字符字节。即对文件读写数据的顺序和数据在文件中的物理顺序一般是不一致的。可以在任何位置写入数据，在任何位置读取数据。
文件位置标记的定位
可以强制使文件位置标记指向人们指定的位置。可以用以下函数实现。
用 rewind函数使文件位置标记指向文件开头
rewind函数的作用是使文件位置标记重新返回文件的开头，此函数没有返回值。
【例】 有一个磁盘文件，内有一些信息。要求第次将它的内容显示在屏幕上，第次把它复制到另一文件上。
解题思路：分别实现以上两个任务都不困难，但是把二者连续做，就会出现问题，因为在第次读入完文件内容后，文件位置标记已指到文件的末尾，如果再接着读数据，就遇到文件结束标志 EOF， feof函数的值等于真，无法再读数据。必须在程序中用 rewind函数使位置指针返回文件的开头。
① 为了使读者便于理解，有的教材把文件读写位置标记形象化地称为“文件位置指针”还有称为“文件指针”的，认为可以设想在文件中有一个看不见的指针在移动，它指向文件中下一个被读写的字节。但是这里说的“指针”和C语言中的“指针”所表示的意思是完全不同的，容易引起混淆。有的读者常把“文件位置标记”和“指向文件的指针”FILE指针相混淆。从概念上说，变量的指针就是变量在内存中存储单元的地址。而文件是存储在外部介质上的，不存在内存地址。因此作者认为指示文件读写位置的不宜称为“指针”，应称为“文件位置标记”更为确切。
C程序设计第五版
编写程序：
include stdio h
int main
FILEfpfp
fpl fopenfilel dat r 打开输入文件
fp fopenfile dat w 打开输出文件
ch getc fpl 从 file dat 文件读入第一个字符
while feof fpl 当未读取文件尾标志
putchar ch 在屏幕输出一个字符
ch getc fpl 再从 filel dat文件读入一个字符
putchar 在屏幕执行换行
rewind fpl 使文件位置标记返回文件开头
ch getc fpl 从 file dat 文件读入第一个字符
while feof fpl 当未读取文件尾标志
fputc chfp 向 file dat 文件输出一个字符
ch fgetc fpl 再从 file dat文件读入一个字符
fclose fpl fclosefp
return
运行结果：
computer and c
程序分析 先打开 file dat 和 file dat两个文件。 file dat中已存放了 computer and c共个字符。先从 file dat读入第一个字符并赋给 ch。 while语句的循环条件是文件尾标志未被读过。在第一个 while循环中，先向屏幕输出一个字符，然后再从 filel dat文件读入一个字符。直到读入和输出最后一个字符。请注意在输出完最后一个字符后，再执行的“ch getc fpl”的作用。它的作用是 在读取完最后一个字符后再读一次 file dat文件，这时就读了文件尾标志，当再在 while语句捡检查循环条件时， feof fpl为真， feoffp为假循环终止。如果没有执行该 getc fpl则 feof fpl不会变为真。请记住 feof fpl为真的条件是： 读完最后一个字符后再读一次文件，即要读一次文件尾标志EOF。
和例一样 while条件也可改为 while chEOF。
rewind 函数的作用是：使文件 file l的文件位置标记重新定位于文件开头，同时 feof函数的值会恢复为假。
这个程序是示意性的，为简化起见，在打开文件时未作“是否打开成功”的检查。这项工作留给读者自己去完成。
用 fseek函数改变文件位置标记
fseek函数的调用形式为
fseek文件类型指针，位移量，起始点
第章 对文件的输入输出
“起始点”用， 或代替，代表“文件开始位置”，为“当前位置”，为“文件末尾位置”。C标准指定的名字如表所示。
表 C标准指定的名字
起 始 点 名 字 用数字代表 文件开始位置 SEEKSET 文件当前位置 SEEKCUR 文件末尾位置SEEKEND
“位移量”指以“起始点”为基点，向前移动的字节数。位移量应是 long型数据在数字的末尾加一个字母L，就表示是 long 型。
fseek 函数一般用于二进制文件。下面是 fseek函数调用的几个例子：
fseek fpL 将文件位置标记向前移到离文件开头个字节处
fseek fpL 将文件位置标记向前移到离当前位置个字节处
fseek fpL 将文件位置标记从文件末尾处向后退个字节
用ftell 函数测定文件位置标记的当前位置
ftell 函数的作用是得到流式文件中文件位置标记的当前位置。
由于文件中的文件位置标记经常移动，人们往往不容易知道其当前位置，所以常用 ftell函数得到当前位置，用相对于文件开头的位移量来表示。如果调用函数时出错如不存在 fp指向的文件 ftell函数返回值为L。例如
i ftell fp 变量i存放文件当前位置
ifiL printferrorn 如果调用函数时出错，输出error
随机读写
有了 rewind和fseek函数，就可以实现随机读写了。通过下面简单的例子可以了解怎样进行随机读写。
【例】 在磁盘文件上存有个学生的数据。要求将第，，，，个学生数据输入计算机，并在屏幕上显示出来。
解题思路：
按“二进制只读”的方式打开指定的磁盘文件，准备从磁盘文件中读取学生数据。
将文件位置标记指向文件的开头，然后从磁盘文件读入一个学生的信息，并把它显示在屏幕上。
再将文件位置标记指向文件中第，，，个学生的数据区的开头，从磁盘文件读入相应学生的信息，并把它显示在屏幕上。
关闭文件。
编写程序：
include stdio h
include stdlib h
C程序设计第五版
struct Student type 学生数据类型
char name
int num
int age
char addr
stud
int main
int i
FILE fp
if fp fopenstu dat rbNULL 以只读方式打开二进制文件
printfcan not open filen
exit
foriigi
fseek fpi sizeof struct Student type 移动文件位置标记
fread studi sizeof struct Student type fp 读一个数据块到结构体变量
printfs d d sn studi name studi num studi age studi addr
在屏幕输出
fclose fp
return
运行结果：
Zhang room
Tan room
Li room
Zhen room
Qin room
程序分析：用 fopen函数打开文件时，指定输入文件名为 stu dat，它和本章例程序中指定的输出文件的名字是相同的。在例程序中用 fopen函数打开文件时，指定读写方式为 wb二进制只写方式，建立的是二进制文件 stu dat，存放在用户当前目录中。在本例中则是以 rb二进制只读方式打开的，路径也是当前目录。可知，本程序要打开的文件就是例程序建立的文件 stu dat。在执行例程序时已把个学生的数据存放在 stu dat文件中了。本程序是从该文件中读入第，，，，位学生的数据，然后输出到屏幕。
例程序是采取顺序读写方式，把个学生的数据顺序写入文件 stu dat，本程序是采取随机读写方式，从个学生的数据中有选择地读入若干个，用fseek函数指定读写位置。
在 fseek函数调用中，指定“起始点”为，即以文件开头为参照点。位移量为i sizeof struct Student type sizeof struct Student type是 struct Student type 类型变量的长度字节数。i初值为因此第次执行 fread函数时读入长度为 sizeof struct Student type的数据，即第个学生的信息，把它存放在结构体数组的元素 stud中，然后在屏幕上输出该学生的信息。在第次循环时，i增值为，文件位置的移动量是 struct Student type类型变量的长度的两倍，即跳过一个结构体变量，移到第个学生的数据区的开头，然
第章 对文件的输入输出
后用 fread函数读入一个结构体变量，即第个学生的信息，存放在结构体数组的元素 stud中，并输出到屏幕。如此继续下去，每次位置指针的移动量是结构体变长度的两倍，这样就读取了第，，，，学生的信息。
需要注意的是应当保证在磁盘中存在所指定的文件 stu dat，并且在该文件中存在这些学生的信息，否则会出错。
文件读写的出错检测
C提供一些函数用来检查输入输出函数调用时可能出现的错误。
ferror函数
在调用各种输入输出函数如 putc getc fread和 fwrite等时如果出现错误除了函数返回值有所反映外，还可以用 ferror函数检查。它的一般调用形式为
ferror fp
如果 ferror返回值为假，表示未出错；如果返回一个非零值，表示出错。
应该注意，对同一个文件每一次调用输入输出函数，都会产生一个新的 ferror函数值，因此，应当在调用一个输入输出函数后立即检查 ferror函数的值，否则信息会丢失。
在执行 fopen 函数时 ferror函数的初始值自动置为。
clearerr函数
clearerr的作用是使文件出错标志和文件结束标志置为。假设在调用一个输入输出函数时出现错误 ferror函数值为一个非零值。应该立即调用 clearerr fp使 ferror fp的值变成，以便再进行下一次的检测。
只要出现文件读写出错标志，它就一直保留，直到对同一文件调用 clearerr函数或 rewind 函数，或任何其他一个输入输出函数。
文件这一章的内容在实际应用中是很重要的，许多可供实际使用的C程序尤其是有关事务管理的程序都包含了文件处理。通常将大批数据存放在磁盘上，在运行应用程序的过程中，内存与磁盘之间频繁地交换数据，从磁盘中读入数据到计算机内存，程序对这些数据进行检查、分析、修改和其他处理，把修改过的数据再保存在磁盘上。这就牵涉到许多文件操作。本章只介绍了一些最基本的概念，并通过一些简单的例子使读者初步了解怎样进行文件操作，为今后进一步学习和应用打下必要的基础。
习 题
什么是文件型指针 通过文件指针访问文件有什么好处
对文件的打开与关闭的含义是什么 为什么要打开和关闭文件
从键盘输入一个字符串，将其中的小写字母全部转换成大写字母，然后输出到一个磁盘文件 test中保存，输入的字符串以“！”结束。
有两个磁盘文件A 和B，各存放一行字母，今要求把这两个文件中的信息合并按字
C程序设计第五版
母顺序排列，输出到一个新文件C中去。
有个学生，每个学生有门课程的成绩，从键盘输入学生数据包括学号，姓名，门课程成绩，计算出平均成绩，将原有数据和计算出的平均分数存放在磁盘文件 stud中。
将第题 stud文件中的学生数据，按平均分进行排序处理，将已排序的学生数据存入一个新文件 stu sort中。
将第题已排序的学生成绩文件进行插入处理。插入一个学生的门课程成绩，程序先计算新插入学生的平均成绩，然后将它按成绩高低顺序插入，插入后建立一个新文件。
将第题结果仍存入原有的 stu sort文件而不另建立新文件。
有一磁盘文件 employee，内存放职工的数据。每个职工的数据包括职工姓名、职工号、性别、年龄、住址、工资、健康状况、文化程度。今要求将职工名、工资的信息单独抽出来另建一个简明的职工工资文件。
从第题的“职工工资文件”中删去一个职工的数据，再存回原文件。
从键盘输入若干行字符每行长度不等，输入后把它们存储到一磁盘文件中。再从该文件中读入这些数据，将其中小写字母转换成大写字母后在显示屏上输出。
附 录
附录A 常用字符与ASCII代码对照表
ASCII 值 字符 控制字符 ASCII值 字符 ASCII值 字符 ASCII 值 字符 SCII值 字符 ASCII值 字符 ASCII 值 字符 ASCII 值 字符 null NUL space 、 Ω á L a SOH a u i ⊥ β ● STX · B b é ó — r ♥ ETX C c à ú 卜 π ◆ EOT D d ā π — ∑ ◆ END E e à N σ ◆ ACK F f ā a ₣ μ beep BEL G E F τ □ BS H h è i LL 禹 tab HT i ē — F θ line feed LF J j è ￢ 业 Ω home VT K k ī ₸ δ form feed FF L i 片 ∞ carriage return CR — M m so · N n A ≪ 艹 ∈ ☆ SI o 。 A ≫ ∩ DLE P p É 《 ◀ DC Q q a ± DC R r E ※ π ≥ DC S s 。 L ≤ DC T t 。 r § NAK U u ò F J SYN v v ü r ÷ 主 ETB w w ù ㄱ 艹 ≈ ↑ CAN x x y 。 ↓ EM Y y 。 H J → SUB z z ü Ⅱ r · ← ESC c ㅋ ✔ L FS π GS ¥ zRS PtJ图▼ us—○fblank‘FF’
注 表中 是标准的。是扩展的。
C程序设计第五版
附录 B C语言中的关键字
auto break case char const
continue default do double else
enum extern float for goto
if inline int long register
restrict return short signed sizeof
static struct switch typedef union
unsigned void volatile while bool
Complex Imaginary
附 录
附录C 运算符和结合性
优先级 运 算 符 含 义 要 求 运算 对象的个数 结合方向 圆括号 自左至右 下标运算符 指 向 结 构 体 成 员 运 算符 · 结构体成员运算符 逻辑非运算符 单目运算符 自右至左 按位取反运算符 自增运算符 — 自减运算符 — 负号运算符 类型 类型转换运算符 指针运算符 取地址运算符 sizeof 长度运算符 乘法运算符 双目运算符 自左至右 除法运算符 求余运算符 加法运算符 双目运算符 自左至右 — 减法运算符 左移运算符 双目运算符 自左至右 右移运算符 关系运算符 双目运算符 自左至右 等于运算符 双目运算符自左至右不等于运算符按位与运算符双目运算符自左至右按位异或运算符双目运算符自左至右按位或运算符双目运算符自左至右逻辑与运算符双目运算符自左至右
C程序设计第五版
续表
优先级 运 算 符 含 义 要 求 运 算 对象的个数 结合方向 逻辑或运算符 双目运算符 自左至右 条件运算符 三目运算符 自右至左 赋值运算符 双目运算符 自右至左 逗号运算符顺序求值运算符自左至右
说明：
同一优先级的运算符，运算次序由结合方向决定。例如与 具有相同的优先级别，其结合方向为自左至右，因此﹡的运算次序是先乘后除。一和为同一优先级，结合方向为自右至左，因此i相当于i。
不同的运算符要求有不同的运算对象个数，如加和一减为双目运算符，要求在运算符两侧各有一个运算对象如、等。而和负号运算符是单目运算符只能在运算符的一侧出现一个运算对象如a、i、i、 floati、 sizeof int、p等。条件运算符是C语言中唯一的三目运算符，如xa： b。
从上表中可以大致归纳出各类运算符的优先级：
初等运算符
单目运算符
算术运算符
先乘除，后加减
关系运算符
逻辑运算符
不包括！
条件运算符
赋值运算符
逗号运算符
以上的优先级别由上到下递减。初等运算符优先级最高，逗号运算符优先级最低。位运算符的优先级比较分散有的在算术运算符之前如，有的在关系运算符之前如和，有的在关系运算符之后如、∧、。为了容易记忆，使用位运算符时可加圆括号。
附 录
附录D C语言常用语法提要
为读者查阅方便，下面列出C语言语法中常用的一些部分的提要。为便于理解，没有采用严格的语法定义形式，只是备忘性质，供参考。
标识符
标识符可由字母、数字和下画线组成。标识符必须以字母或下画线开头，大、小写的字母分别认为是两个不同的字符。不同的系统对标识符的字符数有不同的规定，一般允许个字符。
常量
可以使用：
整型常量
·十进制常数。
· 八进制常数以开头的数字序列。
·十六进制常数以x开头的数字序列。
·长整型常数在数字后加字符L或l。
字符常量
用单撇号括起来的一个字符，可以使用转义字符。
实型常量浮点型常量
·小数形式。
· 指数形式。
字符串常量
用双撇号括起来的字符序列。
表达式
算术表达式
· 整型表达式： 参加运算的运算量是整型量，结果也是整型数。
· 实型表达式：参加运算的运算量是实型量，运算过程中先转换成 double型，结果为 double型。
逻辑表达式
用逻辑运算符连接的整型量，结果为一个整数或。逻辑表达式可以认为是整型表达式的一种特殊形式。
字位表达式
用位运算符连接的整型量，结果为整数。字位表达式也可以认为是整型表达式的一种特殊形式。
强制类型转换表达式
用“类型”运算符使表达式的类型进行强制转换，如 floata。
C程序设计第五版
逗号表达式顺序表达式
其形式为
表达式，表达式，…，表达式 n
顺序求出表达式，表达式，…，表达式n的值，结果为表达式n的值。
赋值表达式
将赋值号“”右侧表达式的值赋给赋值号左边的变量。赋值表达式的值为执行赋值后被赋值的变量的值。
条件表达式
其形式为
逻辑表达式 表达式：表达式
逻辑表达式的值若为非零，则条件表达式的值等于表达式的值；若逻辑表达式的值为零，则条件表达式的值等于表达式的值。
指针表达式
对指针类型的数据进行运算，例如，p、pp等其中 p、p、p均已定义为指向数组的指针变量，p与p 指向同一数组中的元素，结果为指针类型。
以上各种表达式可以包含有关的运算符，也可以是不包含任何运算符的初等量例如，常数是算术表达式的最简单的形式。
数据定义
对程序中用到的所有变量都需要进行定义。对数据要定义其数据类型，需要时要指定其存储类别。
类型标识符可用
int
short
long
unsigned
char
float
double
struct 结构体名
union 共用体名
enum 枚举类型名
用 typedef定义的类型名
结构体与共用体的定义形式为
struct 结构体名
成员表列；
union 共用体名
成员表列 ；
用 typedef定义新类型名的形式为
附 录
typedef 已有类型 新定义类型
例如：
typedef int COUNT
存储类别可用
auto
static
register
extern
如不指定存储类别，作auto处理
变量的定义形式为
存储类别 数据类型 变量表列；
例如：
static float a b c
注意外部数据定义只能用 extern 或 static而不能用 auto或 register。
函数定义
其形式为
存储类别 数据类型 函数名形参表列
函数体
函数的存储类别只能用 extern或static。函数体是用花括号括起来的，可包括数据定义和语句。函数的定义举例如下：
static int max int x int y
int z
zxyxy
returnz
变量的初始化
可以在定义时对变量或数组指定初始值。
静态变量或外部变量如未初始化，系统自动使其初值为零对数值型变量或空对字符型数据。对自动变量或寄存器变量，若未初始化，则其初值为一不可预测的数据。
语句
表达式语句；
函数调用语句；
控制语句
复合语句；
空语句。
C程序设计第五版
其中控制语句包括：
if表达式语句
或
if表达式 语句
else 语句
while 表达式 语句
do 语句
while 表达式
for 表达式表达式表达式
语句
switch 表达式
case 常量表达式 语句
case 常量表达式 语句
⋮
case 常量表达式n 语句n
default 语句 n
前缀 case和 default本身并不改变控制流程，它们只起标号作用，在执行上一个 case所标志的语句后，继续顺序执行下一个 case前缀所标志的语句，除非上一个语句中最后用 break语句使控制转出 switch结构。
break语句
continue语句
return语句
goto语句
预处理指令
define 宏名 字符串
define 宏名参数参数…参数 n字符串
undef 宏名
include“文件名” 或文件名
if常量表达式
ifdef 宏名
ifndef 宏名
else
endif
附 录
附录 E C 库 函 数
库函数并不是C语言的一部分，它是由人们根据需要编制并提供用户使用的。每一种C编译系统都提供了一批库函数，不同的编译系统所提供的库函数的数目和函数名以及函数功能是不完全相同的。ANSI C标准提出了一批建议提供的标准库函数，它包括了目前多数C编译系统所提供的库函数，但也有一些是某些C编译系统未曾实现的。考虑到通用性，本书列出 ANSI C标准建议提供的、常用的部分库函数。对多数C编译系统，可以使用这些函数的绝大部分。由于C库函数的种类和数目很多例如，还有屏幕和图形函数、时间日期函数、与系统有关的函数等，每一类函数又包括各种功能的函数，限于篇幅，本附录不能全部介绍，只从教学需要的角度列出最基本的。读者在编制C程序时可能要用到更多的函数，请查阅所用系统的手册。
数学函数
使用数学函数时，应该在该源文件中使用以下命令行：
include math h或 includemath h
函数名 函数原型 功 能 返回值 说 明 abs int absint x 求整数x的绝对值 计算结果 acos double acosdouble x 计算 cos⁻¹x的值 计算结果 x应为 asin double asindouble x 计算 sin⁻¹x的值 计算结果 x应为 atan double atandouble x 计算 tan⁻¹x的值 计算结果 atan double atan double x double y 计算 tan⁻¹xy的值 计算结果 cos double cosdouble x 计算 cosx的值 计算结果 x的单位为弧度 cosh double coshdouble x 计算 x 的双 曲 余 弦 coshx的值 计算结果 exp double expdouble x 求 e²的值 计算结果 fabs double fabsdouble x 求 x的绝对值 计算结果 floor double floordouble x 求出不大于 x 的最大 整数 该整数的双 精度实数 fmod double fmoddouble x double y 求整除xy的余数 返回余数的双精度数 frexp double frexpdouble val int eptr把双精度数 val 分解为数字部分尾数x和以 为 底 的 指 数 n即 valx n 存 放在 eptr指向的变量中返回数字部分x≤x
C程序设计第五版
续表
函数名 函数原型 功 能 返回值 说 明 log double logdouble x 求 log。x即 ln x 计算结果 log double logdouble x 求 log₁₀x 计算结果 modf double modfdouble val double iptr 把双精度数 val 分解为 整数部分和小数部分， 把整数部分存到 iptr指 向的单元 val 的 小 数 部分 pow double po w double x double y 计算x³的值 计算结果 rand int randvoid 产生 的随 机整数 随机整数 sin double sindouble x 计算 sinx的值 计算结果 x单位为弧度 sinh double sinhdouble x 计算x 的双曲正弦函 数 sinhx的值 计算结果 sqrt double sqrtdouble x 计算 计算结果x应≥ tan double tandouble x计算 tanx的值计算结果x单位为弧度 tanh double tanhdouble x计算 x 的双曲正切函数 tanhx的值计算结果
字符函数和字符串函数
ANSI C标准要求在使用字符串函数时要包含头文件 string h，在使用字符函数时要包含头文件 ctype h。有的C编译不遵循ANSI C标准的规定，而用其他名称的头文件。请使用时查阅有关手册。
函数名 函数原型 功 能 返 回 值 包含文件 isalnum int isalnumint ch 检查 ch 是否为字母alpha或 数字numeric 是字母或数字返回； 否则返回 ctype h isalpha int isalphaint ch 检查 ch 是否为字母 是，返回 ；不是，则返 回 ctype h iscntrl int iscntrlint ch 检查 ch 是否为控制字符其 ASCⅡ码在到xF 之间 是，返回；不是，返回 ctype h isdigit int isdigitint ch 检查 ch是否为数字 是，返回；不是，返回 ctype h isgraph int isgraphint ch 检查 ch是否为可打印字符其 ASCⅡ码在 x 到 xE 之 间，不包括空格 是，返回；不是，返回 ctype h islower int islowerint ch 检查 ch 是否为小写字母az 是，返回；不是，返回 ctype h isprint int isprintint ch检查 ch是否为可打印字符包括空格其 ASCII码在 x到xE之间是，返回；不是，返回 ctype h
附 录
续表
函数名 函数原型 功 能 返 回 值 包含文件 ispunct int ispunctint ch 检查 ch 是否为标点字符不包 括空格，即除字母、数字和空 格以外的所有可打印字符 是，返回；不是，返回 ctype h isspace int isspaceint ch 检查 ch 是否为空格、跳格符 制表符或换行符 是，返回；不是，返回 ctype h isupper int isupperint ch 检查 ch 是否为大写字母AZ 是，返回；不是，返回 ctype h isxdigit int isxdigitint ch 检查 ch 是否为一个十六进制 数字字符即或 AF 或 af 是，返回；不是，返回 ctype h strcat char strcatchar strl charstr 把字符串 str 接到 str 后面 strl 最后面的被取消 strl string h strchr char strchrchar str int ch 找出 str指向的字符串中第一 次出现字符 ch的位置 返回指向该位置的指 针，如找不到，则返回空 指针 string h strcmp int strcmpchar str char str 比较两个字符串 strl 和str strlstr返回负数 strstr返回 strlstr返回正数 string h strcpy char strcpychar strl charstr 把 str指向的字符串复制到 str 中去 返回 strl string h strlen unsigned int strlen char str 统计字符串 str中字符的个数 不包括终止符 返回字符个数 string h strstr char strstrchar strl char str 找出 str 字符串在 str 字符 串中第一次出现的位置不包 括 str的串结束符 返回该位置的指针，如 找不到，返回空指针 string h tolower int tolowerint ch将 ch字符转换为小写字母返回 ch 所代表的字符的小写字母 ctype h toupper int tourperint ch将 ch字符转换成大写字母与 ch 相应的大写字母 ctype h
输入输出函数
凡用以下的输入输出函数应该使用 include stdio h把 stdio h头文件包含到源程序文件中。
函 数 名 函数原型 功 能 返回值 说明 clearerr void clearerrFILE fp 使 fp所指文件的错误，标志 和文件结束标志置 无 fclose int fcloseFILE fp 关闭 fp所指的文件， 释放文件缓冲区 有错则返回非； 否则返回 feof int feofFILE fp检查文件是否结束已读文件尾标志返回非值；否则返回
C程序设计第五版
续表
函 数 名 函数原型 功 能 返回值 说明 fgetc int fgetcFILE fp 从 fp所指定的文件中取得 下一个字符 返回所得到的字符，若 读入出错，返回EOF fgets char fgetschar buff int n FILE fp 从 fp指向的文件读取一个 长度为n的字符串，存 入起始地址为 buff的空间 返回地址 buf，若遇文 件 结 束 或 出 错， 返 回 NULL fopen FILE fopenchar filename char mode 以 mode指定的方式打开名 为 filename的文件 成功，返回一个文件指 针文件信息区的起始 地址；否则返回 fprintf int fprintfFILE fp char format args… 把 args的值以 format 指定 的格式输出到 fp所指定的 文件中 实际输出的字符数 fputc int fputcchar ch FILE fp 将字符 ch输出到 fp指向的 文件中 成功，则返回该字符；否 则返回非 fputs int fputschar str FILE fp 将 str指向的字符串输出到 fp所指定的文件 成功返回；若出错返 回非 fread int freadchar pt unsigned size unsigned n FILE fp 从 fp所指定的文件中读取 长度为 size 的 n个数据项 存到 pt所指向的内存区 返回所读的数据项个 数，如遇文件结束或出 错返回 fscanf int fscanfFILE fp char format args… 从 fp 指定的 文件 中 按 format给定的格式将输入数 据送到 args所指向的内存 单元args 是指针 已输入的数据个数 fseek int fseekFILE fp long offset int base 将 fp 所指向的文件的位置 指针移到以 base所给出的 位置为基准、以 offset 为位 移量的位置 返回当前位置；否则，返 回 ftell long ftellFILE fp 返回 fp所指向的文件中的 读写位置 返回 fp所指向的文件 中的读写位置 fwrite int fwritechar ptr unsigned size unsigned n FILE fp 把 ptr所指向的 n size 个 字节输出到 fp 所指向的文 件中 写到 fp文件中的数据 项的个数 getc int getcFILE fp 从 fp所指向的文件中读入 一个字符 返回所读的字符，若文 件 结 束 或 出 错， 返 回 EOF getchar int getcharvoid 从标准输入设备读取下一个 字符 所读字符。若文件结束 或出错，则返回 getw int getw FILE fp从 fp所指向的文件读取下一个字整数输入的整数。如文件结束或出错，返回非 ANSI 标准函数 open int open char filename int mode以 mode指出的方式打开已存在的名为 filename的文件返回文件号正数；如打开失败，返回非 ANSI 标准函数
附 录
续表
函数 名 函数原型 功 能 返回值 说明 printf int printf char format args … 按 format 指向的格式字符 串所规定的格式，将输出表 列 args的值输出到标准输 出设备 输出字符的个数，若出 错，返回负数 format 可以 是一个字符 串， 或字符 数组的起始 地址 putc int putc int ch FILE fp 把一个字符 ch输出到 fp所 指的文件中 输出的字符 ch，若出 错返回 EOF putchar int putchar char ch 把字符 ch 输出到标准输出 设备 输出的字符 ch，若出 错返回EOF puts int putschar str 把 str指向的字符串输出到 标准输出设备，将转换 为回车换行 返回换行符，若失败，返 回 EOF putw int putw int w FILE fp 将一个整数 w即一个字写 到 fp指向的文件中 返回输出的整数，若出 错返回 EOF 非 ANSI 标 准函数 read int readint fd char buff unsigned count 从文件号 fd所指示的文件 中读 count个字节到由 buf 指示的缓冲区中 返回真正读入的字节个 数，如遇文件结束返回 ，出错返回 非 ANSI 标 准函数 rename int renamechar oldname char newname 把由 oldname 所指的文件 名改为由 newname所指的 文件名 成功返回；出错返回 rewind void rewindFILE fp 将 fp 指示的文件中的位置 指针置于文件开头位置，并 清除文件结束标志和错误 标志 无 scanf int scanf char format args… 从标准输入设备按 format 指向的格式字符串所规定的 格式，输入数据给 args 所指 向的单元 读入并赋给 args的数 据个数，遇文件结束返 回EOF，出错返回 args为指针 write int writeint fd char buff unsigned count从 buff指示的缓冲区输出 count个字符到 fd所标志的文件中返回实际输出的字节数，如出错返回非 ANSI 标准函数
动态存储分配函数
ANSI标准建议设个有关的动态存储分配的函数即 calloc malloc free和 realloc 。实际上，许多C编译系统实现时，往往增加了一些其他函数。ANSI标准建议在 stdlib h头文件中包含有关的信息但许多C编译系统要求用 malloc h而不是 stdlib h。读者在使用时应查阅有关手册。
ANSI标准要求动态分配系统返回 void指针。 void指针具有一般性，它们可以指向任何类型的数据。但目前有的C编译所提供的这类函数返回 char指针。无论以上两种情况的哪一种，都需要用强制类型转换的方法把 void 或char指针转换成所需的
C程序设计第五版
类型。
函数名 函数原型 功 能 返 回值 calloc void callocunsigned n unsign size 分配 n个数据项的内存连续 空间，每个数 据项的大小 为 size 分配内存单元的起始地址，如不成 功，返回 free void freevoid p 释放 p所指的内存区 无 malloc void mallocunsigned size 分配 size字节的存储区 所分配的内存区起始地址，如内存 不够，返回 realloc void reallocvoid p unsigned size将 p所指出的已分配内存区的大小改为 size size可以比原来分配的空间大或小返回指向该内存区的指针