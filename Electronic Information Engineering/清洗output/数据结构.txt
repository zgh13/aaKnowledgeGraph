目 录
第章 概论…………………………… 线性表的定义 ………………
引子………………………… 线性表的顺序存储实现……
数据结构……………………… 线性表的链式存储实现……
定义 ………………………… 广义表与多重链表…………
堆栈…………………………
堆栈的定义 …………………
堆栈的实现 …………………
堆栈应用：表达式求值 ……
队列…………………………、
队列的定义 …………………
队列的实现…………………
应用实例………………………
多项式加法运算……………
迷宫问题……………………
本章小结……………………………
习题…………………………………
第章 树……………………………
引子…………………………
问题的提出 …………………
查找………………………
树的定义、表示和术语 ………
二叉树………………………
二叉树的定义及其逻辑
表示 ………………………
二叉树的性质………………
二叉树的存储结构…………
二叉树的操作………………
二叉搜索树……………………
二叉搜索树的定义 …………
抽象数据类型 …………………
算法………………………
定义 ………………………
算法复杂度 …………………
渐进表示法 …………………
应用实例：最大子列和问题……
本章小结…………………………
习题…………………………………
第章 数据结构实现基础……………
引子…………………………
数据存储基础 …………………
数组…………………………
类型定义 typedef ……………
指针………………………
结构………………………
链表………………………
流程控制基础…………………
分支控制……………………
循环控制 ……………………
函数与递归 …………………
本章小结…………………………
习题………………………
第章 线性结构………………………
引子…………………………
线性表的定义与实现…………
Ⅱ 目录
二叉搜索树的动态查找… 图的遍历……………………
二叉搜索树的插人 ………… 迷宫探索………………
二叉搜索树的删除 ……… 深度优先搜索……………
平衡二叉树………………… 广度优先搜索……………
平衡二叉树的定义 ……… 最小生成树…………………
平衡二叉树的调整 ……… 生成树的构建与最小
树的应用………………… 生成树的概念……………
堆及其操作……………… 构造最小生成树的Prim
哈夫曼树……………… 算法 ………………………
集合及其运算……………… 构造最小生成树的Kruskal
本章小结………………………… 算法……………………
习题……………………………… 最短路径…………………
第章 散列查找 ……………………… 单源最短路径………………
引子……………………… 每一对顶点之间的最短
基本概念………………… 路径……………………
散列函数的构造方法……… 拓扑排序………………………
数字关键词的散列 关键路径计算………………
函数构造………… 应用实例……………………
字符串关键词的散列 六度空间理论……………
函数构造……………… 六度分隔理论的验证 ……
处理冲突的方法…………… 本章小结…………………………
开放定址法………………… 习题………………………………
第章 排序…………………………
引子………………………
选择排序……………………
简单选择排序……………
堆排序…………………
插入排序…………………
简单插入排序……………
希尔排序………………
交换排序…………………
冒泡排序……………………
快速排序……………………
归并排序……………………
基数排序…………………
分离链接法………………
散列表的性能分析…………
应用实例…………………
本章小结……………………………
习题………………………………
第章 图…………………………
引子……………………
图的基本概念………………
图的定义和术语……………
图的抽象数据类型 ………
图的存储结构………………
邻接矩阵………………
邻接表……………………
习题…………………………………
第章 综合应用案例分析……………
目 录 Ⅲ
桶排序………………… 银行排队问题………………
基数排序……………… 单队列多窗口服务………
单关键字的基数分解 …… 单队列多窗口VIP服务…
外部排序………………… 畅通工程问题………………
排序的比较和应用………… 建设道路数量问题 ………
排序算法的比较…………… 最低成本建设问题 ………
排序算法应用案例………… 本章小结……………………………
本章小结………………………… 习题………………………………
附录 PTA 使用说明……………………
参考文献………………………………
第章
概 论
引子
什么是数据结构事实上，这个问题在计算机科学界至今没有标准的定义。
如果你的好奇心充分强，不妨打开各种版本的有关数据结构“的教材首页，看到的会是五
花八门的描述。而在你深入阅读本书之前，大多数的描述对你而言可能太过晦涩——例如 Sartaj
Sahni在他的《数据结构、算法与应用》一书中称：“数据结构是数据对象，以及存在于该对象的实
例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。”Clif ford AShaffer在《数据结构与算法分析》一书中的定义是：“数据结构是ADT抽象数据类型，Ab stract Data Type的物理实现。”互联网上的中文维基百科写道：“数据结构Data Structure是计
算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。”
作为初学者，让我们暂且把那些由专业术语组成的各种定义抛开，先尝试解决下面几个简单
的问题。在解决问题的过程中，或许可以得到对于数据结构的理解。
例书店往往是书的海洋，图显示了著名的圣保罗Livraria da Vila书店一角。如
果你是书店的主人，该如何摆放你的书，才能让读者很方便地找到你手里这本《数据结构》
分析解决的办法有很多，下面只列举种最简单的。
方法随便放。
这种方法使得放书非常方便，任何时候有新书进来，哪里有空就把书插到哪里。但是这种方
法显然使得查找非常痛苦。最不走运的时候，是你的书架上根本没有这本书，但是你需要翻遍整
个书架的每一本书，才能确定地说真的找不到。
方法按照书名的拼音字母顺序排放。
这种方法使得查找方便了一些。我们可以随便抽取一本书，检查书名的拼音首字母。例如
书名是L开头的《离散数学》我们就知道以S开头的《数据结构》一定排在L的后面；再从它后
面随便抽取一本书，例如是W开头的《网络技术基础》那么《数据结构》一定排在W的前面，我
们的查找范围就迅速缩小到L和W之间的区域内。
但是这种方法会使得新书的插入成为一种痛苦。如果买的新书是Z开头的《“做中学”程序
员攻略》还好，如果新买的一本是A开头的《阿Q正传》就惨了，为了给新书腾出空间，要把多少
本书向后挪动啊
第章 概论
开，树润
一
二三
面即
南
T
F都
i鸭ITt W
rn
图 圣保罗的Livraria da Vila书店一角
方法把书架划分成几块区域，每块区域指定摆放某种类别的图书；在每种类别内，按照书
名的拼音字母顺序排放。
这种方法与方法相比，无论是查找还是插入，工作量都减少很多，因为类别一旦确定，要处
理的书架范围就大大缩小了。但是仍然存在问题——因为我们不可能事先知道每种类别的图书
会有多少本，所以划分区域的时候最好给每种类别预留足够的新书空间，这可能造成空间上的
浪费。
另一方面，类别分得越细，属于同一类的书就越少，在某一类内部查找或插入的工作量就越
小。但是如果类别太多，要找到某一类所在的区域又会成为一件麻烦事……你还有更好的解决
方案吗
例写程序实现一个函数PrintN使得传入一个正整数为N的参数后，能顺序打印从
到N的全部正整数。
分析只要略有编程基础的人都可以很容易实现这个函数。代码给出了一个用C语
言循环语句实现的版本。
void PrintNint N
打印从到N的全部正整数·
int i
foriNi
printfdn
return
代码 用C酒言循环语句实现的 PrinIN 函数
引子
另一个用C语言递归语句实现的版本看上去更简洁，甚至不需要临时变量的帮助，如代码
所示。
void PrintNint N
I打印从到N的全部正整数
ifN
PrintNN
printfdnN
代码 用C语言递归语句实现的PrintN函数
问题看上去很简单，上述两种方法似乎都可以完成任务。然而，事实真的如此吗我们可以
运行代码来比较一下两种实现方法。
include stdioh
void PrintNintN
int main
读入整数N并调用PrintN函数
int N
scanfodN
PrintNN
return
代码 函数PrintN的测试程序
把代码和代码分别不是同时贴到代码的尾部，分别编译运行。测试输入N
为、、、的情况——如果还不能发现问题那么继续测试更大的N……终于，
我们将发现，对于充分大的N代码中的递归函数拒绝工作了而此时代码仍然正常
运行。
为什么会这样请读者思考其中的原因。
例一元多项式的标准表达式可以写为：fxaoax…axax。现给定一
个多项式的阶数n并将全体系数aI。存放在数组a里。请写程序计算这个多项式在给定
点x处的值。
第章 概 论
fxax 分析最直接的办法是根据多项式的标准表达式 通过循环累计求和来实
现这个函数。代码给出了这个直接实现的版本。
double fint ndouble adouble x
计算阶数为n系数为aan的多项式在x点的值
int i
double pa
foriini
pai·powxi
return p
代码 计算多项式函数值的直接法
然而早在年前，中国南宋的数学家秦九韶就提出了一种更快的算法，他通过不断提取公
因式x来减少乘法的运算次数，把多项式改写为：
fxa。xax…axa… 公式
代码给出了按照公式编程的多项式求值算法。
double fint ndouble adouble x
计算阶数为n系数为a…an的多项式在x点的值
int i
double pan
return D
forinii
paxP
代码 计算多项式函数值的秦九韶法
看上去代码、代码两个版本的程序一样简单，都只要行语句
就可以了。问题是，秦九韶算法究竟比简单的直接算法快了多少要回答
这个问题，我们需要先学习clock工具的使用。
微视频
clock工具
的使用
要获得一个程序的运行时间，常用的方法是调用头文件 timeh其中提
供了clock函数，可以捕捉从程序开始运行到clock被调用时所耗费的
时间。这个时间单位是cloek tick即“时钟打点”在CC中定义的数据
类型是olock。同时还有一个常数CLKTCK或是CLOCKSPERSEC
给出了机器时钟每秒所走的时钟打点数。代码给出丁一个常用范侧。
引子
incIudecstdoh
clockt atartatop clocke是cloek函数返回的变量类型
int main
·不在测试范围内的准备工作写在clock调用之前
startclock开始计时
MyFunction 把被测函数加在这里，使用时这个函数必须被替换
durationdoublestopstartCLKTCK计算运行时间
其他不在测试范围的处理写在后面，例如输出duration的值·
Hinclude ctIme
doublo duration记录被测函数运行时间，以秒为单位
stopclock 停止计时
s注意CLKTCK是机器时钟每秒所走的时钟打点数，
return
在某些IDE下也可能叫CLOCKSPERSEC。
代码 测试函数 function的运行时间
下面我们可以通过一个具体多项式函数值的计算，来比较秦九韶算法与直接法的效率差别：
令fx∑i·x计算f的值。代码给出了测试函数。
include stdioh
include timeh
include mathh
clockt startstop
double duration
define MAXN 多项式最大项数，即多项式阶数
define MAXK e被测函数最大重复调用次数
double fint ndouble adouble x
I 代码的算法
int i
double pa
foriini
第章 概论
paipowxi
return p
double fint ndouble adouble x
代码的算法·
int i
double pan
forini
paixp
return p
void rundoublefintdoubledoubledouble aint casen
此函数用于测试被测函数f的运行时间，并且根据casen输出相应的结果
casen是输出的函数编号：代表函数f代表函数f
int i
startclock
foriiMAXKi重复调用函数以获得充分多的时钟打点数·
fMAXNa
stopclock
durationdoublestopstartCLKTCK
printftickstdfncasendoublestopatart
printrdurationtdencasenduration
int main
inti
double aMAXN存储多项式的系·
人为木题的多项式系数赋值，即a
foriMAXN adouble
runIa
Z 数 据结 构
run aZ
retun
代码 测试多项式求值函数的运行时间
因为我们要比较两种算法的效率，又不想把相似的测试代码重复写两遍，所以把测试函数运
行时间的代码写成了一个函数 run将被测函数f作为参数函数指针类型传入，测试其运
行时间，并且根据casen输出相应的结果。
注意到被测函数运行一次所花费的时间有可能小于两次时钟打点的间隔，这时我们就有可
能得到stopstart的情况，从而测不出真正的运行时间。
解决这个问题的方法是，让被测函数重复运行充分多次，使得测出的总的时钟打点间隔充分
长，最后计算被测函数平均每次运行的时间即可。在代码中，我们令函数运行次，读者
可以根据自己机器配置选择其他的MAXK值。
注意到测试结果取决于机器的配置，在不同的机器上运行，得到的具体数据是不一样的。但
可以肯定的是，秦九韶算法的计算速度明显比直接法快了一个数量级。
为什么会这样请读者思考其原因。
通过对上面个例子的研究，我们可以发现，即使解决一个非常简单的问题，往往也有多种
方法，且不同方法之间的效率可能相差甚远。解决问题方法的效率，跟数据的组织方式有关如
例跟空间的利用效率有关如例也跟算法的巧妙程度有关如例。
本章将要向大家介绍的，就是有关数据组织、算法设计、时间和空间效率的概念和通用分析
方法，是后续所有数据结构及其相关算法的基础。
数据结构
定义
从例中我们发现用不同方法摆放图书，会直接影响查找、插入等工作的效率。在计算机
的世界里，“图书”就是待处理的“数据对象”“查找”、“插入”等工作就是对数据进行的“操作”
完成这些操作所用的方法就是“算法”。
“数据结构”的定义，首先应该包含数据对象在计算机中的组织方式——这类似于图书的摆
放方法。另一方面，数据对象必定与一系列加在数据对象上的操作相关联，就如我们在书架上摆
放图书是为了能找到想要的书，或者是插入一本新买的书。我们讨论数据对象的各种不同的组
织方式，是为了得到处理这些数据对象的最高效的算法。所以我们在讨论“数据结构”这个概念
的时候，关心的不仅仅是数据对象本身以及它们在计算机中的组织方式，还要关心与它们相关联
第章 概 论
的一个操作集，以及实现这些操作的最高效的算法。
关于数据对象在计算机中的组织方式，其实还包含了两个概念：一是数据对象集的逻辑结
构；二是数据对象集在计算机中的物理存储结构。
例如我们把一本书看成一个数据对象，如果所有的书是一本挨一本排成一大排的，从最左边
第本书开始向右顺序编号，每本书的位置可以由它的编号唯一确定，那么这个数据对象集的逻
辑结构就被称为是“线性Linear”的，因为数据对象都串在一条线上，并且编号跟书是“对”
的关系。当我们把这些书的信息存进计算机时，可以设计一个结构体来记录一本书，而书的集合
可以用结构体的数组来存储，也可以用结构体的链表来存储。数组或者链表就是数据对象集在
计算机中的物理存储结构。
在后面的章节中，大家还会见识到更多样的数据对象逻辑结构。例如在例的解决方法
中，把图书先按类别编号，在同一类中再按字母序编号，那么一个类别编号就对应多本图书，类
别编号跟书是“一对多”的关系。这种数据对象集的逻辑结构就是“树Tree”状的，将在第章
中讨论。如果还需要统计买书人的兴趣关系，即买了某本图书的人同时还买了哪些其他的书，那
么这些图书之间就构成了一个“多对多”的关系网，这种逻辑结构被称为“图Graph”是第章
中将要介绍的内容。而如何在计算机中有效地存放“树”和“图”这样的结构，则是这两章要讨论
的另一个有趣的话题。
抽象数据类型
顾名思义，抽象数据类型Abstract Data Type是一种对“数据类型”的描述，这种描述是“抽
象的。
首先，“数据类型”描述两方面的内容：一是数据对象集；二是与数据集合相关联的操作集。
“抽象”的意思是指，我们描述数据类型的方法是不依赖于具体实现的，即数据对象集和操作集的
描述与存放数据的机器无关、与数据存储的物理结构无关、与实现操作的算法和编程语言均无关。简
而言之，抽象数据类型只描述数据对象集和相关操作集“是什么”并不涉及“如何做到”的问题。
例“矩阵”的抽象数据类型定义
类型名称；矩阵Matrix
数据对象集：一个m xn的矩阵Amnai…mj…n由m xn个三元组aJ
构成，其中a是矩阵元素的值，是元素所在的行号，j是元素所在的列号。
操作集：对于任意矩阵A、B、CeMatrix以及整数jM、N仅列出几项有代表性的操作。更
多关于矩阵的操作不是我们讨论的重点，故在此略去。
Matrix Createint Mint N返回一个MxN的空矩阵；
int GetMaxRowMatrix A返回短阵A的总行数；
intCetMaxColMatrix A返回矩阵A的总列数：
ElementType CetEntryMatrix Aint iint j返回短阵A的第行、第列的元素；
Matrix AddMatrix AMatrix B如果A和B的行、列数一致，则返回矩阵GAD否则
算法
返回错误标志
Matrix MultiplyMatrix AMatrix B如果A的列数等于B的行数，则返回矩阵CAB否
则返回错误标志；
……
通过例我们可以这样理解“抽象”的含义：
当我们在数据对象集中描述矩阵元素的时候，刻画了它的取值和二维位置，但是这个描
述并没有规定矩阵元素是整数还是浮点数，这个元素甚至可能是一个特殊的结构体但无论什
么类型的矩阵元素，都可以用这个数据对象集来描述。相应于数据对象的抽象描述，操作的类
型描述被写为ElementType即“元素类型”意味着当具体实现某一种矩阵的时候，这个类型可
以用相应的具体类型替换掉。而其他操作如加法、乘法的具体实现也可能需要随着元素类型的
不同而不同——想一想，如果矩阵元素是某种特殊的结构体，我们怎么定义两个结构体的相加
这样的描述方法，忽略元素类型这种细节问题，适用于任何一种类型的矩阵。
对于数据对象的描述不依赖于其在计算机中具体的存储方法。例如我们可以用二维数
组存储，也可以用一维数组存储，还可以用十字交叉的链表来存储一个矩阵。抽象数据类型的描
述不涉及这样的细节，但是适用于任何具体的存储方式。
在描述操作的时候，我们只描写了这个操作是做什么用的，并不涉及操作的具体实现方
法。例如矩阵相加的时候，我们是先按行加还是先按列加抽象数据类型的描述也不涉及这样
的细节，更与实现操作的编程语言没有关系。
综上所述，抽象数据类型描述的重要特征是“抽象”。抽象是计算机求解问题的基本方式和
重要手段，它使得一种设计可以应用于多种场景。而且通过抽象可以屏蔽底层的细节，使设计更
加简单、理解更加方便。
抽象数据类型的描述方法与面向对象的思想是一致的，它把数据对象和相关操作封装在一
起，对于需要调用这个数据类型的用户而言，无论内部的具体实现如何改变，只要对外描述的接
口不变，就不影响使用。
在后面的章节中，每当我们介绍一种新的数据结构时，会首先用抽象数据类型来描述这个结
构，以方便读者理解。
算法
定义
“算法”Algorithm一词是由 Algorism衍生而来，而Algorism源自一本波斯数学教材，原意
为“算术”。算法的设计是一门艺术。解决同一个问题，一般有多种算法，但漂亮的算法与其他
算法相比往往有天壤之别。
第章 概 论
一般而言，算法是一个有限指令集，它接受一些输入有些情况下不需要输入产生输出，
并一定在有限步骤之后终止。算法的每一条指令必须有充分明确的目标，不可以有歧义；必须在
计算机能处理的范围之内；且其描述应不依赖于任何一种计算机语言以及具体的实现手段。
当然，用某一种计算机语言进行伪码描述往往使算法更容易被理解，本书即采用C语言的
部分语法作为描述算法的工具。例如代码给出了选择排序算法的伪码描述。
void SelectionSortint Listint N
将N个整数List…ListNj进行非递减排序·
int i
foriiNi
从Listi到ListN中找最小元，并将其位置赋给MinPosition
MinPositionScanForMinListN
将未排序部分的最小元换到有序部分的最后位置
SwapListiListMinPosition
代码 选择排序算法的伪码描述
通过代码的描述可以看到，选择排序基本上分两步，首先找出未排序部分的最小元，然
后将之换到有序部分的队尾。但上述描述并不依赖于具体的实现手段，例如 List 到底是数组还
是链表虽然看上去很像数组Swap用函数还是用宏去实现等。
算法不是程序。
一个显然的区别是，程序可以无限运行例如操作系统但算法必须在有限步后终止。
算法与程序的更重要不同之处，还在于算法比程序“抽象”强调表现“做什么”而忽略细节
性的“怎么做”。这样做的好处是使整体思路清晰易懂，形成模块化的风格，在注重团队配合的
软件开发过程中，显得特别重要。把所有过程都写在一个main 函数中的程序是调试员的噩梦
特别是当程序员自己已无法发现错误，而不得不请同事帮助调试的时候，没有模块化的程序往往
牵一发而动全身，越改越混乱，最后只好推翻重写。
算法复杂度
什么是好的算法
除了算法的描述风格之外，具体衡量、比较算法优劣的指标主要有以下两个：
空间复杂度Sn——根据算法写成的程序在执行时占用存储单元的长度。这个长度
往往与输人数据的规模n有关。空问复杂度过高的算法可能导致使用的内存超限，造成程序非
正常中断。
时间复杂度Tn——根据算法写成的程序在执行时耗费时间的长度。这个长度住往
算法
也与输人数据的规模n有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运
行结果。
现在，让我们回过头仔细审视第节中的例和例。
例给出了实现函数PrintN的两种算法，为什么代码的递归实现会在N比较大时遭
遇非正常中断关键的原因是，计算机在一个函数A内部处理另一个函数B的调用时，必须先
把A的当前状态保存在内存中，当B被调用完成后，再释放内存恢复状态，继续执行A的其余语
句。于是代码的执行过程就是这样的：要计算PrintNN必须先保存这个函数的状态，然
后调用PrintNN而在执行 PrintNN时，又必须先保存它的状态，然后调用PrintNN
……如此类推，直到执行 PrintN时，函数才直接返回，系统开始逐级释放内存。假设存储
每个函数的状态占用个单位的内存空间，那么执行PrintNN就需要N个单位的内存空间，所
以当N非常大时，计算机内存不足就造成程序的非正常中断。
根据定义，代码给出的递归算法的空间复杂度就是SNC·N其中N是需要打印的
整数的个数，是变量；C是个单位的内存空间占用存储单元的长度，是个固定常数。我们可以
清楚地看到，根据该算法写成的程序在执行时占用的空间将随着N的增大而增大。而代码
则没有这个问题，该程序执行时占用的空间是不随N的增大而变化的。所以虽然表面上看来两
种函数同样简单，但实际上空间复杂度有很大差别。
例给出了计算多项式值的秦九韶算法和简单直接算法，通过运行程序，我们发现秦九韶
算法在速度上胜出一筹。当我们仔细分析两种算法的运行时间时，不难发现，直接算法代码
执行了n次语句paipowxi——每次涉及《次乘法和次加法运算，于是全
部计算涉及n次加法和…nnn次乘法。而秦九韶算法代码执行了n次
语句paixp——全部计算只涉及n次加法和n次乘法。
根据定义，秦九韶算法的时间复杂度就是TnC·n其中n是输人多项式的阶数，是个
变量；C是执行次加法和乘法需要的时间，是个固定常数。简单直接算法的时间复杂度是
TnCnCn其中n是输入多项式的阶数，是个变量；C是执行次乘法需要的时间，C
是执行次加法和次乘法需要的时间，都是固定常数。所以对于充分大的nTn总会比
Tn小，也即秦九韶算法比简单直接算法快，而且n越大，快得越明显。如果我们一开始就通
过时间复杂度来分析两种算法，就不需要运行程序也可以直接知道它们的优劣了。
在分析一般算法的效率时，我们经常关注下面两种复杂度：
最坏情况复杂度Tn
平均复杂度Tn。
例如当我们用顺序查找的方法在一排混乱无序的书架上找一本书的时候，最好情况是一次
就找到了，最坏情况是翻遍了n本书都没找到，即TnC·n其中C是查看一本书的时间，
·事实上，powxi函数最快可以用logi次乘法计算得到，这使得每一步的乘法次数降为logi总体计算次数跟
nlogn一个数量级。但是由于涉及递归实现，所以当i不是非常大时，实际效果比直接乘法更慢。细节分析在此略去。
第章 概 论
不妨认为是个常数。要得到平均查找次数，略麻烦一些，我们要把每一种可能的情况都考虑到
有可能需要查找两次，也可能需要查找三次，等等把所有情况下需要查找的次数加起来，最
后除以所有可能情况的个数。
显然Tn≤Tmn。对Tn的分析往往比对Tn的分析容易，因为很多时候定
义平均不是一件容易的事。
渐进表示法
如果程序A执行了N步，程序B执行了N步，A一定比B慢吗
例给定N个整数，存放于数组 List中，求它们的和。
代码和代码分别给出了函数的循环和递归实现的版本。
int IterativeSumint Listint N
循环求N个整数的和
int i执行步
int Sum执行步
foriiNi共执行N步
SumListi共执行N步
return Sum执行步·
代码 循环求和
int RecursiveSumint Liatint N
递归求N个整数的和
ifN执行步
returnRecursiveSumListNListN·执行x步·
return 执行步
代码 递归求和
分析根据代码中的注释，我们可以很容易看到程序一共执行了N步。
代码的情况略微复杂一点，在每次非零N的递归调用中，除了固定的步外，还有一个
X——即递归调用RecursiveSumListN时执行的总步数。如果我们把执行RecursiveSum
ListN的总步数记为TN的话，就应该有XTN。于是我们得到递推式TN
TN。按此递推下去，易得TNTNTN…TNN即
程序一共执行了N步。
算法
然而如果你因此就认为递归程序比循环程序快，那么建议对°个整数不妨令所有整数为
分别用两种方法求和，观察效果……
事实上，精确地比较程序执行的步数是没有意义的，因为每步执行时间可能不同。比如递归
调用的“步实际上涉及到对系统堆栈的很多处理，比循环中的“步”计算慢很多。所以在比
较算法优劣时，人们只考虑宏观渐近性质，即当输入规模n“充分大”时，我们观察不同算法复杂
度的“增长趋势”以判断哪种算法必定效率更高。为此引入下面几种数学符号。
定义 Tnfn表示存在常数Cn。使得当n≥n。时有Tn≤
Cfn。
如例中的两种程序的时间复杂度均为n例中秦九韶算法的时间复杂度是
n而简单直接法的时间复杂度是n。
定义 TnΩgn表示存在常数Cn。使得当n≥n。时有Tn≥
Cgn。
如例中的两种程序的时间复杂度均为Ωn。
定义Tnhn表示同时有Tnhn和TnΩhn。
如例中的两种程序的时间复杂度均为θn亦称为具有“线性”复杂度。
事实上，这三种符号不仅用于分析时间复杂度，对空间复杂度也同样适用。如例的循环
算法具有常数级的空间复杂度Sn而递归算法具有线性空间复杂度Snn。
需要注意的是，和Ω分别表示上界和下界，但一个函数可以有很多不同的上界
和下界。例如n既可以写为n也可以写为n、e……同样的，既可以写为
Ωn也可以写为Ωlog n、Ω……在此我们希望上下界越接近真实函数越好，所以通常取
最小的上界作为函数，最大的下界作为Ω函数。
为了帮助初学者更直观地了解不同级别函数的表现，我们给出表和对应的图。
表 常用函数增长表
输入规模n
函数
logn
n
n logn
n
n
°
n ×
第章 概论
n
p n logn
D
n
e
生 logn
图 常用函数增长曲线
通过观察表和图我们需要牢记，在设计算法时，必须全力避免指数级如复
杂度的算法，更不用说On的算法了。数学上可以严格证明lognn对任意正整数k成
立，这说明对数函数log n的增长是非常缓慢的。而面对n复杂度的算法时，计算机科学家
的本能反应就是将之优化为一个nlog n的算法，因为后者效率高很多。
如果前面的图和表对不同函数运行的时间效率的表示还不够直接，那么让我们观
察一下表其中给出了种函数在每秒可执行亿指令的计算机上运行的时间。
表 亿指令每秒计算机的运行时间表
微秒μss毫秒ms。
n fnn nlogn n n n n
μs
μs
μs
μs
μs
μs
μs
μs
μs
ms
μs
μs
μs
μs
μs
μs
μs
μs
ms
ms
μs
μs
μs
μs
μs
μs
ms
ms
s
min
I μs
μs
μs
μs
μs
ms
s
min
日
年
μs
μs
μs
ms
ms
ms
min
日
年
×年
s
h
日
日
年
年
×°年
×年
×年
×年
μs
I ms
s
min
日
×年
×°年
在对给定的算法做渐进分析时，有几个小窍门可以与大家分享。
若两段算法分别有复杂度Tnfn和Tnfn那么
应用实例：最大子列和问题
两段算法串联在一起的复杂度TnTnmaxOnJn即出领博的
那个算法决定了申联后的效率：
两段算法嵌套在一起的复杂度Tn×Tnfnxfn。
若Tn是关于n的k阶多项式，那么Tnn。
一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度。例如这个循环的复
杂度是NforiiNixyxzk。
若干层嵌套循环的时间复杂度等于各层循环次数的乘积再乘以循环体代码的复杂度。
例如下列层嵌套循环的复杂度是N
foriiNi
forjjNj
Ixyxzk
ifelse结构的复杂度取决于if的条件判断复杂度和两个分枝部分的复杂度，总体复杂度
取三者中最大。即对结构
ifP P的复杂度为f
PP的复杂度为F
else
P P的复杂度为f
总复杂度为maxOfJ。
应用实例：最大子列和问题
在这一节里，我们将讨论最大子列和问题的解。解决这个问题至少有种不同算法，我们将
看到这些算法效率的巨大差别，从而对算法的复杂度分析有更深刻的理解。
问题描述给定n个整数的序列aa…aI求函数fijmax∑a 的最大值。
在这里，“子列”被定义为原始序列中连续的一段数字，我们要找的是具有最大和的一段连
续的子列，并且返回它的和。如果这个最大和是负数，那么我们取为最终答案。例如给定序列
其最大子列为和为
算法 让我们从最直接的方法开始，就是穷举所有子列和，从中找出最大值。代码
给出了这个算法的实现。
int MaxSubseqSumint Listint N
int ijk
int ThisSumMaxSum
第章 概 论
horiiNii是子列左端位置
forjijN jj是子列右端位置·
ThisSum ThisSum是从Listi到List的子列和
forkikjk
ThisSumListk
ifThisSumMaxSum 如果刚得到的这个子列和更大
MaxSumThisSum则更新结果
j循环结束
Fi循环结束
return MaxSum
代码 最大子列和算法的实现
观察代码我们发现程序的时间复杂度是由层嵌套的 for循环决定的，即
rNw
注意到最内层的k循环涉及大量重复计算，是最大的浪费点。因为对于固定的i当j增大
了之后，k 循环要重新从i加到j。而事实上第j步的计算结果完全可以存下来，第j步只要
在此基础上累加一个Listj就可以了，没有必要再从头加起。于是有了下面改进的算法。
算法部分存储中间值的穷举。代码给出了这个算法的实现。
int MaxSubseqSumint Listint N
intij
int ThiaSumMaxSum
foriiNii是子列左端位置
ThieSum Thissum是从List到List的子列和
forjjNJ 是子列右端位置
对于相同的不同的j只要在J次循环的基础上累加项即可
ThisSumLio
ifThiaBumMaxSum八 如果刚得到的这个子列和更大人
MaxSumThiaSum则更新结果人
j循环结束
循环结束
return NaxSum
代码 最大子列和算法的实现
应用实例：最大子列和问题
观察代码我们发现程序的时间复杂度是由层嵌套的for循环决定的，易见该算法复
杂度降低到N。读者如果有兴趣，可以自己试验N时两种算法的差别。
但这仍不是最快的算法。
算法分而治之。
顾名思义，分而治之法简称“分治法”的基本思路就是将原问题拆分
成若干小型问题，分别解决后再将结果合而治之，用递归实现非常方便。
就此题而言，我们可以把问题理解为：如果我们把原始序列一分为二，
那么最大子列或者在左半边、或者在右半边、或者是横跨中分线的一段。分
治法的概要描述为：
…
微视频
最大子列和 第步：将序列从中分为左右两个子序列； 的分治法
第步：递归求得两子列的最大和S左和S若；
第步：从中分点分头向左、右两边扫描，找出跨过分界线的最大子列和S中；
第步：SmaxS左，SS。
代码给出了这个算法的实现。
int Maxint Aint B int c
返回个整数中的最大值·
return ABACACBCBC
int DivideAndconquerint List int leftint right
分治法求Listleft到Listright的最大子列和人
int MaxLeftSumMaxRightSum存放左右子问题的解·
int MaxLeftBorderSumMaxRightBordersum存放跨分界线的结果
int LeftBorderSumRight BorderSum
int centeri
ifleftright递归的终止条件，子列只有个数字·
ifListleft return Listleft
else return
下面是“分的过程·
centerleftright找到中分点
递归求得两边子列的最大和·
MaxLeftSumDivideAndConquerListleftcenter
第章 概论
MaxRightSumDivideAndconquerList centerright
下面求跨分界线的最大子列和
MaxLeftBorderSumLeftBorderSum
foricenterilefti从中线向左扫描
LeftBorderSumListi
ifLeftBorderSumMaxLeftBorderSum
MaxLeftBorderSumLeftBordersum
左边扫描结束·
MaxRightBorderSumRightBorderSum
foricenteririghti从中线向右扫描·
RightBorderSumListi
ifRightBorderSumMaxRightBorderSum
MaxRightBorderSumRightBorderSum
右边扫描结束
下面返回治的结果
return MaxMaxLeftSumMaxRightSumMaxLeftBorderSumMaxRightBorderSum
int MaxSubseqSumint Listint N
保持与前种算法相同的函数接口
return DivideAndconquerListN
代码 最大子列和算法的实现
注意到解决问题的核心函数是DivideAndConquer但是作为专业程序员，令具有相同功能的
函数保持相同风格的函数接口是一个好习惯，所以我们沿用前两种算法的接口，用MaxSubseq Sum进行了包装。这样做的好处是，用户调用不同算法时，输入的参数足不变的，一直都是数组
List 和数据个数N不需要改变。
算法的复杂度分析略有难度：若记整体时间复杂度为TN则函数 DivideAndConquer
中递归进行“分”的复杂度为ZTN因为我们解决了个长度减半的子问题。求跨分界线的
最大子列和时，有两个简单的for 循环，所用步骤一共不超过N所以可以在N时问完成。其
他步骤都只需常数O时间。
综上分析则有递推式：
T
应用实例：最大子列和问题
TNTNN
TNNNTN·N
…TNk·N
当我们不断对分直到N即N时，就得到TNN·TlogN·NMog N。
此算法比算法又快了一些，当N时，效果会非常明显。
然而这仍然不是最快的算法
算法在线处理。
“在线”的意思是指每输人一个数据就进行即时处理，得到结果是对于
当前已经读人的所有数据都成立的解，即在任何一个地方中止输入，算法都
能正确给出当前的解。
…
微视频
最大子列和 前面所给出的种算法都必须等所有的N个整数都读入并存储后才
可以进行，而下面将介绍的算法甚至无须存储输人序列就可以得到任何时
刻的最大子列和。
的在线算法
该算法的核心思想是基于下面的事实：如果整数序列aa…a的最大和子列是
a≥对任意i≤I≤j成立。因此，一旦发现当前子列和为负，则 aa…a那么必定有
可以重新开始考察一个新的子列。代码给出了这个算法的实现。
int MaxSubseqSumint Listint N
inti
int ThisSumMaxSum
ThisSumMaxSum
foriiNi
ThisSumListi 向右累加·
ifThisSumMaxSum
MaxSumThisSum 发现更大和则更新当前结果
ThisSum 则不可能使后面的部分和增大，抛弃之
return MaxSum
else ifThisSum 如果当前子列和为负
代码 最大子列和算法的实现
易见该算法只有一个for 循环，复杂度只有N虽然算法的正确性不如前面种算法那
么显然。
让我们通过一个具体的整数序列来理解这个算法。图的
第章 概 论
ah显示了for 循环步中ThisSum和MaxSum的变化过程。
注意到这个算法的特点，是无论我们停在中间哪一步，返回的MaxSum 都会是当前输入数据
的正确解——例如当我们在第c步停止输入时，对于这个序列，正确的最大和就是
如果在第e步停止，对于这个序列，正确的最大和就是。这就是所谓“在
线算法的意思。
i
List
aiThisSumMaxSumList被抛弃
List
biThisSumMaxSum当前最大子列为List
i
List 二
ciThisSumMaxSum当前最大子列仍为List
i
List
diThisSumMaxSum当前最大子列为List
List
eiThisSumMaxSum当前最大子列仍为List。
因ThisSum小于故此段被抛弃，因为它不可能使后面的和变大
i
List
iThisSumMaxSum当前最大子列仍为List
List
giThisSumMaxSum当前最大子列变为LisiS
T
List
hiThisSumMaxSum当前最大子列仍为List
图 最大子列和算法的演示
另外，这种算法实际上并不要求存储序列中的数据，我们只需要将数字一个一个读入，同时
一个一个处理即可，处理过的数据没必要存起来。整个算法只把输人数据扫描工遍，这应该是
习题
我们能得到的最快的算法了。
这个例子是告诉大家，解决同一个问题，不同的算法会有很大的差别。提高效率的窍门之
一，是让计算机“记住”一些关键的中间结果，避免重复计算。
本 章 小 结
本章介绍了两个重要的概念：“数据结构”与“算法”。
数据结构包括数据对象集以及它们在计算机中的组织方式，即它们的逻辑结构和物理存
储结构，同时还包括与数据对象集相关联的操作集，以及实现这些操作的最高效的算法。抽象数
据类型是用来描述数据结构的重要工具。
“算法”是解决问题步骤的有限集合，通常用某一种计算机语言进行伪码描述。我们用时间
复杂度和空间复杂度来衡量算法的优劣，用渐进表示法分析算法复杂度的增长趋势。
习 题
判断正误。
Nlog N是N的。
Nlog N和Nlog N具有相同的增长速度。
填空题。
给定N×N的二维数组A则在不改变数组的前提下，查找最大元素的时间复杂度是。
斐波那契数列F。的定义为：FFFxFaiFxN…。用递归函数计算F。的空间复杂
度是时间复杂度是。
试分析下面一段代码的时间复杂度：
ifAB
foriiNi
forjNNjij
AB
else
foriiNi
forjNjij
AB
分析例中两个版本的PrintN 函数的时间、空间复杂度，并测试它们的实际运行效率。对N
运行程序，将两版本的N时间曲线绘在一张图里进行比较分析。
fxS×n 测试例中秦九韶算法与直接法的效率差别。令 计算f的值。利用
第章 概 论
clock函数得到两种算法在同一机器上的运行时间。
试分析最大子列和算法的空间复杂度。
测试最大子列和种算法的实际运行效率。简单起见，可令List 中全部整数为。当N
…时，将各算法的N时间曲线绘在一张图里，其中时间以毫秒为单位；当N…
时，以秒为单位绘出各算法的时间增长曲线。两幅图有什么不同为什么
查找算法中的“二分法”是这样定义的：给定N个从小到大排好序的整数序列List以及某待查找整
数X我们的目标是找到X在List中的下标。即若有ListiX则返回i否则返回表示没有找到。二分法
是先找到序列的中点ListM与X进行比较，若相等则返回中点下标；否则，若ListMX则在左边的子系列
中查找X若ListMX则在右边的子系列中查找X。试写出算法的伪码描述，并分析最坏、最好情况下的时
间、空间复杂度。
给定存储了N个从大到小排好序的整数数组 List 试给出算法将任一给定整数X插入数组中合适
的位置，以保持结果依然有序。分析算法在最坏、最好情况下的时间、空间复杂度。
试给出判断N是否为质数的√N的算法。
试给出计算x的时间复杂度为logN的算法。
第章
数据结构实现基础
引子
上一章我们讲过，所谓“数据结构”涉及的不仅仅是数据对象本身以及它们在计算机中的
组织方式，还要考虑与它们相关联的一个操作集，以及实现这些操作的最高效的算法。数据结构
的实现需要依赖具体的程序设计语言，本教材数据结构的实现语是C语言。本章先简要回顾一
下C语言在对支持数据逻辑关系存储以及相关操作实现方面的基础。
我们先来看一个例子，理解抽象与实现之间的关系。
例 在日常数据处理中经常碰到的问题是需要对一组数据进行基本的统计分析。比
如，分析一个课程班学生的平均成绩、最高成绩、最低成绩、中位数、标准差等。同样的统计要求
也可能发生在其他领域，比如，统计家庭每年各月的开支情况、生产线上各位员工计件任务的完
成情况、各省的人均GDP数据等。总之，在工作和生活的许多方面都会涉及数据的这类统计。
为每个具体应用都编一个程序显然不是一种很好的方法，因为这些程序有很大的相似性。
数据结构的处理方法是从这些具体应用中抽象出共性的数据组织与操作方法，进而采用某种具
体的程序设计语言实现相应的数据存储与操作。比如，对于上述例子我们可以从各种不同的应
用背景中抽象出一种针对基本统计要求的数据类型。
类型名称：统计数据集 数据对象集：N个元素xx…xl的集合S。
操作集：
ElementType AverageSN求S中N个元素的平均值；
ElementType MaxSN求S中N个元素的最大值；
ElementType MinSN求S中N个元素的最小值；
ElementType MedianSN求S中N个元素的中位数。这里的中位数指：如果将S
中的元素按从大到小的顺序依次排列，处在中间位置「N大于等于N的最小
整数的那个元素。
可以看到，针对上述数据抽象方式的具体程序，可以用来求解不同领域的基本统计问题，这
样既使得我们程序设计的逻辑清晰，也在很大程度上实现了代码的重用。
如何利用程序设计语言实现上述抽象类型首先，必须首先考虑数据如何存储——在我们
这个例子中，即考虑集合S的数据在C语言中怎么存储；其次必须考虑操作如何实现，即在确定
第章 数据结构实现基础
好数据存储方式的基础上，相应的操作如Average、Max等函数如何实现。
数据存储
对于上述问题，其数据对象集是集合S这也是最简单的一种数据组织方式。今后我们会介
绍一些更复杂的数据组织方式，比如树、图。以集合方式组织不要求数据有序比如从小到大
存放。
C语言包括其他高级语言提供了数据组织的几种基本实现方式，包括数组、链表、结构体
等。事实上，数据组织的基本存储方式主要是利用数组和链表方式来实现的，包括很复杂的数据
结构，如图、树，也都不外乎应用数组和链表来实现。
在这个例子中，我们可以简单地使用数组来存储一个集合。这样，相关的操作包括求平均
值、最大值等就都可以在数组上进行。
必须注意：数据的存储方法是与要实现的操作密切相关的。对于上述问题，用数组存储集合
可以很方便地实现我们列举出的相关统计操作。如果同样是基于集合，但要求的操作发生了变
化，则相应的数据存储方法也有可能需要采用不同的方式。例如：
若要实现的操作不是基本统计，而是集合运算，如判别一个元素是否属于某集合、计算
两集合的“并”和“交”运算、将某元素插入集合等。这些操作运算虽然在简单的数组上也可
以实现，但效率不高。有种更好的表示方法是使用“树”在节中我们将应用树的组织方
式方便地实现集合的上述运算。
若除了基本的统计操作外，我们还需要动态地维护一个集合，即经常往集合里加入一个
元素或删除一个元素，这时简单地使用数组存储就会遇到问题；我们应该事先设计多大的数组来
保存这些元素数组太大浪费空间，太小有可能会不够用；当删除元素时，还需要移动其后面的
元素，所需要的时间相对比较长。这时，另一种方法是使用链表来保存数据，可以根据需要随时
申请和释放空间。但链表存储也有缺点：由于需要记录下一元素结点的地址，所以，跟同样数
据的数组存储相比，链表需要更多的存储空间，同时在程序实现方面也比数组复杂。
所以，数据结构的存储实现跟所需要的操作密切相关，没有最好的存储方式，只有最合适的
存储方式。
操作实现
在确定数据的存储方式后，数据结构涉及的另一个问题是相关的操作运算如何实现。这
些操作的实现需要利用程序设计语言提供的另一个功能，即流程设计功能。
任何高级程序设计语言包括C语言都提供丁一种的基本流程控制语句即分支控制语句
如ifcloc、owitch语句和循环控制语句如for、while、dowhile 语句。分支控制结构、循环控
制结构加上程序自然的语句顺序执行结构，是实现任何算法流程的基本结构。
虽然分支控制、循环控制和顺序执行结构可以实现任何算法流程，但当流程很复杂时程序
设计会变得非常困难。所以，模块化的程序设计方法就自然产生了。模块化程序设计方法以功
能块为单位进行程序设计。模块化的日的是为了降低程序结构的复杂度，使程序设计、调试和维
护等燥作简单化。函数是程序设计语言提供的模块化程序设计的基本手段。在程序中，我们可
引子
以将程序的某个基本功能设计为函数，这一方面降低了程序设计的复杂性，另一方面也提高了程
序设计的重用性。
回到我们例子中的基本统计问题，就操作集中列举的四种操作而言，如果数据存储在一个数
组S里，显然相关的AverageSN、MaxSN、MinSN操作都可以很容易地用循环实现。代
码展示了Average 函数的实现。
ElementType AverageElement Type sint N
I求N个集合元素s的平均值
int i
BlementTypo Sum
foriiNi
Sumsi 将数组元素累加到Sum中
return SumN
代码 求集合元素的平均值
而对于求中位数MedianSN问题则相对比较复杂，没法用一个循环简单地实现。有两种
基本的解决思路。
方法基于排序
首先将集合S数组中的元素从大到小排序，取第N大于等于N的最小整数处的
元素就是中位数。
方法基于问题分解
求集合中位数问题实际上是另一个问题的特殊情况，即求集合中的第K大数问题。当
KN时，集合的第K大数就是中位数。这个问题当然也可以用排序解决，但还有另一种更
巧妙的方法，基本思路是：用一个基准数e将集合S分解为不包含e在内的两个小集合S和S
其中S的任何元素均大于等于eS的任何元素均小于e。记ISI代表集合S元素的个数，这样，
如果S≥K则说明第K大数在S中；如果ISI正好等于K说明e是第K大数；否则第K大
数在S中，并且是S中的第KIS大数。然后，可以用类似的思路继续在S或S中查找。
例利用问题分解思想，求集合的中位数。
由于该集合有个元素，所以中位数应该是集合从大到小排序后的第个元素。首
先，选取集合的第一个元素根据这个元素从集合中分解出SS。
由于S且不等于所以该中位数应该在集合S中，且是S中第大数。
继续选取S中的第一个整数将S分解出两个集合SS。由于ISI
所以就是S集合的第大数，也就是集合的中位数。
第章 数据结构实现基础
上述思路是一种将大问题分解为小问题的求解方法。由于小问题的求解采用与大问题相同
的思路，所以可以采用函数递归的程序设计方法实现。代码给出了基于函数递归的求第K
大数的算法。
ElementType FindKthLargestElementType sint K
此为伪代码·
选取s中的第一个元素e
根据e将集合S不包含e分解为大于等于e的元素集合S和小于e的元素集合S
ifISI≥K return FindKthLargestSK
else ifISJKreturn FindKthLargestSKISI
else return e
代码 求第K大数的算法
上述方法应用函数递归比较简洁地实现了算法流程的控制。今后大家可以了解到递归是数
据结构算法设计的很重要的手段。
本章后面两节跟大家一起回顾一下C语言程序设计中数据存储的实现基础，包括数组、结
构、指针、链表；以及流程实现的主要方法，包括分支控制、循环控制、函数以及递归。重点是进一
步巩固链表和递归中的相关内容。
数据存储基础
变量是数据存储的基本单位，而变量是有类型的。C语言事先定义了几种基本的数据类型，
供程序员直接使用，如整型、实型浮点型、字符型等。为了使程序员能更充分地表达各种复杂
的数据，C语言还提供了构造复杂数据类型的手段，如数组、结构、指针等，为有限能力的程序设
计语言表达客观世界中多种多样的数据提供了良好的基础。
数组
数组是最基本的构造类型，它是一组相同类型数据的有序集合。数组中的元素在内存中连
续存放，每个元素都属于同一种数据类型，用数组名和下标可以唯一地确定数组元素。
一维数组定义的一般形式为：
类型名 数组名数组长度
例如，下列语句定义了大小为的整型数组a。
int a
数组元索的引用要指定下标，形式为：
数据存储基础
数组名下标
数组元素的使用方法与同类型的变量完全相同。C语言的编译器不检查数组下标是否越
界，因此在编程时不要让下标越界。因为，一旦发生下标越界，就会把数据写到其他变量所占的
存储单元中，有可能造成不可预料的运行结果。
和简单变量的初始化一样，在定义数组时，也可以对数组元素赋初值。其一般形式为；
类型名 数组名数组长度初值表；
初值表中依次放着数组元素的初值。
C语言支持多维数组，最常见的多维数组是二维数组，主要用于表示二维表和矩阵。
二维数组的定义形式为：
类型名 数组名行长度列长度
引用二维数组的元素要指定个下标，即行下标和列下标，形式为：
数组名行下标列下标
二维数组的元素在内存中按行优先方式存放，即先存放第行的元素，再存放第行的元
素……其中每一行的元素再按照列的顺序存放。
数组的应用离不开循环。在程序实现中，往往将数组的下标作为循环变量，通过循环，就可
以对数组的所有元素逐个进行处理。对二维数组，可以将行下标和列下标分别作为循环变量，通
过二重循环，就可以遍历二维数组，即访问二维数组的所有元素。由于二维数组的元素在内存中
按行优先方式存放，将行下标作为外循环的循环变量，列下标作为内循环的循环变量，可以提高
程序的执行效率。
数组具有随机存取元素效率较高的优点，即存取第i个元素只需常数时间。也就是说，存取
Ai所需时间与下标i无关。
例求集合元素的最大值。集合元素存放在数组A中，数组大小为N。
代码给出的函数在类型为ElementType的数组A中查找最大的元素。这里的Element Type并不是C语言提供的数据类型。这样写法的好处是通用，我们不需要对每个具体的数据类
型如int、float、double等都实现一个求最大值的函数，读者在使用这个函数解决具体问题之
前，只要把 ElementType定义成自己需要的类型就可以了。
函数参数是个，即数组A和数组大小N。这也是C语言传递数组的基本形式，因为A代表
了数组的第一个元素的地址，并不包含数组元素个数的信息，因此还需要传递一个参数N。该函数
以数组第一个元素为基准作为当前最大值CurMax通过循环控制变量i从数组的第二个元素
下标为开始逐个查找，每次都与当前已知的最大值进行比较，当发现更大值时更新CurMax。
ElementType MaxElementType sint N
求N个集合元素s中的最大值
int i
ElementType CurMaxs
第章 数据结构实现基础
foriiNi
ifSiCurMax·若Ai比当前最大值还要大·
return CurMax
curMaxsi 则更新当前最大值·
代码 求N个元素数组集合中的最大值
类型定义 typedef
在编程过程中，除了使用C语言提供的标准类型和自己定义的一些结构体、枚举等类型外，
还可以用typedef语句来建立已经定义好的数据类型的别名：
typedef 原有类型名 新类型名
利用typedef来建立基本数据类型的别名能够使得程序具有更好的可阅读性和移植性。比
如在上述求集合元素最大值问题中，当我们需要求整数集合的最大值时，就可以利用 typedef定
义代码中的ElementType
typedef int ElementType
把上述语句写在函数之前，我们就可以直接使用代码而不需要把代码中的每个
ElementType换成int 去编译运行。
指针
指针是C语言中一个非常重要的概念，也是C语言的特色之一。使用指针可以对复杂数据
进行处理，能对计算机的内存进行分配控制，在函数调用中使用指针还可以返回多个值。
定义指针变量的一般形式为：
类型名 指针变量名
例如，下列语句定义了指向float类型的指针变量p。
floatp
指针变量用于存放变量的地址。由于不同类型的变量在内存中占用不同大小的存储单元
所以如果只知道内存地址，还不能确定该地址上的对象。因此在定义指针变量时，除了指针变量
名，还需要说明该指针变量如p所指向的内存空问上所存放数据的类型如flont。
指针被定义后，必须将指针和一个特定的变量进行关联后，才可以使用指针，也就是说，指针
变量也要先赋值再使用当然指针变量被赋的值应该是地址。
指针的基本运算
如果指针的值是某个变量的地址，通过指针就能间接访问那个变量。这些操作由取地址运
算符和问接访问运算符中完成。此外，相同类型的指针还能进行赋值和比较。
数据存储基础
指针可以同整数进行加、减操作。例如，如果变量p是指向 float类型变量的指针，那么表达
式 pi代表了从p这个位置开始的第i个Hoat类型变量的地址。
两个类型相同的指针也可进行相减操作，表示两个指针之问相隔的变量个数。两个相同类
型指针还可以使用关系运算符比较大小。
指针与数组
在C语言中，数组名本身就是数组的基地址，即第个元素下标为的地址。
在访问内存方面，指针和数组几乎是相同的，当然也有不同：指针是以地址作为值的变量，而
数组名的值是一个特殊的固定地址，可以把它看作是指针常量，不能改变指针常量数组名
的值。
在函数定义中，被声明为数组的形参实际上是一个指针。当传递数组时，按值调用传递它的
基地址，数组元素本身不被复制。
数组名作为函数的实参，在被调用函数中，就能访问实参数组所在的存储单元，不但可以引
用，还能改变这些单元的内容。返回主调函数后，相应数组元素的值就改变了。
用指针实现内存动态分配
变量在使用前必须被定义且安排好存储空间包括内存中起始地址和存储单元大小。比
如，在定义数组时就需要声明数组的大小。但有些情况下，运行中的存储要求在写程序时无法确
定，因此需要一种可以根据运行时的实际存储需求来动态分配适当存储区的机制。C语言为此
提供了动态存储管理，允许程序动态申请和释放存储空间。
在动态存储分配方面，C语言提供了一组标准函数，定义在stdioh里面，主要有：
动态存储分配函数 void mallocunsigned size在内存的动态存储区中分配一连续空
间，其长度为size。若申请成功，则返回一个指向所分配内存空间的起始地址；若申请内存空间
不成功，则返回NULL值为。该函数的返回值为void 类型，在具体使用中，需要将malloc
的返回值转换到特定指针类型，并赋给一个指针变量。
动态存储释放函数 void freevoid ptr释放由动态存储分配函数申请到的整块内存
空间，ptr为指向要释放空间的首地址。
为了保证动态存储区的有效利用，在动态分配的存储块不再使用时，就应及时将它释放。特
别注意：
指针只有在被赋值以后才能被正确使用。指针如果没有被赋值，它的值是不确定的，即
它指向一个不确定的单元，使用这样的指针，可能会出现难以预料的结果，甚至导致系统操作错
误。例如，下列语句中，指针p没有被事先赋值如指向一个字符数组函数调用strepy可能会
出现难以预料的结果。
char p
strcpypThis is Wrong
在C语言中，指针的算术运算只包括两个相同类型的指针相减以及指针加上或减去一
个整数，其他的操作如指针相加、相乘和相除，或指针加上和减去一个浮点数都是非法的。
第章 数据结构实现基础
结构
结构类型是一种允许程序员把一些数据分量聚合成一个整体的数据类型，它能够把有内在
联系的不同类型的数据统一成一个整体，使它们相互关联。同时，结构又是一个变量的集合，可
以按照与成员类型变量相同的操作方法单独使用其变量成员。结构与数组的区别在于，数组的
所有元素必须是相同类型的，而结构的成员可以是不同的数据类型。
结构类型定义的一般形式为；
struct 结构名
类型名 结构成员名
类型名 结构成员名
……
类型名 结构成员名n
I
在定义结构成员时所用的数据类型也可以是结构类型，这样就形成了结构类型的嵌套。
在C语言中定义结构体变量的一种方式是：先定义一个结构类型，再定义一个具有这种结
构类型的变量，基本形式是：
struct 结构名 结构变量名表；
当然也可以在定义结构类型的同时定义结构变量。另外，也允许在定义结构变量时省略结
构名。要注意的是，这种方式由于没有给出结构名，在以后无法再定义这个类型的其他结构变
量，除非把定义过程再写一遍。
结构变量也可以初始化，即在定义时对其赋初值。结构变量的初始化采用初始化表的方法，
大括号内各数据项间用逗号隔开，将大括号内的数据项对应地赋给结构变量的各个成员，要求数
据类型一致。
结构变量的使用
使用结构变量主要就是对其成员进行操作。在C语言中，使用结构成员操作符“”来引用
结构成员，格式为；
结构变量名，结构成员名
对嵌套结构成员的引用方法和一般成员的引用方法类似，也是采用结构成员操作符”。”进行
的，每个成员按从左到右、从外到内的方式引用。
由于结构成员运算符的优先级属最高级别，所以一般情况下都是优先执行，即和一般运算符
混合运算时，结构体成员运算符优先。
结构变量不仅可以作为函数参数，也可以作为函数的返回值。此外，结构成员变量也能作为
函数参数，与普通变量作为函数参数一样。
结构数组
可以将具有相同结构类型的变量组织起来，形成一个结构数组。结构数组是结构与数组的
结合与普通数组的不同之处在于每个数组元素都是一个结构类型的数据，包括各个成员项。
结构数组的定义方法与普通数组的定义方法相同，此时的类型是结构。在定义结构数组时，
也可以同时对其进行初始化，其格式与二维数组的初始化类似。
对结构数组元素成员的引用是通过使用数组下标与结构成员操作符相结合的方式来完
成的，其一般格式为：
结构数组名下标结构成员名
结构指针
结构指针就是指向结构类型变量的指针。有了结构指针，既可以通过该指针访问结构，也可
以通过指针直接访问结构成员。具体有两种形式：
用·方式访问，形式；
结构指针变量名结构成员名
用指向运算符“”访问指针指向的结构成员，形式：
结构指针变量名结构成员名
结构指针也可以作为函数参数传递。相比于通过参数直接传递结构，将结构指针作为参数
传递不仅可以在函数中修改结构指针所指向的内容，而且参数传递的效率会更高。
共用体
共用体同结构体在声明形式和访问方式上有些类似，但是它和结构体是完全不同的。所谓
共用体类型是指将不同的数据项组织成一个整体，它们在内存中占用同一段存储单元。其定义
形式为：
union共用体名
类型名 成员名
类型名 成员名
……
类型名 成员名n
由于各个成员变量在内存中都使用同一段存储空间，因此共用体变量的长度等于最长的成
员的长度。共用体的访问方式同结构体类似。
下面是一个共用体的例子：
union key
int k
char ch
u
该共用体变量占用空间是int类型占用空间与字节的最大值。读者可以运行一下代码
看看输出结果是什么为什么
第章 数据结构实现基础
include stdioh
int main
union key
int k
char ch
lu
uk
printfdnuchuch
return
代码 共用体的一个例子
链表
链表是一种常见而重要的基础数据结构，也是实现复杂数据结构的重要手段。它不按照线
性的顺序存储数据，而是由若干个同一结构类型的“结点”依次串接而成的，即每一个结点里保
存着下一个结点的地址指针。
使用链表结构可以克服数组需要预先知道数据大小的缺点，可以充分利用计算机内存空间，
实现灵活的内存动态管理。但链表失去了数组方便随机存取的优点，同时链表由于增加了结点
的指针域，空间开销比较大。
链表有很多种不同的类型：单向链表、双向链表以及循环链表。
单向链表的结构
单向链表的组成如图所示。一个表头变量hoad用来存放链表首结点的地址，链表中每
个结点由数据部分和下一个结点的地址部分组成，即每个结点都包含指向下一个结点的指针。
链表中的最后一个结点称为表尾其下一个结点的地址部分的值为NULL表示为空地址》。链
表的各个结点在内存中可能是不连续存放的，具体存放位置由系统分配。
head A
图 单向链表的组成示意图
通常使用结构的该套来定义单向链表结点的数据类型。如：
typedef struet Node xPuToNode
B c D NULL
数据存储基础
struct Node
ElementType Data 存储结点数据
PtrToNode Next 指向下一个结点的指针
结构类型 Node中的Next分量又是该结构类型的指针，称之为结构的递归定义。为了阅读
方便，我们将指针重命名为PtrToNode即“指向Node的指针”之意。除了Next分量外还有其他
表示结点信息的分量如本例中的Data。
通常我们说“给定一个单链表就是给定一个指向该链表头结点的指针，所以“单链表类
型List可以定义为链表结点结构的指针，即：
typedef PtrToNode List
链表是一种动态数据结构。在进行动态存储分配的操作中，C语言提供了几个常用的函数：
malloc、free。例如，要申请大小为struct Node 结构的动态内存空间，可由下面语句实现：
PtrToNode pPtrToNodemallocsizeofstruct Node
若申请成功，p指向被分配内存空间的起始地址；若未申请到内存空间，则p的值为NULL。
单向链表的常见操作
插入结点。
在单向链表 head的某个结点p之后插入一新结点的基本过程是：首先找到正确位置p然后
申请新结点t并对t的结点信息赋值，最后将t插在p之后，如图所示。
head
P
t
图 p之后插入新结点t
将结点t插在结点p之后的语句为：
tNextpNext
pNextt
注意：上述两个语句的顺序不能颠倒。
如果需要在链表的头上插入一个结点t其基本语句是：
tNexthead
headt
删除结点。
从单向链表 head 中删除一个结点的基本过程是：首先找到被删除结点的前面一个结点p
然后删除p之后的那个结点。基本语句为：
tpNext
第章 数据结构实现基础
pNexttNext
freet
注意：删除一个结点后必须释放该结点的空间，为此在上述语句中首先将待删除结点保留在
t中，最后再释放t。
如果删除的是链表的第一个结点，其基本语句是：
thead
headheadNext
freet
单向链表的遍历。
对单向链表最常见的处理方式是逐个查看链表中每个结点的数据并进行处理，因此，链表的
遍历是非常基础的链表程序设计方法。
单向链表遍历的基本程序结构为：
phead
whilepNULL ……
对p所指的结点信息进行处理； ……
ppNext
链表的建立。
应用链表进行程序设计时，往往需要先建立一个链表。建立链表的过程实际上就是不断在
链表中插入结点的过程。
在构建链表时，有两种常见的插人结点方式：①在链表的头上不断插入新结点；②在链表的
尾部不断插入新结点。如果是后者，一般需要有一个临时的结点指针一直指向当前链表的最后
一个结点，以方便新结点的插入。
前面提到的单向链表都是一种不带头结点的单向链表。有时为了程序处理方便，比如在删
除结点时希望不需要特别区分是否是链表的第一个结点还是其他结点，可以在单向链表的头上
加一个“空结点”该结点的Data空置，而Next指向链表的第一个真正结点。这种链表叫带头结
点的单向链表。
双向链表
单向链表的构成使得结点访问要按链的指向进行，某一单元的后继单元可以直接通过链
指针Next指针找到，而要找到其前驱单元，必须从链头开始查找。如果结点增加一个指针
域指向其前驱结点，将在牺牲空间代价的前提下，减少操作的代价。这种在单向链表基础上
增加指向前驱单元指针Previous指针的链表叫做双向链表。图是双向链表的图示表示
形式。
数据存储基础
head
“
a a
图 双向链表
双向链表结点的数据类型与单向链表相似，只是多了一个前驱单元指针：
typedef struct DNode PtrToDNode
struct DNode
存储结点数据 ElementType Data
指向下一个结点的指针 PtrToDNode Next
PtrToDNode Previous 指向前一个结点的指针
typedef PtrToDNode DList
如果将双向链表最后一个单元的Next指针指向链表的第一个单元，而第一个单元的Previ ous 指针指向链表的最后一个单元，这样构成的链表称为双向循环链表图所示。
head a a a
图 双向循环链表
对双向链表的插入、删除和遍历基本思路与单向链表相同，但需要同时考虑前后两个指针。
比如，在图所示的双向链表的p指向的a结点后插入新结点t的方法是：
tPreviousp
tNextpNext
pNextPrevioust
pNextt
同样，这其中个语句之间也需要保持一定的执行顺序，否则可能得不到正确结果。
head a a a a
P
t
图 双向链表的插入
例给定一个单链表L请设计函数Reverse将链表L就地逆转，即不需要申请新的结
点，将链表的第一个元素转为最后一个元素，第二个元素转为倒数第二个元素，以此类推。
第章 数据结构实现基础
分析比较明显，解决这个问题的基本思路是：利用循环，从链表头开始逐个处理。循环
设计中，最核心的要点是如何把握住循环不变式。循环不变式表示一种在循环过程进行时不变
的性质，不依赖于前面所执行过程的重复次数的断言。对于本题，我们可以想象到的场景是：在
每轮循环开始前我们都面临两个链表，其中Oldhead是一个待逆转的链表即“旧”的链表头
而Newhead是一个已经逆转好的链表即“新”的链表头如图所示。每轮循环的目的是
把Oldhead中的第一个元素插入到Newhead的头上，这轮循环执行好后，ldhead和New
head 还是分别指向新的待逆转链表和已经逆转好的链表。
Newhead Oldhead
图 单向链表的逆转
循环程序的主体部分就是将Oldhead的第一个元素插入到Newhead头上，同时更新Old
head、Newhead值。当将Oldhead的第一元素插入到Newhead头上后，我们需要知道Old
head 链表新的头结点在哪里，因此，还需要使用一个临时变量Temp。所以，循环程序的主体部
分是：
TempOldheadNext
OldheadNextNewhead
NewheadOldhead
OldheadTemp
在循环执行前，ldhead、Newhead应该正确初始化，即：待逆转的链表Oldhead 就是原始
链表，已经逆转好的链表Newhead开始时为空。而循环结束后，需要将逆转后的链表头指针
Newhead返回。单向链表逆转函数如代码所示。
List ReveroeLiat L
八将单链表工逆转
PtrTONode d nead Newhead Temp
odheadL人初始化当前旧表头为L
NewheadNULL初始化逆转后新表头为空
whiledheadl当旧表不为空时
TempdheadNext
dheadNeatNewhead
Nowheaddhead将当前旧表头逆转为新表头
AhaadTemp一更新旧表头
流程控制基础
LNewhead八更新L
return L
代码 单向链表的逆转
流程控制基础
程序设计语言除了能表达各种各样的数据外，还必须提供一种手段来表达数据处理的过程，
即程序的控制过程。程序的控制过程通过程序中的一系列语句来实现。
按照结构化程序设计的观点，任何程序都可以将程序模块通过三种基本的控制结构进行组
合来实现。这三种基本的控制结构是顺序、分支和循环。
顺序结构是一种自然的控制结构，通过安排语句或模块的顺序就能实现。所以，对一般程序
设计语言来说，需要提供表达分支控制和循环控制的手段。C语言为分支控制提供了 ifelse和
switch两类语句，而为循环控制提供了for、while和dowhile三类语句。
以上种控制方式称为语句级控制。它实现了程序在语句间的跳转。
当我们要处理的问题比较复杂时，为了增强程序的可读性和可维护性，常常将程序分为若干
个相对独立的子程序。在C语言中，子程序的作用由函数完成。函数通过一系列语句的组合来
完成某种特定的功能如求整数n的阶乘。当程序需要相应功能时，不用重新写一系列代码，
而是直接调用函数，并根据需要传递不同的参数如求阶乘函数中的n。同一个函数可以被一
个或多个函数包括自己多次调用。函数调用时可传递零个或多个参数，函数被调用的结果将
返回给调用函数。这种涉及函数定义和调用的控制称为单位级控制。所以，程序设计语言的另
一个功能就是提供单位级控制的手段，即函数的定义与调用手段。
分支控制
ifelse 语句
ifelse语句的一般形式为：
if表达式
语句
else
语句
该语句用于实现分支结构，根据表达式的值选择语句或语句中的一条执行。ifelse语
句首先求解表达式，如果表达式的值为“真”则执行语句如果表达式的值为“假”则执行语
第章 数据结构实现基础
句。ifelse语句的else部分可以省略。
可以通过多个二路分支语句 ifelse的嵌套组合实现多路选择，其一般形式为：
if表达式
语句
else if表达式
语句
else if表达式 n
语句n
else
语句n
它的执行流程是：首先求解表达式如果表达式的值为“真”则执行语句并结束整个
if语句的执行，否则，求解表达式……最后的else处理给出的条件都不满足的情况，即表达
式、表达式、……和表达式n的值都为“假”时，执行语句n。
在嵌套的 ifelse 语句中，如果内嵌的 if省略了else 部分，会存在后面的else与哪个if配对
的问题。在C语言中，else和if的匹配准则是：else与最靠近它的、没有与别的else匹配过的 if
相匹配。
switch 语句
switch语句可以处理多分支选择问题，典型的形式是：
switch表达式
case 常量表达式语句段break
case 常量表达式语句段break
……
…
casc常量表达式n语句段nbreak
default 语句段nbreak
该switeh 语句首先求解表达式，如果表达式的值与某个常量表达式的值相等，则执行该常量
表达式后的相应语句段，如果表达式的值与任何一个常量表达式的值都不相等，则执行 default
后的语句段。当碰到break 语句时，跳出switeh 语句。
在switch语句中，表达式和常量表达式的值一般是整型或字符型，所有的常量表达式的值都
不能相等。每个语句段可以包括一条或多条语句，也可以为空。
switeh语句中default 可以省略，如果省略了 default当表达式的值与任何一个常量表达式的
值都不相等时，就什么都不执行。
break 语句在owitch 语句中是可选的。如果在switeh 语句中不使用break那么该switeh 语
流程控制基础
句的执行流程将会不一样：求解表达式后，如果表达式的值与某个常量表达式的值相等，则执行
该常量表达式后的所有语句段包括别的常量表达式后面的语句段如果表达式的值与任何一
个常量表达式的值都不相等，则执行 default 后的所有语句段。
由此可见，在switch 语句所有语句段的末尾使用break可以简单清晰地实现多分支选择，这
也是switch 语句的主要使用方法。
循环控制
在程序设计中，如果需要重复执行某些操作，就要用到循环结构。C语言提供了种循环语
句forwhile和 dowhile。
for语句
在C语言中，for 语句是一种常用的循环语句。它的一般形式为：
for表达式表达式表达式
循环体语句；
for语句先计算表达式再判断表达式若值为“真”则执行循环体语句，并接着计算表达
式然后继续判断表达式如此循环；若值为“假”则结束循环，继续执行 for的下一条语句。
while语句
while 语句的一般形式为：
while表达式
循环体语句；
对于while 语句，当表达式的值为“真”时，循环执行，直到表达式的值为“假”循环中止，并
继续执行 while的下一条语句。
while语句的构成简单，只有个表达式和条循环体语句，分别对应循环的两个核心要素：
循环条件和循环体。
循环的实现一般包括个部分，即初始化、条件控制、重复的操作以及通过改变某些量的值
最终改变条件的真假性，使循环能正常结束。这个部分可以直接和 for语句中的个成分表
达式、表达式、循环体语句和表达式相对应。当使用while语句时，由于它只有个成分
表达式和循环体语句就需要另加初始化部分，至于第个部分，while语句的循环体语句可包
含for语句的循环体语句和表达式所以 while的循环体语句中必须包含能最终改变循环条件
真假性的操作。
可以把for语句改写成while 语句：
表达式
while表达式
for 的循环体语句；
表达式
第章 数据结构实现基础
for 语句和while 语句都能实现循环。一般情况下，如果问题比较明显地蕴含了循环次数，使
用 for语句更清晰，循环的个组成部分一目了然。其他情况下多使用 while语句。
dowhile 语句
dowhile语句与上述种循环语句略有不同，它先执行循环体，后判断循环条件。所以无论
循环条件的真假如何，至少会执行一次循环体。其一般形式为：
do
循环体语句；
while表达式
dowhile语句第一次进入循环时，首先执行循环体语句，然后再检查循环控制条件，即计算
表达式，若值为“真”继续循环，直到表达式的值为“假”循环结束，执行 dowhile的下一条
语句。
dowhile语句的使用方法和 while 语句类似，语句中的表达式可以是任意合法的表达式，使
用时要另加初始化部分，循环体语句必须包含能最终改变条件真假性的操作。
dowhile语句适合于先循环后判断循环条件的情况，一般在循环体的执行过程中明确循环
控制条件。它每执行一次循环体后，再判断条件，以决定是否进行下一次循环。
break 语句和 continue 语句
break 语句强制循环结束，一旦执行了break 语句，循环提前结束，不再执行循环体中位于其
后的其他语句。break 语句应该和if语句配合使用，即条件满足时，才执行 break 跳出循环；不然
的话，若break 无条件执行，意味着永远不会执行循环体中break 后面的其他语句。
continue语句的作用是跳过循环体中continue后面的语句，继续下一次循环。continue语句
一般也需要与if语句配合使用。
continue语句和 break 语句的区别在于，break 结束循环，而continue只是跳过后面语句，继续
循环。break 除了可以终止循环外，还用于结束switch 语句，而continue只能用于循环。
嵌套循环
嵌套循环或多重循环是指大循环中嵌套了小循环。在处理许多比较复杂问题时经常会
使用嵌套循环，三种循环for、whilo、dowhile都可以相互嵌套。
例求单链表L中所有结点Data的阶乘和。这里保证所有结点的Data值非负。
分析可以设定两重循环：大循环外层循环控制指针P遍历单链表的每个结点用
while语句而小循环内层循环则用来求每个结点Data的阶乘用for语句。程序结构如代
码所示。
nt FactoriaSumList L
I Int ractsumI
DErToNode DL
Sum
流程控制基础
whiIeP
Fact
forIPData
Fact
SumPact
PPNoxt
return sum
代码 求单链表L中所有结点Data的阶乘和
例 基于排序的方法求一组数的中位数。
分析前面提到过，可以先对一组数排序，然后就可以很方便地找出这组数的中位数。目
前排序的算法很多，比较简单的有选择排序、插入排序以及冒泡排序。这里我们以简单的选择排
序为例。选择排序的基本思路是：从待排序列中找出值最大的元素，然后将该最大值元素跟待排
序列的第一个元素交换。一直重复上述过程，使待排序列越来越短，当待排序列只剩一个元素时
排序就完成了。我们同样可以使用两重循环来实现上述算法。外循环控制变量i代表in
为数组中待排序列的下标区间，i初值为每循环一次i加内层循环主要目标是在数组
in区间里找出一个最大值。代码给出了这个方法的实现。
ElementType MedianElementType Aint N
intijMaxPosition
ElementType TmpA
foriiNi
MaxPositioni
forjijNj 内循环找出最大值的下标MaxPosition·
ifAjAMaxPositionMaxPositionj
下面将最大值与待排序列的第一个元素A交换
TmpAAAAMaxPositionAMaxPositignTmpA
排序结束
数组中下标为N位置的元素就是序列中第N个元素·
return AN
代码 基于排序方法求中位数
第章 数据结构实现基础
更多的关于排序的算法将在第章中介绍。
函数与递归
函数是一个完成特定工作的独立程序模块。程序中一旦调用了某个函数，该函数就会完成
一些特定的工作，然后返回到调用它的地方。函数包括库函数和自定义函数两种。例如，scanf、
printf 等库函数由C语言系统提供定义，编程时只要直接调用即可。在程序设计中，往往根据模
块化程序设计的需要，需要用户自己定义函数，属于自定义函数。
函数定义的基本形式是：
函数类型 函数名形参表 函数首部
函数体 函数实现过程；
函数的定义包括函数首部和函数体两部分。其中，函数首部由函数类型、函数名和形参表组
成；函数体包括函数实现过程和 return语句return表达式；体现为一对大括号内的若干条
语句。
在函数首部，函数类型指函数返回值的类型，一般与return语句中表达式的类型一致；函数
名是一个合法的标识符；形参表中给出函数所有形参的名称和类型，它的格式为：
类型 形参类型 形参……类型n 形参n
形参表中各个形参之间用逗号分隔，每个形参前面的类型必须分别写明。函数的形参的数
量可以是n个，即根据具体情况，形参可以是个，也可以是多个，或者没有形参。
在函数体中，函数的实现过程是一些完成特定工作的语句，return语句中的表达式反映了函
数运算的结果，通过 return语句结束该函数的运行并将该结果回送给主调函数。return语句的作
用有两个：一是结束函数的运行；二是带着运算结果表达式的值返回主调函数。在函数定义
中也可以没有returm语句，此时函数执行时的最后一个语句的值作为函数的返回值。
return 语句只能返回一个值，如果函数产生了多个运算结果将无法通过 return直接全部返
回。如果函数要返回多个运算结果，一般有以下几种方法：①通过全局变量；②通过函数参数传
递变量地址，在函数中通过这个参数给变量赋值；③把准备返回的多个结果组成一个结构返回。
有些函数可以不返回任何值，仅仅是执行一个过程。这类函数的类型可以说明为 void其函
数体中的return语句后面的表达式可以省略。
注意：在函数定义时，若不说明函数类型即函数类型缺省该函数的类型被缺省定义
为int。
函数的调用
定义一个函数后，就可以在程序中调用这个函数。调用函数时，将实参传递给形参并执行函
数定义中所规定的程序过程，以实现相应的功能。
在C语言中，调用标准库函数时，只需要在程序的最前面用include命令包含相应的头文
流程控制基础
件；调用自定义函数时，程序中必须有与调用函数相对应的函数定义。
函数调用的一般形式为；
函数名实参表》
实参可以是常量、变量和表达式。
计算机在执行程序时，从主函数main开始执行，如果遇到某个函数调用，主函数被暂停执
行，转而执行相应的函数；该函数执行完后，将返回主函数，然后再从原先暂停的位置继续执行。
函数定义中的参数被称为形参，函数调用时的参数被称为实参。形参和实参必须一一对应，
要求两者数量相同、类型一致。在程序运行中，遇到函数调用时，将实参的值按依次传给形参，这
就是参数传递。
函数的形参必须是变量，用于接受实参传递过来的值，形参的使用方法和普通变量相同；而
实参可以是常量、变量或表达式，其作用是把常量、变量或表达式的值传递给形参。
按照C语言的规定，在参数传递过程中，将实参的值复制给形参。这种参数传递是单向的，
只允许实参把值复制给形参，而形参的值即使在函数中改变了，也不会反过来影响实参。
例设计一个函数Swap实现两个整数变量值的交换。
代码直接将待交换的两个整数传入函数Swap中。由于C语言的函数参数是值传递，所
以尽管函数Swap 中将形参X和Y的值进行了交换，但是main 函数中的X和Y的值始终没有改
变。程序输出结果为：
XY
include stdioh
void Swapint xint Y
错误的交换函数·
int tmp
tmpXXYYtmp
int main
int XY
SwapXY
printfXdYdXY
return
代码 无法实现变量值交换的Swap 函数
第章 数据结构实现基础
为了真正达到交换这两个变量的值，就需要将变量的地址作为函数参数，然后通过访问变量
地址来修改变量的值。代码可以输出正确结果：
XY
include stdioh
void Swapint Xint Y
正确的交换函数
int tmp
tmpXXYYtmp
int main
int XY
SwapXY
printfXdYdxY
return
代码 通过传递变量地址实现变量值交换
Swap 函数之所以能够实现main 函数中X和Y的数值交换，是因为Swap 函数的指针形参接
受了实参传送过来的X和Y的地址，并通过两个指针对换了main 函数中的X和Y的数值。
C语言要求函数先定义后调用，将主调函数放在被调函数的后面，就像变量先定义后使用一
样。如果主调函数放在自定义函数的前面，就需要在函数调用前，加上函数原型声明。如果不声
明，编译时会默认调用函数是int类型。
函数声明的目的主要是说明函数的类型和参数的情况，以保证程序编译时能判断对该函数
的调用是否正确并进行相应的编译处理。函数声明的一般格式为：
函数类型 函数名参数表
在设计函数时，注意掌握以下原则。
函数功能的设计原则：结合模块的独立性原则，函数的功能要单一，不要设计多用途的
函数，否则会降低模块的聚合度。
函数规模的设计原则：函数的规模要小，尽量控制在行代码以内，这样可以使得丽数
更易于维护。
函数接口的设计原则：结合模块的独立性原则，函数的按口包括函数的参数入口和
流程控制基础
返回值出口不要设计过于复杂的接口，合理选择、设置并控制参数的数量，尽量不要使用全
局变量否则会增加模块的耦合度。
递归函数
一个函数除了可以调用其他函数外，C语言还支持函数直接或间接调用自己。这种函数自
己调用自己的形式称为函数的递归调用，带有递归调用的函数也称为递归函数。
从递归函数的程序编写角度看，有两个关键点必须紧紧抓住。
递归出口：即递归的结束条件，到何时不再递归调用下去。
递归式子；当前函数结果与准备调用的函数结果之间的关系，如求阶乘函数
FactorialNN FactorialN。
递归程序设计是一个非常有用的工具，可以解决一些用其他方法很难解决的问题。但递归
程序设计的技巧性要求比较高，对于一个具体问题，要想归纳出递归式子有时是很困难的，并不
是每个问题都像求阶乘函数Factorial那样直截了当。
当函数调用自己时，每一次调用都会产生一个新的、同先前调用相独立的版本。因此递归调
用并不能减少空间消耗，相反大多数情况下采用递归操作会大大消耗内存；同样，递归也无法提
高程序运行速度。递归函数的主要优点是可以把算法写的比使用非递归函数时更清晰更简洁，
相对其他方法，递归能更加自然的反映问题的解决过程，而且在程序的理解和调试方面，递归也
更容易让人接受。
下面我们来看几个有关递归程序的例子。
例设计函数求N
利用递归函数求整数的阶乘是个很经典也很简单的问题。这个问题的递归函数设计相对直
接，如代码所示。
int Factorialint N
ifN
return
else
return N FactorialN
代码 阶乘函数的递归实现
图表示了调用Factorial求的过程。从Factorial到Factorial的各箭头表示递
归过程，而从Factorial到Factorial的箭头是从基础求解返回的过程和结果。
在上述递归过程中，N是递归函数Factorial的出口条件，即递归结束条件。
例汉诺塔Tower of Hanoi问题。
汉诺塔问题来自于一个古老的传说。传说印度的主神梵天做了一个汉诺塔，它是在一个黄
第章 数据结构实现基础
铜板上插根宝石针，其中一根针上从上到下按从小到大的顺序串上了个金片。梵天要求僧
侣们轮流把金片在根针之间移来移去，规定每次只能移动一片，且不许将大金片压在小金片
上，并说如果这片金片全部移至另一根针上时，世界就会在一声霹雳之中毁灭。
Factorial
·Factorial
Factorial
Factoriall
FactorialO
图 递归求解的过程
图a表示了有n个金片汉诺塔的初始状态，n个金片串在第一根针上。问题要求将金
片从第一根针上挪到第三根针上。
a初始状态 b中间状态
图 汉诺塔问题
即使金片的片数n不大，如果按要求一步步挪动起来，其过程也是十分繁琐的。但从递归的
角度考虑，问题将变得简单。我们先不要考虑小金片如何移动，而是看最下面的金片要完成从第
一根针起始位置到第三根针目标位置的移动所必须满足的状态。此时，一定会移成图
b所示的情况，即起始位置上只剩一个最大的金片，其余 n个移到第二根针过渡位置
上目标位置没有任何金片。这样n个金片移动问题变成了，n个金片从起始位置移到过渡
位置，然后将起始位置上剩下的一个金片移到目标位置。最大一个金片移好后，问题变成了n
个金片如何从第二个针被看作新的起始针移到目标位置的问题了。依次类推，直到完成整个
移动为止。
根据上述分析，我们可以用递归方法来求解汉诺塔问题也就是将n个金片的移动问题转换
为个n个金片的移动问题。首先需要考虑的是函数参数的设计。当然，金片个数肯定是一
个参数：金片移动涉及到起始位置和目标位置，所以这些位置也应该是参数。另外，在将n个金
片的移动问题转换为n个金片的移动问题时还需要一个过渡针，所以过渡针也需要作为参
数。这三类针我们可以用整数、来表示。因此，拟设计的递归函数Move应该由四个整型变
量作为参数，即：
流程控制基础
void Moveint nint startint goalint temp
其中，n代表金片个数，start、goal和 temp分别代表当前的起始针、目标针和过渡针。这样，
汉诺塔问题实际上就是求解：
Move将个金片从号针移到号针，号针为过渡针
按上述递归分析过程，这个问题可以转变为：
Move将个金片从号针移到号针，将号针为过渡针
printfMove disk from tower I to tower n
Move将个金片从号针移到号针，号针为过渡针
此时，问题已变成比原始问题少一个金片的汉诺塔移动问题了。照此递归地求解下去，当
n时，就不需要再递归了。代码给出了递归求解汉诺塔问题的函数。
void Moveint nint startint goalint temp
ifn
Movenatarttempgoal
printfMove disk d from d to dnn startgoal
Moven tempgoalstart
else当n时不需要做任何事
代码 汉诺塔问题的递归函数
为了加深对递归的理解，我们跟踪一下n时，函数的执行过程。
设金属片数为在主程序中用语句Move调用递归函数，程序的执行过程可用图
所示的递归树表示。在图中，函数Move用一个黑盒子表示，我们称之为树的结点，第一
次进入Move 函数的点称为树的根结点，在函数内部再次调用进入 Move的点称为子结点，反过
来引起子结点调用的函数点是父结点，它们之间边表示这种父子或调用和被调用关系。可以
看出，除了根结点外，每个结点都有父结点。
每次递归调用进入一个黑盒子表示的结点，在结点内执行程序可能的行为为：
当n时，执行函数中的第一个递归调用语句，递归层次加深。图中用有向实线表
示进入其子结点，并在相应的边的右侧用函数调用形式 Moveabcd标识出参数的具体值。
当n时，程序不执行任何语句，递归返回上一层。图中用有向虚线表示进入其
父结点。
每当递归返回，紧接着执行printf语句输出一次移动金片结果。图中用输出图形符
号列出输出结果，并在其旁边用带圈的数字标识出输出的顺序。
第章 数据结构实现基础
Move disk from I to Move
④Move disk from I to
①
②
Move 口
Move
Move disk from to
⑥
①
Move Move D Move
Move
■
Move Move I Move Move
Move
Move Move Move
I
①
①
① Move disk I from to
Move disk I from I to
j③
①
⑦
j①
Move disk I from to Move disk I from I to
图 Move的递归树
例用递归方法求集合的中位数。
在本章开头的基本统计问题中，有一个操作是求集合的中位数。这个问题可以建立在求集
合笫K大元素问题上，也就是当K等于集合大小一半时，第K大元素就是中位数。
在节中我们也给出求集合S中第K大数的基本算法思路，也就是；选取S中的第一个元
索e根据e将集合S分解为e和大于等于c的元素集合S、小于。的元素集合S然后通过判
别集合S的大小，将从S集合中找第K大数问题转换为在S或S中的查找问题。由于S或S
的集合规模都比S小，这样就将复杂问题转换为规模相对小的问题这也是递归函数设计的
基础。
流程控制基础
在我们确定好用递归方法解决上述问题时，还需要解决以下两个关键问题：
如何根据元素e将集合S分解为S和S两个集合一种简单的方法是，应用一个临时
数组，对集合S也存放在数组中的元素进行遍历，如果当前元素比e大或值相等，但不是e
则放到临时数组的一头，否则放到临时数组的另一头。这种方法思路比较简单且分解集合的时
间复杂性是n但需要一个额外的数组空间。而代码给出了一种保持时间复杂性是
On且不需要额外数组空间的集合分解方法：先从数组左边扫描，如果发现比e小的元素则暂
停；再从数组右边扫描，遇到大于等于e的元素则哲停。此时左右两个暂停点的元素是错位的，
把它们交换一下。然后从左右暂停点开始重复上述步骤，直到左右扫描在中间某处相会。此时
相会的位置就是基准e把两个集合分开的位置，把e换到这个位置上，S中的元素就被放在e的
左边，S中的元素就被放在e的右边。
如何设计递归函数的参数如果我们用数组S来存储集合，当然S需要作为参数，K也
是个参数；在递归过程中，我们将集合S分解为S和S两个集合，而这两个集合也是存放在数组
S中，所以我们需要用集合S在数组中的左右边界来表示当前处理的集合。
代码给出了求第K大数的递归函数。
void SwapElementType·xElementType Y
交换X和Y两个元素
ElementType tmp
tmpXXYYtmp
ElementType FindKthLargestElementType sint Kint Leftint Right
在SLeftSRight中找第K大元素
ElementType eSLeft简单取首元素为基准
int LLeftRRight
while将序列中比基准大的移到基准左边，小的移到右边
whileLeftRightesLeft Left
whileLeftRighteSRight Right
ifLeftRight
SwapSLeftSRight
else break
SwapS LeftSL 将基准换到两集合之间·
ifLeftLKLeftL代表了集合S的大小
return FindKthLargestSKLLeft 在集合S中找
else ifLeftLK 在集合S中找
第章 数据结构实现基础
return FindKthLargestSKLeftLLeftR
else
return e找到，返回
代码 求第K大数的递归函数
求集合S的中位数就可以简单调用代码中的函数实现，如代码所示。
ElementType MedianElementType sint N
return FindKthLargestsNN
代码 通过调用第K大数的函数求中位数
本 章 小 结
本章回顾了作为本课程重要基础的C语言程序设计的一些重点内容，包括数据存储、流程
控制、函数及递归等方面的基础知识。
C语言除提供标准数据类型外，还提供了数组、结构、指针等构造复杂数据类型的方法。数组
是同类数据在存储空间上的连续有序组织，是实现数据结构的重要存储手段。结构可以将不同类
型的数据组织在一起形成一个整体。结构与指针的结合是构成链表的基础。链表不仅在存储有序
序列方面具有动态、灵活的特点，而且也是实现更复杂数据结构比如树、图的重要方法。
程序设计语言的流程控制是算法实现的基本依赖。按照结构化程序设计的观点，任何程序
都可以将模块通过顺序、分支和循环这三种基本的控制结构组合来实现。一般程序设计语言都
提供了表达分支控制和循环控制的手段。程序设计语言还提供了描述程序独立模块的方法，即
函数。函数通过一系列语句的组合来完成某种特定的功能，并可以被一个或多个函数包括自
已多次调用。其中，自已直接或者间接调用自已的函数称为递归函数。递归是一项非常重要
的编程技巧，将在数据结构的后继内容中大量出现。递归函数设计时需要注意：递归的出口、每
次调用应该是更接近于解。另外，每次递归时，递归函数会占用一些资源如系统内存、系统堆
栈空间。当递归函数退出时，这些资源才会破释放。所以，当函数的递归层次过多时，就有可
能会用尽所有可用的资源。
通过本章学习，重点是要深入掌握链表和递归方面的内容，从而为后继内容的学习打下基础。
习题
请编写程序模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数
习题
种运算符的优先级相同，按从左到右的顺序计算。
请编写程序将一个大小为n的整数数组循环左移m位。如：循环左移三位后结果
是：。
请编写程序，输人整数n和a输出Saaaaaa…aa…an个a的结果。
请编写函数在递增的整数序列链表中插入一个新整数，并保持该序列的有序性。
请编写函数将两个链表表示的递增整数序列合并为一个递增的整数序列。请直接使用原序列中的
结点。
请编写一个递归函数计算下列式子：
fxnxxxx…xn
设有一个球从高度为h米的地方落下，碰到地面后又弹到高度为原来倍的位置，然后又落下，再
弹起，再落下……请编写递归和非递归函数，求初始高度为h的球下落后到基本停下来高度小于°米时在
空中所经过的路程总和。
请编写递归函数，输出…n的全排列n小于并观察n逐步增大时程序的运行时间。
请思考一下，是否可以设计一个递归过程，实现对n个整数的排序。可以考虑两种不同的递归过程：
将n个整数的排序问题转换为对n个整数排序问题的递归；将n个整数的排序问题转换为对两个
n个整数排序问题的递归。
第章
线性结构
引子
在数据的逻辑结构中，有种常见而且简单的结构是线性结构，即数据元素之间构成一个有序
的序列。下面我们先看一个例子。
例一元多项式及其运算。 一元多项式的标准表达式可以写为：fxaoax…axax°。与一元多项式相关的
主要运算是：多项式相加、相减、相乘等。如何在计算机中表示一元多项式并实现相关的运算
分析首先，我们考虑一下如何表示多项式的问题。可以看出，决定一个多项式的关键数
据是：多项式项数n、每一项的系数a当然也涉及相应指数i。如果能直接或间接地保存这些
数据，那就意味着在计算机里保存了一个一元多项式。我们来讨论种不同的方法。
方法采用顺序存储结构直接表示一元多项式。
用一个数组a存储多项式的相关数据：数组分量ai表示项x的系数a即用数组分量下
标对应相应项的指数，而数组分量值就是系数。数组中非零的分量个数就等于多项式的项数。
例如，xx可以用图中的数组表示。
下标
ai
…
图 多项式的数组直接表示法
这种表示方法，在一般情况下对实施多项式运算还是比较方便的。比如，要实现两个多项式
相加，只要把两个数组对应分量项相加就可以了，显然程序很容易编写。但它存在着重大的问
题，即在多项式比较稀疏的情况下，时间和空问效率都会比较差。比如表示x这样的多
项式，就必须采用一个大小至少为的数组，而在这个数组中绝大部分数据为只有两项
不为显然空间浪费很厉害。而要将之与多项式xx加在一起，则必须遍历个
数组元素虽然这两个多项式一共只有个非零项，可见时间效率也很低。
因此，在多项式比较稀疏的情况下，最好只存储非零项的信息，其他项不用为之浪费空间。
指多项式有比较高的阶，但只有很少非零项。
引 子
于是有了第二种表示方案。
方法采用顺序存储结构表示多项式的非零项。
每个非零项ax涉及两个信息：指数i和系数a。因此，可以将一个多项式看成是一个ai
二元组的集合。为了以后多项式运算方便，我们可以按照指数下降的顺序组织这个二元组。所
以，可以把多项式看成是ai二元组的有序序列anan…a。。
我们可以用一个结构数组来存储以上系数非零项二元组的有序序列。数组的大小可以根据
非零项的最多个数来确定，而不是根据多项式的阶数来确定。显然，这样的表示方法，对于稀疏
多项式的情况能节省大量空问。但是如果多项式不是很稀疏，则空间节省的优势就没有了，甚至
需要的空间更多。
图给出了用结构数组表示两个给定多项式Pxxxx和Pxxx
x°的例子。
数组下标i
…
数组下标
…
系数 系数
指数 指数
aPxxxx bPxx°xx
图 多项式非零项的结构数组表示
当多项式的存储采用方法时，相应的运算实现如多项式相加显然就比方法更加复杂
一些。
例如，实现两个多项式相加，可采用以下策略：分别从头开始查看两个多项式中的每一项，如
果当前两项的指数不一样，那就将指数大的那一项“拷贝”到结果多项式中；如果它们的指数一
样而且对应系数和不为那么就在结果多项式中增加一个系数为它们之和的新项。
对于图中的例子，这两个多项式的相加过程基本是这样：
比较和将移到结果多项式；
继续比较和将移到结果多项式；
比较和不为将新的一项增加到结果多项式；
比较和将移到结果多项式；
比较和将移到结果多项式；
将直接移到结果多项式。最后得到的结果多项式是：
即多项式：
Pxx°x xxx
用数组表示的一个问题是灵活性不够。由于事先无法知道多项式可能的非零项数，因此我
们只能根据可能的最大值事先确定数组大小；如果实际非零项数比较小时，空间的浪费同样严
重。更进一步的解决方法是利用链表存储一维的有序序列，相比于数组表示，更具有灵活性。
第章 线 性 结 构
方法采用链表结构来存储多项式的非零项。
用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数和指数两个数据
域以及一个指针域，其结点结构可以表示为：
对应的数据结构定义为：
typedef struct PolyNodePtrToPolyNode
typedef struct PolyNode
int Coef
int Expon
PtrToPolyNode Next
typedef PtrToPolyNode Polynomial
例如，前面提到的两个多项式Pxxxx和Pxxxx的链表
存储形式如图所示。
PI
P
图 多项式非零项的链表表示
如果要实现链表表示的两个多项式相加，采用的方法与结构数组表示的方法非常相似，具体
实现见本章最后一节。
从前面例子中，读者应该能感受到，数据结构的操作与数据结构的存储方式是密切相关的。
不同的数据存储方式，相应的操作实现方法是不一样的。比如，如果用数组直接存储，那么多项
式的加法运算通过简单的数组相加就可以实现，而如果采用链表来记录非零项那么多项式的相
加运算就要复杂得多。这两种方式比较起来，在多项式非零项相对较少的情况下，前者实现简
单，但时间和存储空问浪费大；后者实现起来复杂，但时间和空间效率较高。所以，数据结构的设
计往往需要在算法可理解性与时间、空间效率之间做出折中，针对具体问题选择合适的数据结构
及设计相应的算法。
例前面我们分析了一元多项式的表示，更进一步地，二元多项式该如何表示比如，
给定二元多项式；xyxxyxyx。
分析可以拓展一元多项式的表示方法来表示二元多项式，即我们可以把二元多项式按照
一元多项式方法来组织。比如，可以将上述二元多项式看成关于x的一元多项式：yx
yyxx。其中，一元多项式中的常量系数在这里就成了关于y的一元多项式。同样，我
们可以采用链表结点表示多项式的各个非零项，原来结点中的表示系数的域就成了指向关于y
的一元多项式链表的指针域。所以，上述二元多项式可以用链表表示如图所示。
Coef Expon Next
NULL
NULL
线性表的定义与实现
P
图 二元多项式非零项的链表表示
上述二元多项式是按照x的指数组织的一个有序序列。在该序列中，既包含纯粹的“系
数，指数项，也有包含一元多项式当然也是个有序序列的项。类似这种可能包含子序列的
有序序列就是一种广义表，本章第节中将有进一步介绍。
在前面关于多项式的例子中，我们将多项式问题抽象为由系数和指数所构成的二元组有序
序列的存储与操作问题。有序序列的存储与操作问题，是一类比较有共性的问题，如：银行等候
队列的管理、班级学生的管理、计算机中空闲内存的管理等。
我们可以研究更一般的有序的对象序列的组织与管理方法，其基本操作包括：插人元素、删
除元素等，这类问题就是我们本章要研究的线性表，也是一类典型的数据结构。
本章将介绍线性表的抽象定义，并分别讨论基于顺序存储和链式存储的线性表的实现方法。
同时将介绍两种典型且应用广泛的线性表：堆栈和队列。线性表的基本操作是插入和删除，堆栈
是插人和删除操作只发生在同一端的线性表，而队列的插入和删除操作则分别发生在有序序列
的两端，即一端只做插入，另一端只做删除。
线性表的定义与实现
线性表的定义
线性表Linear List是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素
的个数称为线性表的长度；当一个线性表中没有元素长度为时，称为空表；表的起始位置称
表头，表的结束位置称表尾。
线性表的抽象数据类型描述为：
类型名称：线性表List
数据对象集：线性表是nn≥个元素构成的有序序列aa…a。其中a是表的第一
个元素表头a。是表的最后一个元素表尾a称为a的直接后继，a为a的直接前驱；直
接前驱和直接后继反映了元素之间一对一的邻接逻辑关系。
操作集：对于一个具体的线性表L∈List一个表示位序的整数i一个元素X∈ElementType
NULL
NULL
NULL
第章 线性结 构
线性表的基本操作主要有：
List MakeEmpty初始化一个新的空线性表；
ElementType FindKthList Lint i根据指定的位序i返回L中相应元素a
Position FindList LElementType X已知X返回线性表L中与X相同的第一个元素
的位置；若不存在则返回错误信息；
bool InsertList LElementType Xint i在L的指定位序i前插入一个新元素X成功则
返回true否则返回 false
bool DeleteList Lint i从L中删除指定位序i的元素；成功则返回 true否则返回 false
int LengthList L返回线性表L的长度。
线性表的顺序存储实现
线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素。在
程序设计语言中，一维数组在内存中占用的存储空间就是一组连续的存储区域，因此，用一维数
组来表示顺序存储的数据区域是再合适不过的。
考虑到线性表的运算有插入、删除等，即表的长度是动态可变的，因此，数组的容量需设计得足
够大。假设用DataMAXSIZE来表示，其中MAXSIZE是一个根据实际问题定义的足够大的整数，
线性表中的数据从Data开始依次顺序存放。由于当前线性表中的实际元素个数可能未达到
MAXSIZE多个，因此需用一个变量Last 记录当前线性表中最后一个元素在数组中的位置，即Last
起一个指针实际是数组下标的作用，始终指向线性表中最后一个元素。表空时Last。
这样表示的顺序表如图所示。当前表长为Last数据元素aa…a。分别存放在
Data到Data Last中。
i
…
…
n
…
a a
…
a a
…
a
… MAXSIZE
Data
Last
图 线性表的顺序存储示意
为了体现数据组织的整体性，通常将数组 Data和变量Last 封装成一个结构作为顺序表的类型：
typedef int Position
这里的位置就是数组的整型下标，从开始。前面提到的位序是指第几个，从开始
typedef struct LNodePurToLNode
struct LNode
ElementType DataMAXSIZE
Position Last
线性表的定义与实现
typedef PtrToLNode List
由于LNode是一个包含数组的结构，当我们实现各种针对顺序表的操作时，直接将该结构
作为函数参数传递显然不是个好方法，使用结构指针传递效率更高，所以我们把List 定义为结构
指针。这样，我们可以利用List 定义线性表L
List L
通过L我们可以访问相应线性表的内容。比如下标为i的元素可以通过LDatai访问，
线性表的长度可以通过LLast得到。
下面将介绍在上述存储方式基础上相应主要操作的实现。
初始化
顺序表的初始化即构造一个空表。首先动态分配表结构所需要的存储空间，然后将表中
Last指针置为表示表中没有数据元素。具体实现如代码所示。
List MakeEmpty
I List L
LListmallocsizeofstruct LNode
LLast
return L
代码 顺序表的初始化
查找
顺序存储的线性表中，查找主要是指在线性表中查找与给定值X相等的数据元素。由于线性
表的元素都存储在数组 Data中，所以这个查找过程实际上就是在数组里的顺序查找：从第一个元
素a起依次和X比较，直到找到一个与X相等的数据元素，返回它在顺序表中的存储下标；或者查
遍整个表都没有找到与X相等的元素，则返回错误信息ERROR。顺序表的查找如代码所示。
define ERROR将错误信息 ERROR的值定义为任一负数都可以
Position FindList LElementType x
Position i
whileiLLast LDataiX
i
ifiLLast return ERROR如果没找到，返回错误信息
else return i找到后返回的是存储位置
代码 顺序表的查找
第章 线性 结 构
在Find 函数中的主要运算是比较。显然比较的次数与X在表中的位置有关，也与表长有
关。当a恰好等于X时，比较一次成功；当a。等于X时比较n次成功。查找成功的平均比较次
数为…nnn即平均时间复杂度为n。
插入
顺序表的插入是指在表的第i≤i≤n个位序上插入一个值为X的新元素也可以
理解为在第i个元素之前插人新元素插入后使原长度为n的数组元素系列aa…
aaa…a成为长度为n的序列aa…aXaa体…a。当插入位
序i为时，代表插入到序列最前端；为n时，代表插入到序列最后。
顺序表的插入如代码所示，完成这一运算是通过以下步骤进行的：
将aa顺序向后移动移动次序是从a。到a为新元素让出位置；
将X置入空出的第i个位序；
修改Last 指针相当于修改表长使之仍指向最后一个元素。
bool InsertList LElementType xint i
I在L的指定位序i前插入一个新元素x位序元素的数组位置下标是i
Position j
ifLLastMAXSIZEI
表空间已满，不能插人
printf表满“
return false
ifiiLLastI
检查插入位序的合法性：是否在n。n为当前元素个数，即Last
printf·位序不合法
return falce
forjLLastjiLast 指向序列最后元素a·
LDataLDatax将位序及以后的元素顺序向后移动·
LDatax市新元素插入第位序，其数组下标为
LLast Laot仍指向最后元素·
return true
代码 顺序表的插人
本函数中注意以下问题：
顺序表中数据区域有MAXSIZE 个存储单元，所以在向顺序表中做插入时先检查表空间
线性表的定义与实现
是否满了，在表满的情况下不能再做插入，否则产生溢出错误。
要检验插人位序的合法性，这里i是指元素序号而非数组中的下标，有效范围是≤i≤
n其中n为原表长。所以，代码中i检查的是到LLast这个范围LLast 值是
n当i为n时代表插入到现有表的表尾。
注意数据的移动次序和方向。
顺序表上的插入运算，时间主要消耗在数据的移动上。在第；个位序上插人X从a到a。
都要向后移动一个位置，共需移动ni个元素，而的取值范围为i≤n即有n个位置
Dai。 可插人。设在第i个位置上做插人的概率为p则平均移动数据元素的次数为
Daiai。 在等概率情况下，即pn时，平均移动次数则为
这说明：在顺序表上做插入操作平均需移动表中一半的数据元素，显然时间复杂度为
n。
删除
顺序表的删除运算是指将表中位序为i≤i≤n的元素从线性表中去掉，删除后使原长
度为n的数组元素序列aa…aaa…a成为长度为 n的序列aa…
aa…a。
顺序表的删除如代码所示，完成这一运算的步骤如下：
将aa。顺序向前移动，a元素被a覆盖；
修改Last 指针相当于修改表长使之仍指向最后一个元素。
bool DeleteListLint i
从L中删除指定位序i的元素，该元素数组下标为i
Positionj
ifi iLLast检查空表及删除位序的合法性
printf·位序d不存在元素i
return false
forjijLLastj
LDatajLDataj将位序i及以后的元素顺序向前移动·
LLastLast仍指向最后元素
return true
代码 顺序表的删除
第章 线 性 结 构
本函数中注意以下问题：
删除位序为i的元素，i的取值必须为≤i≤n否则该元素不存在，因此，要检查删除位
置的合法性。代码中的i检查的是到LLast这个范围的值。
当表空时不能做删除，因表空时LLast的值为条件iliLLast也包括
了对表空的检查。
删除a之后，该数据已不存在。如果需要用，可先取出a再做删除。
与插入运算相同，其时间主要消耗在了移动表中元素上，删除位序为i的元素时，其后面
的元素aa。都要向前移动一个位置，共移动了ni个元素，所以平均移动数据元素的次数
pni—ni 为∑pni。在等概率情况下，即pn时，平均移动次数则为 “。
这说明顺序表上作删除运算时平均需要移动表中一半的元素，显然该算法的时间复杂度为
n。
线性表的链式存储实现
由于顺序表的存储特点是用物理上的相邻实现了逻辑上的相邻，它要求用连续的存储单元
顺序存储线性表中各元素，因此，对顺序表插入、删除时需要通过移动数据元素来实现，影响了运
行效率。本节介绍线性表链式存储结构，它不需要用地址连续的存储单元来实现，因为它不要求
逻辑上相邻的两个数据元素物理上也相邻，它是通过“链”建立起数据元素之间的逻辑关系，因
此对线性表的插入、删除不需要移动数据元素，只需要修改“链”。
用链表结构可以克服数组表示线性表的缺陷。图为单向链表的图示表示形式，它有
n个数据单元，每个数据单元由数据域和链接域两部分组成。数据域用来存放数值，图中用
aa…a。表示。链接域是线性表数据单元的结构指针，用一带箭头的线段表示，线性表的
顺序是用各结点上指针构成的指针链实现的。
head a a NULL
图 线性表的链表表示
为了访问链表，必须先找到链表的第一个数据单元，因此实际应用中常用一个称为“表头
Header”的指针指向链表的第一个单元，并用它表示一个具体的链表。
在第章中我们已经定义过单链表的结构，线性表的链式存储其实就是单链表结构，这里为
了跟顺序存储结构的接口样式保持一致，我们重新将结点的结构定义如下：
typedef struct LNodePuToLNode
struct LNode
线性表的定义与实现
ElementType Data
PtrToLNode Next
I
typedef PtrToLNode Position这里的位置是结点的地址
typedef PtrToLNode List
同样也可以用List定义具体的表头结点指针，该指针就代表了一个链式表：
List L
注意到，无论是用顺序存储还是链式存储，我们都用一致的接口例如都命名为LNode、List、
Position等定义线性表，因为这两种具体的存储方式都是对同一个抽象概念的实现。
求表长
在顺序存储表示的线性表中求表长是容易的事，直接返回Last值就可以了。但在链式存
储表示中，需要将链表从头到尾遍历一遍：设一个移动指针p和计数器cnt初始化后，p从表的
第一个结点开始逐步往后移，同时计数器 cnt加。当后面不再有结点时，cnt的值就是结点个
数，即表长。具体实现如代码所示，函数的时间复杂度为n。
int LengthList L
Position p
int cnt初始化计数器·
pLp指向表的第一个结点
whilep
ppNext
cnt当前p指向的是第cnt个结点
return cnt
代码 求链式表的表长
查找
在线性表抽象类型说明中，我们提到线性表的查找有两种，即按序号查找FindKth和按值
查找Find两种。
按序号查找FindKth。
对于顺序存储，按序号查找是很直接的事情，要得到第K个元素的值，直接取LDataK
就可以了。但对于链式存储则需要采用跟求表长类似的思路：从链表的第一个元素结点起，判断
当前结点是否是第K个；若是，则返回该结点的值，否则继续后一个，直到表结束为止。如果没
有第K个结点则返回错误信息。函数实现如代码所示。
第章 线 性 结 构
define ERROR一般定义为表中元素不可能取到的值
ElementType FindKthList Lint K
根据指定的位序K返回工中相应元素·
Position p
int cnt位序从开始
pLp指向L的第个结点么
whilep k cntK
ppNext
cnt
ifcntK p
return pData找到第K个
else
return ERROR否则返回错误信息
代码 链式表的按序号查找
按值查找，即定位Find。
按值查找的基本方法也是从头到尾遍历，直到找到为止：从链表的第一个元素结点起，判断
当前结点其值是否等于X若是，返回该结点的位置，否则继续后一个，直到表结束为止。找不到
时返回错误信息。函数实现如代码所示。
define ERROR NULL用空地址表示错误·
Position FindListLElementType x
Position pLp指向L的第个结点
whilep pDataX
DpNext
下语句可以用 return p替换
ifp
return p
else
return ERROR
代码 链式表的按值查找
线性表的定义与实现
上述两种查找算法的时间复杂度均为n。
插入
线性表的插入是在指定位序i≤i≤n前插入一个新元素X。当插入位序i为时，
代表插入到链表的头；i为n时，代表插入到链表最后。其基本思路是：如果i不为则找
到位序为i的结点pre若存在，则申请一个新结点并在数据域填上相应值X然后将新结点
插入到结点pre之后，返回结果链表；如果不存在则返回错误信息。函数实现如代码
所示。
Hderine ERROR NULL用空地址表示错误。
Liat InsertListLElementType xint i
Position tmppre
tmpPositionmallocsizeofstruct LNode申请、填装结点·
tmpDatax
ifi新结点插入在表头
tmpNextL
return tmp返回新表头指针
elsel
查找位序为i的结点
int cnt位序从开始
preL pre指向L的第个结点
whilepre cnti
prepreNext
cnt
ifpreNULL cntiI所找结点不在L中
printf插入位置参数错误n
freetmp
return ERROR
else I找到了待插结点的前一个结点pre·
s插入新结点，并且返回表头L
tmpNextpreNext
preNexttmp
return L
第章 线性 结 构
代码 链式表的插人
注意：在上述函数中表头指针L的值可能会发生变化——当插人发生在表头结点时，L需要指
向新的表头结点可利用函数返回值对L重新赋值其他情况下L值不变。所以，在本函数中我
们将L既作为函数参数，同时也作为函数返回值，保证新的L值能够被带回来。但是因为当插
入操作不成功时，返回的指针为NULL所以我们不能直接用“LInsertLXi”来调用函数，而
是必须用一个临时指针接收插入函数的返回值，根据该指针的值判断应该进行什么样的处理。
但是，这样插入函数的接口就跟顺序表的插入函数见代码不一致了，也不符合第
节中线性表的定义。那么如何与定义的风格保持一致，避免将表头插入作为一种特殊情
况处理呢一种解决的方法是为链表增加一个空的“头结点”真正的元素链接在这个空结点之
后。这样做的好处是，无论在哪里插入或者删除，L的值一直指向固定的空结点，不会改变。代
码给出了带头结点的链式表的插人函数，插入算法的时间复杂度为n。
bool InsertList LElementType xint i
这里默认L有头结点·
Position tmp pre
int cnt
查找位序为i的结点·
preLpre指向表头·
whilepre cnti
prepreNext
cnt
ifproNULL lcnt所找结点不在工中·
printr“桶人位置参数错误n”
returnfalae
else找到了待插结点的前一个结点pre若为pre就指向表头
插人新结点
tmpPositionmallocolzeofstruct LNode人申请、填装结点
tmpDataX
tmpNextpreNext
proNexttmp
线性表的定义与实现
return true
代码 带头结点的链式表的插入
删除
在单向链表中删除指定位序i的元素，首先需要找到被删除结点的前一个元素，然后再删除
结点并释放空间。代码是带头结点的链式表的删除。函数的时间复杂度为n。
bool DeleteLlst Lint i
·这里默认L有头结点·
Position tmppre
int cnt
查找位序为i的结点
preLpre指向表头
whilepre cnti
prepreNext
cnt
ifpreNULL Ⅱcntil preNextNULL
所找结点或位序为i的结点不在L中
printf插入位置参数错误n
return false
else 找到了待删结点的前一个结点pre
将结点删除·
tmppreNext
preNexttmpNext
freetmp
return true
代码 带头结点的链式表的删除
从链式线性表的插人、删除的程序实现中可以看出：
在单链表上插入、删除一个结点，必须知道其前驱结点。
单链表不具有按序号随机访问的特点，只能从头指针开始一个个顺序进行。
第章 线性 结 构
前面我们讨论的主要是以单向链表的形式存储线性表，这样的结构可以使每个结点找到
其后继结点很容易，但要找到其前驱结点，必须从链表头开始查找。如果我们需要前后查找
都很容易，则可以采用双向链表表示，但它占用的空间也相对大些，因为每个结点都需要两个
指针域。
广义表与多重链表
广义表
首先我们来看一个例子，就是如何表示一个单位的人员情况。一种简单的表示方法是用一
个线性表来表示，其先后顺序按照进单位的时间顺序排列：
张三，李四，王五，钱六，孙七，……
但如果这些人又分布在同一单位的三个不同部门，比如办公室、生产部、销售部，我们又希望
表示每个人与哪些人是一个部门的，那么可以用三个有序序列的子表构成的线性表来表示：
张三，……李四；孙七，……王五，钱六，……
如果想突出表示这个单位的负责人是谁，可将负责人作为表的第一元素：
丁一，张三，……李四，孙七，……王五，钱六，……
上述这类表就是一种广义表Generalized List。广义表是线性表的推广。广义表与线性
表一样，也是n个元素组成的有序序列。其不同点在于，对于线性表而言，n个元素都是基本
的单元素；而在广义表中，这些元素不仅可以是单元素也可以是另一个广义表。广义表在人
工智能、文本处理等领域有广泛的应用。例如，人工智能领域中的表处理语言LISP的实现就
是将广义表作为基本的数据结构。广义表不仅跟线性表一样可以表达简单的线性顺序关系，
而且可以表达更复杂的非线性多元关系。比如，以后我们会讲到的树，就可以用广义表的方
式来表示。
广义表一般记为：GListaa…aaa…a其中，a可以是单元素，也可以是广
义表。
由于广义表中的元素可以有不同的结构单元素或者广义表因此不适合采用顺序存储方
式表示，通常采用链式存储结构，也就是用由结点组成的链表来表示广义表，结点对应每个元素；
如果该元素还是一个广义表，则通过该结点引申出另一个链表。
广义表中的结点可能有两种情况：
单元素，需要有一个域来存储该单元素的值；
广义表，需要有一个域来指向另一个链表。对于每个结点来说，上述两个域只可能需要
其中的一种，所以我们可以利用C语言中的共用体Union来实现这两个域的复用。
这样广义表的数据结构可以定义如下：
typedef struct GNode sPrToGNode
typedef PtrToGNode GList
struct GNode f
线性表的定义与实现
int Tag标志域：表示该结点是单元素；表示该结点是广义表
union
子表指针域Sublist与单元素数据域Data复用，即共用存储空间
ElementType Data
CList Sublist
URegion
PurTCNode Next指向后继结点
图a表示上述结点结构，图b表示了前面提到的单位员工情况的链表表示
方式。
Tag Data Next Sublist
aGNode的结点结构
丁一
张三
I
…
李四
b按部门组织的单位员工广义表
图 广义表结构
多重链表
在图的例子中，广义表采用链表存储的方式实现，其中代表子表的元素结点如指向
“张三”以及指向“李四”、“王五”的结点不仅是这个广义链表中的一个结点，而且还是它所
代表的子表的起点。像这种存在结点属于多个链的链表叫“多重链表”。一般来说，多重链表中
每个结点的指针域会有多个，如前面的例子包含了Next和Sublist 两个指针域；但包含两个指针
域的链表并不一定是多重链表，比如在双向链表中每个结点都包含了向前和向后的两个指针域，
但由于每个结点还是都属于同一个链表，所以双向链表尽管结点有多个指针域，但不是多重
链表。
多重链表在数据结构实现中有广泛的用途，基本上如树、图这样相对复杂的数据结构都可以
采用多重链表的方式实现存储。
下面，我们以稀疏矩阵的表示为例，来进一步说明多重链表的实现方式。
王五 钱六
NULL
孙七
第章 线 性 结 构
例 矩阵最直观的表示方法是用二维数组，但二维数组表示有两个缺陷：一是数
组的大小需要事先确定，另一个是当矩阵包含许多元素时，要存储这些“意义不大”的
元素，将造成大量的存储空间浪费。例如，图a和b即为两个元素占多数的矩阵
A和B。对于A和B这样的稀疏矩阵最好是只存储非元素。如何用多重链表方式实现
存储
住湘
aPxxxx bPxxxx
图 稀疏矩阵
分析我们可以采用一种典型的多重链表——十字链表来存储稀疏矩阵。链表中用
于存放矩阵非元素的每个结点有两个指针域，一个是行指针或称为向右指针Right另
一个是列指针或称为向下指针Down结点的数据域存放元素的行坐标Row、列坐标Col和
数值Value。
对应每个行链表和列链表都有一个表头结点，在这里我们将行列两种表头结点合并成一
个，即第i行的表头结点也是第i列的表头结点Head。各行链表和列链表均是一个带头结点
的单向循环链表，以相应的表头结点 Head为头结点，通过Right或 Down域用循环链表将各
行或列的结点连接起来。而且各表头结点Head本身也用链接域Next链起来，构成一个带
头结点的循环链表，该头结点作为整个矩阵结构的入口。由这三种循环链表实现了矩阵的多
重链表表示。
在稀疏矩阵的十字链表实现中，存在头结点和非元素结点两种不同结构的结点。我们同
样也可以考虑用union来融合不同类型的结点。为了区分头结点和非元素结点，可以使用一
个标识域Tag头结点的标识值为Head矩阵非元素结点的标识值为Term。图a是union
后的结点总体结构，图b给出了两种结点的组成示意图。
Tag
Down URegion Right
结点的总体结构
·指大部分元素为零的炬阵。
Term
Down
Row Col
Right
Value
b矩阵非元系结点
图 稀疏矩阵多重链表结点结构
Head
Down Next Right
C头结点
线性表的定义与实现
稀疏矩阵的数据结构可定义为：
typedef enumHeadTermNodeTag
struct TermNode 非零元素结点
int RowCol
ElementType Value
I
typedef struct MNodePtrToMNode
struct MNode 矩阵结点定义
PtrToMNode DownRight
NodeTag Tag
union Head对应Next指针；Term 对应非零元素结点
PtrToMNode Next
struct TermNode Term
URegion
I
typedef PtrToMNode Matrix稀疏矩阵类型定义
Matrix HeadNode MAXSIZE
MAXSIZE 是矩阵最大规模，即行数、列数的最大值
HeadNode是为了能快速指向各行或列链表头结点的指针数组
上述定义中用结点标识Tag和一个共用体URegion将两种结点统
一在一起定义。对于某一个具体结点，当它是头结点时，其结点标识域
Tag赋值为Head相应的共用体URegion为结点指针 Next否则是一个
非元素结点，结点标识域赋值为Term相应的共用体URegion取元素
项Term。 微视频
图为图a中矩阵A的多重链表表示形式。头结点Head的
个数为矩阵行列数的较大者，这里为。需要一提的是，头结点链表的头结
稀疏矩阵的
多 重 链 表
表示
点图中A所指结点它指向并代表了一个具体的稀疏矩阵，而且它
的结构与非元素结点是一样的，但它的Row、Col和Value域的值分别为矩阵的行数、列数和非
元素总个数。
为了表示清晰起见，图中画出了两组头结点，用水平排列的头结点表示列链表，它们的
Down域指向每个列链表的第一个元素结点；而垂直排列的头结点表示行链表，它们的Right 域
指向每个行链表的第一个元素结点。其实，水平和垂直的两组头结点是同一组头结点，它们的
Down域和Right域分别链接列链表和行链表，Next域则链接头结点本身。
第章 线性 结 构
Term
A s
Head
Head
Head
Head
Head
Head Head Head Head Head
Term Term
Term
Term
Term
Term Term
图 图a中矩阵A的多重链表十字链表表示
堆栈
堆栈的定义
表达式求值是程序设计语言编译中的一个基本问题，即编译程序要将源程序中描述的表达
式转换为正确的机器指令序列或直接求出常量表达式的值。要实现表达式求值，首先需要正确
理解一个表达式主要是运算的先后顺序。
例对于算术表达式来说，其基本规则是；先乘除，后加减；先括号内，再括号外；相同
优先级情况下从左到右。比如，就是一个算术表达式，它的正确理解应该是：
。可以看到这类表达式主要由两类对象构成的，即运算
数如、、等和运算符号如、一、、等。不同运算符号优先级是不一样的，而且运算符号
堆栈
均位于两个运算数中间。那么计算机编译程序如何才能自动地理解这样的表达式
分析我们先来分析一类仅由两种运算符号和三个运算数构成的相对简单的算术表达式，
比如或其基本形式是aoPaoPa其中a为运算数、op为运算符号。
当计算机编译程序分析这样的表达式时，一般就是从左到右扫描。当扫描了aopa找到
两个运算数一个运算符号后，并没法做出是否马上进行运算的决定。因为还需要看op的优先
级是否比op高。所以，编译程序从左往右扫描时，需要根据前后运算优先级的情况决定：先保
留当前数据和运算符号，还是马上进行计算。比如，对于当扫描了后还不能做出计
算的决定，因为后面“·的优先级比“”高，所以必须先将、以及“”保留起来，等到后
面合适机会时再将这些数据和运算符号拿来运算。所以，需要有一种数据结构能够很好地实现
对等待运算或数据的组织。
为了更容易理解表达式的求值方法，我们分析一下更简单的一种表达式：后缀表达式。平常
我们经常使用的表达式是中缀表达式，即运算符号位于两个运算数之间的表达式。而在后缀表
达式中，运算符号位于两个运算数之后。比如，前面提到常量表达式的后缀形式就
是：。还有一种表达式形式叫前缀表达式，运算符号位于两个运算数之前。比
如，的前缀形式就是：。
可见，后缀表达式运算数出现的顺序与相应中缀表达式一样，但运算符
号出现在不同的位置。
后缀表达式相对比中缀表达式的求值要容易得多。我们先来看一下，
后缀表达式如何求解。
微视频 同样，我们还是从左到右扫描这个表达式，求解过程如下。 后缀表达式 遇见运算数时均不做计算，同时记住这个序列。 的求解过程
当遇见运算符号“”时，把最近遇到的两个数和从序列中取
出作运算，并把结果放到刚才那个序列的后面，即当前序列为：。
当遇见运算符号“”时，把序列的最后两个数和取出作运算，并把结果放到当前
序列的后面，因而当前序列为：。
遇见时均不做计算，把这两个数放到当前序列的后面，因而当前序列。
当遇见运算符号“”时，把当前序列的最后两个数和取出作运算，并把结果放
到当前序列的后面，因而当前序列为：。
当遇见运算符号“”时，把当前序列的最后两个数和取出作运算，并把结果放
到当前序列的后面，因而当前序列为：。
当输入中不再有符号时，当前序列中的值就是表达式的结果值。
大家可以看到，上述方法很简单也很巧妙，关键问题是需要管理一个序列，对该序列的主要
操作是在序列的末尾插入元素和删除取出元素。有这类操作要求的序列我们称之为“堆栈”。
堆栈Stack可以认为是具有一定约束的线性表，插入和删除操作都作用在一个称为栈顶
Top的端点位置。其实，我们日常生活中也可以看到堆栈的例子，比如，我们厨房中叠放的盘
第章 线性 结 构
子，使用盘子删除操作时我们是从顶端拿走盘子，用完放回插入操作时也是放到顶端。
正是堆栈所具有的这种特性，通常把数据插入称为压入栈Push而数据删除可看作从堆
栈中取出数据，叫做弹出栈Pop。也正是由于这一特性，最后入栈的数据将被最先弹出，所以
堆栈也被称为后入先出Last In First OutLIFO表。
堆栈的抽象数据类型定义为：
类型名称：堆栈Stack。
数据对象集：一个有个或多个元素的有穷线性表。
操作集：对于一个具体的长度为正整数MaxSize的堆栈SeStack记堆栈中的任一元素X∈
ElementType堆栈的基本操作主要有：
Stack CreateStackint MaxSize生成空堆栈，其最大长度为MaxSize
bool IsFullStack S判断堆栈S是否已满。若S中元素个数等于MaxSize时返回 true
否则返回false
bool PushStack SElementType X将元素X压入堆栈。若堆栈已满，返回 false否则
将数据元素X插入到堆栈S栈顶处并返回true
bool IsEmptyStack S判断堆栈S是否为空，若是返回 true否则返回false。
ElementType PopStack S删除并返回栈顶元素。若堆栈为空，返回错误信息；否则将
栈顶数据元素从堆栈中删除并返回。
图表示了堆栈的数据存储及其操作。为了形象起见，我们将数据表示为带字符标志的
小球，堆栈用带底的小筒表示。图a表示字符ABCD的压栈过程，图b是栈内元素
依次弹出栈的过程，Top指向当前操作的元素称为栈顶元素。
A B D
C
Top
Top A
Top B
A
Top D
A
a宇符ABCD的压找过程
D O D
Top
○回 Top
A
O
A
Top
A
b找内元素依次弹出栈的过程
图 堆栈的出入栈操作过程
D
D
A
O
①
A
Top
Top
A
Top
堆栈
例如果将ABCD四个字符按顺序压入堆栈，是不是ABCD的所有排列都可能是出栈
的序列可以产生CABD这样的序列吗
分析我们先来看一下简单的情况。
当只有一个字符出入栈时，显然只有一种可能，即A人栈也只有A出栈。
当有两个字符AB出入栈时，如果进栈顺序为AB那么出栈的系列AB、BA都有可能，
即可以A进栈、A出栈、B进栈、B出栈，产生输出序列AB也可以A进栈、B进栈、B出栈、A出
栈，产生输出序列BA。这两个可能的序列也是正好是两个字符的全排列。
如果有三个字符ABC出入栈时，全排列有种可能，但其中的CAB是没法生成的。
因为，先输出C需要C进栈再出栈，而要求按照ABC这样的顺序进栈，所以C出栈时AB必然
还在栈里，而且A还压在B下面。因此，CAB的序列是没法生成的，而其他种排列都可以
生成。
如果有四个字符ABCD出入栈时，同样不是所有排列都有可能是出栈的序列，象CABD
这样的序列是产生不了的。ABCD的全排列有种可能，那么这样四个字符出栈的所有可
能序列有几种这是一个很有趣的计数问题，读者可以在已知n的出栈序列个数的基础
上推算出n时的序列个数。
堆栈的实现
由于栈是线性表，因而栈的存储结构可采用顺序和链式两种形式。顺序存储的栈称为顺序
栈，链式存储的栈称为链栈。
栈的顺序存储实现
栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，另外我们还
可以用一个变量来存储堆栈的最大容量MaxSize这样方便判断什么时候堆栈是满的。我们用一
维数组 DataMaxSize下标MaxSize存储一个栈的元素。习惯上将栈底放在数组下标小
的那端，栈顶位置用一个整型变量Top记录当前栈顶无素的下标值。当Top 指向时，表示空
栈；当Top 指向MaxSize时，表示满栈。用C语言描述顺序栈类型 Stack 如下：
typedef int Position
typedef struct SNodePtrToSNode
struct SNode
ElementType Data存储元素的数组
Position Top 栈顶指针
int MaxSize 堆栈最大容量
l
typedef PtrToSNode Stack
结构中的数组的长度是由MaxSize决定的。代码给出了创建一个给定容量的空堆栈
的函数。
第章 线性 结 构
Stack Createstackint MaxSize
Stack SStackmallocsizeofstruct SNode
SDataElementTypemallocMaxsize·sizeofElementType
SMaxSizeMaxsize
STop
return S
代码 顺序栈的创建
下面我们来看一下，堆栈的两个最主要操作“入栈”和“出栈”是如何实现的。
入栈操作Push。
在执行堆栈 Push操作时，首先判别栈是否满；若不满，Top加并将新元素放入 Data数组
的Top位置中。具体实现如代码所示。
bool IsFulStack s
returnSTopSMaxSize
bool PushStack S ElementType x
ifISFuS士
printf堆栈满“
return false
elae
SDataSTOpx
return true
代码 顺序栈的人栈操作
出栈操作Pop
执行Pop操作时首先判别栈是否空；若不空，返回 DataTop同时将Top减否则要返回
一个ElemcntTypc类型的特殊错误标志，即代码中的ERROR——这个值一般根据具体问题
做定义，必须是正常的栈元素数据不可能取到的值。
堆 栈
bool ISEmptyStack S
returnSTop
ElementType PopStack S
ISEmptyS
printf堆栈空“
return ERRORERROR是RlementType的特殊值，标志错误
else
returnSDataSTOp
代码 顺序栈的出栈操作
下面举一个用一个数组实现两个堆栈的例子。
例 请用一个数组实现两个堆栈，要求最大可能地利用数组空间，使数组只要有空间
入栈操作就可以成功。写出相应的入栈和出栈操作函数。
分析这个问题有多种解决方案，例如可以先将数组空间一分为二地分配给两个堆栈使
用，一个堆栈的底在数组的起始位置，另一个底在数组中间的位置，两个Top 指针都沿同一个方
向增长。这时如果其中一个堆栈先满了，而另外一个堆栈还有空，我们可以顺序移动数据，为满
的那个堆栈腾出空位来。但是这种方法显然不太聪明，因为可能涉及很多数据的移位，而这些麻
烦其实是不必要的。
一种聪明的方法是使这两个栈分别从数组的两头开始向中间生长；当两个栈的栈顶指针相
遇时，表示两个栈都满了。此时，最大化地利用了数组空间。
双堆栈的结构只比标准堆栈多了一个栈顶指针：
typedef int Position
typedef struct SNodePtrToSNode
struct SNode
ElementTypeData存储元素的数组
Position Topl 堆栈的栈顶指针
Position Top 堆栈的栈顶指针
int MaxSize 堆栈最大容量
typedef PtrToSNode Stack
第章 线 性 结 构
对双堆栈的创建也与代码是相似的，只是需要初始化两个栈顶指针，方法是令Topl
TopMaxSize。相关的主要操作实现方法如代码所示。
bool PushStack SElementType Xint Tag
Tag作为区分两个堆栈的标志，取值为和
ifSTopSToplI堆栈满
printf堆栈满n
return false
elsel
ifTag对第一个堆栈操作
SDataSTopx
else 对第二个堆栈操作
SDataSTopx
return true
ElementType PopStack sint Tag
Tag作为区分两个堆栈的标志，取值为和人
ifTagI对第一个堆栈操作
ifSTopI堆栈空
printf堆栈空n
return ERROR
elae return SDataSTop
else l对第二个堆栈操作
ifSTopzMaxsize堆栈a空·
printf·堆栈空a
return ERROR
eise return sDataSTopz
代码 在一个数组中实现两个堆栈
注意；在上述问题中，不能用STopSToplMaxSize来判别堆栈是否满想想为什
么。
堆栈
堆栈的链式存储实现
栈的链式存储结构链栈与单链表类似，但其操作受限制，插人和删除操作只能在链栈的
栈顶进行。栈顶指针 Top 就是链表的头指针。有时为了简便算法，链栈也可以带一空的表头结
点，表头结点后面的第一个结点就是链栈的栈顶结点，栈中的其他结点通过它们的指针Next链
接起来，栈底结点的Next为NULL。
用C语言描述链栈如下；
typedef struct SNode PtrToSNode
struct SNode
ElementType Data
PtrToSNode Next
I
typedef PtrToSNode Stack
代码给出了带头结点的链栈主要操作的实现。
Stack CreateStack
构建一个堆栈的头结点，返回该结点指针
stack S
Smallocsizeofstruct SNode
SNextNULL
return S
—
bool ISEmptyStack s
判断堆栈S是否为空，若是返回true否则返回false
returnSNext NULL
bool PushStack SElementType x
将元素X压入堆栈S
PtrTOSNode TmpCell
TmpCelPtrTOSNodemallocsizeofstruct SNode
TmpCelDataX
TmpCelNextSNext
SNextTmpcell
第章 线 性 结 构
return true
ElementType PopStack s
·删除并返回堆栈S的栈顶元素·
PtrToSNode FirstCell
ElementType TopElem
ifISEmptyS
printf堆栈空
return ERROR
else
FirstcellSNext
TopElemFirstCellData
SNextFirstcelNext
freeFirstcel
return TopElem
代码 带头结点的链栈操作实现
堆栈应用：表达式求值
在节中，我们给出了后缀表达式计算的基本过程，在这个计算过程中我们需要暂存还
不能马上参与运算的运算数，对这些运算数的管理方法基本是先入后出的原则，即需要使用一个
堆栈对这些暂存的运算数在求值过程中进行管理。
根据节中后缀表达式的求值方法，我们可以很容易总结出应用堆栈实现表达式求值
的基本过程：从左到右读人后缀表达式的各项，并根据读入的对象判断执行操作。操作分下列
种情况：
当读入的是一个运算数时，把它被压人栈中：
当读入的是一个运算符时，就从堆栈中弹出适当数量的运算数，对该运算进行计算，计
算结果再压回到栈中：
处理完整个后缀表达式之后，堆栈顶上的元素就是表达式的结果值。
下面我们给出了利用堆栈求后缀表达式值的完整程序。为了简便起见，我们假设后缀表达
式的对象运算数或运算符号之间用空格分割开来，运算数为正实数，比如：
堆栈
程序中的堆栈采用数组存储方式，入栈和出栈的操作实现见代码和。这里根据
实际问题需要将堆栈的元素类型ElcmentType具体化为double类型，见代码。
include stdioh
Hinclude atalibh
Hinclude sctypah
tdefine MAXOP 操作数序列可能的最大长度
derine INFINITY e代表正无穷·
typedef double ElementType人将堆栈的元素类型具体化
类型依次对应运算数、运算符、字符串结尾
typedef enum numopr end Type
八关于顺序堆栈的代码请参见顺序堆栈的定义和代码至在此略去·
Type GetopcharExprfntstartcharstr
从start开始读入下一个对象操作数或运算符并保存在字符串 str中·
int i
跳过表达式前空格
whilestrExpr·start
whilestr stri
striExpr·start
ifstri如果读到输入的结尾·
startstart指向结束符·
str结束一个对象的获取
ifireturn end读到了结束
如果str是数字、或是符号跟个数字·
else ifisdigitstrⅡisdigitstr
·表示此时 str中存的是一个数字 return num
如果str不是空串，又不是数字· else
表示此时 str中存的是一个运算符 return opr
ElementType PostfixExpcharExpr
第章 线 性 结 构
调用Getop 函数读入后缀表达式并求值·
Stack S
Type T
ElementType OpOp
char strMAXOP
int start
申请一个新堆栈
SCreateStackMAXOP
opp
whileTGetopExprstartstrend
当未读到输入结束时·
ifTnum
PushS atofstr
elsel
ifISEmptySOpPopS
else OpINFINITY
ifISEmptySOpPops
else opINFINITY
switchstr
casetPushSOpOpbreak
casettPushSOpOpbreak
casetPushs OplOpZbreak
caseI
ifOpZ 检查除法的分母是否为·
PushS oppz
elae
printE错误；除法分母为零n
OpINFINITY
break
default
printf错误：未知运算符s n str
·事实上，人们一般不直按判断两个 double型实数是否相等或不等，因为从不同渠道获得的两个理论上相等的实数很可
能因为不间的舍人过程而产生微小的误差。一般以两个实数差的绝对值是否小于某给定阙值来判断两数是否相等。在这里，
我们可以用“fabeOpZERO”来判断Op不等于其中ZERO可以定义为一个充分小的数字，例如E。
堆栈
OpINFINITY
break
ifOpINFINITYbreak
fOpZINFINITY 如果处理完了表达式
ifIEmptyS 而此时堆栈正常·
OpPops 记录计算结果·
elee OpINPINITY八否则标记错误
froeS释放堆栈
return OpZ
intmain
char ExprMAXOP
ElementType f
getsExpr
fPostfixExpExpr
iffINFINITY
printffnf
else
printf表达式错误n
return
代码 利用堆栈求后级表达式
很明显，在计算后缀表达式的过程中，不需要判别运算的优先级。程序
运行时间跟问题规模是线性关系，即时间复杂度为n。
在中缀表示的算术表达式简称中缀表达式中，由于不同运算符间存
在优先级，同一优先级的运算间又存在着运算结合顺序的问题即左结合，
还是右结合所以简单地从左到右的计算是不可行的。 微视频
我们也可以应用堆栈将中缀表达式转换为后缀表达式。注意到转换前
后运算数的顺序是不改变的，改变的是运算符的顺序，所以此时堆栈里要保
存的是运算符。而在后缀表达式计算中，堆栈里保存的是运算数。
如何将中缀表
达式转换为后
缀表达式
第章 线 性 结 构
应用堆栈将中缀表达式转换为后缀表达式的基本过程为：从头到尾读取中缀表达式的每个
对象，对不同对象按不同的情况处理。对象分下列种情况：
如果遇到空格则认为是分隔符，不需处理；
若遇到运算数，则直接输出；
若是左括号，则将其压入至堆栈中；
若遇到的是右括号，表明括号内的中缀表达式已经扫描完毕，将栈顶的运算符弹出并输
出，直到遇到左括号左括号也出栈，但不输出
若遇到的是运算符，若该运算符的优先级大于栈顶运算符的优先级时，则把它压栈；若
该运算符的优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，
按同样处理方法，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；
若中缀表达式中的各对象处理完毕，则把堆栈中存留的运算符一并输出。
上述处理过程的一个关键是不同运算符优先级的设置。在程序实现中，可以用一个数来代
表运算符的优先级，优先级数值越大，它的优先级越高，这样优先级的比较就转换为了两个数大
小的比较。
表表示了利用堆栈将中缀表达式“”转换为后缀表达式“
”的过程。
表 中缀表达式“”转换为后缀表达式的过程
步骤
待处理表达式 堆栈状态
底一…→顶
输出状态
队列
队列
队列的定义
在现实生活中，我们经常会遇到为了得到某种服务而排队的情况，比如，食堂买饭时需要排
队，银行存款时也需要排队。在计算机资源管理中也有类似的情景，比如，计算机的CPU资源是
有限的早先计算机只有一个CPU但同时有许多程序进程需要CPU来运行，这些准备运行
的进程就需要排队。
在许多应用中，排队的基本规则是：新来者排在队伍末尾，排在队伍前面的人先得到服务，期
间不允许插队。对于这类排队问题，需要有一种能解决共性问题的数据序列的管理组织方式，在
这个方式中，多个数据构成一个有序序列，而对这个序列的操作比如插人、删除有一定要求：
只能在一端插入，而在另一端删除。这样的数据组织方式就是“队列”。
“队列”Queue也是一个有序线性表，但队列的插入和删除操作是分别在线性表的两个不
同端点进行的。比如，人们在银行排队等待服务，后来的人要排在队尾插入队伍而先来的排
在头前并先接受服务从队伍中删除。
设一个队列Qaa…a那么a称为队头元素，而a。称为队尾元素，a排在a的后
面i≤n。如果将元素A、B、C、D依次插入队列，第一个从队列中删除的元素将是A即先插
人的将被率先删除，因此队列通常又被称为“先进先出”表Fist In First OutFIFO。
队列的抽象数据类型定义为：
类型名称：队列Queue。
数据对象集：一个有个或多个元素的有穷线性表。
操作集：对于一个长度为正整数 MaxSize的队列QQueue记队列中的任一元素X∈Ele mentType队列的基本操作主要有：
Queue CreateQueueint MaxSize生成空队列，其最大长度为MaxSize
bool IsFullQueue Q判断队列Q是否已满。若是返回true否则返回 false
bool AddQQueue QElementType X将元素X压入队列Q。若队列已满，返回false否
则将数据元素X插入到队列Q并返回 true
bool IsEmptyQueue Q判断队列Q是否为空，若是返回 true否则返回 false
ElementType DeleteQQueue Q删除并返回队列头元素。若队列为空，返回错误信息；
否则将队列头数据元素从队列中删除并返回。
队列的实现
队列的顺序存储实现
队列最简单的表示方法是用数组。用数组存储队列有许多种具体的方法。一般可以选择将
第章 线 性 结 构
队列头放数组下标小的位置，而将队列尾放在数组下标大的位置，并用两个变量 Front 和Rear分
别指示队列的头和尾，如图a。一般Front 和Rear先初始化为。当有元素入队，Rear向
右移动一格加放入队尾元素；当有元素出队，先将 Front 向右移动一格加再删除队头
元素。所以，入队和出队操作实现都相对简单。
…Front Rear… nn
a队列的一般情况
… Frontn Rear
b队列的“假溢出”
图 队列的一种数组表示
随着入队出队的进行，会使整个队列整体向后移动，这样就出现了图b的现象：队尾
指针已经移到了最后，再有元素入队就会出现溢出，而事 Front
实上此时队中并未真的“满员”这种现象称为“假溢出”。 为了解决队尾溢出而实际上数组仍然有空余空间的
问题，一般在队列的顺序存储结构中采用循环队列的方
式：Rear和Front 到达数组端点时，能折回到数组开始处，
即相当于将数组头尾相接，想象成环状，如图所示。
当插人和删除操作的作用单元达到数组的末端后，用公式
“Rear或Front组长度”取余运算就可以实现折返到
起始单元。
Rear
n
n
采用循环队列解决了我们前面 图 循环队列
提到的假溢出问题，但在循环队列中，Front和Rear如何初始化却并不是一
个十分显然的问题，如何根据Front和Rear值判别当前队列是否空或者满
… 如果队列初始化时，将Front和Rear都初始化为当插入一个元素
微视频 时Rcar 加删除一个元素时Front加则当 Front和Rear相等的时候队
循环队列的
空 满判 断
问题
列为空，如图a所示。当Front在Rear前面一个位置时表示队列中
只有一个元素，如图b所示。在这种设置方式中，Rear指向的是队尾
元素的位置，而Front 则是指向队头的前一个位置。
当数组中有n个元素时即数组剩最后一个空位时状态如图c此时如果再插入
一个元素，Rear加Front 和Rear值就相等了。但我们知道，队列为空的时候 Front和Rear值也
队列
是相等的。因而，按照目前的操作方式，当Front和Rear值相等时，队列可能为空或者为满，我们
无法判别。其根本原因是：我们是根据Rear和Front 之间的差距来判别队列元素个数的，而Rear
和Front 之间的差距最多只有n种情况n为数组大小而队列元素个数总共有n种情况
…n个元素所以仅依靠Front和Rear是没办法区分n种情况的。
Front Rear Front Rear Rear Front
重 书 曲
n n n
n n n
n队列为空的状态 b队列中只有一个元素 c队列满状态
图 循环队列的空与满
可见，无法区分队列满还是空的原因是Front 和Rear提供的信息量不够。解决方法有两种：
方法之一是另外增设一个变量，比如：记录当前队列元素个数的变量Size或者用一个变量
Flag记录最后一次操作是入队还是出队。根据变量Size我们就可以直接判断队列是满还是空；
根据变量Flag就可以知道当Front 等于Rear时是满还是空。
方法之二是少用一个元素空间，把图c所示的情况就视为队列满。此时的状态是队
尾指针加就会从后面赶上队头指针，因此，队满的条件是：Rear组长度等于Front。队
空的条件仍然是：Rear 等于Front。
下面我们采用方法二实现循环队列。队列的顺序存储实现结构可以定义为：
typedef int Position
typedef struct QNodePtrToQNode
struct QNode
ElementTypeData 存储元素的数组
Position FrontRear 队列的头、尾指针
int MaxSize 队列最大容量
I
typedef PtrToQNode Queue
循环队列的创建与插入和删除操作实现由代码给出。
Queue createQueueint Maxsize
Queue QQueuemallocsizeofstruct QNode
第章 线 性 结 构
QDataElementTypemallocMaxsizesizeofElementType
QFrontQRear
QMaxsizeMaxSize
return Q
bool ISFulQueue Q
returnQRearQMaxSizeQFront
bool AddQQueue QElementType X
ifIsFullQ
printf队列满
return false
elsel
QRearQRearMaxsize
QDataQRearx
return true
bool IeEmptyQuoue
returnQFront QRear
ElementType DeleteQOueuo
ifISEmpty
printE“队列空“
roturn ERROR
else
QFrontQFrontQMaxize
队列
return QDataQPront
代码 循环队列的创建与人队和出队操作
队列的链式存储实现
队列与堆栈一样，也可以采用链式存储结构，但队列的头Front必须指向链表的头结点，队
列的尾Rear指向链表的尾结点反过来行不行为什么。
用C语言描述链式队列结构如下：
typedef struct NodePtrToNode
struet Node 队列中的结点
ElementType Data
PtrToNode Next
l
typedef PtrToNode Position
typedef struct QNodePtrToQNode
struct QNode
Position FrontRear队列的头、尾指针
int MaxSize 队列最大容量
typedef PtrToQNode Queue
采用链式存储的入队和出队操作实际就是在一个链表的尾部插入结点或者在头部删除结
点。下面代码是不带头结点的链式队列出队操作的一个示例：
bool ISEmptyQueue Q
returnQFrontNULL
ElementTypeDeleteQQueue Q
Position FrontCel
ElementType FrontElem
ifISEmptyQ
第章 线 性 结 构
printf队列空
return ERROR
else
FrontcelQFront
ifQFront QRear 若队列只有一个元素
QFrontQRearNULL删除后队列置为空
else
QFrontQFrontNext
FrontElemFrontcelData
freeFrontCel 释放被删除结点空间
return FrontElem
代码 链式存储队列的出队操作
应用实例
多项式加法运算
在本章第一节，我们分析了一元多项式的三种可能的存储实现方法。本节我们将给出采用
链表结构来存储多项式的非零项的实现方法。
前面提到，用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数和指
数两个数据域以及一个指针域，其结点结构已在节的方法中给出。
我们准备采用不带头结点的单向链表结构表示一元多项式，并按照指
数递减的顺序排列各项示例如图所示。
…
微视频
链式存储多
对链表存放的两个多项式进行加法运算可以使用两个指针P和P。
初始时P和P分别指向这两个多项式第一个结点指数最高的项。通
过循环不断比较P和P所指的各结点，比较结果为以下种情况之一，
并做不同处理。 项式的相加 两数据项指数相等。系数相加，若结果不为则作为结果多项式 过程
………………对应项的系数，连同指数一并存入结果多项式。沿两结点的链域，使PI和
P都分别指向两个多项式的下一项，再进行新一轮的比较和处理。
应用 实 例
P中的数据项指数较大。P不变，将P的当前项存入结果多项式，并使P指向下一
项，再进行新一轮的比较和处理。
P中的数据项指数较大。PI不变，将P的当前项存入结果多项式，并使P指向下一
项，再进行新一轮的比较和处理。
当某一多项式最后一个结点处理完时，停止上述求和过程，将未处理完的另一个多项式的所
有结点依次复制到结果多项式中去。
代码是链表存储的两个多项式加法运算的具体实现，其中函数Attachcoefexpon
PtrRear将系数coef和指数expon 构成的新的项加入结果多项式的末端，同时改变当前结果多
项式末尾项指针 PtrRear值；ComparePIexponPexpon比较两个指数的大小，根据大于、
小于、等于三种情况分别返回PolyAddPP将多项式PI和P相加，并返回结果多
项式。注意：相加并不改变原有的多项式P和P。
int Compareint eint e
·比较两项指数e和e根据大、小、等三种情况分别返回
ifesereturn ke大，返回
else ifelereturne大，返回
else return el和e 相等，返回
void Attachint coefint exponPolynomialPtrRear
由于在本函数中需要改变当前结果表达式尾项指针的值，
所以函数传递进来的是尾项结点指针的地址，PtrRear 指向尾项·
Polynomial P
申请新结点，并赋值
PPolynomialmallocsizeofstruct PolyNode
Pcoefcoef
Pexponexpon
PlinkNULL
将P指向的新结点插入到当前结果表达式尾项的后面
PtrRearlinkP
PtrRearP修改PtrRear值
Polynomial PolyAddPolynomial PPolynomial P
Polynomial frontreartemp
int sum
第章 线 性 结 构
为方便表头插人，先产生一个临时空结点作为结果多项式链表头·
switchComparePexponPexpon
case P中的数据项指数较大人
AttachPcoefPIexponkrear
PPlink
break
caseP中的数据项指数较大
AttachPcoefPexponrear
PPlink
break
case 两数据项指数相等
sumPcoefPcoef
ifsumAttachsumPexponrear
PPlink
PPlink
break
·将未处理完的另一个多项式的所有结点依次复制到结果多项式中去
forPPPlinkAttachPcoefPexponrear
forPPPlinkAttachPZcoef Pexponbrear
rearlinkNULL
tempfront
front frontlink令front 指向结果多项式第一个非零项·
freqtemp人释放临时空表头结点
return front
rearPolynomialmallocsizeofstruct PolyNode
frontrear由front 记录结果多项式链表头结点
whilePI P当两个多项式都有非零项待处理时
代码 链式存储的一元多项式加法运算
迷宫问题
作为堆栈应用的一个比较有挑战性的例子，我们介绍一下迷宫问题的求解。迷宫问题要求
从一个人口出发，经过若干连通的格子达到指定的出口。
应 用 实 例
首先，我们需要考虑如何在程序中表示迷宫。假定用nxm的二维矩阵表示迷宫，位置
为人口，位置nm为出口。迷宫中的任一位置可以用其行列坐标来指定。某一位置有
障碍，其对应的矩阵元素ij的值为否则其值为。图是某个给定迷宫的矩阵表示
形式。
图 迷宫的矩阵表示
这时迷宫求解问题转换成从矩阵的起始位置到结束位置nm寻找一条连通路
径，路径是由一组两两相邻每个位置与它周围的个方向的位置都相邻的位置构成，这一组
位置的矩阵元素值都为。
求解迷宫问题的基本思路是“穷尽法”即从入口出发尝试各种可能，直到找到出口。在从
一个位置尝试走到下一个位置时，有种可能的走法，图用方向东E、西W、南S、北
N、东南SE、东北NE、西南SW、西北NW表示这种情况。
实际上并非每个位置上都有个可移动的方向，处于迷宫边缘上的位置只有个可移动方
向，而处于四角的位置只有个可移动方向。为了一致起见，使得程序设计不必考虑这些边缘和
角落特殊情况，可以人为地环绕迷宫增加一圈障碍。改变后迷宫所对应的矩阵表示见图
增加部分用涂灰的且值为的边框表示。
扩大的矩阵并不影响算法寻找通路，只是入口下标为出口下标为nm而不
是原来的左上角和右下角了。n、m为带边界的二维数组大小。
设在迷宫中走到某一位置RowColRow 表示纵坐标，Col 表示横坐标。如果下一步朝北
走，相对于当前位置将步入位置RowCol若朝东南走，下一步将步入位置RowCol。
以此类推，可得到每一个方向的坐标变化情况。相对于当前位置Row Col下一位置纵横坐
标的偏移量为、或者。
表列出了下一位置在个方向中的具体下标偏移量。为了程序实现简单起见，个方
向从北开始顺时针依次从到编号。
第章 线性 结 构
NW
西北
北N NE 东北
西W 东E
西南
SW
南S 东南
SE
F
图 任一位置的个方向 图 迷宫增加一圈障碍的矩阵表示
表 迷宫中的方向、编号及坐标偏移量
方向 编号 row 偏移 col偏移
北N
东北NE I
东E
东南SE
南S
西南SW
西W
西北NW
求解迷宫路径可以从入口开始尝试各个方向以找到下一个位置，并进而在新的位置再尝试
所有可能找下一个位置。当在某个位置尝试所有可能找不到新位置时，说明进入了“死胡同”需
要返回，即“回溯”。为了记住回溯的位置，需要采用一种数据结构来保存和恢复从前尝试过的
潜在路径的位置信息，这个数据结构应该具有“后入先出”的特点，因而就是堆栈。
应用堆栈求解迷宫路径的基本思路如下。
将初始人口坐标和起始方向信息放入堆栈中。
从堆栈中弹出上次位置信息，设定当前位置和当前尝试方向：若堆栈为空而出口尚
未找到，则该迷宫没有解，程序退出。
应 用 实 例
在当前位置从当前方向起按顺序尝试剩余方向上的可通性：
①若某一方向可通，则将当前位置信息及目前方向信息存入堆栈；
②若该可通位置是出口，则成功退出，堆栈中的从栈底到栈顶的各位置顺序构成迷宫路径；
③若该可通位置不是出口，将该可通位置设为当前位置，并将第一个方向设为当前方向；转
第步。
若个方向均不可通，则转第步。
相应的数据结构为：
define MAXMATRIXSIZE 迷宫矩阵最大行列数
define MAXSTACKSIZE 堆栈最大规模
struct Offsets 偏移量结构定义
short int Vert纵向偏移
short int Horiz横向偏移
I
struct MazePosition迷宫中的位置结构
short int Row行号
short int Col列号
short int Dir对应偏移量数组的方向号
I
typedef struct MazePosition ElementType堆栈元素类型
堆栈的创建及入栈和出栈的函数已经在代码至给出，在此不再赘述。代码
给出了寻找迷宫路径的函数Path。调用该函数时，假设迷宫已经给出，用带边界的二维数组
Maze表示；人口位置为出口位置为EXITROWEXITCOL。若迷宫无解，该函数将
输出“该迷宫无解。”若有解，则将顺序输出从人口到出口的路径上每个位置的横、纵坐标。
为了不重复访问已经走过的路线，我们还需要用一个二维数组MarkMAXMATRIXSIZE
MAXMATRIXSIZE来标记已经走过的位置，如果位置Row Col已经被走过，则MarkRow
Col为否则为。
注意：由于从堆栈弹出的路径是反向的，所以我们从出口向人口反向搜索比较方便。从出口
向入口反向搜索的方法与从入口正向搜索的方法是一样的。下面的代码是从出口反向搜
索的迷宫问题路径求解程序。
void Pathint MazeMAXMATRIXSIZEint EXITROWint EXITCOL
迷宫个方向的偏移量数组
默认迷宫Maze的入口为出口为EXITROWEXITCOL
第章 线 性 结 构
struct Offsets Move
Ff
Stack S辅助求解的堆栈
struct MazPosition P
short int RowColNextRowNextColDir
bool Foundfalse
SCreateStackMAXSTACKSIZE初始化空堆栈·
MarkEXITROWEXITCOL从出口位置开始，标记为走过·
将出口位置及下一个方向放入堆栈
PRowEXITROW
whileISEmptySFound当栈非空且没找到入口时
尝试往下一个方向Dir移动
NextRowRowMoveDirVert
NextColColMoveDirHoriz
ifNextRowNextCol
如果到达人口
Foundtrue
clse 下一个位置不是入口·
八若下一个位置可通，且没走过
ifMa NextRowNextCo
MarkNextRowNextco
MarkNextRowNextco标记为走过
当前位置和下一个方向存入栈
PRowRow
PColcol
PDirDir
PushsP
人更新当前位置，从方向开始
int MarkMAXMATRIXSIZEMAXMATRIXSIZE标记位置是否走过
PColEXITCOL
PPopS取出栈顶元素为当前位置∠
PDir
RowPRow ColPCol DirPDir
PushSP
whileDirFound当还有方向可探且没找到人口时
本 章 小 结
RowNextRow ColNextColDir
结束if
else Dir若此路不通，则在当前位置尝试下一个方向
十结束方向探测
结束搜素·
ifFound找到一个路径，并输出该路径·
printf找到路径如下n
printf行列n
printf n打印入口
printfd tdnRow co不要忘记最后一步未入堆栈
whiloISEmptyS
PPopS
printfkdnPRow PCol
else 若没找到路径
printf该迷宫无解。n
代码 迷宫求解
注意到程序中有一个细节，当探测到下一个能走的位置时，我们存入堆栈的是当前的位置，
但却不是当前的方向，而是下一个方向——为什么如果我们在此存入的是当前方向，程序会出
错吗这个问题留给读者自己去思考。
本 章 小 结
在分析一元多项式及其运算问题的基础上，引入线性表的概念及其基于顺序存储和链式存
储的两种实现方法。线性表是若干数据元素组成的有序序列，其基本操作有插入、删除、查找等。
基于顺序存储的线性表实现方式简单，对元素访问随机，但动态性不够，是实现静态线性数据管
理的理想方式。链表存储方式对频繁增删结点且表长有较大变化的应用来说更加适合。
广义表是对一般线性表的推广，是一种“表中有表”的数据元素组织方式。广义表可以采用
多重链表方式实现，即多个单向链表的综合，其中存在一些结点属于多个链表。稀疏矩阵的典型
实现方式是采用横纵行列交错的多重链表十字链表。
堆栈是一种只在一端做插入删除的受限的线性表，具有“后进先出”的特点，主要操作包括：
入栈、出栈、栈满和栈空判断。堆栈的实现可以采用顺序存储数组和链式存储两种方式。在
实际应用中，顺序存储实现方式更加常见和方便。堆栈的应用非常广，常见的应用包括：表达式
第章 线 性 结 构
求值、函数调用和递归实现、深度优先搜索等。本章重点分析了表达式求值和迷宫问题。
队列是一种在一端进行插入而在另一端进行删除的受限的线性表，具有“先进先出”的特
点，主要操作包括：入队、出队、队满和队空判断。队列的实现也可以采用顺序存储数组和链
式存储两种方式。顺序存储实现方式主要采用循环数组实现，其中队空和队满的判断需要特别
关注。队列的应用也非常广，包括：广度优先搜索、操作系统中各种竞争性资源如CPU的管
理、实际应用中服务资源的获得如银行窗口服务等。
习题
判断正误。
若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存
储最节省时间。
若一个栈的输入序列为…N输出序列的第一个元素是i则第j个输出元素一定是ji。
在用数组表示的循环队列中，front 值一定小于等于 rear值。
填空题。
数组A每个元素占个单元，将其按行优先次序存储在起始地址为的连续的内存单
元中，则元素A的地址为。
带头结点的单链表L为空的判定条件是。
通过对堆栈S操作：PushSPushSPopSPushSPopSPopS。输出的序列为
如果循环队列用大小为m的数组表示，且用队头指针 front和队列元素个数size代替一般循环队列中
的 front和 rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为。
给定一个顺序存储的线性表Laa…a请设计一个算法删除所有值大于min而且小于max
的元素。
给定一个顺序存储的线性表Laaa请设计一个算法查找该线性表中最长递增子序列。
例如。中最长的递增子序列为。
请设计时间和空问上都尽可能高效的算法，求链式存储的线性表的倒数第m个元素。
请设计实现两个链式存储的一元多项式乘法运算的算法，并分析该算法的时间复杂性。
如果有、、、、按顺序人栈，不同的堆栈操作poppush顺序可得到不同的堆栈输出序列。请问
共有多少种不同的输出序列为什么
请编写程序检查C语言源程序中下列符号是否配对：·与·人、与、与、与。输入为C语言源
程序文件。
假设以S和X分别表示入栈和出栈操作。如果根据一个仅有S和X构成的序列，对一个空堆栈进行
操作，相应操作均可行〈如没有出现删除时栈空且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请
编写程序，输人S和X序列，判断该序列是否合法。
利用堆栈可以以非递归方式求解汉诺塔问题。请编写非递归方式的汉诺塔问题求解算法。
请编写程序将中缀表达式转换为后缀表达式。
习题
如果用一个循环数组表示队列，并且只设队列头指针 Front不设尾指针 Rear而是另设Count 记录队
列中元素。请编写算法实现队列的入队和出队操作。
双端队列deque即 doubleended queue的缩写是一种具有队列和栈性质的数据结构，即可以也只
能在线性表的两端进行插入和删除。若以顺序存储方式实现双端队列，请编写例程实现下列操作。
PushXD将元素X插人到双端队列的头；
PopD删除双端队列的头元素，并返回：
InjectXD将元素X插入到双端队列的尾部；
EjectD删除双端队列的尾部元素，并返回。
在栈的顺序存储实现中，另有一种方法是将Top定义为栈顶的上一个位置。请编写程序实现这种定
义下堆栈的入栈、出栈操作。如何判断堆栈为空或者满
第章
树
引子
问题的提出
我们已学过线性表，并知道，所谓线性是指其任何元素至多有一个前驱或一个后继元素。一
般情况下，不管是用数组实现还是用链表实现，对线性表的大多数操作总避免不了线性的时间复
杂度，这是由于其逻辑结构是线性的这一本质特性所决定的。
客观世界中许多事物具有层次关系，例如，人类社会的家族谱、各种社会组织机构、图书馆中
图书的分类存放等，这些事物中各元素之间有分支、层次关系。图部分地表示了图书馆中图
哲学宗數 …
图书
文学 医药卫生 农业科学 工业技术 …
综合
学理论 世界皙学 欧洲皙学 宗教 电工技术 计算机 …
宗教分析研究 宗教理论与概况 …
建筑科学
佛教 般性坟术 计算机软件 电子模拟计算机 微型计算机 …
宗教与社会改治 宗教与科学 … 破除迷信 软件工程 程序语言 … 编评程序 襟作系统
图 图书分类
水利工程
计算机的应用
引子
书的分类，图中省略了绝大多数具体分类，而只是说明一个层次框架。在各分类层次中，具
体分类标识在方框称为结点内，而它们之间的隶属关系用连线分支表示出来。
图中灰颜色方框列出了具体类型的图书实体，而白色方框表示的是分类实体隶属关系。
如果我们只用线性表来存储图书实体，而忽视隶属关系的话，得到图所示的线性存储结构，
这相当于将图书实体随机存储在一个线性空间内。
宗教与社会政治 宗教与科学 … 破除迷信 … 软件工程 程序语言 验蔽胜事 作系统
图 图书实体的线性表存储
试想采用这种丢弃分类线索并按线性表存储的方式，若要查找某一个具体的图书实体，算法
的时间复杂度是多少如果我们能有一种存储方式将隶属关系也考虑在内，查找某一图书实体
的算法是否能有更高的效率
查找
为了更好地理解树的结构和特性，在正式回答上述问题和介绍树的内容之前，我们首先通过
线性表介绍静态查找的概念，并以两个实例详细介绍顺序查找和二分查找的实现过程与算法。
在此基础上再给出非线性结构树的概念，以使读者对线性和非线性结构的本质特征有更好的
理解。
查找Searching在人们日常生活中被频繁使用，例如从字典中查找某个单词的读音与注解，
从黄页簿中查找某个单位的地址和电话等。严格的定义为：给定一个记录的集合R根据某个给
定的关键字K从集合R中找出关键字与K相同的记录，这个过程称为“查找”。若集合中存在
这样的记录，则称查找是“成功的”返回该记录的信息或该记录在集合中的位置；若集合中不存
在这样的记录，则称查找为“不成功的”返回一个空记录或空指针。
查找可分静态和动态两种情况考虑，又分为利用比较和利用映射两种查找思路。所谓静态
查找，是指集合中的记录是固定的，不涉及对记录的插入和删除操作，而仅仅是按关键字查找记
录。例如，一本词典中所含的词汇是固定不变的，当人们想了解某一个词汇时，以此词汇作为关
键字就可以查到其含义。又如C语言编译器工作时就是在静态的关键字表包括关键词 in clude、typedefstruct、int、double、for、while、return等中查找的。
静态查找的效率主要用“平均查找长度”这一指标来衡量。设查找集合中第i个记录的概率
万m。 是PZn且需要进行 n次比较才能找到，则成功查找的平均查找长度定义为
因为在实际应用中，往往查找成功的可能性比不成功的可能性大得多如在词典中查找词汇
第章 树
故可以重点考察成功查找的平均查找长度。一个好的查找算法应能使平均查找长度最小化。
静态查找通常是从一个线性表中查找数据元素，线性表可以是基于数组的顺序存储或者是
线性链表存储，已经在节及节中分别给出了定义。下面讨论种静态查找方法。
方法顺序查找
顺序查找是一种最基本、直接的查找方法。它从线性表的一端开始，向另一端逐个取出数据
元素的关键字，并与要找的关键字K进行比较，以判定是否存在要找的数据元素。
以数组存储为例，设数据元素从下标为的数组单元到下标为Last的单元存放。为了简化
算法，使得从后向前查找失败时，不必判断表是否检查完毕，可以在查找开始前，作为哨兵将要查
找的关键字K存入下标为的数组单元。这样，即使原表Last单元中没有关键字为K的记
录，算法再多一次查找下标为的单元，也会找到元素而终止，而此时用返回数组下标值表明
查找失败。
代码给出了顺序查找算法的实现函数SequentialSearch。
Position SequentialSearchList TbElementType K
在顺序存储的表 Tbl中查找关键字为K的数据元素，使用“哨兵”
Position i
TblDataK建立哨兵
foriTblLastTblDataiKi
return i查找成功返回数据元素所在单元下标；查找不成功返回
代码 顺序查找
算法复杂度分析：若有n个数据元素Last为n查找从数组下标为Last 的最后一个单元开
始到第一个单元逐个进行数据比对。查找结束时，算法返回一个下标值i关键字的比较次数则
为ni。因此，顺序查找算法的平均查找长度为 ∑pni其中p是查找第；个数据元
素的概率。若每个数据元素的查找概率相等，即pn则等概率情况下的平均查找长度为
pni富ni 查找不成功时，每个关键字比较一次，直到哨兵为
止，共进行了n次比较。由此可见，顺序查找算法的时间复杂度为n。
方法二分查找
从查找方法我们知道，顺序查找算法的时间复杂度是线性的。而当线性表中数据元素是
按大小排列存放时，可以设计一种更高效率的新算法——二分查找。二分查找也称为折半查找，
是针对线性表中数据的存放是有序的这一特殊性，而采用的一种有效方法。
假设n个数据元素的关键字满足kk…ka试想若要查找的关键字K小于线性表中的某
引子
一关键字k那么接下来是从k的左边还是右边继续查找答案是显而易见的，要找的元素只
可能是在k左边的i个元素中，而一定不会是在k的右边。因此，利用有序这一特性可以缩
小查找的范围，使得接下来的查找总是在上一次查找范围的一个子集中进行。
二分查找是每次在要查找的数据集合中取出中间元素关键字km与K进行比较，根据比较
结果确定是否要进一步查找。当Kk查找成功；否则，将在k的左半部分或者右半部分继
续下一步查找。以此类推，每步的查找范围都将是上一次的一半，因此，二分查找也常常被称为
折半查找。
例 假设有个数据元素，它们的关键字为
。若按关键字由小到大顺序存放这个数，二分查找关键字为的数据元素过程
如下。
第一步：要查找数据集合的左边界left为下标为的元素，右边界right为下标为的元
midedtris 素，则此范围内中间元素的下标为 关键字K与mid单元的关键字相比较，结
果为。下一步的查找将在mid 的右边继续进行。此时，左边界重新设置为leftmiddle
而右边界保持不变。
古 古
第二步：此时的左边界为left右边界为 right计算此范围内中间单元的下标为mid。
K与mid单元的关键字比较，结果为。下一步将继续在mid单元的右边查找。
古
第三步：此时的左边界为left右边界仍然是计算中间单元下标mid。K与mid
单元的关键字比较，结果为表明已在线性表中找到要查找的元素。
m古
上述过程中灰色单元表示某一步不必考虑缩小的查找范围。经过上述三步三次比较
找到了关键字为的元素。而采用从左到右的顺序查找将需要比较次。
第章 树
例 仍然以上面个数据元素构成的有序线性表为例，二分查找关键字为的数据
元素过程如下：
第一步：与例相同，left、right、mid。关键字K与mid单元的关键字相比较，结
果为。
第二步：查找将在mid的左边继续进行。此时，右边界重新设置为 rightmiddle而
左边界保持不变。在缩小的范围内，mid。关键字K与mid单元的关键字相比较，结果为
。
古
第三步：查找将在第二步的mid的右边继续进行。此时，左边界重新设置为leftmiddle
而右边界保持不变。在缩小的范围内，mid。关键字K与mid单元的关键字相比较，结果为
。
古 古
第四步：查找将在第三步的mid的左边继续进行。此时，右边界重新设置为 rightmiddle
而左边界保持不变。在缩小的范围内，mid。此时，查找范围缩小到只有一个单元。关键字K与
mid单元的关键字相比较，结果为。
第五步：查找将在上一步的mid的左边继续进行。右边界重新设置为rightmiddle而
左边界仍为保持不变。此时，出现了左右边界错位的情况，右边界已小于左边界，表明二分查
找结束，没有发现所要找的数据元素。
分析上述例题两个关键值查找的过程，可以得到代码所示的二分查找算法。
树的定义、表示和术语
define Not Found 找不到则返回
Position BinarySearchLiat TbElementType R
在顺序存储的表TbLast中查找关键字为K的数据元素
Position Ioft rightmid
left 初始左边界·
rightTbLast初始右边界·
whiloIeftright
midleftrightZ计算中间元素坐标
irKTbDatamidrightmid调整右边界·
return NotFound返回查找不成功的标识
elae ifKTbDatamidleftmid调整左边界
else return mid人查找成功，返回数据元素的下标
代码 二分查找
与顺序查找算法不同，我们不必通过在单元增加哨兵来判断查找是否成功，而是通过判断
是否还有合理的剩余查找范围。因此，其实可以将表中元素从单元开始存起，那么当查找失败
时二分查找算法返回的NotFound就应该是一个负数比如。
算法时间复杂度分析：从算法代码可以看出，当线性表中没有所要查找的元素时，算法
复杂度达到最大。设经过k步，查找范围从n减小到。因为每步查找范围是上一步的二分之
一，可得到关系n即klogn。由此可以得到结论：二分查找算法具有对数的时间复杂度
log n。
至此，我们已知道顺序查找和二分查找都属于静态查找方法，所谓静态是指数据一旦建立起
来就基本不添加新的数据元素，也不删除原有的数据元素。因此用数组存放数据并通过下标访
问数据元素既方便又高效。但当数据集变化频繁，采用链表存储时，这种基于有序性的二分查找
策略还适用吗在本章后面我们将介绍二叉搜索树，大家还会看到，基于二分查找思路的动态结
构方法。
树的定义、表示和术语
从上一节静态查找算法我们知道，当数据具有有序性时，基于线性表的二分查找算法时间复
第章 树
杂度可以达到log n。我们要问的是，当数据组成不具有这种特性时，是否能采用其他的非
线性表数据结构，使得算法也具有较好的时间复杂度接下来本章的重要内容有关树结构及其
应用二叉搜索树和AVL树将使读者得到答案。
树是一种十分重要的非线性数据结构，它的形式化定义如下：
定义树Tree是nn≥个结点构成的有限集合。当n时，称为空树；对于任一
棵非空树n它具备以下性质：
树中有一个称为“树根”Root的特殊结点，用r表示。
其余结点可以划分为m个不相交的子集TT…Tm。任何子集Ti∈m也是
一个树，称为根结点r的“子树”SubTree。每个子树的根结点都与r有一条相连接的边，r是这
些子树根结点的“父结点”Parent。
由上述树的定义可以看出这是一种递归的定义形式。由于子树是不相交的，那么除了根结
点外，树中每条边将某个结点与其父结点连起来。因此，除了根结点外，每个结点有且仅有一个
父结点。这隐含着一棵N个结点的树有N条边。
在以下有关树的内容介绍中，树的结点用圆圈表示，圈内用一个数字或字母等符号代表该结
点的数据信息比如，可以是关键字例如图中的字母A、B、C、…是树的结点。而树枝树
的边仍然用结点之间的连线表示。图a是一个具有个结点的树的逻辑表示形式，根结
点A有个子树，假设命名为T、Ta和T、T见图中的b、c、d、e子图个子
树的根结点分别是B、C、D和E。B结点又有两个子树，依此类推，树中的每个结点都是其子树
的根结点。
A
B C D B O
D E
F O H ① ①K 日 ①①K
① M ① M
a树T b子树T e子树Ta d子树Ts e子树T
图 树的表示形式
mm≥棵树的集合称为“森林Forest”。对树中每个结点而言，其子树的集合即为森林。
例如，对于图a中根结点A它的棵子树T、Ta和Ta、T就构成了一个森林。因此，任
何一棵树可以看作为一个二元组 TreeRootForest其中Root是根结点，Forest是这个根结点
所有子树构成的森林。
有关树的一些基本术语包括：
结点的度Degree一个结点的度是其子树的个数。例如，图a中结点D的度为
树的定义、表示和术语
结点E的度为。
树的度：树的所有结点中最大的度数。例如，图a的树中结点A有最大的度数
所以这棵树的度为。
叶结点Leaf是度为的结点。叶结点也可称为端结点，图a中E、F、H、J、K、L
和M等个结点是叶结点。
父结点Parent具有子树的结点是其子树的根结点的父结点。例如，图a中B
是F、G的父结点。
子结点Child与父结点相反，对于某一个结点来讲，其子树的根结点是它的子结点。
例如，图a中F和G是B的子结点。
兄弟结点Sibling具有同一父结点的各结点彼此是兄弟结点。例如，图a中B、
C、D、E有共同的父结点A它们彼此是兄弟结点。
祖先结点Ancestor沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。
例如，图a中A、B、C是L的祖先。
子孙结点Descendant某一结点的子树中的所有结点是这个结点的子孙。例如，图
a中F、G、L是B的子孙。
结点的层次Level规定根结点在层，其他任一结点的层数是其父结点的层数加。
例如，图a中结点G在第层。
树的深度Depth树中所有结点中的最大层次是这棵树的深度。例如，图a树
T的深度为。树的高度Height跟深度是一样的，只不过是自底向上计数。叶结点的高度规定
为其他任一结点的高度层数是其所有子结点的最大高度层数加。树的高度就是其根结点的
高度。
分支：树中两个相邻结点的连边称为一个分支。
路径和路径长度：从结点n到n的路径被定义为一个结点序列nn…n对于≤ikn
是n的父结点。一条路径的长度为这条路径所包含的边分支的个数。例如，图a中结
点序列ADIM是结点A到结点M的路径，其长度为。
根据上述树的定义和逻辑表示形式，很容易判断在图中，只有图a是棵树。而由于图
b、e、d都出现了子树相交、构成了回路的情况，或者说它们不满足N个结点的树有N
条边的特性，所以它们都不是树。
A A A A
B
C B
C D B
C D B C D
E F GH E F GA E F GH E F GH
a树 b非树 c非树 d非树
图 树与非树
第章 树
二叉树
二叉树的定义及其逻辑表示
定义一个二叉树是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由
根结点和称为其左子树和右子树的两个不相交的二叉树组成。
根据二叉树的定义，一般来讲，一棵二叉树可以看作为由一个根结点Root 和其左右两棵子
树T和T组成。具体可有种基本形态，分别是：①空二叉树；②只有根结点的二叉树；③只
有根结点和左子树T的二叉树；④只有根结点和右子树T的二叉树；⑤具有根结点、左子树T
和右子树Ta的二叉树。图是这种基本形态二叉树的图示表示形式。
中
TL T TL TR
a b c d e
图 二叉树的五种基本形态
一般树的定义它们是同一个树，而对于二叉树来讲，它们是不同的
上述二叉树的定义采用了递归定义方法。与树的一般定义不同，除了每个结点至多有两棵
子树外，子结点是有左右顺序之分的。例如，图中的两个树按 A A
两个树，因为第一个二叉树的右子树为空，而第二个二叉树的左子
树为空。 B D
二叉树的性质 图 两个不同的二叉树
二叉树的深度小于等于结点数N可以证明平均深度是√N。图所示为两个二叉树
的特例，图a是斜二叉树Skewed Binary Tree也称为退化二又树图b是完美二叉
树Perfect Binary Tree。斜二叉树结构最差，深度达到最大N它已退化为线性表。在一棵二叉
树中，如果所有分支结点都存在左子树和右子树，并且所有叶结点都在同一层上，这样的一棵二
叉树称作完美二叉树也称为满二叉树。
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编
号，如果编号为i≤i≤n的结点与满二叉树中编号为i的结点在二又树中的位置相同，则这棵
二叉树称为完全二叉树Complete Binary Tree。图给出的是一个完全二又树，读者可以对
照图与图b看到它们的对应关系。完全二叉树的特点是：叶结点只能出现在最下层和
二 又 树
A
A
B
B C
D E F G
D H ① ① K ① M N ◎
斜二叉树 b完美二叉树
图 斜二叉树和满二叉树
次下层，且最下层的叶结点集中在树的左部。显然，一棵完美二叉树必定是一棵完全二叉树。
完全二叉树是最理想的树结构，很容易证明有N个
结点的完全二叉树的深度为log N。 A
二叉树有很多重要的性质，下面就罗列部分非常
有用的性质。
B C
用数学归纳法容易证明：一个二叉树第i层
的最大结点数为≥。
D E F
利用等比数列求和公式，容易得到：深度为k
的二叉树有最大结点总数k≥。
H ① ① K
①
图 完全二叉树
对任何非空的二叉树T若n。表示叶结点的
个数、n是度为的非叶结点个数，那么两者满足关系n。n。
这个公式看上去有趣的地方是，二叉树中明明有类结点，而公式中却只涉及到度数为和
的结点数，那么n到哪里去了让我们略花时间仔细看一下各类结点之间的关系。
设n是二叉树中度为的结点个数、n是总的结点个数，那么可得到公式
nn。nn 公式
因为除了根结点外，树中每个结点有且仅有一条与其父结点相连的边。结点数n与边数B
满足关系Bn。而Bnn所以有公式
nnn 公式
公式减公式就得到non。
根据完全二叉树的定义和性质可知：具有n个结点的完全二叉树的深度k为Llogn。
二叉树的存储结构
在计算机内存中存储二叉树时，除了存储它的每个结点数据外，结点之间的逻辑关系父子
关系也要得到体现。
第章 树
顺序存储结构
微视频
这种结构是用一组连续的存储单元比如数组存储二叉树结点的
数据，结点的父子关系是通过它们相对位置来反映的，而不需要任何附
加的存储单元来存放指针。通常情况下顺序存储结构用于完全二叉树
的存储。 完全二叉树
的顺序存储
方法
具体实现是从树的根结点开始，从上层至下层，每层从左到右，依次
给结点编号并将数据存放到一个数组的对应单元中。图a是一个
完全二叉树，图b是其顺序存储的结果。完全二叉树的顺序存储除
了高效的存储空间利用率外，结点的父子关系计算也十分简单高效。从
图a可知，结点C的父结点是结点B它的左孩子是结点W右孩子是结点K。从图
b可知，C结点存储单元的下标是将其除以得到它的父结点B的存储单元下标，而将其
乘以则是它的左孩子W存储单元的下标，当然将其乘再加则是它右孩子K的存储单元
下标。
土
A
B ◎
C S M
数据 A B C s M Q W
K
W K
编号
a完全二叉树 b顺序存储结构
图 完全二又树及其顺序存储
概括起来，在N个结点的完全二叉树中，对于下标为i的结点：
当Li≥时，Li单元是其父结点；当LiJ时，表明该结点是树的根结点，无父
结点。
当i≤N时i单元是其左孩子；否则无左孩子。
当Zi≤N时，i单元是其右孩子；否则无右孩子。
还要特别声明的是，这种下标的简单运算确定父子关系所用的数组起始单元下标是而不
是。
二叉树的链表存储
虽然完全二叉树的顺序存储具有存储空间利用率高、计算简单的双重优点，但它并不适合于
一般的二叉树。比如图是一个二叉树及其他的顺序存储结果。
二 叉 树
A
A
B ◎ B O
M
M
C
a二叉树 b对应a的完全二叉树
数据 A B 人 入 M 入 入 入 入 入 入
c
编号
C顺序存储结果
图 一般二叉树的顺序存储
图a为给定的二叉树。图b给出了从上至下、从左至右的层序存储的对应
结点编号，其中灰色结点是为了满足顺序存储要求而增加的“虚”结点，可以在相应的存储单
元存放一个特殊的数值，以区别于其他“实结点”。图c则是最终的存储结果。可以看
到，个结点的二叉树，顺序存储需要个存储单元，超过一半的存储空间浪费掉了。更有甚
者，对一个深度为k的右斜二叉树来讲，需要个存储单元，而实际上该斜二叉树只有k个
结点。
另外，二叉树的顺序存储方式避免不了顺序存储的固有缺点，即不易实现增加、删除操作。
因此，二叉树的顺序存储方式适用于一定的条件，对于不需要修改的完全二叉树，是一种较好的
选择。
实际上，二叉树的最常用表示方法是用链表表示，每个结点由数据和左右指针三个数据成员
组成如图所示代码为其结构定义。
typedef struct TNodePosition
typedef Position BinTree二叉树类型·
struct TNodel树结点定义
ElementType Data结点数据
BinTree Left 指向左子树
BinTree Right指向右子树
I
代码 二叉树的链表结构
第章 树
Left Data Right Data
Left Right
图 二叉树结点结构
其中，Data域表示这个树结点的数值，Left 域代表指向本结点的左子树根结点的指针，Right是其
右子树根结点的指针。例如，图a为一棵二叉树，图b是其链表表示的实现。
A A
B C B C
D F G ① AD 入 F A A G A I A
E H A E 入 A H A
a b
图 树的链表实现
虽然在图a中每条连线上没有用箭头指定方向，但各连线仍然是有向的，其方向隐含
从上而下，即连线的上方结点是下方结点的父结点或称为“前驱结点”下方结点是上方结点的
子结点或称为“后继结点”。
二叉树的操作
首先我们给出二叉树的抽象数据类型定义。
类型名称：二叉树BinTree
数据对象集；一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根结点和其左、
右二又子树组成。
操作集：对于所有BT ∈BinTree重要的操作有：
bool IsEmptyBinTree BT若BT为空返回true否则返回 false
void TraversalBinTree BT二叉树的遍历，即按某一顺序访问二叉树BT中的每个结点
仅一次：
BinTree CreatBinTree创建一个二又树。
判断二叉树是否为空是比较简单的事。下面我们着重介绍遍历和创建二叉树的操作。
二叉树的遍历
树的遍历是指访问树的每个结点，且每个结点仅被访问一次。访问是一个抽象的概念，实际
二 叉 树
上可以是对结点数据的各种处理，比如输出结点信息。二叉树的遍历可按二叉树的构成以及访
问结点的顺序分为四种方式，即先序遍历、中序遍历、后序遍历和层序遍历。
前三种顺序的命名是依据一个结点和其左右子树被访问的先后次序。我们用L、V和R分
别表示遍历左分支L、访问结点V和遍历右分支R那么可以有六种不同的访问顺序，它们
是LVR、LRV、VLR、VRL、RVL和RLV。若再规定对某一结点左子树的遍历总是在右子树之前，
则只要考虑三种次序的遍历，即LVR、LRV和VLR。按V的位置，它们分别代表中序遍历、后序
遍历和先序遍历。这三种遍历的区别在于同一结点在不同时刻访问，在其各自的遍历结果序列
中位置不同。
中序遍历。
它是指对树中任一结点的访问是在遍历完其左子树后进行的，访问此结点后，再对其右子树
遍历。遍历从根结点开始，遇到每个结点时，其遍历过程为：
①中序遍历其左子树；
②访问根结点；
③中序遍历其右子树。
这个过程用递归可以很方便地实现，如代码所示。在此函数中，“访问结点”定义为用
屏幕输出结点的数据。在实际应用中，读者可以根据自己的需要另外定义“访问结点”函数。
void InorderTraversalBinTree BT
ifBTI
InorderTraversalBTLeft
此处假设对BT结点的访问就是打印数据
printfBTData假设数据为整型
TnorderTraversalBTRight
代码 二叉树中序遍历
如果从非递归的角度理解，遍历实际上是从树根结点开始，沿其左孩子域向下移动，直到某
一结点再无左孩子为止，访问这个最左边的结点，接下来再从此结点的右孩子结点开始进行中序
遍历，当右子树遍历完了以后，退回到上一层的未访问结点继续二叉树的遍历，直到树中所有的
结点被访问到为止。
在图的举例中，标注出了二叉树中序遍历算法的执行过程及其输出结果。其中，图
a从根结点开始，在每条边旁的灰色箭头表示算法执行过程中沿各结点指针的探索过程，
而各结点旁的带数字的黑底色圆框给出了结点输出的时刻和顺序。图b列出了最终的输
出结果。
第章 树
A
B
② D B E F A G H C I
D F G ①
E H
a b
图 二叉树中序遍历过程及其结果举例
先序遍历。
它是指对结点的访问是在其左、右子树遍历之前进行的。遍历是从根结点开始，遇到每个结
点时，其遍历过程为：
①访问根结点；
②先序遍历其左子树；
③先序遍历其右子树。
递归实现由代码给出。
void PreorderTraversalBinTree BT
ifBT
printfdBTData
PreorderTraversalBTLeft
PreorderTraversalBTRight
代码 二又树先序遍历
同中序遍历的举例类似，图中，标注出了先序遍历二叉树的具体过程和遍历结果。
A
B
A B D F E C G H I
D
④ F G ①
E ⑧ H
a b
图 二叉树先序遍历过程及其结果举例
二 叉 树
后序遍历。
它是指结点左右子树的遍历先进行，然后才是对此结点的访问。后序遍历则是从根结点开
始，遇到每个结点时，其遍历过程为：
①后序遍历其左子树；
②后续遍历其右子树；
③访问根结点。
递归实现由代码给出。
void PostorderTraversaIBinTree BT
fBT
PostorderTraversalBTLeft
PoatorderTraversalBTRight
printfdBTData
代码 二叉树后序遍历
在图的举例中，我们标注出了后序遍历二叉树的具体过程和结果。
A
B④ C
D E F B H G I CA
D F G ①
Q
E ⑥ H
a b
图 二叉树后序遍历过程及其结果举例
二叉树的非递归遍历。
上面给出的二叉树先序、中序和后序三种遍历算法都是递归算法。但是，并非所有程序设计语
言都支持递归；另一方面，递归程序虽然简洁，但程序执行效率不高——从代
码与代码的运行比较就可以看出。因此，就存在如何把一个递归算
法转化为非递归算法的问题。下面，我们再分析、概括一下种遍历方法的具
体过程，在此基础上将给出解决这个问题的方法。
从二叉树先序、中序和后序遍历的遍历过程图、图和图
所标示出的遍历路径来看，都是从根结点A开始的，且在遍历过程中经过
结点的路线是一样的，只是访问各结点的时机不同而已。在图中，我
微视频
二叉树的遍
历路线
第章 树
们用一围绕此树的连续曲线表示出这一遍历路线，路线从根结点左外侧入口处开始，由根结点右
外侧出口处结束。并在从人口到出口的曲线上用、☆和△三种符号分别标记出了先序、中序和
后序遍历各结点的时刻。沿着该路线按标记的结点读得的序列为先序序列，按☆标记读得的
序列为中序序列，按△标记读得的序列为后序序列。
入口 出口
×
A
B △
D F
×
E H
图 二叉树遍历路线示意图
注意到，这一路线正是从根结点开始沿左子树深入下去，当深入到最左端，无法再深人下去
时，则返回刚才深入时遇到的结点，再逐一进入其右子树，进行如此的深入和返回，直到最后从根
结点的右子树返回到根结点为止。先序遍历是在深入时遇到结点就访问，中序遍历是在从左子
树返回时遇到结点访问，后序遍历是在从右子树返回时遇到结点访问。
在这一过程中，返回结点的顺序与进入结点的顺序相反，即后进入先返回，正好符合堆栈结
构后进先出的特点。因此，可以借助于堆栈来实现这一遍历路线。其过程如下。
在沿左子树深人时，进入一个结点就将其压人堆栈。若是先序遍历，则在入栈之前访问之；
当沿左分支深人不下去时，则返回，即从堆栈中弹出前面压入的结点；若为中序遍历，则此时访问
该结点，然后从该结点的右子树继续深入；若为后序遍历，则将此结点二次入栈，然后从该结点的
右子树继续深入，与前面类同，仍为进入一个结点入栈一个结点，深入不下去再返回，直到第二次
从栈里弹出该结点，才访问之。
因此，按照上述描述过程，使用堆栈可以直接实现相应的非递归算法。先序和中序算法相对
简单些，而后序遍历因为需要两次将一个结点入栈，情况相对复杂些。这里，我们只以中序遍历
为例，介绍二叉树遍历的非递归算法。
在按中序遍历二叉树时，遇到一个结点，就把它压栈，并去遍历它的左子树；当左子树遍历结
束后，从栈顶弹出这个结点并访问它，然后按其右指针再去中序遍历该结点的右子树。代码
列出了实现二叉树的非递归中序遍历的算法。
void InordorTraversalBinTree BT
BinTree T
Stack sCreatestack人创建空堆栈S元素类型为BinTree
二 叉 树
TBT从根结点出发
whileT ⅡISEmptyS
whileT一直向左并将沿途结点压人堆栈
PushsT
TTLeft
TPopS· 结点弹出堆栈·
printfdTData访问打印结点
TTRight 转向右子树
代码 二叉树非递归中序遍历算法
层序遍历。
除了先序、中序和后序三种基本的二叉树遍历方法外，有时还用到二叉树的层序遍历。层序
遍历是按树的层次，从第层的根结点开始向下逐层访问每个结点，对某一层中的结点是按从左
到右的顺序访问。因此，在进行层序遍历时，完成某一层结点的访问后，再按它们的访问次序依
次访问各结点的左右孩子，这样一层一层进行下去，先遇到的结点先访问，这与队列的操作过程
是吻合的。具体的算法实现可以设置一个队列结构，遍历从根结点开始，首先将根结点指针入
队，然后开始执行下面三个操作：
①从队列中取出一个元素；
②访问该元素所指结点；
③若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。
不断执行这三步操作，直到队列为空，再无元素可取，二叉树的层序遍历就完成了。代码
为二叉树层序遍历算法。
void LevelorderTraversalBinTreeBT
IQueue Q
BinTree T
ifBTreturn若是空树则直接返回
QCreatQueue创建空队列Q
AddQQBT
whileISEmptyQ
TDeleteQQ
printfTData 访问取出队列的结点
第章 树
ifTLeftAddQQTLeft
ifTRight AddQQTRight
代码 二叉树的层序遍历算法
仍然以图中的二叉树为例，执行层序遍历算法得到的输出序列为ABCDFGI
EH。
例输出二叉树中的所有叶结点。
输出二叉树中的叶子结点与输出二叉树中的结点相比，它是一个有条件的输出问题。唯一
的区别就是执行“访问结点”的时候，先对该结点进行检测，看它是否是叶子结点，也就是看它的
左右子树是否都为空。所以只要在二叉树的遍历算法中增加检测条件就可以了。代码所示
的叶子结点输出算法是在代码的二叉树先序遍历算法基础上修改的。
void PreorderPrintLeavesBinTree BT
ifBT
ifBTLeft BTRight如果BT结点是叶子
printfdBTData
PreorderPrintLeavesBTLeft
PreorderPrintLeavesBTRight
代码 二叉树叶结点输出算法
例求二叉树的高度。
我们知道一棵二叉树的高度Height是其根结点的高度，而根结点的高度则是其左子树高
度H和右子树高度H两者中的最大值加如图所示。因此可采用二叉树遍历的原
理，递归地计算出二叉树的高度。由于要获得根结点的高度，首先要获得其左右子树的高度，所
以需要利用后序遍历。代码就是根据代码改编而来。注意：根据定义，叶结点高度为
所以空树的高度为。
H 李树 右子树 H
图 二叉树高度示意图
二 叉 树
int GetHeightBinTree BT
int HLHRMaxH
ifBT
HLCetHeightBTLeft求左子树的高度
HRGetHeightBTRight求右子树的高度
MaxHHLS HRHLHR 取左右子树较大的高度
returnMaxH 返回树的高度·
else return 空树高度为
代码 求二叉树高度算法
例 表达式树及其遍历。
为了加深对二叉树遍历的理解，我们先介绍表达式树，再将其作为二叉树的一个具体的应用
看一下不同遍历的实现。
在节我们介绍了利用堆栈进行表达式求值，知道一个表达式是由一系列运算符号和运
算数组成的。为方便起见，我们只考虑二元运算，即一个运算符作用于两个运算数，比如：abc
defg此表达式有加法和乘法两种二元运算符，以及ag等个运算数。这种一个运算符
夹在两个运算数中间的表达形式称为中缀表达式。
由于每个运算符完成两个运算数的算术运算，因此用二叉树表示表达式是合适的。图
是这个表达式的二叉树表示形式，树的叶结点是运算数，可以是常数或变量名；树的非叶结点是
运算符。
如果以图的表达式树为实参调用二叉树遍历函数InorderTraversal代码、Preorde rTraversal代码和PostorderTraversal代码将会分别得到不同的遍历序列，输出结果
为：abcdefg、abcdefg和 abcdefg。
从表达式树的种遍历可以得到种不同的访问
结果，基本对应于中缀表达式、前缀表达式和后缀表达
式。注意，由于不同运算存在优先级，表达式树的中序
遍历结果并不一定是表达式所对应的中缀形式如图
a
就是这样的情况。不过，只要做个简单的处理就
能正确输出中缀表达式请想想怎么做提示：加括
号。实际上，有了表达式树后可以按照后缀遍历直接
计算表达式。
C
①
e
图 表达式树
第章 树
例由两种遍历序列确定二叉树
从前面讨论的二叉树的遍历知道，任意一棵二叉树结点的先序遍历序列和中序遍历序列都
是唯一的。反过来，若已知结点的先序遍历序列和中序遍历序列，能否确定一棵二叉树这样确
定的二叉树是否是唯一的
分析根据定义，二叉树的先序遍历是先访问根结点，其次，再按先序遍历方式遍历根
结点的左子树，最后，按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一
个结点一定是二叉树的根结点。另一方面，中序遍历是先遍历左子树，然后访问根结点，最后
再遍历右子树。这样，根结点在中序遍历序列中必然将其分割成两个子序列，前一个子序列
是根结点的左子树的中序遍历序列，而后一个子序列是根结点的右子树的中序遍历序列。根
据这两个子序列，在先序序列中找到对应的左子序列和右子序列，如图所示。在先序序
列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。
这样，就确定了二叉树的个结点。同时，左子树和右子树的根结点又可以分别把左子序列
和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵
二叉树。
根结点 左子树 右子树 左子树 根结点 右子树
a先序序列 b中序序列
图 先序遍历序列和中序遍历序列的关系
同样的道理，由二叉树的后序遍历序列和中序遍历序列也可唯一地确定一棵二叉树。因为，
依据后序遍历和中序遍历的定义，后序序列的最后一个结点根结点就如同先序序列的第一
个结点一样，可将中序序列分成两个子序列，分别为这个结点的左子树的中序遍历序列和右子树
的中序遍历序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列。如此递归下去，当
倒着取尽后序序列中的结点时，便可以得到一棵二又树。
例如，已知一棵二又树的中序遍历结果为cbedahgijf后序遍历结果为cedbbjigfa图画
出的就是这两个遍历序列所确定的二叉树。
从后序遍历结果可以知道最后一个访问的结点是a可推出该二叉树的根结点是a那么中
序遍历在a之前的结点序列cbed构成a结点的左子树，在其后的结点序列hgijf则构成a的右子
树，可以得到图a的结果。
分析a的左子树，子序列cbed后序遍历时，b是最后访问到的结点，可以断定它是a的左子
树的根结点，中序遍历在b之前的结点c构成其左子树，中序遍历在b后的结点序列ed构成了b
的右子树，此时可以得到图b的结果。
分析b的右子树，结点 ed在后序遍历序列中d排在e之后，d是此右子树的根结点，在中序
二叉 树
遍历序列中e排在d之前，说明e是d的左子树结点，由此得到图c的结果。
此时根结点的左子树已完全画出，用同样的方法分析根结点a的右子树，就可以得出最终的
图d所示的结果。
a
a hgijt
cbed hgijD C ed
a b
a
a b
b hgijf
④ C h ①
①
c d
图 用中序和后序遍历序列构造其二叉树
二叉树的创建
由于树是非线性结构，创建一棵二叉树必须首先确定树中结点的输入顺序，常有的方法是先
序创建和层序创建两种。
层序创建所用的结点输入序列是按树的从上至下从左到右的顺序形成的，各层的空结点输
入数值。在构造二叉树过程中，需要一个队列暂时存储各结点地址，其创建过程如下。
输入第一个数据：
● 若为表示是此树为空，将空指针赋给根指针，树构造完毕；
● 若不为动态分配一个结点单元，并存入数据，同时将该结点地址放入队列。
若队列不为空，从队列中取出一个结点地址，并建立该结点的左右孩子：
●从输入序列中读入下一数据；
若读入的数据为将出队结点的左孩子指针置空；否则，分配一个结点单元，存人所读数
值，并将其置为出队结点的左孩子，同时将此孩子地址入队；
● 接着再从输入序列中读入下一个数据；
若读入的数据为将出队结点的右孩子指针置空；否则，分配一个结点，存人所读数值，并
将其置为出队结点的右孩子，同时将此孩子地址入队。
重复第步过程，直到队列为空，再无结点出队，构造过程到此结束。
第章 树
为了说明如何确定图a所示二叉树的层序输入序列，可对其进行适当改造，添加空结
点灰色结点。图a是改造后的结果，b则是对应的输入序列。
A
B C
D
F
G ①
E H
a根据图a改造后的二叉树
A B c DF GIE H
b输入序列
图 二叉树的生成
代码列出了层序生成二叉树的算法。
typedef int ElementType假设结点数据是整数
define NoInfo 用表示没有结点
BinTree CreatBinTree
ElementType Data
BinTree BTT
Queue QCreatQueue创建空队列·
建立第个结点，即根结点
scanfGData
ifDataNoInfo
八 分配根结点单元，并将结点地址入队
BTBinTreemallocsizeofstruct TNode
BTDataData
BTLeftBTRightNULL
AddQQBT
else return NULL若第个数据就是返回空树
二 叉 树
whileISEmptyQ
TDeleteQQ从队列中取出一结点地址
scanfkdData 读入T的左孩子
ifData NoInfoTLeftNULL
elsel 分配新结点，作为出队结点左孩子；新结点入队·
TLeftBinTreemallocaizeofstruct TNode
TLeftDataData
TSLeftLeftTLeftRightNULL
Addo TLert
scanfdData 读人T的右孩子
ifDataNoInfoTRightNULL
else I分配新结点，作为出队结点右孩子：新结点人队
TRightBinTreemallocsizeofstruct TNode
TRightDataData
TRightLeftTRightRight NULL
AddQQTRight
结束while
return BT
代码 二叉树层序生成算法
下面我们以图为例，由图详细给出执行二叉树层序生成算法的具体过程。
输入序列：ABCDFGEH A
A
a输入A作为根，并入队
输入序列：ABCDFGLEH
A
BC B
A
C
bA出队，输入B作为A的左孩子，并入队：输入C作为A的右孩子，并入队
第章 树
输入序列：ABCDEGEH A
B
B
CDF D F
cB出队，输入D作为B的左孩子，并入队；输入F作为B的右孩子，并入队
输入序列：ABCDFGEH
A
C
B
DF G① ① F G ①
dC出队，输入G作为C的左孩子，并入队：输入I作为C的右孩子，并入队
输入序列：ABCDEGEH
A
B
D F G① D F
eD出队，输入D的左孩子置空：输入D的右孩子置空
输入序列：ABCDEGEH A
B
F
O①E D F G
E
F出队，输入E作为F的左孩子，并入队；输入F的右孩子置空
输入序列：ABCDEGEH
A
B
G ① EH D F G
E
gG出队，输入G的左孩子置空：输入H作为G的右孩子，并入队
G ①
C
①
①
二 叉 树
输入序列：ABCDFGEH
A
B C
① EH D F ①
E H
h出队，输入I的左孩子置空，输入的右孩子置空
输入序列：ABCDEGJEH
A
B
E 日 D F G ①
E H
①E出队，输入E的左孩子置空：输入E的右孩子置空
输入序列：ABCDFGEH
A
B
H D F G ①
E H
H出队，输入H的左孩子置空：输入H的右孩子置空；队列为空，过程结束
图 层序生成二叉树举例
例 表达式树的构造
既然可以用二叉树表示表达式，并且通过二叉树的遍历可以完成表达式的计算，那么如何将
一串字符构成的表达式在内存中以表达式树的形式存放
下面给出的算法实现后缀表达式的二叉树存储。堆栈同样可以在构造表达式树的过程中扮
演十分重要的角色，每次读入表达式的一个符号，如果读入答号是运算数，将其作为单个结点构
造一棵二叉树，并将指向这棵树的指针压入堆栈；如果读入的符号是运算符，从堆栈中弹出两个
元素，连同读入的符号构成一棵新的二叉树，树的根结点存人所读入的运算符，左子树为从堆栈
中后弹出的元素，右子树为先弹出的元素，接下来把指向这棵新的二叉树的指针压入堆栈。重复
这一过程，直到处理完表达式的最后一个符号为止，最后形成的二叉树就是所要求的结果。
我们以上一节所介绍例子的后缀表达式 abedefg为输入，构造其相应的表达式
树，并以图详细列出构造过程。图中的堆栈横着摆放，左侧为栈底位置。
第章 树
abcdefg abcdefg
a C a
a b
abcdefg abedefg
e
a O a ④
C
d e
abcdefg
a ① a
C d e b
g
abedefg
a B
图 表达式树的构造
abedefg
a
b C
c
abedefg
a O ④
b C
t
abedefg
⑧
①
C d e
h
abedefg
⑧
O ①
①
①
二叉搜索树
首先，依次读入三个符号a、b、c都是运算数，构成三棵一个结点的二叉树，并依次将三
棵树的指针压栈，结果如图a所示。
当读入运算符号后，从堆栈中弹出两个元素，与号构成新的二叉树，并将指向它的
指针压栈，结果如图b所示。
当读入后，从堆栈中弹出两个元素，构成新的二叉树，并将指向它的指针压栈，结果如
图c所示。
当读入d、e后，构成二棵单个结点的二叉树，并依次将指向它们的指针压栈，结果如图
d所示。
当读入后，从堆栈中弹出两个元素，与号构成新的二叉树，并将指向它的指针压栈，
结果如图e所示。
当读入符号f后，构成单个结点的二叉树，并将指向它的指针压栈，结果如图f
所示。
当读入后，从堆栈中弹出两个元素，与号构成新的二叉树，并将指向它的指针压栈，
结果如图g所示。
当读入符号g后，构成一个单个结点的二叉树，并将指向它的指针压栈，结果如图
h所示。
当读入后，从堆栈中弹出两个元素，与号构成新的二叉树，并将指向它的指针压栈，
结果如图i所示。
当读入最后一个符号后，从堆栈中弹出两个元素，与号构成新的二叉树，并将指向
它的指针压栈。此时完成了表达式的二叉树存储，结果如图j所示。
二叉搜索树
二叉搜索树的定义
二叉搜索树Binary Search Tree也叫做二叉排序树或二叉查找树，它是一种对排序和查找
都很有用的特殊二叉树。在下面的介绍中，为了方便起见，规定各键值彼此不同。
定义一个二叉搜索树是一棵二叉树，它可以为空。如果不为空，它将满足以下
性质：
非空左子树的所有键值小于其根结点的键值；
非空右子树的所有键值大于其根结点的键值；
左、右子树都是二叉搜索树。
图给出了两棵二叉树。在图a中键值为的结点有一个键值为的右孩子，
这不满足非空右子树键值要大于根结点的性质，因此，它不是二叉搜索树。而图b所示的
第章 树
二叉树是一棵二叉搜索树。由于二叉搜索树具有的左小右大的有序特征，不难看出对它进行中
序遍历，将得到一个从小到大的输出序列。
⑩ ④
⑦ ⑤
a b
图 二叉树与二叉搜索树
二叉搜索树的动态查找
二叉搜索树是施加了一定约束的特殊二叉树，前面介绍的二叉树的表示和操作都可以直接
用于二叉搜索树，比如中序、先序和后序遍历。不同的是，二叉搜索树的查找、插入和删除操作将
与其特性有关，但这些主要是算法实现的不同，而函数原型并没有什么变化。事实上，二叉搜索
树结点的定义与代码给出的普通二叉树完全是一样的，一般用链表存储。
二叉搜索树作为抽象数据结构的定义也与普通二叉树基本相同，只是操作集中多了下列几
个特别的函数：
Position FindBinTree BSTElementType X从二叉搜索树BST中查找元素X返回其所
在结点的地址；
Position FindMinBinTree BST从二叉搜索树BST中查找并返回最小元素所在结点的
地址；
Position FindMaxBinTree BST从二叉搜索树BST中查找并返回最大元素所在结点的
地址。
下面我们就详细介绍这三种操作的实现。
二叉搜索树的查找操作Find
它是指在二叉搜索树中查找关键字为X的结点，返回其所在结点的地址。由于二叉搜索树
的特殊性质，查找可以比较方便地实现。其过程如下。
查找从树的根结点开始，如果树为空，返回NULL表示未找到关键字为X的结点。
搜索树非空，则根结点关键字和X进行比较，依据比较结果，需要进行不同的处理：
①若根结点键字小于X满足条件的结点将不会出现在它的左子树，接下来的搜素只需在
此根结点的右子树中进行；
②如果根结点的键字大于X接下来的搜索将在此根结点的左子树中进行：
③若两者比较结果是相等，搜索完成，返回指向此结点的指针。
显然，在二叉排序树上进行查找，若查找成功，则是从根结点出发走了一条从根到待查结点
二叉搜索树
的路径；若查找不成功，则是从根结点出发走了一条从根到某一叶结点的路径。代码列出
了实现此过程的递归算法。
Position FindBinTree BSTElementType x
ifBSTreturn NULL 查找失败
ifXBSTData
return FindBSTRightx·在右子树中递归查找
else ifXBSTData
return FindBSTLeftX 在左子树中递归查找
elseXBSTData
return BST 在当前结点查找成功，返回当前结点的地址
代码 二叉搜索树的递归查找函数
由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改
为迭代函数——在代码中用while循环替代代码中的Find递归调用即可。
Position FindBinTree BSTElementType x
whileBST
ifXBSTData
BSTBSTRight 向右子树中移动，继续查找
else ifXBSTData
BSTBSTLeft 向左子树中移动，继续查找·
elseXBSTData
break·在当前结点查找成功，跳出循环
return BST 返回找到的结点地址，或是NULL
代码 二叉搜索树的迭代查找函数
查找最大和最小元素
根据二叉搜索树的性质，最小元素一定是在树的最左分支的端结点上。所谓最左分支的端
结点，是指最左分支上无左孩子的结点。而最大元素一定是在最右分支的端结点上。例如图
中的结点和结点分别是最左端点和最右端点。这使得 FindMin和 FindMax较Find函
数更简单，只要从根结点开始，当其不为空时，沿着左分支或右分支逐个判断各结点的指针，
直到遇到空指针为止。从左分支逐层推下来查找到的是最小元素；反之，从右分支找到的是
最大元素。
第章 树
⑩
最左端点 ⑦
一最右端点
⑨
图 二叉搜索树的最左和最右端结点
代码和分别给出了实现查找最小元素的递归函数FindMin和查找最大元素的非
递归迭代函数FindMax。读者可以尝试自己写出这两个函数的迭代和递归版本。
Position FindMinBinTree BST
最小元素在最左端点
ifBSTreturn NULL空的二叉搜索树，返回NULL·
else ifBSTLeftreturn BST找到最左端点并返回
else return FindMinBSTLeft沿左分支递归查找
代码 查找最小元素的递归函数
Position FindMaxBinTree BST
ifBST
whileBSTRight
BSTBSTRight沿右分支一直向下，直到最右端点
return BST
代码 查找最大元素的迭代函数
从上述基于二又搜索树的动态查找我们可以看到，它实现的基本原理与基于线性表的静态
二分查找很相似，都是利用有序性不断地缩小查找空间。而之所以有静态和动态之分主要是为
了适应于不同的应用需求，前者适用于数据一旦建立好，一般不大需要改变，也就是说不需要或
者很少进行删除和插入操作；而后者适用于频繁的数据变化，插入和删除是
其基本的操作。
二叉搜索树的插入
微视频
二又搜素树
的插人
将元素X插人二叉搜索树BST中关键是要找到元素应该插入的位置。
位置的确定可以利用与查找函数 Find类似的方法，如果在树BST中找到
X说明要插人的元素已存在，可放弃插入操作。如果没找到X查找终止
二又搜索树
的位置就是X应插人的位置。
例如要在图a中插人元素先做查找操作。按照上一节介绍的查找算法，查找将终
止在键值为的叶结点处，将元素作为此终止结点的右孩子就完成了新元素的插入，图
b为插人完成后的结果。
S
a b
图 二叉搜索树的插人
代码为实现上述插入算法的函数。
BinTree InsertBinTree BSTElementType X
ifBST若原树为空，生成并返回一个结点的二叉搜索树
BSTBinTreemallocsizeofstruct TNode
BSTDatax
BSTLeftBSTRightNULL
else 开始找要插人元素的位置
ifXBSTData
BSTLeftInsertBSTLeftX递归插入左子树
else ifXBSTData
BSTRightInsertBSTRightx递归插入右子树
else X已经存在，什么都不做·
return BST
代码 二叉搜索树的插入算法
例 以一年十二个月的英文缩写为键值，按从一月到十二月顺序输入它们，即输入序
列为JanFebMarAprMayJunJulyAugSepOctNovDec将产生什么样的二叉搜索树
分析图am给出了从一个结点为空的二叉搜索树逐个插入个结点生成最
终结果树的过程。结点键值的比较是按字符串的字母序进行的。
第章 树
Jan Jan Jan Jan Jan
Feb Feb Mar Feb Mar Feb Mar
Ap APT Ma
a b c d e
Jan Jm
Feb Mar Mar
Ap Jun May Ap Jun May Apr Jun
uly Aug July Sep
g h ⑥
Jan Jan Jan
Feb Mar Feb Mar
Apr
Aug uly
a
Nov Noy
k m
图 二又搜索树的生成过程
二叉搜索树的删除
二叉搜索树的删除操作比其他操作更为复杂，要删除结点在树中的位置决定了操作所采取
的策略。有三种情况需要考虑。
要删除的是叶结点。这种情况最简单，可以直接删除，然后再修改其父结点的指针，置
空即可。图a为删除操作前的情况。图b为删除键值为的叶结点以后的结果，
此时删除结点的父结点右指针为空。图b中结点和其连边变为虚线表示已删除。
二叉搜索树
要删除结点一
a b
图 二叉搜索树叶结点的删除
如果要删除的结点只有一个孩子结点该结点不一定是叶结点，可以是子树的根删
除之前需要改变其父结点的指针，指向要删除结点的孩子结点，图表示了这一过程。图
a为删除操作前的情况。图b为删除键值为的结点以后的结果，此时删除结点
的父结点的左儿子指针指向了删除结点的子结点。删除的结点和其连边用虚线表示。将
图b按二叉树的标准画法重画，得到图c的结果。
要删除结点— ⑤
a b c
图 具有一个子树的结点删除
如果要删除的结点有左、右两棵子树，究竟用哪棵子树的根结点来填充删除结点的位置
这里有两种不同选择，基本原则是要保持二叉搜索树的有序性。一种选择是取其右子树中的最小
元素；另一个是取其左子树的最大元素。无论哪种选择，被选择的结点都必定最多只有一个孩子
为什么请读者思考于是可以调用情况的解决方案删除这个被选择的结点。图是具有两
d
×
a
⑤
×
b c
图 具有两个子树的结点删除
第章 树
个子树的结点删除操作的过程。图a是删除前的情况，要删除的是关键值为的结点，其左
子树中最大值结点是键值为的结点。图b是删除结点被填充后的结果。接下来是要
继续递归删除关键值原来所在结点，这时它只有一个子树，可以采用上面介绍的具有一个子树
的结点删除方法，图c则是最终的结果。图d为按二叉树标准画法重新画出的结果。
代码给出了针对上述三种情况的二叉搜索树删除操作算法。其中，当待删除结点左右都
不空时，采用右子树最小元素的删除替代策略。
BinTree DeleteBinTree BSTElementType x
Position Tmp
ifBST
printf要删除的元素未找到“
else l
ifXBSTData
BSTLeftDeleteBSTLeftx从左子树递归删除
else ifXBSTData
BSTRightDeleteBSTRightX 从右子树递归删除·
如果被删除结点有左右两个子结点·
ifBSTLeft BSTRight
从右子树中找最小的元素填充删除结点
TmpPindMinBSTRight
BSTDataTmpData
· 从右子树中删除最小元素
BSTRight DeleteBSTRightBSTData
E
elsel 被删除结点有一个或无子结点·
TmpBST
fBSTLeft 八只有右孩子或无子结点
BSTBSTRight
else x只有左孩子
BSTBSTLeft
freeTmp
return BST
else BST就是要删除的结点·
代码 二又搜索树的删除算法
平衡二叉树
平衡二叉树
对于二叉搜索树进行查找的时间复杂度是由查找过程中的比较次数来衡量的，比较是从根
结点到叶结点的路径进行的，它取决于树的深度。树深在最好的情况下是logN所以，二叉
搜索树在最好情况下的查找复杂度是logN。但这一结论是由“最好情况”——即“完全二叉
树导出的，事实上，N个结点的二叉树深度取决于其树枝的分布情况。当二叉树退化成为一棵
单枝树的极端情况下，查找的复杂度将是线性的N。
假定二叉搜索树中每个结点的查找概率都是相同的，我们称查找所有结点的比较次数的平
均值为树的“平均查找长度”Average Search LengthASL。图为三棵二叉搜索树，结点的
关键值是一年中的某一月份，三棵树都是采用二叉搜索树的插入操作逐点生成的，只是输入的顺
序不同。其中图a是按一月到十二月的自然月份序列输人所生成的，图b的输入
序列为JulyFebMayMarAugJanAprJunOctSeptNovDec而图c的输入序列则
是按月份字符串从小到大的顺序排列的。从图中我们知道，图a的深度为图
b的深度为图c是一棵斜二叉树，深度达到最高的。
按ASL的定义，可以分别计算出三棵二叉搜索树的平均长度：
ASLa×××××
ASLb×××
ASLe×××××××××××
Jan
Apr
Feb Mar July
Apr Jun Feb May Aug
Aug luly Aug Jan Mar Oct
Dee Apr Dec Jun Nov Sep
No
a b c
图 不同输入顺序生成的三棵二叉搜索树
显然，图b是最好的情况，其ASL和 logN成正比，而图c是最坏的情形，它已
退化成线性表。上述ASL的计算结果表明，一棵树的ASL值越小，它的结构越好，与完全二叉树
第章 树
越接近，对它的查找时间复杂度也越接近logN。因此，为了保证二叉搜索树查找的对数级时
间效率，应尽可能创建枝繁叶茂的树，而避免树枝过长、过少。
最好的树结构当然是满二叉树，它是从根到叶的各条路径长都相同的，我们称这种树是完全
平衡的。但是，通常情况下二叉搜索树的结点插入顺序并不是事先确定的，动态查找在查找的
同时要进行插入和删除总是要改变树的结构，不可能做到完全平衡。所以，需要考虑如何解决
既能保证插入和删除正常进行又能保持二叉搜索树的查找性能不退化、尽可能地接近平衡的问
题。这样就有两个问题需要解决，其一是，确定一个“接近平衡”的标准；其二是，如何在动态查
找过程中进行“平衡化”处理，使之保持平衡。
平衡二叉树的定义
平衡二叉树Balanced Binary Tree又称为AVL树，是最早被提出的自平衡二叉搜索树，得
名于它的发明者GMAdelsonVelsky和EMLandis他们在年发表的论文 An algorithm for
the organization of information 中描述了它。AVL树的插入、删除、查找操作均可在logN时间
内完成。
定义AVL树或者是一棵空树，或者是具有下列性质的非空二叉搜索树：
任一结点的左、右子树均为AVL树；
根结点左、右子树高度差的绝对值不超过。
在图的三棵二叉搜索树中，只有中间的图b满足上述性质，是AVL树，而图
a和c都不是。
定义对于二叉树中任一结点T其平衡因子Balance FactorBF定义为BFThhg
其中h和hg分别为T的左、右子树的高度。
有了平衡因子的定义，AVL树“任一结点左右子树高度差的绝对值不超过”这一性质可以
表述为“一棵AVL树中任一结点的平衡因子只能在集合中取值”。这就是平衡的量化
标准。
平衡二叉树的调整
当向一棵AVL树中插入新的结点时，该结点的平衡因子很可能不在上述集合范围内，破坏
了树的平衡，这时就需要做“平衡化”处理，即相应的局部“旋转”调整，使得调整后的树达到
平衡。
单旋调整
下面仍以月份关键字为例，向一棵初始为空的二叉搜索树中顺次插入 Mar 、May 、Nov
其结果如图a—e所示。各结点的平衡因子分别标于结点顶端。每当AVL树中
插人一个新结点时，其插人路径上各结点的平衡因子都需做自底向上重新计算，以判断树
是否平衡。
平衡二叉树
Mar Mar May
Mar Ma May
Mar Nov
Nov
a b d
图 右单旋示例
问题出现在第个结点Nov的插人之后见图c所示此时根结点 Mar的平衡因子为
标识出树的不平衡。解决方法是将树做逆时针旋转，如图d中箭头所示，以达到平衡状态。
我们以图 为例，概括上述不平衡的调整过程的一般规律。图
a为新结点C插入之前的AVL树的构成情况，结点A的平衡因子为
其右孩子结点B的平衡因子为结点C将要插入B的右子树B中。
插入结点C后，重新计算相关结点的平衡因子，此时，结点A的平衡因子为
它的右孩子结点B的平衡因子为如图b所示。此时，可以看 平衡二叉树 到被插入结点C产生问题结点、发现问题的结点A以及它们之间路径上 的RR调整
的结点B三个结点向右排成一线，我们称这种右子树的不平衡状态为RR
………
向右倾斜型不平衡。RR不平衡的调整策略是通过逆时针旋转相关结
微视频
点，将B置于A的位置，A置为B的左子结点，C所在子树仍为B的右子树。若B原有左子树，
则将其左子树置为A的右子树。这个调整过程称为“右单旋”。经过右单旋调整后的平衡结构
和结点的平衡因子如图c所示。需要强调的是A不一定是根结点，它是距离产生问题结
点最近的且平衡因子大于或小于的结点。
L A
右单旋
A B
B B A
AL A BR
B BR B BR AL B C
C
a原AVL树 b插入C以后 c调整后的AVL树
图 右单旋示意图
用类似的方法我们可以判断与RR型相对称的LL型不平衡，并用“左单旋”处理产生这种向
左倾斜的不平衡。
第章 树
图列出了向图d所示的树中插人 Aug和Apr两个结点的调整过程。Aug结点
插入并没有破坏树的平衡，各结点的平衡因子如图a所示。而图b为插入结点Apr
后各结点平衡因子的变化情况，虽然May和Mar的平衡因子都超出了AVL树所允许的范围，但
因为平衡因子是自底向上调整的，故Mar是第一个发现问题的结点。旋转调整时只需考虑由
Mar、Aug、Apr三个结点构成的局部子树，顺时针旋转后的结果如图c所示。
May
May
May
Mar Nov Mar Nov
Aug
Nov
Aug Aug Apr
Mar
Apr
a b c
图 左单旋示例
图列出了一般情况下的左单旋过程。图a是插人结点C之前的情形，图
b为插人C后引起不平衡的情况，发现不平衡的是结点A新结点C是插入在A的左孩子
B的左子树中，三个结点向左排成一线，称其为LL向左倾斜型不平衡。左旋调整后，结点A变
成结点B的右孩子，B原来的右子树将作为A的左子树，调整后的结果如图c所示。
L
A A
左单旋 L
B
◎
B B
A
Ap A
B
B Bp BL BR C BR AR C
a原AVL树 b插入C以后 C调整后的AVL树
图 左单旋示意图
双旋调整
继续向图c的树中插入结点 Jan并自底向上计算平衡因子，得到图a所示的
结构。此时根结点May的平衡因子为是首先发现问题的结点，产生问题的新结点Jan位于其
左子结点Aug的右子树中。与上述单旋调整的LL型和RR型不平衡不同的是，三个相关结点
的倾斜是“先左后右”的排列形式，我们称其为LR型不平衡。解决LR型不平衡问题的办法是做
“左右双旋”结果如图b所示。
平衡二叉树
May Mar
Aug Nov
Aug
May
Apr Mar
Apr Jan Nov
Jan
a b
图 左右双旋示例
下面以图为例说明调整LR型不平衡的规律。一般情况下，若产生问题的结点D在发
现问题的结点A的左子结点B的右子树以C为根结点中，称为LR型不平衡，如图b所
示。调整是将C置于A的位置，A及其右子树调整为C的右子树。原C的左子树将作为B的右
子树，而原C的右子树则作为A的左子树，如图c所示。
左右双旋 A A
B
B
或 或
B A
或
C
AR Ag c CR
B CL Cr D B c Cr B D D Ag
或 ① ① 或
或
a原AVL树 b将D插入C的左子树或右子树 c调整后的AVL树
图 左右双旋示意图
之所以称为“左右双旋”是因为调整过程相当于先对以B为根结点的子树做了一次右单
旋，再对以A为根结点的子树做了一次左单旋，是两次单旋的合成结果。图是与图
左右双旋等价的两次单旋合成的过程示意图，图a为出现LR不平衡时的树结构，图
b和图c是右单旋和左单旋调整后的结果。实际上，下面将给出的AVL树插入算
法就是采用两次单旋策略实现LR和RL型不平衡调整的。
用完全对称的方式可以用“右左双旋”来处理RL型不平衡。图列出了向图b
中依次插入 Dec、July和Feb三个结点的调整过程。插入前两个结点后并没有破坏AVL树的平
衡如图a和图b所示。但当插入第个结点Feb之后，在引起和发现不平衡结点
Feb和Aug之间形成了“先右后左”的不平衡，如图c所示。图d为调整后的结果。
第章 树
A
右单旋 A
左单旋 L
C
或 B C
或 B
或 A
C B
Ag cR A c C
B c Ca c ① B ① ① Ag
① D B ① 或
或
aLR型不平衡 b先右单旋调整后的AVL树 c再左单旋调整后的AVL树
图 左右双旋等价的两次单旋示意图
Mar Mar
Aug May Aug May
Apr Jan Nov Apr Jan Nov
Dee Dec July
a插入Dee b插入July
Mar Mar
Aug May Dee
May
Apr Jan No
Aug Jan Nov
Dee July
Apr Feb July
Feb
c插入Feb d右左双旋
图 右左双旋示例
图列出了一般情况下的“右左双旋”过程。产生问题的结点D在发现问题的结点A
的右子结点B的左子树以C为根结点中，称为RL型不平衡。则调整的结果将是C置于A的
位置，A及其右子树调整为C的左子树，原C的左子树将作为A的右子树，而原C的右子树则作
为B的左子树。
平衡二叉树
A
右左双旋
L A
或 C
B
B
或 A
或 B
C
AL c ca
A
c Ca Bg A ① BR
D c Ca Bg ① 或
或 或
a原AVL树 b将D插入C的左子树或右子树 c调整后的AVL树
图 右左双旋示意图
上面介绍了AVL树插入过程中可能出现的LL、RR、LR、RL四种不平衡情况及其相应的旋
转调整方法。AVL树的插入操作用非递归算法实现一般比用递归实现快，然而程序可读性却差
很多，很容易写错，故通常都用递归算法来实现插入操作。
AVL树的数据结构中除了一般二叉树的数据成员外，还需附加平衡信息。代码实现
了AVL树的插入操作，在函数描述中，我们假设结点的附加信息为以该结点为根的子树的高度，
定义为整型的Height。当然，也可以用平衡因子BF取代 Height。代码中Maxab函数返
回a和b中较大整数。另外还用到函数GetHeightT其功能是获得树T的高度。代码给
出了该函数递归求解的版本，但在这里可简化为直接访问结点结构中的Height 值。
typedef struct AVLNode Position
typedef Position AVLTree AVL树类型·
typedef struct AVLNodel
ElementType Data结点数据·
AVLTree Left 指向左子树
AVLTree Right 指向右子树·
int Height 树高
I
int Maxint aint b
return abab
AVLTree InsertAVLTree TElementType x
第章 树
将X插入AVL树T中，并且返回调整后的AVL树
TAVLTreemallocsizeofstruct AVLNode
TDataX
THeight
TLeftTRightNULL
Eif插入空树结束
else ifXTData
插入T的左子树
TLeftInsertTLeftX
如果需要左旋
ifGetHeightTLeftGetHeightTRight
ifXTLeftData
TsingleLeftRotationT 左单旋
else
TDoubleLeftRightRotationT左右双旋
Felse if插入左子树结束
else ifXTData
插人T的右子树
TRightInsertTRightX
如果需要右旋
ifGetHeightTLeftGetHeightTRight
ifXTRightData
TsingleRightRotationT右单旋
else
TDoubleRightLeftRotationT右左双旋
else if插人右子树结束
else XTData无需插入·
别忘了更新树高
THeightMaxGetHeightTLertGetHeightTRight
return T
ifT若插入空树，则新建包含一个结点的树
代码 AVL树的插入操作
树的应 用
代码和代码分别为左单旋和左右双旋调整算法。
AVLTree SingleLeftRotationAVLTree A
注意：A必须有一个左子结点B
·将A与B做如图所示的左单旋，更新A与B的高度，返回新的根结点B
AVLTree BALeft
ALeftBRight
BRightA
AHeightMaxGetHeightALeftGet HeightARight
BHeightMaxGetHeightBLeftAHeight
return B
代码 左单旋算法
AVLTree DoubleLeftRightRotationAVLTree A
注意：A必须有一个左子结点B且B必须有一个右子结点C
将B与C做右单旋，C被返回
ALeftSingleRightRotationALeft
将A、B与C做如图所示的两次单旋，返回新的根结点C
将A与C做左单旋，C被返回
return singleLeftRotationA
代码 左右双旋算法
树的应用
堆及其操作
在第章中，我们介绍过队列，知道它的一个基本特征是“先进先出”或者说是“先来先服
务”队列中的元素没有哪个是可以有特权的，前面的元素未处理完，后面的只能等待。
但在现实世界中，许多情况需要有特权。比如，有许多客户在一个打印店排队等待打印资
料，某一个客户需要打印数百页的一本书，而排在他后面的客户只需打印两页的一份简历表。我
第章 树
们不妨把前者称为大作业，而后者称为小作业。这时小作业客户对店主和大作业客户提出是否
可以先为他打印两页的简历，也就是说是否允许他“插队”。遇到这种情形，店主和大作业客户
往往能接受小作业客户的请求。此时，违背了队列先来先服务的策略，是一种称为“小作业优
先”的排队策略。本节介绍的“堆”Heap正是考虑了适合于特权需求的数据结构，因此，堆也
通常被称作为“优先队列”Priority Queue。
堆的定义和表示
堆是特殊的队列，从堆中取出元素是依照元素的优先级大小，而不是元素进入队列的先后
顺序。
我们当然可以用简单的线性数组或者链表来实现有N个元素的优先队列：
如果使用数组，插入时可以将新元素放在末尾，时间复杂度只是但是删除需要找
优先级最高的元素，必须遍历全部元素，并且从数组中删除一个元素还涉及其他元素的位置移动
问题，时间复杂度是ON。
如果使用有序数组，可令元素按优先级从低到高排列，这样删除的时候只要删除最后一
个元素即可，复杂度变成问题是插入就变得很麻烦，因为要保证插人后元素还是有序的，
需要用log N的时间找到合适的插入位置，而且在数组中插入新元素必定需要涉及其他元素
的位置移动问题，最坏情况下，时间复杂度仍然是N。
当使用链表时，新元素可插入在链头处，时间复杂度是但删除元素必须遍历全部
元素才能找到优先级最高的那个，虽然找到后删除用时是但总的时间代价仍为ON。
若链表中数据要求有序的话，删除元素代价为而插入变为N。
观察上述种方法，最坏情况下它们的时间复杂度都会达到N。而我们知道，二叉搜索
树的插入和删除操作代价为log N。那么是否可以利用树型结构达到这种性能答案是肯
定的。
堆的最常用结构是用二叉树表示，不特指的话，它是一棵完全二叉树。因为高度为h的
完全二叉树有结点到个且结点排布极其规律，因此，通常不必用指针，而是用数组
来实现堆的存储。图上半部分为堆的完全二叉树的表示，而下半部分方格代表其数组
存储实现。
a
C
d e ① B
①
a b d f b i
图 堆的完全二叉树表示及其数组存储
树的应 用
对照图上下两部分，可以看出，堆中的元素在数组中是按完全二叉树的层序存储的，根
结点存放在数组的起始处，接着是其子结点，一层层下去，直到最后一个结点。还要特别提醒的
是，所用的数组起始单元为而不是通常的从单元开始。这样做的目的是很容易从子结点找
到其父结点，即根据节中顺序存储二叉树的性质，对于下标为i的结点，其父结点的下标
为Li」。反过来，找结点i的左、右子结点也十分方便，分别为i和i。
用数组表示完全二叉树是堆的第一个特性，称为堆的结构特性。堆的另一特性是其部分有
序性，即指任一结点元素的数值与其子结点所存储的值是相关的。相关性的不同决定了两种不
同的基本堆：最小堆MinHeap和最大堆MaxHeap。
在最大堆中，任一结点的值大于或等于其子结点的值。这一性质决定了根结点元素的值在
整个堆中是最大的。
而在最小堆中，任一结点的值小于或等于其子结点的值。那么根结点元素的值是整个堆中
最小的。
需要指出的是，兄弟结点之间并不存在什么约束关系。例如，可能会出现根的左子树各结点
的值都大于右子树所有结点的值的情况。
图为几个堆的实例，为简便起见，堆中元素的键值设为整数。其中图a和b为
最大堆，而c和d为两个最小堆。
② ⑤ ⑦
⑩
⑨③
a b c d
图 最大堆和最小堆
很明显，最小堆和最大堆有各自的用途。当需要小键值优先时，可以使用最小堆；反之，当大
键值优先时，则要使用最大堆。我们下面介绍的内容主要以最大堆为例。
最大堆的操作
根据上面已介绍的最大堆的构成和基本特性，可以用以下抽象数据类型表示最大堆：
类型名称：最大堆MaxHeap
数据对象集：一个有N个元素的最大堆H是一棵完全二叉树，每个结点上的元素值不小
于其子结点元素的值。
操作集：对于任意最多有MaxSize个元素的最大堆H∈MaxHeap元素XeElementType我们
重点关注下列操作：
MaxHeap CreateHeapint MaxSize创建空的最大堆，其最大长度为MaxSize
bool IsFullMaxHeap H判断最大堆H是否已满，若是返回true否则返回false
bool InsertMaxHeap HElementType X将元素X插入最大堆H。若堆已满，返回
第章 树
false否则将数据元素X插入到堆H并返回true
bool IsEmptyMaxHeap H判断最大堆H是否为空，若是返回 true否则返回false
ElementType DeleteMaxMaxHeap H删除并返回H中最大元素。
下面我们就重点介绍堆的创建、插入和删除，以及另外一个特殊的操作：根据给定的N个元
素建立最大堆。
最大堆的创建
用C语言描述堆结构如下：
typedef struct HNode Heap堆的类型定义
struct HNode
ElementTypeData存储元素的数组
int Size 堆中当前元素个数
int Capacity 堆的最大容量
typedef Heap MaxHeap最大堆
typedef Heap MinHeap最小堆
注意到在根据用户输入的MaxSize 建立空的最大堆时，数组应该有MaxSize个元素，因为
数组起始单元为元素是存在第MaxSize个单元中的。通常第个单元是无用的，但是如果
我们事先知道堆中所有元素的取值范围，也可以给第单元赋一个特殊的值MAXDATA这个值
比堆中任何一个可能的元素都要大。至于这个MAXDATA的“哨兵”作用，会在介绍插入操作的
时候提到。
代码给出了创建最大堆的实现。事实上这个程序也同样适用于创建最小堆，只是把
MAXDATA换成小于堆中所有元素的MINDATA即可。
define MAXDATA 该值应根据具体情况定义为大于堆中所有可能元素的值
MaxHeap CreateHeapint MaxSize
创建容量为Maxsize的空的最大堆
MaxHeap HMaxHeapmaloaizeofstruct HNode
HDataElemeneType·mallocMaxSizesizeofElementType
HSize
HSCapacityMaxsize
HDataMAXDATA 定义“哨兵”为大于堆中所有可能元素的值·
return H
代码 最大堆的创建
树的应 用
最大堆的插入
最大堆中插人一个新元素以后，新增结点既要保证最大堆仍是完全二叉树，结点之间元素值
的大小也要满足最大堆的性质，因此，一般情况下要移动元素。是否移动、多少元素要移动，取决
于要插入元素以及最大堆中已有元素数值的大小。
图是一个最大堆插入一个新元素的过程。其中，图a是最大堆的初始情况。当
要插入新元素时，按完全二叉树的性质，增加结点的位置应该是图b中用灰色结点表示的
最后一个结点。
当插入的元素值小于时，新增结点处就是要插入元素的正确位置。图c表示插入
元素黑色结点值为的结果。
当插入元素值大于但小于时，元素下移到新增结点，在空出的位置处插入新元
素。图d表示插入元素值为的结果。
当插入元素值大于时，元素和元素依次下移一层，在最后空出的根结点位置处插
入新元素。图e表示插入元素值为的结果。
⑩ ⑩
、
a b
⑩ ⑩ ⑩
c d e
图 最大堆的插入
由图列出的几种可能的插入结果可知，完成一个元素的最大堆插入操作，只要从完全
二叉树的新增结点开始，顺着其父结点到根结点的路径，将路径上各结点依次与新元素值进行比
较，当一结点的值小于新元素的值，就下移这个结点的元素，直到有结点的值大于新元素的值或
根结点也下移为止，空出的结点位置就是新元素插入点。插入过程也可以用一句话简单描述：从
新增的最后一个结点的父结点开始，用要插入的元素向下过滤上层结点。实际上，由于堆元素之
间的部分有序性，最大堆从根结点到任何叶结点的路径都是递降的有序序列。插入过程的调整
第章 树
就是继续保证这个序列的有序性。
代码给出了最大堆的插入操作算法。注意到如果新插入的X比原来堆中所有的元素
都大，那么它将一直向上比较到根结点都不会停止。对于这种情况，我们可以加一个特殊判断，
当i取值为时，直接跳出 for循环，但是这种程序不够优美。在代码中我们定义了一个
“哨兵”即如果我们事先知道堆中所有元素的取值范围，可以给HData赋一个特殊的值
MAXDATA这个值比堆中任何一个可能的元素都要大，这样当i为时，HDataiX这
个条件肯定不满足，就可以自然跳出循环了。
boo IBFullMaxHeap H
returnHSizeHCapacity
bool InsertMaxHeapHElementType x
将元素X插入最大堆H其中HData已经定义为哨兵
int i
ifISFuH
printf最大堆已满
return false
iHSizei指向插入后堆中的最后一个元素的位置·
forHDataixi
HDataHDatai 上滤X·
HDataix·将X插入·
return true
代码 最大堆的插入操作
最大堆的删除
最大堆的删除实际上是取出根结点的最大值元素，同时删除堆的一个结点。与插人操作类
似，删除操作后，最大堆仍然要是完全二叉树，结点元素值的大小仍然要满足最大堆的性质。因
此，删除的结点应该是数组的最后一个单元。那么取走根结点的元素后，堆的最后一个结点必
须重新放置。确定最后一个结点的元素放到哪个结点中去是最大堆删除操作的关键所在。
图是一个最大堆删除操作的过程。其中，图a是最大堆的初始情况。当取出根
结点的元素后，要删除的结点应该是图b中用灰色表示的最后一个结点。删除结点的
元素能放到空的根结点处吗从图c看，显然不行，因为其右子结点的值大于。
树的应 用
要保持最大堆的性质，只能上移元素，得到图d的中间结果。此时，空出的结点位置为
存放删除结点元素的正确位置，图e为最终结果。
②
⑩ ⑩
a b
⑩ ⑩ ⑩
③
c d e
图 最大堆的删除
从图列出的最大堆删除过程可以看到，将删除结点数组中最后一个元素单元的元
素作为假设的根结点，依次与其下层的子结点进行比较，如果小于子结点的元素值，从两个子结
点中选择值大的元素上移一层，直到在某一点上，比较结果是大于两个子结点的值，此时的空结
点就是要放置删除结点元素的正确位置。删除过程也可以用一句话简单描述：从根结点开始，用
最大堆中的最后一个元素向上过滤下层结点。代码为实现最大堆的删除操作的函数。
define ERROR错误标识应根据具体情况定义为堆中不可能出现的元素值·
bool ISEmptyMaxHeap H
returnHSize
ElementType DeleteMaxMaxHeap H
从最大堆H中取出键值为最大的元素，并删除一个结点
int ParentChild
ElementType MaxItemX
第章 树
ifISEmptyH
printf最大堆已为空
return ERROR
I
MaxItemHData。取出根结点存放的最大值
用最大堆中最后一个元素从根结点开始向上过滤下层结点
XHDataHSize注意当前堆的规模要减小
forParentParent看Size ParentChild
childParent·
ifChildHSizeHDataChildHDataChild
Child Child指向左右子结点的较大者
ifXHDataChildbreak找到了合适位置
else 下滤X
HDataParentHDataChild
HDataParentx
return MaxItem
代码 最大堆的删除
最大堆的建立
这里所谓的“建立”是指如何将已经存在的N个元素按最大堆的要求
存放在一个一维数组中。我们当然可以通过最大堆的插人操作，将N个元素
一个个相继插人到一个初始为空的堆中去，其时间代价最大为DN log N。
下面我们将介绍一种更简便的方式，在线性时间复杂度下建立最大堆。
微视频
最大推的建
立过程
具体分两步进行，第一步，将N个元素按输入顺序存入二叉树中，这一步只
要求满足完全二又树的结构特性，而不管其有序性。第二步，调整各结点元
素，以满足最大堆的有序特性。
图是实现这种简便方式的一个实例。图a是按输入顺序
依次将各元素存人数组完成第一步操作后的各结点分布情况。接着进行第二步操作，从第LN」
个结点这是最后面一个有儿子的结点开始，对包括此结点以及其他前面的各结点LNJ
LN……逐一进行向下过滤操作，直到根结点过滤完毕，最大堆也就建立起来了见图
bh所示。
图所示的堆有个结点，从L的数组单元位置上的结点开始处理，接着是
单元、单元……一直到单元的根结点每个结点与它的子树中子孙结点进行比较过滤。图
树的 应 用
中我们用灰色结点表示每次过滤所涉及的各个结点。对于某一结点的处理，当其两个子结点
中较大键值的元素大于它时，将它与大键值子结点交换位置，完成一个层次的向下过滤，接着在新
的层次上进行再下一层的过滤，直到找到它的正确位置。图中用灰底白字的结点及其连边旁
的箭头表示两层结点交互过滤；而灰底黑字表示两结点间已满足有序性，不需要调整位置。
⑧
⑨ SS
ss
ss
a b
⑨ ⑦
s
c d
S ⑨
ss
ss
e
⑨ ⑨
ss
h
图 最大堆的建立过程
第章 树
代码是实现上述建立最大堆的过程函数。
void PercDownMaxHeap Hint p
A下滤：将H中以HDatap为根的子堆调整为最大堆
int ParentChild
ElementType x
XHDatap取出根结点存放的值·
forParentpParentSize ParentChild
childParent
ifChild HSizeHDataChildHDataChild
Childchild指向左右子结点的较大者
ifXHDataChildbreak找到了合适位置
else 下滤X
HDataParentHDataChild
HData Parentx
void BuildHeapMaxHeap H
调整HData中的元素，使满足最大堆的有序性
这里假设所有HSize个元素已经存在HData中·
inti
八·从最后一个结点的父结点开始，到根结点
foriHSizei
PercDownHi
代码 建立最大堆
分析上述建立最大堆的实例和算法描述可以看出，从一个无序的完全二叉树进行结点向下
过滤操作是构建最大堆的主要工作。某一结点向下过滤要与其下层的子孙结点比较键值，因此
最大的比较次数是树中各结点高度的和，这个高度和也就决定了算法的复杂度。而关于各结点
高度，我们有如下结论：
一个高度为h的完全二又树最多包含个结点完美二叉树这些结点的高度和为
h。
由于一个完全二叉树的结点个数N是在和之间，因此结点的高度和为DN说
树 的应 用
明最大堆建立算法的复杂度与结点个数呈线性关系。
哈夫曼树
问题的提出
让我们先看一个简单的例子。
例要求编写一个程序将百分制的考试成绩转换成五分制的成绩。
分析首先给出一个简单程序的主要部分，它利用了嵌套条件语句将种可能的分数
转换为不及格、通过、一般、良好和优秀五个等级。
ifscoregrade
else ifscoregrade
else ifscoregrade
else ifscoregrade
else grade
上述程序段的判定过程可以用图a所示的判定树来表示。如果需要转换的学生成绩
很多，用此判定树或者说基于此判定树的程序效率问题就比较突出了。主要原因是学生成绩的
分布在上述五个分数段中是不均匀的。表是一个实际的学生成绩分布情况表。
yes
grade
yes score no
grade yes score no
grade yes score
grade yes
a
yes
grade
score
yes score
no yes
score
no
grade
grade
b
图 不同判定树
grade
no
score no
no
Score
grade
no
grade
第章 树
表 学生成绩分布情况表
分数段
比例
如果学生成绩按表的比例分布，采用图a判定树，上的数据需要进行三次
或三次以上的比较才能求出结果。现假设有 个输入数据，按图a判定进行转换，需
要 次比较运算；而图b是考虑了分数分布比例所设计的另一判定逻辑，对同样的
输入数据，则需要进行 次比较。
由此可见，同一问题，采用不同的判定逻辑，计算效率是不一样的。可以推断，图b的
判定结构对概率大的数据有更少的比较次数，计算效率得到了提高。那么是否能够找到最好的
比较判定逻辑，使运算效率达到最高这就是“最优树”要解决的问题。
哈夫曼树Huffman Tree的定义
我们已经知道，从树根到某个结点的路径是从根结点开始沿着某个分支到达该结点的一个
结点序列，路径所含的分支数结点个数减称为此路径的长度。而一棵树的路径长度是指从
树根到其余各结点的路径长度之和。
结点的带权路径长度是指从根结点到该结点之间的路径长度与该结点上所带权值的乘积。
设一棵树有n个叶结点，每个叶结点带有权值W从根结点到每个叶结点的长度为L则每个叶
结点的带权路径长度之和就是这棵树的带权路径长度Weighted Path LengthWPL它可以被表
示为：
wPL
定义 假设有n个权值WW…W构造有n个叶子的二叉树，每个叶子的权值
是n个权值之一，这样的二叉树可以构造很多个，其中必有一个是带权路径长度最小的，这棵二
叉树就称为最优二叉树或哈夫曼树。
例如，有五个叶结点，它们的权值为用此权值序列可以构造出形状不同的多
个二叉树。这些形状不同的二叉树的带权路径长度可能各不相同。图列出了对应此权值
序列的三棵二叉树，为了清楚起见，用方框表示叶结点，并将权值标注到方框中。而其他结点的
键值省略。
这三棵树的带权路径长度分别为：
WPLa×××××
WPLb×××××
WPLc×××××
其中图b的带权路径长度较小。实际上，可以证明它是最小的带权路径长度，对应的
树是这个权值序列的哈夫曼树。
树的 应 用
a b c
图 三棵不同带权路径长度的二又树
哈夫曼树的构造
我们已经知道由相同权值的一组叶结点所构成的二叉树有不同的形态和不同的带权路径长
度，那么如何找到带权路径长度最小的哈夫曼树呢由哈夫曼树和带权路径长度的定义可知，一
棵二叉树要使其WPL值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越
远离根结点。哈夫曼依据这一特点提出了一种方法，它是一种贪心算法。该算法在初始状态下
将每个字符看成一棵独立的树，每一步执行两棵树的合并，而选择合并对象的原则是“贪心”的，
即每次选择权最小的两棵树进行合并。具体过程描述如下：
由给定的n个权值WW…W构造n棵只有一个叶结点的二叉树，从而得到一个
二叉树的集合FTT…TI
在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉
树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和；
在集合F中删除中作为左、右子树的两棵二叉树，并将新构造的二叉树加入到集合
F中；
重复当F中只剩下一棵二叉树时，这棵二叉树就是所要建立的哈夫曼树。
图给出了前面提到的叶结点权值集合为W的哈夫曼树的构造过程。首
先，按权值大小构成棵单个结点的二叉树，如图a所示；由权值最小的棵二叉树构造
新的二叉树，计算其权值为用圆结点中的数值表示产生新的树集合，如图b所示；图
c为两个权值为的结点合并后的结果；图d是选择最小权值、结点合并后的结
果；图e是将剩余两个子树合并成，构成最后的哈夫曼树。
尽管按哈夫曼方法构造成了图的结果，但需要指出的是：对于同一组给定权值叶
结点所构造的哈夫曼树，树的形状可能不同。比如，图是另一棵上述给定权值序列的
哈夫曼树。但不论形状如何，这些哈夫曼树的带权路径长度是相同的，并一定都是同一最
小值。
代码为哈夫曼树构造算法。为了便于抽取最小权值的子树，在树的构造过程中使用了
最小堆及其删除、插入操作。这里堆中的元素是一个加了权值的树结点的指针。
第章 树
③
③
a b c
⑨
③
③
d e
图 哈夫曼树的生成过程
①⑤
③
图 结构不同的哈夫曼树
typedef struct HTNode·HuffmanTree八哈夫曼树类型
struct HTNode哈夫曼树结点定义
int Weight 结点权值
HuffmanTree Left指向左子树
HuffmanTree Right指向右子树·
I
HuffmanTree HuffmanMinHeap H
这里最小堆的元素类型为HuffmanTree
假设HSize个权值已经存在HDataWeight里·
int IN
树的应用
HuffmanTree T
BuildHeapH将HData按权值Weight调整为最小堆
NHSize
foriiNi╱·做HSize次合并
THuffmanTreemallocsizeofstruct HTNode·建立一个新的根结点
return DeleteMinH最小堆中最后一个元素即是指向哈夫曼树根结点的指针
TLeftDeleteMinH从最小堆中删除一个结点，作为新T的左子结点
TRightDeleteMinH从最小堆中删除一个结点，作为新T的右子结点·
TWeightTLeftWeightTRightWeight计算新权值·
InsertHT·将新T插入最小堆·
代码 哈夫曼树的构造
Huffman算法的复杂度主要由以下几部分组成：
调整最小堆：N
N个删除：NlogN
N个插人：NlogN。
故整体复杂度为NlogN。
哈夫曼编码
给定一段字符串，如何对其中的字符进行编码，使得该字符串的编码存储空间最少当然从
存储空间取出的编码必须通过对应的解码才能还原出原字符串。
上述问题的最优解决方案是哈夫曼于年提出的，按他给出的算法得到的编码就称为
“哈夫曼Huffman编码”是进行文件压缩的有效方法，其压缩比通常在间。
可见的ASCII字符大约有一百个左右，加上部分不可见字符，可以用log位来识别它
们，再加上位校验码，所以一般用位即一个字节来表示一个字符。但一般文本中每个字符出
现的频率是不同的，且差异较大，通常只是少量不同字符在大量重复出现，用位来存储每个字
符是比较浪费的。
例 假设有一段文本，包含个字符。经过统计；发现其中只有个字符是互不相
同的，它们是：aeist空格sp换行nl。
若按每字符字节的方式存储，则该文本需占×位。而其中既然只有个字符是
不同的，我们完全可以仅用log位码来识别它们。例如可令：aei
stspnl。这时空间被压缩为×位，效果已经不错了。
要获得更好的压缩效果，即压缩后的总空间最小，就不能再用等长的编码。一个很直观的想
法是，让出现频率高的字符编码短些，出现频率低的字符则编码不妨长些，可能会得到更好的压
第章 树
缩效果。这要求必须知道更多的信息。
设fc为字符c出现的频率。假设例中的统计结果为fafefi
fsftfspfnl。表列出了一种最优编码，可见存储空间被进一步压
缩到位。
表 最优编码统计
字符 频率 编码
占位
a
e
i
t
sp
nl
总和
现在就出现了一个新问题，在允许不同字符采用不同长度编码的情况下，如何保证解码能顺
利实现
例如，有一个字符串it is a tie如果按照表中的编码，此字符串就被压缩为
。当进行文本恢复时，我们从左向右扫描压缩后的编码，并对
照表发现不在表中，而对应i接着不在表中，而对应t于是从前位得到
“it”以此类推，完全可以解码原文，而不出现二义性。
并不是任何一种编码都可以如此顺利地解码，比如若将sp的编码改为再从左向右解
码，前位解码结果将是“isp”导致错误的原因是出现二义性问题了，即sp的编码是a的编
码的前缀。
不产生二义性的关键在于任何一个字符的编码都不能是另一个字符的编码的前缀，因此哈
夫曼编码也称为“前缀编码”。
采用哈夫曼树生成方法可以保证构成正确的文本前缀编码，图为上述文本的最优前缀
编码树。
从图中来看，与前面介绍的哈夫曼树有
所不同的是在每个结点的左分支被记为右分支
被记为。某一字符的编码可通过组合从根结点到
该字符结点叶结点的路径上所标注的、得到。
注意前缀编码树的特点是每个字符必是叶结点，且
树中没有度为的结点。否则就会出现解码二义
性的问题，比如将sp换成a的父结点，此时，sp为
O ①
a
m
图 最优前缀编码树
O
树的应用
非叶结点，那么编码中前两位解码为i后，右边剩下的四位既可以一并解码为t也
可以先解码前两位为sp再解码剩下的两位为e。导致出现“it”和“i sp e”两种解释。
一个字符的编码长度即是该字符结点在其哈夫曼树中的深度d。设字符c为哈夫曼树中
的一个叶结点，若在树中的深度为d将它在文本中的出现频率为f看作结点的权值，则压缩后
文本长度为∑df哈夫曼树的生成确保了这个前缀编码树的编码长度为最小。
图列出了调用哈夫曼树生成算法构造图最优编码树的过程。为清楚起见，用方
结点表示原始字符结点，用圆结点表示生成的树结点，内含以该结点为根的树的权值。
a e
a初始状态
nl s a
b调整为最小堆
t i ④
s
e
c
t
t
sp
sp
sp
n s
c第次合并
⑧ a
t ④
nl
d第次合并
i sp
sp
e
a
t ④
nl s
e第次合并
nl
i
a
i
s
e
e
i
t
第章 树
a i
④
第次合并
sp e
a
t ④
第次合并
S
sP e
a
t ④
nl s
h一棵最优前缀编码树
图 哈夫曼树生成过程演示
sp
树的应 用
可以看到，图生成的树与图并不相同，又一次说明哈夫曼编码不是唯一的。
集合及其运算
集合的表示
集合是一种常用的数据表示方法。集合运算包括交、并、补、差以及判定一个数据是否是某
一集合中的元素等。
为了有效地对集合执行各种操作，可以用树结构表示集合，树的每个结点代表一个集合元
素。例如，有个互不相交的整数集合S、S、S图是这
个集合的多叉树表示形式，每个结点允许有多个子结点。与我们之前所见到的父子关系指针
不同，这里结点的指针不是从父结点指向子结点，而是由子结点指向父结点。每个根结点与其集
合名称相关联。当然，究竟选择哪个结点作为代表此集合的父结点是无关紧要的。
①
集合名 指针
S
S
S
②④⑦ ③
⑤ ⑧
⑨ ◎
图 集合的多叉树表示形式
采取这样的树结构表示集合好处是有利于判定某个元素所属的集合，也便于集合的归并运
算。从另一方面考虑，当我们执行集合运算的时候，关注的是集合中的元素，并不在乎这个集合
叫什么名字，所以集合名结构图左边部分其实是没有必要存在的。一个巧妙的方法是
直接用树的根结点的编号代表一个集合。让我们把所有N个元素从到N编号，当把它们存
储在数组中时，它们的下标范围也是到N的—充分利用这一点，我们就可以简单地用一
个整型数组表示集合，这个数组的第i个元素下标为i存储的是编号为i的集合元素的父结点
编号。例如图中，是的父结点，那么数组的第个元素的值就是。由于根结点没有父结
点，为了区分根结点和非根结点，我们把根结点单元的值定义成负数例如就定义成。例如
是图中一棵树的根结点，那么对应的那个集合的名字就是在第个单元里存的值是因
为这棵树有个结点，对应的集合有个元素。于是图中的三棵树就如图所示。
在此我们把N个集合元素的类型 ElementType定义为int即简单地用到N的编号代替
实际元素。于是集合的类型可描述为：
define MAXN
typedef int ElementType
集合最大元素个数
默认元素可以用非负整数表示
第章 树
默认用根结点的下标作为集合名称 typedef int SetName
typedef ElementType SetType MAXN假设集合元素下标从开始
下标 S
① ③
②④⑦⑤ ⑨ ◎
a集合的数组存储 b集合S、S、和S
图 集合的树结构表示及其存储实现
集合运算
查找某个元素所在的集合
查找编号为X的元素所属的集合，可以沿着该元素父结点指针向上查，当发现一个元素的指针
域值为负数时，该元素就是X所属集合的树根结点。代码的函数Find实现了这一查找过程。
SetName FindSetType sElementType X
I默认集合元素全部初始化为
for sxXsx
return x
代码 集合元素查找
集合的并运算
集合的并运算是要完成将元素X和X所属的两个集合合并的操作。可以先找到两个元
素所在集合树的根结点，如果它们不同根，则将其中一个根结点的父结点域值设置成另一个根结
点的数组下标就行了。例如，要将数值为和的两个元素所属的集合归并，通过Find 函数可
以确定它们所属的集合为和。我们只要将S的值设置为就实现了两个集合的并运算。
图为并运算完成后的结果。其中根结点的值由原来的变成了。为清晰起见，图
a中用灰底色标注出了该值的变化。
代码为实现集合并运算的Union 函数。这里默认传人函数的Root和Root是两个不同集
合的根结点，所以一般我们在调用Union之前，都应该先确认这一点。换言之，如果我们要将元素X
树 的应 用
和X所属的两个集合合并，应该先调用FindX和 FindX得到两个集合的根，然后比较一下：如
果两个根不同，则调用Union 执行合并；否则根本没必要合并，因为它们本来就在同一个集合里。
下标 S
①
②④⑦ ③ ⑨ O
I
⑤
a集合的数组存储 b集合SUS和S
图 集合S和S的并运算
void UnionSetType s SetName RootSetName Root
s RootRoot
这里默认 Root和Root是不同集合的根结点
代码 集合并运算
按秩合并
乍一看代码是如此简单，会有什么问题呢假设有N个元素，一开始各自独立，然后
我们要执行这样一系列的并运算：
●合并和所在的集合：调用UnionS的结果，是令S生成根为、高度为
的一棵树；
●合并和所在的集合：FindS搜索了个结点后找到根结点调用 UnionS
的结果，是令S生成根为、高度为的一棵树；
● 合并和所在的集合：FindS搜索了个结点后找到根结点调用UnionS
的结果，是令S生成根为、高度为的一棵树；
……
以此类推，当我们不断执行“合并i和”≤i≤N的操作，FindS的总执行时间就是
N因为生成的集合树越来越高。最后的结果如图所示。出现这种问题的根本原因，
是我们每次都把一棵比较高的树并到了一棵矮树上。如果我们每次合并前都先比较一下两棵树
的高度，把矮树并到高树上，就不会改变结果树的高度，也就可以避免上述糟糕情况的发生。
第章 树
当然要做到这一点，我们需要快速知道每个集合的树有多高，而这并不是很容易做到。比较容
易获得的是集合的规模，即集合中元素的个数。用规模替换高度，也 N
可以起到比较好的作用——至少在前面的例子里是这样：如果我们
每次都把规模小的树并到大树上，那么会一直是根结点，树的高 ② 度始终是整套操作的时间复杂度就降为N了。这种按规模、
或者按高度进行合并的算法，就统称为按“秩”合并。 ①
在实现这个算法时，为了能够快速获得集合的规模，我们把对 O
应集合的树的总结点数存在根结点单元里。同时为了与普通结点 图 简单并运算的结果
区分开，我们在这个数字前加负号，使之仍然为负数。代码给
出了按秩合并的算法。这里SRootSRoot说明集合比较大，是因为对两个正整数A和B
而言，AB即意味着AB。当合并两个集合的时候，新的根结点应该存两个集合规模的和。
void UnionSetType sSetName RootSetName Root
这里默认 Root和Root是不同集合的根结点
保证小集合并人大集合·
ifSRootsRoot 如果集合比较大
SRootSRoot 集合并入集合
sRootRoot
else 如果集合比较大
SRootsRoot 集合并入集合
sRootRoot
代码 Union的按秩合并算法
下标 S
在按秩合并的规则下，图中两个集合合并的结果就变成
了图所示的数组。图中灰底突出了根结点单元的数值变化。
路径压缩
图 图中集合S
和S的按秩并运算
如果一棵集合树很不幸地长高了，而我们又不得不反复调用
Find去查找它最底部的某个元素，怎么做能提高效率呢
有一种“路径压缩”的方法可以在第一次查找的时候把树变
矮，使得要查找的元素直接变成根结点的孩子，则下次再查找它的
时候就只需要次比较了，可以大大提高效率。代码给出了
这个算法的递归版本。在这个算法中，我们递归地把X的父结点
的值SX设置为对其当前父结点SX执行 Find的结果，并且返
回更新后的父结点值；直到X本身是集合的根，被Find返回给上
本 章 小 结
一层。这样执行的效果是，每返回一层，Find 就把当前结点的父结点设置成根结点，即把当前元
素直接变成了根结点的孩子，并且一路返回根结点的值。最后从X到根结点的路径上所有的结
点都变成了根结点的孩子，这就是路径的压缩。
Set Name FindSetType s ElementType x
I默认集合元素全部初始化为·
fsx找到集合的根
return X
olse
return sxFindS sx 路径压缩·
代码 Find的路径压缩算法
图给出了一个示例，在对图a给出的集合执行 FindS后，从到根的路径
上所有三个结点、、都变成了的孩子，如图b所示。
④ ④
O ② O
②
① ③
⑤ ①
③
⑤
a原始集合 b调用FindS后的结果
图 路径压缩算法示例
本 章 小 结
树是一种十分重要且广泛应用的非线性数据结构。本章首先以线性表的静态查找作为引
子，给出了动态查找的概念，为树的内容介绍做了适当铺垫。第节介绍了树的定义和基本术
语。紧接着，在第节详细介绍了二叉树的存储形式和操作，给出了二叉树的建立和几种遍历算
法并讲解了几个应用实例。第节介绍了二叉搜索树及其插人、删除和查找操作。第节的内
容主要是平衡二叉树及其调整策略和算法。最后，在第节中给出了树的几个重要应用实例。
二叉树是最基本和最简单的树结构，其遍历是最重要的操作，依据结点被访问的顺序分为先
序、中序、后序和层序等。尽管几种遍历用递归算法实现既直观又简单，但效率比迭代算法低。
二叉搜索树的有序特性使得它成为一种对排序和查找都很有用的特殊二叉树，通过对二叉
搜索树进行中序遍历可以得到从小到大的排好序的序列。依据结点关键字与要查找值的比较结
果，查找范围限定在左或右子树是动态二分查找思想的实现；查找最大或最小元素也更加有效，
第章 树
它们处于树的最右分支端结点和最左分支端结点处。
平衡二叉树的引入是为了使二叉搜索树始终具有良好的结构，有尽量小的高度，以保证各种
操作的对数复杂度。平衡调整算法中引入了平衡因子的概念，以反映树的不平衡情况，确定采用
单旋或双旋调整策略。
在树的应用中介绍了堆、哈夫曼树和哈夫曼编码、集合及其运算。堆分为最大堆和最小堆两
种，它们是考虑了优先级的特殊队列，因此常用于诸如考虑短作业优先调度等排队情况。尽管逻
辑上用完全二叉树表示，实际的物理存储通常采用数组；哈夫曼树又称为最优二叉树，也就是带
权路径长度最小的二叉树，它进一步提高了树中叶结点访问的总体效率。常用的集合运算包括
判断元素所属集合、不同的集合归并等，树结构适合于这种集合的表示和操作，在本书的集合树
的表示中，采用了子结点到父结点的链接方式，不仅使得集合操作更简捷，也说明树的边只是表
示结点之间的关系。
习题
判断正误。
二叉搜索树的查找和折半查找的时间复杂度相同。
若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个
结点。
哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
填空题。
设T是非空二叉树，若T的先序遍历和中序遍历序列相同，则T的形态是。若T的先序遍历和
后序遍历序列相同，则T的形态是。若T的中序遍历和后序遍历序列相同，则T的形态是。
以二叉链表作为二叉树的存储结构，在具有n个结点的二叉链表中n空链域的个数为。
已知二叉树的前序遍历序列为ABDCEFG中序遍历序列为DBCAFEG则后序遍历序列为。
利用过滤法将关键字序列建成的最大堆为。
在一棵度为的树中，度为的结点个数是度为的结点个数是则度为的结点个数是。
设二又树的存储结构如下；
J H F D B A C E G
Lchild
data
Rchild
其中根结点的指针值为实际为所在数组位置的下标LchildRchild分别为结点的左、右孩子指针域，
data 为数据域。
画出二叉树的逻辑结构。
写出该树的前序、中序和后序遍历的序列。
习题
试编写一个算法，判别给定的二叉树是否是二叉搜索树。
对于算术表达式ABCDEF·G给出其中序二叉树表示。
设顺序存储的二叉树中有编号为i和j的两个结点，请设计算法求出它们最近的公共祖先结点的
编号。
假设一个文本使用的字符集为abcdefgl字符的哈夫曼编码依次为
。
请根据哈夫曼编码画出此哈夫曼树，并在叶结点中标注相应的字符。
若这些字符在文本中出现的频率分别为：求该哈夫曼树的带权路径长度。
若有个数据元素初始每个元素构成一个独立的集合，其数组单元的数值和树
的表示如图所示。通过集合并运算序列UnionS、UnionS、UnionS、UnionS、
Union、Union和UnionS后，集合树和对应的数组S变化如何试比较采用按秩合并和简
单合并，以及路径压缩与简单合并结合的结果。
下标 S
a集合的数组S b个独立集合
图 题图
第章
散列查找
引子
在前面的第章中，我们已经介绍了查找的几种方法：当查找的数据对象集合中元素数量N
不大的时候可以采用“顺序查找”时间复杂度为N当N很大的时候可以采用“二分查找”
时间复杂度为log N但二分查找的前提是数据元素已经按照关键字排序并且存储在连续
的地址空间中，这就要求不能有频繁的元素变化经常性的插入和删除——即要求是“静态查
找”当N较大并且经常需要插入和删除元素的时候，可以采用“二叉搜索树”结构进行查找时
间复杂度为hh为二叉搜索树的高度插入和删除元素操作的时间复杂度也是h这
里h的最好情况是log N最坏情况可以达到N。
虽然log N是相当不错的时间复杂度，但是有时需要附加条件。到底还有没有其他适应
性广而速度又快的查找方法呢
例我们来考虑一下广泛使用的在线聊天软件QQ的登录过程，登录界面如图所
示。首先，大家知道QQ号码现在已经达到位数字——数十亿的规模的容量，实际用户估计
也达到亿数量级。当然就目前全球数十亿人口来看，一定有许多号码没有主人或者主人已经抛
弃它，也一定有许多人占有多个号码，占有多个号码的原因可能是主人希望以不同的面貌出现在
他人面前以隐藏身份，或者是择机出卖“吉利号码”以赚取经济利益等。
我们现在感兴趣的是，在登录QQ的时候，QQ服务器如何核对你的身份，以确定你就是该号码
的主人方法似乎也不难，只要匹配一下你的密码即可。但是很少有人会想：在多达十亿量级的有
效QQ号码中如何快速找到你刚刚输入的QQ号码，以 Z 便取出相应的密码与你刚刚输入的密码进行核对
分析现在我们来做个简单分析，先看看是否
可以用二分法查找。假定数十亿的号码容量中有十
亿有效用户，用二分查找次，可以解决N°十
亿个有效QQ号码的问题。而次长整数比较对
现在的计算机来说可以瞬间完成。所以从时间方面
来看是没有问题的。
再来看一下空间的情况。假设每个有效QQ号码
有关信息如密码、个性签名、个人资料、好友等，但不
C
QQIO
在线精彩生活更骑彩
帐号： A
密码：…
状态； □记住峦码 □自动登录
设置
Ia
注册新帐号
我回密码
登放
图 QQ登录界面
引子
包括个人相册和邮箱等需要 KB存储空间，那么亿个账号大约只需要 GB TB的
连续存储容量，这也是可以接受的。
但是，二分查找要求“按有效QQ号大小顺序存储有关信息”这是不是一个合理的要求呢
我们知道在连续存储空间中，插入和删除一个新QQ号码将需要移动大量数据，而插入一个新
QQ号码当某人成功申请一个QQ号时几乎每小时甚至每分钟都会发生很多次。所以这个代
价是不能接受的。
用不了二分查找，我们该怎么办
例我们来琢磨一下查英文字典的过程。比如要查询英文单词“zoo”如图所示，
相信大家都知道应该直接到字典的后面去找，而不会
从字典中间开始用二分法去找，更不会从头顺序查
找。为什么呢因为我们“知道”字典的单词排序规
则以及字母“z”在个字母中位列最后。实际上，我
们已经根据要查找的关键词“zoo”在脑子里经过了
“计算”得出该关键词所在的大致位置，这样就能更
快地找到它。这个“计算”过程非常类似于本章将要
介绍的散列查找中的散列函数计算。
实际上，查字典的过程结合了散列查找用于初
步定位、二分查找一般不是准确二分和顺序查找
当很接近关键词的时候等几种查找方法。
图 查字典
例 我们再来看一下网上搜索。大家都习惯于通过百度和谷歌等搜索工具在因特网
上搜索感兴趣的任何信息，如图所示，但是你有没有思考过，搜索引擎是如何如此神速地把
我们需要的有关信息呈现在面前的
ehdom ×
收藏决e网快讯库
图百度一下，道 ·目·页·全⑤ IRo
拉室设置登量注
Baidu百度
新区 网页 贴王 知道 MP 图片 现题 地图
数据结构 算法 百度下
空回 百科 na更多》
Interet 保护顿式插用 ·
图 Google 搜索界面
第章 散 列 查 找
分析与搜索相关的主要数据结构是“倒排索引”。正常的索引结构建立的是“文档到单
词”的映射关系，而倒排索引建立的是“单词到文档”的映射关系，即关键词对应所有拥有这个关
键词的文档编号列表。其实可以这样理解，倒排索引就是描述一个关键词对象集合Terms和
一个文档集合Docs对应关系的数据结构。通常仅记录关键词在哪些文章中出现还不够，同时
还需要记录关键词在文章中出现次数和出现的位置行号或段落号这样做可以方便快速获取
查询记录的数目和列出查询结果。一个倒排索引的示意如表所示。
表 倒排索引表
Docs
Terms 文档， 文档
……
文档
……
……
…… …… …… ……
……
……
文档。
关键词，
关键词 …… ……
关键词
关键词。
比如，用户要搜索“关键词。”查找上面的索引表知道，“文档，”出现次“关键词。”分别在
第、、、和行，“文档。”仅在第行出现次“关键词。”。根据这些线索，就可以将“文
档，”和“文档。”的有关行信息经过适当删减和排序显示在用户面前。如果同时需要搜索“关
键词”和“关键词…”查找索引表知道，“文档”中“关键词”和“关键词”同时出现的地方
有处，分别在第和行；这两个词在“文档”的第行同时出现了次。
如何高效地建立和查找该表格呢理论上说这个表格包含了所有关键词和文档的索引，它
是非常巨大的，如果不采取适当的技术，几乎是没有办法来具体实现。因为搜索面对的是任何人
和任何事，所以这里的“关键词”包含了任何人想出的任何名词、动词、词组和地名、人名等，数量
可想而知，很容易超过几千万，甚至上亿条。这里的“文档”也可以是所有网站上的在线图书、杂
志、论文、博客、网页等任意文章，也容易突破千万级数量，如何删选它们主要看搜索提供商的能
力。更进一步地这个表还是动态的，因为网络上时时刻刻都在增加和删除各种各样的文档，所
以这个索引表也需要时刻更新。
对每个关键词来说，一般不会出现在大多数文档中如果到处出现，搜索这个关键词的意义
不会很大所以采用链表表示每一行，可以大大减小上面表格的存储量。实际上也是这么
做的。
现在，最重要的问题是如何能够在极短的时间内比如秒内在表中搜索到需要的关
键词本章要介绍的方法——散列查找法可以很好地解决这样的问题。
散列方法为什么会有很快的查找效率呢通过分析前面的例子，可以看出散列方法的思想，
也就可以理解其中的奥妙了。
基本概 念
先回到第二个例子——查字典。我们能够很快找到“关键词”的第一步是根据“关键词”的
字母序“估算”出它在字典中的大体位置。而散列方法查找关键字的第一步也是通过“散列函
数”的计算，求出关键字所在的存储位置。区别在于查字典时我们事先“估计”关键词的“大致位
置”而散列函数“计算”的是关键词的“准确位置”。散列查找法之所以能够通过计算来快速定
位要找的关键词，一个基本的前提是在存放的时候也要通过同样的“计算方法”来定位存储的
位置。
再看第三个例子，表中插人“关键词时，其存储位置应该由散列函数“计算”来决定，然
后在查找的时候就可以通过同样的“计算方法”求出它的存储位置而迅速找到它。
读者可能有一个疑问：如果有两个或更多关键词通过某散列函数计算出相同的存储位
置，那又该怎么办呢总不能把多个关键词的信息存放在相同的位置吧我们把这种情况叫做
冲突Collision。因此，还需要研究解决冲突的方法。这样我们就提出了散列查找法的两个基
本内容：如何构造散列函数和如何解决冲突。很显然，假如某一次查找没有发生冲突，那么只需
要一次就完成了查找，而不管我们面对的是多大的查找集。现在读者应该可以感觉到这种方法
具有何等强大的诱惑力
散列查找被广泛地应用于数据库的信息搜索。例如，当你用信用卡刷卡系统需要在百万
条信用卡号中找到你的信用卡号以及相关的信息、当你登录一个网站系统需要在数据库中找
到你的登录名、当你在其他应用软件中使用查找功能时等。
本章将系统地讨论散列函数的特性要求和构造方法，并介绍解决冲突的分离链接法和开放
地址法，同时进行散列方法性能分析，最后通过单词频度统计的应用实例，给出一个完整程序实
例。本章还讨论了装入因子对查找性能的影响、关键词特点、删除特性、重散列等各项技术特性，
最后总结了各种方法优缺点比较，试图给大家在解决实际问题时提供选择依据。
基本概念
从抽象的数据类型的角度看，表实际上就是符号表Symbol Table它定义为“名字属
性”对的集合。名字和属性的含义随着应用的不同而不同。例如，我们在查字典时，名字就是一
个单词，而属性就是该单词的解释；在编译程序符号表中，名字就是标识符，而属性则可能是包含
其类型、初值和使用该标识符的行号表。
符号表的抽象数据类型描述为：
类型名称：符号表SymbolTable。
数据对象集：符号表是“名字Name属性Attribute”对的集合。
操作集：对于一个具体的符号表Table ESymbolTable一个给定名字Name ∈NameType属性
Attr ∈AttributeType以及正整数TableSize符号表的基本操作主要有：
SymbolTable CreateTableint TableSize创建空的符号表，其最大长度为TableSize
第章 散 列查 找
bool IsInSymbolTable TableNameType Name查找指定名字Name是否在符号表Table
中，若是返回true否则返回false
AttributeType FindSymbolTable TableNameType Name获取符号表Table中指定名字
Name 对应的属性；
bool ModifySymbolTable TableNameType NameAttributeType Attr将Table 中指定名
字Name的属性修改为Attr。成功返回true找不到Name则返回false
bool InsertSymboITable TableNameType NameAttributeType Attr向Table中插入一个
新名字Name及其属性Attr。成功返回 true若Name 已存在则返回 false
bool DeleteSymbolTable TableNameType Name从Table 中删除一个名字Name及其
属性。成功返回 true找不到Name则返回 false。
符号表最核心的操作是查找、插入和删除，所以在选择符号表的存储结构时，关键是保证有
效地实现这三种操作。而这三种操作频度最大的应该是查找，频度最小的是删除。插入某“关
键词属性”也称记录的操作往往要先查找这个关键词，看是否在符号表中已经存在，只有不
存在这个关键词的时候才可以插入该记录。从后面的散列方法可以知道，查找确定不存在某关
键词的时候，也同时找到了要插入的存储位置，而具体插入记录的动作只需常量时间所
以插入操作的时间与查找不成功的所需时间相当。
采用本章的散列技术实现上面的操作，符号表也叫做散列表Hash Table即哈希表。
散列Hashing是一种重要的查找方法。它的基本思想是：以数据对象的关键字key为自变
量，通过一个确定的函数关系h计算出对应的函数值hkey把这个值解释为数据对象的存储
地址，并按此存放，即“存储位置hkey”。
微视频
在查找某数据对象时，由函数h对给定值key 计算出地址，将key与该
地址单元中数据对象关键字进行比较，确定查找是否成功。因此，散列法又
称为“关键字地址转换法”。散列方法中使用的计算函数称为散列函数
也称哈希函数按这个思想构造的表称为散列表，所以它也是一种存储
方法。 散列表与散
列查找 例有n个数据对象的集合，关键词是正整数，分别为
。如果符号表的大小用TableSize通常
用一个素数选取散列函数h如下：
hkeykey mod TableSize 公式
其中mod是求余运算，相当于C语言中的算。
用这个散列函数对个数据对象建立查找表忽略其属性部分如表所示：
表 例对应的关键词散列查找表
i
Table
基本 概 念
这里，我们特意选取关键词，使得没有两个关键词key和key的散列值是相同的，即当key≠key
时，必有hkey≠hkey否则就应该用节中将要介绍的方法来调整存储位置。本例中查找和
插入操作都只需要一次比较就可以定位完成，与表的大小TableSize和关键词的数量n都无关。
查找时，对给定关键词key依然通过公式计算出地址，再将key与该地址单元中关键词
比较，若相等，则查找成功。
对于n个数据对象的集合，总能找到关键字与存放地址一一对应的函数。例如当关键词为正
整数时，若最大关键词为m可以分配m个数据对象存放单元，选取散列函数hkeykey 即可，但
这样可能会造成存储空间的很大浪费，甚至不可能分配这么大的存储空间。比如用身份证号码作为
关键词的时候，位十进制数字的大小已经超过百万太字节TB这完全是没有办法承受的。
一般情况下，设散列表空间大小为m填人表中的元素个数是n则称αnm为散列表的装
填因子Loading Factor。分离链接法节的装填因子定义成每个链表的平均长度。例
的装填因子α≈。实用时，常将散列表大小设计使得α为宜。
经过散列函数变换后，可能将不同的关键字映射到同一个散列地址上，这种现象称为冲突
Collision映射到同一散列地址上的关键字称为同义词synonym。通常关键词的值域允许
取值的范围远远大于表空间的地址集，所以说，冲突不可能避免，只能尽可能减少。
例将给定的个C语言中的关键词保留字或标准函数名顺次存人一张散列表。
这个关键词为：acos、define、float、exp、char、atan、ceil、floor、clock、ctime。散列表设计为一个
维数组Table。
根据关键字均为小写英文字符串这一事实，可设计散列函数如下：
hkeykeya 公式
将关键字key 按其首字母映射到Tablehkey若该单元已满，即发生了“冲突”解决
的办法是将关键字放入 Tablehkey这种在同一个散列地址定义多个槽slot的方法可
以解决一部分冲突。但若此单元亦满，则插入失败——这种情况称为散列表溢出Overflow。
对于例中给定的个关键词，表显示了从acos到floor被插入后的散列表。此时该表
的装填因子α仅为≈然而clock 和ctime已经因溢出而无法直接插入了。
表 散列表的插入
i Tablei
acos
char
define
exp
float
…
Tablei
atan
ceil
floor … …
第章 散 列 查 找
一种解决方法是将产生溢出的关键字插入任何一个空单元，但下次查找时如何能找到它们
又成了一个难题。
通过上面两个例子可以看到，使用散列表时，在没有冲突和溢出的情况下，插入、删除、查找
等操作都可一步完成。散列映射法的关键问题有两个：一是如何设计散列函数，使得发生冲突的
概率尽可能小；二是当冲突或溢出不可避免时，如何处理使得表中没有空单元被浪费，同时插入、
删除、查找等操作都能正确完成。
所以，散列方法需要解决以下两个问题：
构造“好”的散列函数，将在节中介绍；
制定解决冲突的方案，将在节中介绍。
散列函数的构造方法
一个“好”的散列函数一般应考虑下列两个因素：
计算简单，以便提高转换速度；
关键词对应的地址空间分布均匀，以尽量减少冲突。即对于关键词集合中的任何一个
关键字，经散列函数映射到地址集合中任何一个地址的概率是基本相等的。实际应用中，严格的
均匀分布也是不可能的，只是不要过于“聚集”就行了。
本节把关键词分为数字型关键词和字符串型关键词这两种类型，分别介绍散列函数的构造
方法。
数字关键词的散列函数构造
构造这类散列函数只不过是把原来的数字按某种规律转换成另一个数字。
直接定址法
如果我们要统计人口的年龄分布情况岁如表所示，那么对年龄这个关键词
可以直接作为地址。此时，hkeykey。
表 年龄分布表
地址 年龄
…
…
及以上
人数
万
万
万 … …
… …
散列函数的构造方法
如果我们要统计的是年以后出生的人口的分布情况，如表所示，那么对出生年份
这个关键词可以减去作为地址。此时，hkeykey。
表 后分布表
地址 出生年份
…
人数
万
万
万 … …
万 … …
万
总之，取关键词的某个线性函数值为散列地址，即
a、b为常数 hkeya×key b 公式
这类函数计算简单，分布均匀，不会产生冲突，但要求地址集合与关键词集合大小相同，因
此，对于较大的关键词集合不适用。所以在现实应用中并不常用。
除留余数法
现实应用中比较常用的方法是除留余数法。假设散列表长为TableSizeTableSize的选取，
通常由关键词集合的大小n和允许最大装填因子α决定，一般将TableSize取为nα选择一个
正整数p≤TableSize散列函数为：
hkeykey mod p 公式
即取关键词除以p的余数作为散列地址。使用除留余数法，选取合适的p很重要，一般选取p为
小于或等于散列表表长TableSize的某个最大素数比较好。用素数求得的余数作为散列地址，比
较均匀分布在整个地址空间上的可能性较大。表给出了一系列TableSize对应的p值。
表 p的取 值
TableSize
P
大家可能已经注意到，如果pTableSize则意味着地址pTableSize是不能通过散列函数
直接映射到的。不过不用担心这些空间被浪费了，事实上，在冲突发生时就可能会用到它们。
数字分析法
如果数字关键词的位数比较多，在特定的情况下，有些位数容易相同，而有的位数比较随机。
第章 散 列 查 找
比如位手机号码，前位容易相同，中间位表示用户的归属地，在一定范围内也容易重复，
而最后位表示用户号，是很随机的。所以一般选择最后位作为散列地址，这样发生冲突的可
能性较小。因为数字已经超过长整数，所以可以改成字符串表示。如果用key表示指向某
位数字字符串的指针，那么采用C语言的字符串转换成整数的处理函数 atoi可以将散列函数
表示成：
hkeyatoikey 公式
这里key表示指针往后移个数字，即留下位数字。如果位正整数太大，不适合作为地
址，那么还可以结合前面介绍的除留余数法再做一次转换。
另一个例子，如果关键词是位的身份证号码，各位数字的含义如表所示，其中第
位是校验码，可以取和x这个符号。通过分析容易知道，在一定范围内，前位表示的所
属地编号，容易相同；如果考虑在校生范围的时候，第位表示的出生年份都应该比较接近；
第位是的可能性为是的可能性为也不够随机；第位基本上取不可
能取以上的数字；第位取的可能性远大于其他数字，因为同一个区县下属辖区中同生
日的人数很难达到位数；第位的奇偶性用来区分男女性别；一般来说不够随机的位不适合
参与散列计算，否则映射出来的地址可能会产生某种“聚集”效应。
表 身份证号码分析表
省 市
区县
下属辖区
编号
出生年份 月份 日期 该辖区中的序号
校验
因此，我们可以针对不同的应用对象，选取尽可能取值较随机的身份证号码的“位”参与散
列计算，从而达到均匀分别的效果。比如，我们选取第、、、、、位参与散列计算，计算
方法可以是：
hkeykey×key×key×
key×key
hkeyhkey× 当keyx时
hkeyhkey×key当key为时 公式
公式计算结果可以达到位的正整数。如果太大，不适合作为散列地址，那么还可以结
合前面介绍的除留余数法再做一次转换。也可以取前面个位数中的几位类似地计算散列地
址，主要考虑依据是选取合适的装入因子，从而估计需要多大的地址空间。比如，有 个数
据元素的集合，装入因子选为则地址空间大小应为 左右，即可以选用上
述个位数中的某个位数。
散列函数的构造方法
字符串关键词的散列函数构造
对于字符串类型的关键词，因为字符串的比较比整数的比较要花费更大的代价，所以通过散
列函数计算，把字符串映射到整数后再比较也是散列方法的优势之一。
一个简单的散列函数——ASCII码加和法
对字符型关键词key定义散列函数如下：
hkeyZkeyimod TableSize 公式
函数很简单，然而均匀性也较差。例如考虑长度不超过的字符串关键词集，并把字符限制
在大小写英文字母、下横线和数字×以内，关键词集包含有°个不同的关键词。
取TableSize为质数 这个数字相对于关键词总数还是很小的。然而Zkeyi最大只能
取到×这就意味着h将全部个关键字都映射到 区间内，显然冲突可
能是很严重的。比如关键词“a、“b”和“c”的散列值都是它们是冲突的；关键词“tea”和
eat也是冲突的。
简单的改进——前个字符移位法
上面介绍的ASCII码加和法完全不区分每个字符的出现位置，导致严重冲突。现改造如下：
hkeykeykey×key×mod TableSize公式
选择进制是因为英文有个字母不分大小写加个空格符。函数仅考虑关键字
key的前个字符。该函数假设key至少有位字符，此时字符串结束符也参与计算。
若忽略空格符不计，则前位所有可能的不同组合有 种，似乎TableSize
是不错的选择。可惜不巧的是，英文不是随机的，真正的英文单词中，前位的不同组合大约不
到种，即使没有冲突问题，也是对空间的浪费装填因子不到何况具有相同的前
个字符的不同关键词一定会发生冲突，比如：string、street、strong、structure等。因此，虽然很容易
计算，但是当散列表太大的时候，这个函数还是不合适的。
好的散列函数——移位法
这个散列函数涉及关键词的所有n个字符，并且分布得很好。形式如下：
hkey∑keyni× mod Tablesize 公式
该函数用于处理长度为n的字符串型关键字，每位字符占位即如图所示。
具体实现时并不需要做乘法运算，而是通过一次左移位来完成，如参考代码所示。这也是
为什么选用来代替公式中的的原因。
…
key key keyn keyn
图 关键字位移映射示意
第章 散 列 查 找
int Hashconst charKeyint Tablesize
unsigned int H 散列函数值，初始化为
while·Key o 位移映射·
HHKey
return H Tablesize
代码 散列函数——位移映射
该函数遇到的主要问题是，当n太大时例如关键词是一段邮寄地址所组成的字符串前
面若干位字符可能被左移出界，而起作用的只有最后几位字符。一种解决的办法是不使用整个
字符串，而是从中选择若干位有代表性的字符进行映射，比如字符串长度大于的时候，仅选取
奇数位置上的字符来实现散列函数。
处理冲突的方法
在前面的散列函数构造过程中，我们努力使散列地址均匀分布于整个地址空间，但是实
际应用中，冲突只能尽量减少，而不能完全避免。接下来我们讨论在冲突发生时，如何有效地
解决它。常用的处理冲突的方法有两种：开放地址法Open Addressing和链地址法Linear
Probing。
开放定址法
假如你打算在某小区买套房子住，根据你的生辰八字关键词风水先生散列函数告诉
你最适合你。正准备下单的时候，开发商却告诉你说该房子已经被其他人买走了冲突
发生啦此时你会怎么办呢其实很简单，只能换一套房子看看呗这就是解决冲突的开放地
址法。而“换一套房子”的策略也有不同，比如可以看看或者或者或者
等，这种试探紧邻的单元有没有空的策略叫做线性探测法。当然你也可以换一个策略平
方探测、双散列决定试探其他房子。
所谓开放定址法，就是一旦产生了冲突，即该地址已经存放了其他数据元素，就去寻找另一
个空的散列地址。在没有装满的散列表中，空的散列地址是否总能找到，这也是我们在选择解决
冲突方法时要考虑的因素之一。
一般来说，发生了第i次冲突，我们试探的下一个地址将增加d。它的基本公式是：
hkeyhkeydmod TableSize≤iTableSize公式
根据d的选取方式不同，我们可以得到不同的解决冲突方法。上面的地址必须对TableSize
处理冲突的方法
取余，否则可能超出散列表的地址空间。
线性探测法
如果公式中的d就选为i那么它就是线性探测法。即线性探测法以增量序列
…TableSize循环试探下一个存储地址。做插入操作的时候，要找到一个空位置，或者知
道散列表已满为止；做查找操作的时候，探测一个比较一次关键词，直到找到特定的数据对象，或
者探测到一个空位置表示查找失败为止。
例 设关键词序列为散列表表长TableSize散列
函数为：hkeykey mod 。用线性探测法处理冲突，列出依次插人后的散列表，并估算查找性
能。表列出了相应的地址计算和冲突情况统计。
表 散列函数计算与冲突统计
关键词
散列地址
冲突次数
表给出了用线性探测法依次插入上述序列的散列表过程。
表 线性探测法构建散列表的过程
散列
地址 说 明
操作
插入 无冲突
插入 无冲突
插入 d
插入 无冲突
插入 无冲突
插入 d
插入 d
插入 d
插入 d
如表所示，关键词、是由散列函数得到的没有冲突的散列地址而直接存入的。第
个关键词遇到h散列地址冲突，需寻找下一个空的散列地址：由hh
mod 散列地址为空，将存入。关键词、的散列地址没有冲突，直接存入。而
h散列地址又一次冲突，于是进行以下探测：
第章 散 列 查 找
hhmod 仍然冲突；
hhmod 仍然冲突；
hhmod 找到空的散列地址，存入。
类似地，关键词、分别冲突次和次才找到空地址，存入；关键词经过次冲突才
找到可以存放的地址存人。
微视频
散列表查找
性能分析
线性探测法可能使第i个散列地址的同义词存入第i个散列地址，
也就是说，本应存入第i个散列地址的数据对象变成了第i个散列地址
的同义词。因此，可能出现很多元素在相邻的散列地址上“堆积”起来的现
象，会大大降低查找效率。如上例中插入需要经过很多次冲突才找到空
位置。这种现象叫做一次聚集Primary Clustering。为减轻这种一次聚集
效应，可采用平方探测法，或双散列探测法，这些方法随后介绍。
在节中，我们介绍了平均查找长度ASL的概念，现在来估计算一
下，在这个散列表中查找数据对象的ASL。我们假设要查找的关键词一定
在散列表中存在，来计算一下平均需要查找多少次，即成功查找的ASL。只要对查找表中的每个
关键词的比较次数加起来，除以关键词的个数，就得到平均每个关键词的查找长度。而每个关键
词的比较次数是其冲突次数加。就例中的数据而言，根据表有：
成功查找的ASL≈
关于线性探测法的查找性能分析将在节中不加证明地给出。线性探测法思想简单，并
且只要散列表中有空地址，这个方法总能够找到它。
平方探测法
如果公式中的d选为±i那么它就是平方探测法Quadratic Probing。即平方探测法
以增量序列…qq且q≤TableSizeJ循环试探下一
个存储地址。有证明表示，如果散列表长度TableSize是某个kk是正
整数形式的素数时，平方探测法就可以探查到整个散列表空间。这一点
很重要，是我们能够放心使用平方探测法的理论保证。
关键词
散列地址
冲突次数
微视频
平方探测法
的理论保证
例设关键词序列为散列表表
长TableSize即满足×形式的素数散列函数为：hkey
key mod 。用平方探测法处理冲突，列出依次插人后的散列表，并估算查
找成功的平均查找长度。表列出了相应的地址计算和冲突情况统计。
表 散列函数计算与冲突统计
处理冲突的方法
表给出了用平方探测法依次插入上述序列的散列表过程。
表 平方探测法构建散列表的过程
散列
地址
说 明
操作
插人 无冲突
插人 无冲突
插人 d
插入 无冲突
插入 无冲突
插入 d
插人 无冲突
插人 dy
插人 d
类似于例中的计算，根据表有：
成功查找的ASL
例的装填因子α≈而例的装填因子α≈。从这两个例子中
看到，装填因子较大的例反而比装填因子较小的例有更小的ASL。似乎给我们一定的
暗示，平方探测法在一定程度上减轻了“聚集”效应，从而提高了散列表的查找性能。关于平方
探测法的查找性能分析将在节中不加证明地给出。
虽然平方探测法排除了一次聚集，但是散列到同一地址的那些数据对象将探测相同的备选
单元，这叫做二次聚集Secondary Clustering。二次聚集在理论上是个小缺憾，下面的双散列探
测法可以弥补这个缺憾，但也需要一定的代价，用得不好还会带来严重后果。
在开放地址散列表中，不能进行标准的删除操作，因为相应的单元可能已经引起过冲突，数
据对象绕过它存在了别处。例如在例和中，完全删除关键词将导致再也找不到关键
词了。为此，开放地址散列表需要“懒惰删除”即需要增加一个“删除标记”而并不是真正
删除它。这样可以不影响查找，但增加了额外的存储负担并增加了程序的复杂程度。代码
的类型声明中，EntryType取值Deleted的时候就表示已被删除的意思。
实现开放定址法的类型声明在代码中表示，其中关键词类型 ElementType和数组下标
Index 都在这里定义为整型，实际应用中可以根据情况定义为其他类型。
允许开辟的最大散列表长度· define MAXTABLESIZE
关键词类型用整型 typedef int EIementType
散列地址类型 typedef int Index
数据所在位置与散列地址是同一类型 typedef Index Position
第章 散 列查 找
散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素·
typedef enumI LegitimateEmptyDeleted EntryType
typedef struct HashEntry cell散列表单元类型
struct HashEntryl
ElementType Data存放元素·
EntryType Info单元状态·
I
typedef struct TbNodeHashTable散列表类型
struct TblNode 散列表结点定义·
int Tablesize 表的最大长度
CellCells 存放散列单元数据的数组
I
代码 开放定址法的类型声明
代码给出了散列表的初始化函数CreateTable。首先申请散列表需要的空间，再将每个
单元的 info域设置成 Empty表示为空。注意需要确定一个不小于TableSize的素数，用作真正的
散列表的地址空间大小，这个功能由函数NextPrime 实现。
int NextPrimeint N
I返回大于N且不超过 MAXTABLESIZE的最小素数
int ipNNN从大于N的下一个奇数开始·
whilepMAXTABLESIZE
foriintsqrtpii
ifpOibreakp不是素数
ifibreakfor 正常结束，说明p是索数
else p否则试探下一个奇数
F
return pi
HashTable CreateTableint TableSize
HashTable H
int i
处理冲突的方法
HHashTablemallocsizeofstruct TblNode
·保证散列表最大长度是素数·
HTableSizeNextPrimeTableSize
声明单元数组
HCellsCelmallocHTablesizesizeofCel
初始化单元状态为“空单元”·
foriiHTableSizei
HCellsiInfoEmpty
return H
代码 开放定址法的初始化函数
代码是平方探测法的查找函数Find。首先调用Hash 函数计算地址，以确定关键词所在
的散列表的地址。用while循环控制直到明确查找成功或者找到空位置表示查找失败，遇到冲
突则继续查找。注意：关键词Key的类型 ElementType不一定总是如代码中定义为整型，也可
能在某些应用中被定为字符串。若是字符串类型，则while的判断条件中“HCellsNewPos
DataKey要用C语言strcmp 函数来替换。若找到了关键词，函数直接返回结点的地址，若找
不到则返回一个空单元的位置。
Position FindHashTable HElementType Key
Position Current PosNewPos
int CNum记录冲突次数
NewPosCurrentPosHashKeyHTablesfze初始散列位置
当该位置的单元非空，并且不是要找的元素时，发生冲突
whileHCellsNewPosInfoEmpty
HCellsNewPosDataKey
字符串类型的关键词需要 strcmp 函数
统计次冲突，并判断奇偶次
ifCNum奇数次冲突·
增量为CNum
NewPosCurrentPosCNumCNum
ifNewPos HTablesize
NewPosNewPosHTableSize调整为合法地址
else 偶数次冲突·
第章 散 列 查 找
NewPosCurrent PosCNumCNum增量为CNum·
whileNewPos
NewPosHTablesize调整为合法地址·
return NewPos
此时NewPos或者是Key的位置，或者是一个空单元的位置表示找不到
代码 平方探测法的查找函数
代码是插入函数Insert。先检查Key是否已经存在，该地址的单元状态只要不是合法的
元素Empty 或者 Deleted就可以确定在此插入。插入后，把单元状态改成合法数据Legiti mate。与查找的情况类似，如果关键词是字符串类型的数据，语句“HCellsPosDataKey”
需要用strcpy 函数替换。
bool InsertHashTable HElementType Key
Position PosFindHKey先检查Key是否已经存在
ifHCellsPosInfo Legitimate
如果这个单元没有被占，说明Key可以插入在此
HCellsPosInfoLegitimate
HCells PosDataKey
·字符串类型的关键词需要 strcpy 函数
return true
else
printf键值已存在“
return false
代码 平方探测法的插人函数
双散列探测法
如果公式中的d选为ihkey其中hkey是另一个散列函数。我们把它叫做双散
列探测法Double Hashing。这个公式的意思是，我们的探测增量序列成了hkeyhkey
hkey……第二个散列函数hkey如果选得不好，结果将会是灾难性的。比如，如果用
处理冲突的方法
hkeykey mod 要把key插入到表的最后一行中去，这是没法实现的。原因是
h所有的探测都是同一个位置。因此，要求对任意的keyhkey都不能是值。
另外，探测增量序列还应该保证所有的散列存储单元都应该能够被探测到。一般形如
hkeypkey mod p 公式
这样的函数会有良好的效果，其中p是小于TableSize的素数。选用一个素数作为TableSize
也同样重要，否则可能探测不到所有的存储单元。
采用双散列探测法会增加每次探测的乘法和除法的计算，但其期望的探测次数比较少，这使
得它在理论上很有吸引力。不过平方探测法不需要计算第二个散列函数，从而在实践中可能更
简单又实用。
再散列法
开放地址法的装填因子αα会严重影响查找效率，由于表长在一定时间内是定
值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性
就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。实用最大装填因子一般取
α超过最大装填因子将导致查找速度严重下降。
当装填因子过大时，解决的方法是加倍扩大散列表，这样α可以减小一半，这个过程叫做再
散列Rehashing。
再散列需要新建一个两倍大的散列表，并将原表中的数据重新计算分配到新表中去，这个过
程集中花费较多的时间，因此在交互系统中会使人感觉有“停顿”现象。而在一些实时系统中使
用要充分谨慎，比如在医用的生命保障系统中，设备的短时“停顿”有可能导致严重的后果。此
时可以采用不需要再散列的“分离链接法”。
分离链接法
分离链接法Separate Chaining是解决冲突的另一种方法，其做法是将所有关键词为同义词
的数据对象通过结点链接存储在同一个单链表中。
设散列函数得到的散列地址域在区间m上，以每个散列地址作为一个指针，指向一
个链，即分配指针数组如下：
List Headsm
建立m个带头结点的空链表，散列地址为i的所有关键词均插入到Headsi指向的单链表
中。插入时，新元素插入到表头，这不仅为了方便，而且还因为新近插入的元素最有可能最先被
访问，这样可以加快在单链表中的顺序查找速度。每个分离链的单链表设计成带表头结点，根据
节可以知道，带空头结点的单链表实现插人和删除等操作的代码可以更简洁。后面的代
码到代码以及例采用的就是这样的数据结构。
例设关键字序列为散列函数取为：
hkeykey mod 。用分离链接法处理冲突，建表如图所示，注意向链表中插入元素均在
表头进行。
第章 散 列查 找
A
A
A
A
A
入
图 分离链接法处理冲突时的散列表
容易看出，该表中有个结点只需次查找，个结点需要次查找，因此查找成功的平均
查找次数ASL。
接下去我们将具体介绍分离链接法的代码实现。有关声明在代码中，在此我们设关键
词类型用字符串，且字符串的长度不超过。
A
A
关键词字符串的最大长度 define KEYLENGTH
typedef char Element TypeKEYLENGTH关键词类型用字符串
typedef int Index 散列地址类型
以下是第章中单链表的定义
typedef struct LNode·PtrTOLNode
Btruct LNode
ElementType Data
PtrTOLNode Next
typedef ptrTOLNode Position
typedef PtrToLNode List
以上是第章中单链表的定义
typedef struct TbINodeHashTable散列表类型
struct TblNode散列表结点定义·
处理冲突的方法
int Tablesize表的最大长度
List Heads指向链表头结点的数组
代码 分离链接法的结构声明
散列表结构包括一个TableSize记录表的最大长度以及一个结点数组对应的单链表，它们在
初始化时动态分配空间，并设置相应的初值。
代码是散列表的初始化函数CreateTable。首先申请散列表的头结点空间；然后确定一
个不小于TableSize的素数，用作真正的散列表的地址空间大小；最后动态分配散列表的地址列
表数组并初始化空的头结点如图所示。
H TableSize
Heads …
NULL NULL NULL
图 散列表结构
HashTable CreateTableint Tablesize
HashTable H
int i
HHashTablemallocsizeofstruct TbINode
以下分配链表头结点数组
HHeadsListmallocHTablesizesizeofstruct LNode
foriiHTablesizei
HHeadsData
HHeadsiNextNULL
return H
保证散列表最大长度是素数，具体见代码
初始化表头结点
HTablesizeNextPrimeTablesize
代码 分离链接法的初始化函数
第章 散 列 查 找
代码是查找函数Find。首先调用Hash 函数代码计算地址，得到关键词所在的
Heads 中单元的下标PosP则指向HeadsPos链表中真正的第个元素。因为关键词是字符
串，所以 while的条件判断中要用strcmp 函数来比较 Data与Key的值。若找到了关键词，函数直
接返回结点的地址，若找不到则返回空地址。
Position FindHashTable HElementType Key
Position P
Index Pos
PosHashKeyHTablesize初始散列位置
PHHeadsPosNext从该链表的第个结点开始
当未到表尾，并且 Key未找到时
whileP strcmpPDataKey
PPNext
return P此时P或者指向找到的结点，或者为NULL
代码 分离链接法的查找函数
代码是插入函数Insert。该函数先调用函数Find如果找到了关键词则不需要插入，返
回插入不成功的信息；如果找不到关键词才需要插人。插入时，先申请一个新结点NewCell然后
计算Key的地址 Pos注意，第次调用Hash函数。插入成为单链表HeadsPos的第一个
结点。
函数Insert有点不尽如人意的地方是它计算了两次散列函数，在最初的Find 函数里面计算
了一次，而在插入之前又重复计算它。一个简单的改进是Find 函数增加一个参数传递计算后的
散列地址，但这样在程序可读性方面会要付出代价。
bool InsertHashTable HElementType Key
Position PNewCe
Tndex Pos
PFindHKey
ifP关键词未找到，可以插入·
NewcelPositionmallocsizeofstruct LNode
strepyNewCellDataKey
PosHashKeyHTablesize初始散列位置·
处理冲突的方法
将Newcel插入为HHeadsPos链表的第个结点·
NewcelNextHHeadsPosNext
HHeadsPosNextNewCell
return true
elsef●关键词已存在·
printf键值已存在
return false
代码 分离链接法的插人函数
释放CreateTable函数所占用的所有内存空间可以调用代码的函数DestroyTable。
void DestroyTableHashTable H
int i
Position PTmp
释放每个链表的结点
foriiHTablesizei
PHHeadsiNext
whileP
TmpPNext
freeP
PTmp
freeHHeads释放头结点数组
freeH 释放散列表结点
代码 分离链接法的释放散列表函数
删除关键词的操作可以直接实现，因为链表结点的删除不会影响其他关键词。就这一点来
说分离链接法比开放地址法要好。删除操作的程序实现作为一道练习留给读者。
第章 散 列 查 找
散列表的性能分析
散列表的查找过程基本上和建表过程相同。一些关键字可通过散列函数转换的地址直接找
到，另一些关键词在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介
绍的两种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键字进行比较的过程。所以，
在上一节中的例和例中，我们已经用平均查找长度ASL来度量散列表查找效率。
查找过程中，关键词的比较次数，取决于产生冲突的多少。产生的冲突少，查找效率就高；产
生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影
响产生冲突多少有以下三个因素：
散列函数是否均匀；
处理冲突的方法；
散列表的装填因子α。
分析这三个因素，尽管散列函数的“好坏”直接影响冲突产生的频度，但一般情况下，我们总
认为所选的散列函数是“均匀的”因此，可不考虑散列函数对平均查找长度的影响。
另外，期望的平均查找次数与操作有关，插入操作和不成功的查找需要探测相同的次数，成
功查找应该比不成功查找花费较少的查找次数。
线性探测法的查找性能
可以证明，线性探测法的期望探测次数p满足下列公式：
对插人和不成功查找而言
对成功查找而言
公式
假设α那么可以算出，插人操作和不成功查找的期望查找长度是次，成功查找的
期望查找长度是次。例子的α这两类期望查找次数分别次和次例
中实际成功查找的ASL是。
平方探测法和双散列探测法的查找性能
可以证明，平方探测法和双散列探测法的期望测次数p满足下列公式：
成功查找而言
寸成功查找而言
公式
假设α那么可以算出，插入操作和不成功查找的期望查找长度是次，成功查找的期
望查找长度是In ≈次。例子的α这两类期望查找次数分别次是和
应用 实 例
次例中实际成功查找的ASL是。
图表示了上面几种探测法的期望探测次数与装填因子α的关系。当装填因子α
的时候，各种探测法的期望探测次数都不大，也比较接近。随着装填因子的增大，线性探测法的
期望探测次数增加较快，不成功查找和插入操作的期望探测次数明显比成功查找的期望探测次
数要大。合理的最大装入因子α应该不超过。
UI UI
s
S
图 期望探测次数与装填因子α的关系
线性探测法虚线、双散列探测法实线
U表示不成功查找，I表示插入，S表示成功查找
分离链接法的查找性能
为了给出分离链接法的期望查找次数，先定义分离链接法的装填因子。我们把分离链接表
中每个链表的平均长度定义成装填因子α因此这个α有可能超过。
不难证明：分离链接表中每个链表的平均长度为α那么其期望探测次数p为：
对插入和不成功查找而言
对成功查找而言 公式
假设α可以算出，插人操作和不成功查找的期望查找长度是次，成功查找的期望
查找长度是次。例子的个元素分布在个单链表中，所以α≈这两类
期望查找次数分别次是和次例中实际成功查找的ASL是。
应用实例
《哈利·波特》Harry Potter是英国作家J·K·罗琳的奇幻文学系列小说，被翻译成了近
七十多种语言，在全世界两百多个国家，截至年的累计销量已达四亿多册。下面关于
·出自《数据结构与算法—C语言描述》英文版第版，Mark Allen Weiss著。
第章 散 列 查 找
“Harry Potter”的问题你会不会觉得很奇怪呢：谁能告诉我，在其共七集的小说中，Harry Potter
的名字总共出现了多少次
用本节讨论的程序，你只要输入小说的文本文件，就可以知道答案。该程序不仅可以回答上
面的问题，它实际上可以统计所有单词的出现次数。
例给定一个英文文本文件，统计文件中所有单词出现的频率，并输出词频最大的前
单词及其词频。假设单词字符定义为大小写字母、数字和下划线，其他字符均认为是单词
分隔符。
解决这个问题的最基本的工作、也是大量的工作是不断对新读入的单词在已有单词表中查
找，如果已经存在，则增加该单词的词频，如果不存在，则插入该单词并记词频为。
关键问题是，如何设计该单词表的数据结构才可以进行快速地查找和插入呢散列表结构
正好符合快速查找的要求。
需要注意的是，在这个问题中我们将要统计每个单词的词频，所以代码中的链表结点类
型LNode必须增加计数器 Count用于存储该单词的出现次数。空头结点中的Count 被利用来存
储该单链表中的结点数，并且在代码的CreateTable 函数中应被初始化为。更改后的结点
声明如下：
struct LNode
ElementType Data
int Count
PtrToLNode Next
下面给出解决该问题的完整程序。
主控函数代码先将散列表的大小估计为——这不是素数，不过散列表初始化时
会调用代码求出比较接近的素数，用作真正的散列表大小。这个估计大小可以根据应用问
题的规模更改。如果你有《哈利·波特》的电子版文本文件，做词频统计的散列表的大小取
左右比较合适。
在创建了散列表之后，进入 while循环，每次调用CetAWord 函数从文件中读一个单词。这
里要求根据返回的单词的长度，过滤太短的没有多大意义的单词。如果需要的话，还可以增加条
件，过滤掉全数字的单词等。然后统计文件中的单词数量，并调用 InsertAndCount 函数实现把该
单词插入到散列表结构中，并计算它的词频。重复以上过程直至输入文件结束。
函数InsertAndCount是对代码给出的Insert 函数的一个改编，主要的修改有三点；一是
将NewCell 插入为HHeadsPos链表的第个结点时，要将NewCell的Count 初始化为即
这是新单词第一次出现；二是插入后HeadsPos头结点的Count要加表示这个链表中增加了
一个新单词；三是如果一开始 Find 函数找到了关键词，不需要打印错误信息，而是应该把找到的
这个P指向的结点的Count加即执行“PCount”表示这个单词又出现了一次。完整代码
在代码中给出。
应用 实 例
此时，已经完成把文件中的所有单词与词频信息存入散列表中。据此，调用Show 函数显示
词频前单词。
销毁散列表函数 DestroyTable将释放由初始化函数申请的全部内存空间。“有借有还，再借
不难。尽管程序运行结束后，操作系统会回收应用程序的内存空间，但还是强烈建议不要忘记
这个步骤。良好的程序设计习惯将使你受益匪浅。
int main
PILEfp
HashTable H需改编代码结点增加计数器Count·
ElementType word
int Tablesize·散列表的估计大小，可以根据应用更改·
int lengthwordcount
char documentHarryPottertxt要被统计词频的文件名
HCreateTableTablesize用代码建立散列表
iffpfopendocumentrNULL
printf无法打开文件 n
whilefeoffp
lengthGetAWordfpword读取一个单词·
iflength只考虑长度大于个字符的单词
wordcount
InsertAndCountHword改编代码统计 word出现次数
fclosefp
printf该文档共出现 d 个有效单词wordcount
ShowH显示词频前的所有单词
DestroyTableH用代码销毁散列表
return
代码 主函数
void InsertAndCountHashTable HElementType Key
Position PNewCell
第章 散 列查 找
Index Pos
PFindHKey
ifP关键词未找到，可以插人
NewcellPositionmallocsizeofstruct LNode
strcpyNewCelDataKey
NewcellCount新单词第一次出现人
PosHashKeyHTablesize初始散列位置·
将Newcell插入为HHeads Pos链表的第个结点·
NewCelNextHHeadsPosNext
HHeads PosNextNewCell
HHeadsPoscount链表中增加了一个新单词
else关键词已存在·
PCount
代码 插入单词并统计词频
代码的IsWordChar 函数判断一个字符是否为合法的单词字符。本例中单词的合法字
符为大小写字母、数字和下划线。
bool IsWordCharchar c
ifcacz cA反cz Ieoce e
return true
else
return false
代码 判断合法的单词字符
代码的GetAWord 函数从给定文件中读取一个单词，返回该单词的长度，超出
KEYLENGTH本例中定义为的长度将截去。
define MAXWORDLEN 所有单词最大长度
int GetAWordFILEfp ElementType word
应用 实 例
char tempword MAXWORDLENc
int len单词长度·
cfgetcfp
whilefeoffp
ifISWordCharc如果是合法的单词字符
tempwordlenc
cfgetefp
跳过单词前的非法字符，或以非法字符结束一个单词
iflen IsWordcharc
breaks一个单词结束
tempwordleno设定字符串结束符
iflenKEYLENGTH·太长的单词被截断
tempwordKEYLENGTH
lenKEYLENGTH
strcpyword tempword
return len
代码 读取一个单词
最后介绍代码。Show 函数显示词频前一定百分比的单词。另外，附带的一些统计功能
都可以在这个函数里面加入。比如有多少不同单词的数量有别于文件中单词数，不计重复单
词、最大词频的单词是哪些单词、冲突次数单链表的长度大小的分布情况作为练习，读者自
己修改实现等。
Show 函数的大概流程如下：首先用第一个for循环扫描整个散列表，统计不同的单词数量和
最大词频maxf其次，根据最大词频maxf申请一个数组 difwords用于存储词频从到maxf的单
词数量；然后，根据每个词频的单词数数组才能划定最频繁出现的前给定百分比Percent的单
词应该有多大的词频i最后一个for 循环按词频从大到小输出单词；当然，不要忘记释放数组
diffwords占用的内存空间。
void ShowHashTable Hdouble percent
int diffwordcount不同的单词数量·
每个词频对应的不同单词数量·
int maxf 最大的词频
最大冲突次数，初始化为
intdiffwords
int maxColision
第章 散 列 查 找
int mincollision最小冲突次数，初始化为·
Position L
int ijklowerboundcount
foriiHTablesizei
求不同的单词数量·
diffwordcountHHeadsiCount头结点 Count 统计链表长度·
统计最大和最小冲突次数
ifmaxcollisionHHeadsiCount
maxCollisionHHeadsiCount
ifmincollisionHHeadsiCount
minCollisionHHeadsiCount
求最大的词频
LHHeadsiNext从每个链表的表头开始·
whileLI遍历链表
ifmaxfLCountmaxfLCount
LLNext
结束for循环
printf共有d个不同的单词，词频最大是tdndiffwordcountmaxf
求每个词频等级拥有的不同单词数量·
diffwordsint·mallocmaxf·sizeofint
foriHTablesizei
LHHeadsNext
whileL遍历链表·
diffwordsLCount该词频增加一个单词
LLNext
printf最大冲突次数是d最小冲突次数是 tdnmaxcollisionmincollision
根据最大的词频，分配一个整数数组·
统计词频从到maxf的单词数量
foriimaxfi
diffwords
本 章 小结
求特定的词频，使得大于等于该词频的单词总和超过给定的比例·
lowerboundintdiffwordcountpercent
forimaxfi countlowerboundi
countdiffwords
按词频从大到小输出单词
forjmaxfjij对每个词频
forkkHTableSizek遍历整个散列表·
LHHeadskNext
whileL
ifjLCount发现一个单词的词频与当前词频相等
输出该单词及词频
printfsdnLDataLCount
LLNext
freediffwords
代码 显示词频超过给定的比例的所有单词
代码值得讨论的是，最后一个for循环按词频从大到小输出单词，其效率是成问题的，
如果输入的文件很大而输出的百分比也不小的话，将花费较多的时间。读者可以用第章排序
中介绍的方法，尝试改写这部分代码，使其对大数量输出时提高效率。当然，如果输出单词不需
要按照词频从大到小的顺序，那么可以省去最外层的 for 循环，并把语句“ifjLCount”改
成ifiLCount即可成为高效的程序。
本 章 小 结
顺序查找、二分查找和树形查找等方法，由于数据对象的存储位置与其关键字之间不存在确
定的关系，因此，查找时，需要进行一系列对关键字的查找比较，即“查找算法”是建立在比较的
基础上的，查找效率由比较一次能够缩小多少查找范围来决定。而本章介绍的散列方法是依据
关键字直接计算得到其对应数据对象的位置，即要求关键字与数据元素间存在一定对应关系，通
过这个关系，能很快地由关键字得到对应的数据对象位置，这就是散列方法的思想核心。关键词
是字符串的时候，由于字符串比较过程较之于整型的地址比较需要花费更多的时间，所以散列方
法相对于其他查找方法有更好的查找效率。
第章 散 列查 找
在合适的散列函数和装入因子下，散列法的查找效率是常数它几乎与查找空间的大
小n无关。这一点是非常诱人的。
另一方面，常数的查找时间复杂度不是无条件的。总的来说，它是以较小的装入因子α为
前提。因此，散列方法是一个以空间换时间的成功范例。
散列方法的两个基本内容是散列函数的构造与冲突的解决策略。
构造散列函数的原则是“计算简单”和“分布均匀”。对整数型的关键词，采用除留余数法是
比较好的方法，通常取除数为素数。对字符串关键词采用移位法是好的选择。
解决冲突的策略我们介绍了开放地址法和分离链接法。开放地址法的散列表是一个数组，
散列函数求得的地址对应数组下标。开放地址法相对于分离链接法而言有较高的存储密度和存
取效率。开放地址法的冲突解决方法又分成线性探测法、平方探测法和双散列法。使用这些方
法的两个要点是：避免或减少“聚集”现象；保证可以循环探测到每个地址。第一点主要考虑采
用“好”的散列函数和合适的探测法；第二点主要采用特定形式素数k的散列表大小和特定
的双散列函数。
当装填因子过大时，我们可以通过再散列将数据重新分配到一张两倍大的散列表中去。不
过这个过程需要一次性花费较多的时间，对于一些实时性要求非常高的系统而言，宁可可以采用
不需要再散列的分离链接法。
分离链接法是把冲突的关键词链接成一个单链表，而所有的单链表的头结点构成的数组与
散列表地址对应。链表指针的存储和操作会付出一些空间和时间效率的代价。选择“不好”的
散列函数和太小的表头数组会导致有的单链表太长，而在单链表中的查找完全是顺序的，所以长
的单链表将严重影响效率。
分离链接法的装入因子α定义为这些单链表的平均长度。太小的装入因子α可能导致较
多的空间浪费，较大的装入因子α又将付出更多的时间代价。选择≤α≤或将是比较好的
折中。
另外，开放地址法中删除数据对象需要做临时的“懒惰删除”等待有插入时或者进行再散
列时再行处理。这样散列表中会有部分“垃圾”影响空间和时间效率。而分离链接法中删除数
据对象不需要特别处理，从而也不会存在这样的“垃圾”所以需要做频繁插入和删除操作的散
列表可以首先考虑使用分离链接法。
散列方法的存储是随机的，它不便于顺序查找，比如例中按词频大小次序输出单词，或
者按照单词的字母序输出单词都是比较麻烦的事情；它也不适合于范围查找，比如查找车价在
万元到万元的所有车型；同样它也不适合查找最大值、最小值等。
习 题
判断正误。
在散列表中，所谓同义词就是被不同散列函数映射到同一地址的两个元素。
习题
将个元素散列到 个单元的哈希表中，一定不会产生冲突。
若用平方探测法解决冲突，则插入新元素时，若散列表容量为质数，插入就一定可以成功。
填空题。
假定有K个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，要进行的探测次数至
少为。
从一个具有N个结点的单链表中查找其值等于X的结点时，在查找成功的情况下，需平均比较
个结点。
用公式计算一下你姓名的散列值是多少。假定你姓名的关键词是各个汉字的首拼音字母构成的
字符串，比如“张三的关键词是“ZS”。
在例中，如果最后还要插入关键词它应该插入到散列表的哪个位置
设有一组关键宇散列函数为：Hkeykey 采用线性
探测方法解决冲突。试在到的散列地址空间中对该关键字序列构造散列表，并计算成功查找的平均查找
长度。
设有一组关键字散列函数为：hkeykey 采用平方
探测方法解决冲突。试在到的散列地址空间中对该关键字序列构造散列表。
设有一组关键字散列函数为：hkeykey 采用下列双散列
探测方法解决第次冲突：hkeyhkeyi hkeymod 其中hkeykey mod 。试在到
的散列地址空间中对该关键字序列构造散列表。
已知线性表的关键字集合散列函数hkeykey 采用
分离链接法处理冲突，试给出散列表的结构，并计算该表的成功查找的平均查找长度。
将关键字序列散列存储到散列列表中，散列表的存储空间是一个下标从开始
的一个一维数组。处理冲突采用线性探测法，散列函数为：hkeykey×mod TableSize要求装入因子
为。
试实现线性探测法的查找函数Find。
试实现分离链接法的删除操作函数Delete。
试修改代码中的Show 函数，使得程序能输出文件中有多少个不同的单词。
利用节介绍的方法和程序代码，调试实现一个完整的程序。该程序能够对一个英文文本文件
最好达到数万单词统计文件中所有不同单词的个数，以及词频最大的前单词。
第章
图
引子
网络在我们的生活中随处可见，计算机网络、交通网络、电话网络、超文本链接，甚至人际关
系网络都将人们的日常生活高效地联接起来。不论是网络中的电缆、无线电通信线路，还是交通
中的道路，都能以多种方式连接事物。本章我们将看到并解决在各种网络图中许多有趣的问题。
假设某个山区县为了加快发展农村建设；决定实施公路村村通项目。该项目包括必要时对
已有公路的升级改造。但是资金是有限的，钱必须用在刀刃上。县长提出的要求是，如何能够用
最小的资金投入完成公路村村通项目。
我们来考虑相对小一点的范围，比如一个镇，如图所示，共有十个村：卜家村B、陈家
村C、丁家村D、冯家村F、何家村H、李家村L、魏家村W、徐家村X、杨家村
田田田 m
魏
用同
田田
画 田
田回
le
圈
图 一个山区乡镇的公路规划示意图
图的基本概念
Y、张家村Z。图中村与村之间的道路是一个较长远的规划目标。有的邻村之间暂时
没有规划道路的原因可能是自然地理不适合建设道路。
由于资金的原因暂时不能建设所有的道路，但是公路村村通项目要求用最小的投入实现每
个村都能够有公路通达。那么应该选择建设哪些道路可以使这个投资最小呢
你暂时回答不上来是很正常的。这一章要介绍一种非常有意思的数据结构——图，图的应
用非常广泛，我们日常生活中的许多问题都可以归结为图的问题。学完这一章，你就知道该如何
去解决公路村村通问题了。
当然，要准确描述这个问题，还需要给出每条规划公路的造价预算。图就是给出了造价
预算的示意图，比如魏家村W到徐家村X的公路造价预算为万元。这个问题将在
节中详细讨论。
⑦ ×
w
B
H
L
D
C
F
图 公路规划及造价预算示意图
图的基本概念
图状结构是一种比树形结构更复杂的非线性结构。在树形结构中，结点间具有分支层次关系，
每一层上的结点只能和上一层中的至多一个结点相关，但可能和下一层的多个结点相关。树的关
系也叫做一对多关系。而在图状结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可
以是任意的。比如“朋友”关系是一种多对多的关系，因为我认识的朋友，他们之间可能也相互是朋
友。图的结构是任意两个数据对象之间都可能存在某种特定关系的数据结构。
为了以后陈述上的方便与准确，需要对图中涉及的许多术语给出明确的定义或约定。不过
这些术语不是随意取名的，只要你用心体会，它们其实还是比较有规律的。
图的定义和术语
图的定义
图Graph是由两个集合构成，一个是非空但有限的顶点集合V另一个是描述顶点之间关
系——边的集合E可以是。因此，图可以表示为GVE。每条边是一顶点对vw且v
第章 图
w∈V。通常用V表示顶点的数量，用E表示边的数量。
例图给出了一个图的示例，在该图中：
集合VBCDFHLWXYZV
集合EZBZWBWBLBDDLWXWLLH
LFXHXYHYHFHCFCYCE。
关于图的定义，与以前的线性表和树比较，还有几点需要明确：
在线性表中，一般叫数据对象为元素；在树中，将数据对象称为结点；而在图中，我们把
数据对象称作顶点Vertex。
线性表中可以没有数据对象，此时叫空表；没有数据对象的树称为空树；而在图中，我们
至少要求有一个顶点，但边集可以是空。
图的相关术语
图的术语比树的术语要多得多，而且许多概念对于初学者来说难以一下子理解。如果阅读
本节太觉乏味，你可以初步了解一下后先进大后面小节的学习，在以后发现对某个术语不甚理解
的时候再回到本节来仔细琢磨就行了。
无向图Undirected Graphs如图、图a所示的图叫无向图。无向图中顶点之
间的边Edge没有方向，即边vw等同于wv。用圆括号“”表示无向边。边的起点w和
终点v次序并不重要。
例对图a来说，GVE其顶点集合V边的集合E
I。
有向图Directed Graphs如图b所示的图叫“有向图”。有向图中顶点之间的所
有边都有方向，即边vw不同于wD。用尖括号“”表示有向边。有向边也称弧Are。弧
的“起点弧头和“终点弧尾”的次序不能随意颠倒。在不会混淆的场合，有向边和无向边
都简称为“边”。
例对图b来说，GVE其顶点集合V边的集合E
。
O ① ①
② ③
② ③ ④
a无向图G b有向图C
图 两种基本图
简单图Simple Graph如果图中出现重边即边的集合E中有相同的重复元素或者
自回路边即边的起点和终点是同一个顶点就叫做非简单图，如图所示。它们都不在要
讨论的范围，我们考虑的都是“简单图”。
图的基本概念
O ① O ①
② ③ ②
a重边图 b自回路图
图 两种非简单图
邻接点Adjacent Vertices如果vw是无向图中任意一条边，那么称v和w互为邻接
点；如果vw是有向图中任意一条边，那么称起点v“邻接到”Adjacent to终点w也称终点w
“邻接自”Adjacent from起点v。比如，考察图中的有向图G顶点邻接到顶点或者说
顶点邻接自顶点。
路径Path、简单路径Simple Path、回路Cycle也叫做“环”、无环图Acyclic
Graph图中的一条路径是一顶点序列nD…D序列中任何相邻的两顶点都能在图中找到
对应的边，即nD∈EI≤iN。一条路径的长度是这条路径所包含的边数。比如，考察图
中的无向图G顶点序列是从顶点到顶点的一条路径，该路径长度是。
一条简单路径是指除了路径的首尾顶点外，其余顶点都是不同的。
有向图中的一条回路是指vv的一条路径。路径长度为的回路是一个自回路属于非
简单图。简单路径形成的回路称为简单回路Simple Cycle。
如果在一个有向图中不存在回路，那么这个有向图称为无环图。比如，考察图中的有向
图G它有个简单回路：、和回路不是简单
回路。
对于无向图，由于顶点是无序的，环路的长度要大于等于。比如路径uvu不会是一条环
路，因为uv和vu是同一条边，它是重边图，不属于讨论之列。
无向完全图Undirected Complete Graph在一个无向图中，如果任意两顶点都有一条边相连
接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，共有nn条边。
有向完全图Directed Complete Graph在一个有向图中，如果任意两顶点之间都由方
向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，共
有nn条弧。
顶点的度Degree、入度Indegree、出度Outdegree顶点v的度是指依附于该顶点的边
数。在有向图中，顶点的度还要分为人度与出度。顶点v的人度是指以顶点v为终点的弧的数目；顶
点v的出度是指以顶点o为起点的弧的数目。有DegreeoIndegreen Outdegreev。
例在图a中的G有：DegreeDegreeDegreeDegree。
在图b中的G有：
IndegreeutdegreeDegree
IndegreeOutdegreeDegree
IndegreeutdegreeDegree
第章 图
IndegreeOutdegreeDegree
IndegreeOutdegreeDegree。
可以证明，对于具有n个顶点、e条边的图不论是有向图还是无向图每个顶点v的度
Degreev与顶点的个数n以及边的数目e满足关系：
eDegreevAlndegreeuOutdegree 公式
稠密图Dense Graph、稀疏图Sparse Graph若一个图的边数接近完全图的边数，称这
样的图为稠密图；相对地，称边数很少的图为稀疏图。通常，设图GVE如果边的数量为E
顶点的数量为V一个图的稠密度Density定义为平均顶点度EV显然，对于完全图
来说，平均顶点度应该是V。由EVVI可知，EVV。
类似地，我们把稠密图定量定义成“平均顶点度与顶点数量V成正比的图”由EV
kVk可知，EkVk。对一个具体的图来说，当然这里的k不能
太小，比如取k。有的教材也用是否满足EV logV作为稠密图和稀疏图的分
界条件。
权Weight、网图Network根据需要边可以附带一个数值信息，通常称这个信息为
权或代价Cost。在实际应用中，权值可以有某种含义。比如，在一个反映城市交通线路的图
中，边上的权值可以表示该条线路的长度、造价或者等级；对于一个电子线路图，边上的权值可以
表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示边
代表的工作所需要的时间等。边上带权的图称为网图。如图所示的公路规划及造价预算示
意图，就是一个无向网图。如果边是有方向的带权图，则就是一个有向网图。在不会引起混淆的
时候，为了简便起见，网图也简称为图。
I子图Subgraph对于图GVE和GVE若满足V是V的子集，并且E是E
的子集，则称图G是G的一个子图。
例图示出了G和G的三个子图G、G和Gi。
O ① ◎ O ① O ①
② ③ ② ③ ② ③
a无向图G bGi cGi dGi
O ① ①
③ O ① ② ③ ④ ③ ④ ② ④
e有向图C fC gGz hG
图 子图示例
图的基本概念
连通图Connected Graph、连通分量Connected Component在无向图中，如果从一个
顶点v到另一个顶点pi≠j有路径，则称顶点v和v是连通的Connected。如果图中任意两顶
点都是连通的，则称该图是连通图。无向图的极大连通子图称为连通分量。连通分量的概念包
含以下个要点：
●子图：连通分量应该是原图的子图；
● 连通：连通分量本身应该是连通的；
● 极大顶点数：连通子图含有极大顶点数，即再加入其他顶点将会导致子图不连通；
● 极大边数：具有极大顶点数的连通子图包含依附于这些顶点的所有边。
因此，连通的无向图只有一个连通分量，这个连通分量就是本图。比如，图中的无向图
C的连通分量就是C本身。不连通的无向图有多于一个的连通分量。
例 如图其中无向非连通图C有两个连通分量，如图b、c所示，而图
d虽然也是a的子图，并且是连通的，但是d没有达到极大的顶点数，所以
d不是G连通分量。
A B A B A
BE FD
E
C
F
C D C
a无向图G b c d
图 无向图及连通分量
强连通图Strongly Connected Graph、强连通分量Strongly Connected Component对
于有向图来说，若图中任意一对顶点v和vi≠j均既有从v到v的路径，也有从v到v的路径，
则称该有向图是强连通图。有向图的极大强连通子图称为强连通分量。
强连通分量的概念与连通分量类似，也包含个要点。图中有向图G是强连通图任
意两个顶点都存在来回双向路径，请读者自行验证所以G本图就是一个强连通分量。不是强
连通的有向图有多于一个的强连通分量。
例如图其中有向非强连通图G有两个连通分量，如图b、c所示，而
图d既不是a的子图，也不是强连通的，所以d不是G的强连通分量。
A D A A
B
① B B
a有向图G b c d
图 有向图G的两个强连通分量
第章 图
生成树Spanning Tree所谓连通图G的生成树，是G的包含其全部n个顶点的一个
极小连通子图。它必定包含且仅包含G的n条边。图中连通图G有个顶点，任何包含
这全部个顶点的有条边的连通子图都是G的生成树。显然，生成树有可能不唯一。
O ① O ① O ① O ①
② ③ ② ③ ② ③ ② ③
aG G cG dG
图 G及其生成树
有n个顶点的图，如果边的数量小于n那么它必定是不连通的，所以 n是连通图所需
的“极小”的边的数量。而多于n条边的图必将产生回路，它就不是树了，因为树中是没有回
路的。由此可见，图G是一棵树，当且仅当G满足下面个条件之一：
·G有n条边，且没有环；
·G有n条边，且是连通的；
● G中的每一对顶点有且只有一条路径相连；
·G是连通的，但删除任何一条边就会使它不连通。
对有向图来说，生成树应该是一棵有向树。如果一个有向图恰有一个顶点的入度为其余
的顶点入度为则它就是一棵有向树Directed Tree。对有向树的理解并不难，入度为的顶
点就是树的根，其余顶点入度为表示非根结点只有一个父结点。
生成森林Spanning Forest在非连通图中，由于每个连通分量都是一个极小连通子
图，即一棵生成树可以对应一个连通分量。对应各个连通分量的各棵生成树就组成了一个图的
生成森林。对无向图而言，一个图的生成森林中树的数量就等于它的连通分量数。
对有向图来说，一个强连通分量当然可以得到对应的生成树不唯一但是，非强连通图也
可能只需用一棵生成树有向树与之对应。
例如图所示，图a有个强连通分量，而b、c或者d
中的任意一棵树都是a的生成树。所以生成森林中树的数量可能会少于强连通分
量数。
A D A D A D A ①
B B C B B
a有向图G b顶点A为根 c顶点B为根 d顶点C为根
图 非强连通有向图G的生成树
图的存储结构
图的抽象数据类型
对图的构成及其特性了解以后，现在可以给出图的抽象数据类型，其描述为：
类型名称：图Graph。
数据对象集：一非空的顶点集合Vertex和一个边集合 Edge每条边用对应的一对顶点
表示。
操作集：对于任意的图G∈Graph顶点VeVertex边EeEdge以及任一访问顶点的函数
Visit我们主要关心下列操作：
Graph CreateGraphint VertexNum构造一个有VertexNum个顶点但没有边的图；
void InsertEdgeGraph GEdge E在G中增加新边E
void DeleteEdgeGraph GEdge E从G中删除边E
bool IsEmptyGraph G如果图G为空，返回 true否则返回false
void DFSGraph GVertex VVisitVertex在图G中，从顶点V出发进行深度优
先遍历；
void BFSGraph GVertex V·VisitVertex在图G中，从顶点V出发进行广度优
先遍历。
与图相关的操作还有很多，这里我们只列出最常见的几个，在后面一一讨论。
图的存储结构
图是一种结构复杂的数据结构，主要表现在逻辑上任意顶点之间都可以存在特定关系。而
这些顶点位置和边的次序可以有某种随意性。比如图中的个图表示的是同一个逻辑
问题。
在顶点和边的数量不多的时候，比如教材上给出的所有示意图，画在纸上我们可以一目了然
图的结构和边上的信息。但是当顶点和边的数量达到几十、几百、几千的时候，我们就很难看清
楚这些关系了，更何况计算机没有我们的“慧眼”。那么如何把图的所有信息完整地存储在计算
机中，并可以方便地存取和修改呢
从图的定义可知，一个图的信息包括两部分，即图中顶点的信息以及描述顶点之间的关
系——边或者弧的信息。因此无论采用什么方法建立图的存储结构，都要完整、准确地反映这两
方面的信息。
下面介绍几种常用的图的存储结构。
第章 图
G H
B C
F
A D
C D H G
E
B A E F
a b
B
A D G H
E F A
H G
E
B D
E
c d
图 个等价的图
邻接矩阵
所谓邻接矩阵Adjacency Matrix的存储结构，就是用矩阵表示图中各顶点之间的邻接关系
和权值。假设图GraphVE有n个确定的顶点，即VtoD…v则表示Graph 中各顶
点相邻关系为一个n×n的矩阵G矩阵的元素为：
cu。或不是EGmsp中的边
若Graph是网图，则邻接矩阵可定义为：
若v或DB是EGraph中的边
Ci们或若vv或不是ECraph中的边
其中，w表示边vD或vD上的权值。在有权值的图中，因为可能被误认为是权值，所以
有时用○表示没有边。∞表示一个计算机允许的、大于所有边上权值的数。
例图左边所示的无向图的邻接矩阵列于在右边。从图可以看出，无向图
对应的邻接矩阵必定是对称矩阵回忆一下，对称矩阵在《线性代数》中是怎么定义的
GiiGji。C表示vov是图的一条边；而G表示图中不存在
vov这条边。主对角线上的元素必定为因为不存在自回路顶点。。顶点的度就是对应行
或对应列中的元素个数。
图的存储结构
o
O o
v的度为
G
②
v
v
主对角线
图 一个无向图的邻接矩阵表示
例图左边所示的无向网图的邻接矩阵表示法列在右边。从图可以看
出，有向图对应的邻接矩阵可以是不对称的一定是不对称的吗否。主对角线上的元素也
必定为∞或。G表示是图的一条边弧而G表示图中不存
在这条边弧。顶点的出度就是对应第行中非的元素个数是。
O
o
①
② G
可
③
ni 出度
④
入度 主对角线
图 一个有向网图的邻接矩阵表示
从图的邻接矩阵存储方法容易看出这种表示具有以下特点。
无向图的邻接矩阵一定是一个对称矩阵。因此，在具体存放邻接
矩阵时只需存放上或下三角矩阵的元素即可。所需存储元素的个数是
V×V。
对于无向图，邻接矩阵的第i行或第i列非元素或非元 无向图邻接 素的个数正好是第i个顶点的度Degreev。 矩阵的存储
微视频
对于有向图，邻接矩阵的第i行或第i列非元素或非元素 技巧
的个数正好是第i个顶点的出度Outdegreev或入度Indegreev。
用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否
有边相连，只需考察邻接矩阵对应的元素即可；确定一个顶点的所有邻接点，也只需邻接矩阵对
应的一行或一列但是，要确定图中有多少条边，则必须按行或按列对每个元素进行检测，
所花费的时间代价是θV。这是用邻接矩阵来存储图的局限性。
下面介绍图的邻接矩阵存储的C语言描述。
在用邻接矩阵存储图时，除了用一个二维数组存储表示顶点间相邻关系的邻接矩阵外，还需
用一个一维数组来存储顶点信息，另外还有图的顶点数和边数。故可将其形式描述如下：
如代码所示，最大顶点数MaxVertexNum暂设为可以根据需要更改。顶点数据类
第章 图
微视频
型DataType设为字符型，这也是为了简单起见，事实上关于顶点的信息可
以很多，一般应使用一个struct类型来描述。边的权值类型WeightType一
般为整型，但必须注意区分合法权值和无边的表示值或或负数，根据
应用选择特别的约定。顶点类型Vertex 被定义为整型，意即用顶点的下
标代表顶点所以当我们提到顶点i的时候，就指的是v。 邻接矩阵表 MGraph是邻接矩阵存储的图类型，它是指向图结点的指针。我们把这 示法的结构
两个类型都定义成指针，是为了传递函数参数的方便。图结点不仅包含图 和类型声明
的顶点数Nv和边数Ne还有一个二维数组G存储邻接矩阵，一个一维数组
Data存储顶点数据，它们的大小都采用MaxVertexNum固定值。采用固定
大小的数组可能会导致比较大的空间浪费，实际上，最好根据问题的大小顶点数Nv动态分配
它们的大小。这件事情作为练习留给读者去尝试完成。
最大顶点数设为 fdefine MaxVertexNum
设为双字节无符号整数的最大值
图结点的定义·
typedef struct GNodePtrTOGNode
int Nv顶点数·
WeightType GMaxvertexNum MaxvertexNum 邻接矩阵
注意：若顶点无数据，此时 Data可以不用出现·
I
typedef ptrToGNode MGraph以邻接矩阵存储的图类型
define INFINITY
用顶点下标表示顶点，为整型
struct GNodel
int Ne 边数
DataType DataMaxVertexNum 存顶点的数据·
typedef int Vertex
边的权值设为整型 typedef int WeightType
顶点存储的数据类型设为字符型 typedefchar DataType
代码 邻接矩阵表示法的结构和类型声明
有了图的结构与类型定义，代码通过先创建一个包含全部顶点但没有边的图，再逐条插
入边，从而创建了一个无向网图的数据对象。其中Edge是边的类型，边结构中包含两个端点V
和V还有边的权重Weight。Edge是指向这个结构的指针。
该程序所需的时间复杂性和空间复杂性都是Nv。
边的定义
typedef struct ENode·PtrTOENode
struct ENodel
图的存储结构
有向边VV Vertex VV
WeightType Weight·权重·
I
typedef PtrTOENode Edge
MGraph CreateGraphint VertexNum
初始化一个有VertexNum个顶点但没有边的图
VertexVW
MGraph Graph
GraphMGraphmallocsizeofstruet CNode人建立图
GraphNvVertexNum
GraphNe
初始化邻接矩阵
注意：这里默认顶点编号从开始，到GraphNV
forV VGraphNVV
forWWGraphNVW
GraphGvWINFINITY
return Graph
void InsertEdgeMGraph GraphEdge E
插人边VV
GraphGEVEVEWeight
若是无向图，还要插入边VV
GraphGEVEVEWeight
MGraph BuildGraph
MGraph Graph
Edge E
Vertex V
int Nvi
scanfdNV 读入顶点个数·
微视频
邻接矩阵表
示法：图的初
始化
微视频
邻接矩阵表
示 法：图的
创建
第章 图
GraphCreateGraphNv 初始化有Nv个顶点但没有边的图∠
scanftdGraphNe 读入边数·
ifGraphNe 如果有边
EEdgemallocsizeofstruct ENode 建立边结点
读入边，格式为起点 终点 权重插入邻接矩阵·
foriiGraphNei
scanfd tdEVEVEWeight
注意：如果权重不是整型，Weight的读入格式要改
InsertEdgeGraphE
如果顶点有数据的话，读入数据
forVVGraphNv V
scanfcGraphDataV
return Graph
代码 邻接矩阵表示——无向网图的初始化程序
邻接矩阵是一种表示各类图的简洁的数据结构。但是我们发现，不论图中的边的数量多或
少，我们都花费了◎Nv即OVI的存储空间，这对于稠密图来说是一种高效的方法。
但是如果我们面对的是一个稀疏图，则邻接矩阵中大多数项为或四形成了所谓的稀疏矩
阵，就会浪费许多空间。同时，有些操作也会经常访问邻接矩阵中或代表的无效元素，这
也会浪费许多时间。
为了解决这些浪费问题，我们考虑另外一种存储结构。回忆我们在线性表时曾说过，顺序存
储结构需要事先分配连续内存，这就可能造成空间浪费的问题，于是引出了链式存储的思路，同
样，这里也可以对边或弧采用链式存储来减少空间浪费的问题。这就是下面一小节要讨论的邻
接表存储结构。
邻接表
邻接表Adjacency Lists是图的一种顺序存储与链式存储结合的存储方法。邻接表表示法
类似于树的孩子链表表示法。就是对于图G中的每个顶点v将所有邻接于v的顶点v链成一
个单链表，这个单链表就称为顶点v的邻接表，再将所有点的邻接表表头放到一个数组中，就构
成了图的邻接表。在邻接表表示中有两种结点结构，如图所示。
图的存储结构
一种是顶点表的结点结构，它由顶点数据域Data和指向第一条邻接边的指针域
FirstEdge构成，另一种是边表即邻接表结点，它由邻接点域AdjV和指向下一条邻接边的
指针域Next构成。对于网图的边表需再增设一个存储边上信息如权值等的域Weight网
图的边表结构如图所示。图给出无向图 对应的邻接表表示。
顶点域 边表头指针 邻接点城 指针城
Data FirstEdge AdjV Next 邻接点域 边上信息 指针域
a顶点表 b边表
图 邻接表表示的结点结构
AdjV Weight Next
图 网图的边表结构
序号 Data FirstEdge
A
A
微视频
入 邻接表表示
法的结构和 类型声明
图 图的邻接表表示
邻接表表示的图结构和类型声明由代码给出。图的初始化过程由代码给出。
最大顶点数设为 define MaxVertexNum
边的定义
typedef struct ENodePtrTOENode
Vertex VV ·有向边VV
WeightType Weight权重
I
typedef PtrTOENode Edge
邻接点的定义
typedef struct AdjVNode·PtrTOAdjVNode
struet AdjVNodel
Vertex AdjV · 邻接点下标
·用顶点下标表示顶点，为整型 typedef int Vertex
struct ENodel
边的权值设为整型· typedef int WeightType
顶点存储的数据类型设为字符型 typedef char DataType
第章 图
WeightType Weight 边权重·
PtrToAdjVNode Next 指向下一个邻接点的指针
顶点表头结点的定义
typedef struct Vnodel
PtrTOAdjVNode FirstEdge边表头指针·
DataType Data 存顶点的数据
注意：很多情况下，顶点无数据，此时 Data可以不用出现
IAdjList MaxVertexNum AdjList是邻接表类型·
图结点的定义
typedef struct GNode PtrTOGNode
struct GNodel
int Nv· 顶点数
int Ne 边数
AdjList G 邻接表
typedef PtrTOGNode LGraph·以邻接表方式存储的图类型
代码 邻接表表示法的结构和类型声明
LGraph CreateGraphint VertexNum
初始化一个有VertexNum个顶点但没有边的图
Vertex V
LGraph Graph
GraphLGraphmallocsizeofstruct GNode八建立图·
GraphNVVertexNum
GraphNe
初始化邻接表头指针
注意：这里默认顶点编号从开始，到GraphNv
forVVGraphNVV
GraphGvFirstEdgeNULL
return Graph
void InsertEdgeLGraph GraphEdge E
图的存储结构
PtrTOAdjVNode NewNode
插入边VV
NewNodePtrTOAdjVNodemallocsizeofstruct AdjVNode
NewNodeNextGraphGEVFirstEdge
八 若是无向图，还要插入边VVI
为V建立新的邻接点
NewNodePtrTOAdjVNodemallocsizeofstruct AdjVNode
NewNodeAdjVEV
NewNodeWeightEWeight
·将V插入V的表头
NewNodeNextGraphGEVFirstEdge
GraphGEVFirstEdgeNewNode
LGraph BuildGraph
LGraph Graph
Edge E
Vertex V
int Nvi
scanfdNv 读人顶点个数·
scanfBdGraphNe 读入边数
ifGraphNe 如果有边
EEdgemallocsizeofstruct ENode 建立边结点
scanfd d dEVEVEWeight
为V建立新的邻接点
NewNodeAdjVEV
GraphGEVFirstEdgeNewNode
GraphCreateGraphNv初始化有Nv个顶点但没有边的图
读入边，格式为“起点 终点 权重”插人邻接矩阵
注意：如果权重不是整型，Weight的读入格式要改
NewNodeWeightEWeight
foriiGraphNei
InsertEdgeGraphE
将V插入V的表头
第章 图
· 如果顶点有数据的话，读入数据
forVVGraphNvV
scanfBcGraphGVData
return Graph
代码 邻接表表示——无向图的初始化程序
若无向图中有V个顶点和E条边，则它的邻接表需V个头结
点和E个表边结点。显然，在边稀疏E VV的
情况下，用邻接表表示图比邻接矩阵节省存储空间，当和边相关的信息较多
时更是如此。
微视频 在无向图的邻接表中，顶点v的度恰为第i个链表中的结点数；而在
邻接表表示 有向图中，第i个链表中的结点个数只是顶点v的出度，但是求入度就很 法：图的创建
不方便，必须遍历整个邻接表，在所有链表中其邻接点域的值为i的结点
的个数是顶点v的入度。有时，为了便于确定顶点的入度或以顶点v为头的弧，可以建立一个
有向图的逆邻接表，即对每个顶点v建立一个链接以v为头的弧的链表。
例 例如图给出了a中有向图G的邻接表b和逆邻接表c。
A D
A A A A
B △ B 入
C A
B
C A
D 入 D A
有向图G b邻接表 c逆邻按表
图 有向图C及其邻接表和逆邻接表
在建立邻接表或逆邻接表时，若输人的顶点信息为顶点的编号，则建立邻接表的复杂度为
VE否则，需要通过查找才能得到顶点在图中位置，时间复杂度为v·El。
在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个顶点n
和p之间是否有边或弧相连，则需搜索第i个或第j个链表，因此，不及邻接矩阵方便。
图的遍 历
图的遍历
迷宫探索
在节中，我们讨论了一个简单的迷宫问题。这里我们将讨论另外一个更灵活的版本，
这里的迷宫不一定是由方格子组成，虽然我们仍然假设它的通道都是直的，而通道所有交叉点
包括通道的端点上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有
的灯并回到起点比如，你将以什么样的策略，走遍图所示迷宫的所有通道的交叉点顶点
②
⑥ ① ① ⑦
③
⑤ ④
a b
图 一个点灯迷宫及其对应的图
虽然，在一些特殊的简单的迷宫中，采用诸如“保持右手靠墙”的简单策略就可以解决问题，
如图a所示的迷宫，但是如果在有些迷宫如图b所示中，这种策略将可能永远达
不到目的，因为你可能在其中的一个环中无休止地绕圈。
a b
图 探索迷宫
当我们到达的通道端点如果已经亮着灯，表明曾经来到过这里，这在规则上是允许的。同样
曾经走过的通道还是可以重复走。
第章 图
为了设计一个策略来解决这个问题，并且在叙述上更加直观，我们暂时用术语“迷宫”而不
是“图“通道”而不是“边”“交叉点”而不是“顶点”。
自古以来，我们就知道探索迷宫而不迷路的技巧，就是用一个线球的线跟在我们身后，这根
线除了可以保证我们总能找到出口，还可以记住最先是从哪个通道来到这个交叉点的，以便在探
索了该交叉点的所有通道以后，沿着这根线退回原先过来的通道。我们始终心怀一个目标，就是
探索迷宫的每个交叉点点亮所有灯但除非万不得已，我们并不想走回头路。为了达到这些
目标，就需要用一些方法来标记到过的地方。以下的描述更接近为计算机实现建模。
假设每个交叉点都有灯，开始时所有灯都是关着的，另外，每个通道的两端都有门，开始时也
是关着的，并约定我们需要打开门才能观察通道的另一端是否亮着灯。进一步假设这些门都有
玻璃窗户，通道的另一端并不需要开着门，我们也能从这一端看见另一端的灯是否亮着。我们的
目标是打开所有的灯和所有的门。
基于这些假设，以下的迷宫探索策略就变得容易理解，这个策略被称为Tremaux 探索，至少
从世纪以来就为人们所知了，算法描述如下：
如果在当前的交叉点还有关着的门，则打开其中的任何一扇门并使该门一直开着，记
住我们已经探索过该通道并转向第步；否则转向第步。
如果你看到通道另一端的交叉点已经亮着灯，则尝试当前交叉点的另一扇门转向第
步否则，沿着该通道走到另一端，边走边放线绳，开灯，再转向第步。
如果当前交叉点的所有门是打开的，则检查是否回到了起点，如果是，则结束算法；否
则，利用线绳返回到首次带你到该交叉点通道上，边走边收线绳，退回到交叉点，再转向第步。
例图描述了遍历一个简单迷宫的过程。这些图只是显示了很多可能的探索中
的一种，因为我们可以随意地按照任意顺序打开一个交叉点上的多个关着的门。放绳的方法是一
种高效的方法。从该例子还可以得知，对于我们考虑选取的每个通道，会出现种可能的情况：
通道是暗的，所以选择该通道；
该通道曾经进去过其中有我们的线绳因此利用它退出同时卷起线绳
通道另一端的门是关着的但交叉点的灯是亮着的因而跳过不选择该通道；
通道另一端的门是开着的并且交叉点的灯是亮着的因此跳过该通道。
从交叉点出发，图所示的迷宫的Tremaux 探索遍历过程如图所示。先点亮
入口交叉点的灯，它有三个通道可以选择，因为这三个通道门都不曾打开，为了简单起见，我们
总是选择到达交叉点编号小的先打开，因为通道是暗的，所以选择通往交叉点的通道情况
到达并点亮灯；下一步没有其他选择，打开通往交叉点的通道，到达并点灯；同样道理，
接着到达交叉点并点灯；我们的线绳也到达交叉点。
交叉点可以到达的并且通道没有开门的交叉点邻接点有、和是刚刚放线绳过
来的通道，不考虑，除非在回退的时候选择最小编号。因为通道是暗的，所以选择通往交叉
点的通道情况到达并点亮灯；下一步没有其他选择，打开通往交叉点的通道，到达
并点灯；我们的线绳也到达交叉点。
图的 遍 历
O
③
M
①
④
①
④
◎
①
③
④
① ①
③ ③
④
×
④
图 Tremaux探索迷宫示例
交叉点可以到达的并且通道没有开门的邻接点有和是刚刚放线绳过来的通道，不
考虑，除非在回退的时候先打开通往小编号的通道门，发现交叉点的灯是亮着的，因而跳
过该通道情况再打开通往交叉点的通道门，发现交叉点的灯是亮着的，因而跳过该通
第章 图
道情况。此时已经无路可走，只好沿着通往通道退回到情况同样再退回到情况
。线绳也退回卷起。
回到交叉点还有通往交叉点和的通道门没有打开，先打开通往的通道门，发现通道
另一端的门是开的并且交叉点的灯是亮着的，因而跳过该通道情况。再打开通往交叉点
的通道门，因为通道是暗的，所以选择通往交叉点的通道情况到达并点亮灯；再打开通
往交叉点的通道门，发现交叉点的灯是亮着的，因而跳过该通道情况接着打开通往交
叉点的通道门，发现通道是暗的，所以选择通往交叉点的通道情况到达并点灯，线绳
也到达交叉点。
从交叉点退回到交叉点并收回线绳。此时站在交叉点上，发现已经没有未打开的通
道门，根据算法，此时要判断是否就是起点，不是的话沿着线绳退回到交叉点情况。同
样，沿着线绳，依次退回到交叉点、直到交叉点。
交叉点还有通往和的两个通道的门没有打开，先打开通往的通道门，发现通道另一
端的门是开的并且交叉点的灯是亮着的，因而跳过该通道情况再打开通往的通道门，
发现通道另一端的门也是开的并且交叉点的灯是亮着的，因而跳过该通道情况。于是，发
现已经没有未打开的通道门，根据算法，此时要判断是否就是起点，果真如此，算法结束。
综上所述，交叉点点灯的次序为这就是所谓的图的顶点的“遍历次
序”。
如果这个迷宫探索的例子改用图的术语，实际上就是图b从顶点出发的“深度优先
遍历”。迷宫就是图，通道就是边，交叉点就是顶点。交叉点通往相邻交叉点的通道的门的打开
与否用来记录该边是否已经考虑过。交叉点的灯点亮了表示该顶点已经访问过了，从而不需要
再次访问。线绳的作用是在没有新的通道可以探索的时候，可以顺利退回到上次过来的交叉点，
而不至于迷路。在深度优先搜索的非递归算法中，通常用一个堆栈来记录一路走来的交叉点，因
为回退的次序是按“后来先退”刚好符合栈的操作特点。不过，深度优先搜索的算法用递归显
得更简单。
“图的遍历”是指从图中的任一顶点出发，对图中的所有顶点访问一次且只访问一次的次序
序列。对应迷宫探索的问题就是点亮一次各个交叉点的灯，输出点灯次序序列。图的遍历是图
的一种基本操作，图的许多其他操作都是建立在遍历操作的基础之上。
深度优先搜索
深度优先搜索Depth First SearchDFS类似于树的先序遍历，是树的先序遍历的推广。上
一小节的迷宫探索就是对迷宫图的深度优先遍历。
假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点v出发，访问
此顶点，然后依次从v。的未被访问的邻接点出发递归地进行同样的深度优先搜索，直至图中所有
和v。有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问非连通图则另选图中一
个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
图的 遍历
例以图a的无向图G为例，进行图的深度优先搜索。假设从顶点E出发进
行搜索建议读者从其他顶点出发，自行练习在访问了顶点E之后，选择E的邻接点进行递
归，此时E的未曾访问过的邻接点有A、F和H理论上说，选哪个邻接点都是可以的，但实际应
用中，算法是在一个确定的数据结构上运行，所以会按照某种存储次序选取邻接点。在这里，为
了方便起见，当有多种选择的时候，采用字母序的策略选择下一个邻接点。遍历顺序如图
b所示。
④ ⑥ ⑧
D H C D H O
D A E F B A E F
③ ② ⑥
a b
图 一个无向图G及其一种深度优先遍历顺序
选择A为下一个邻接点，则从A出发进行递归搜索。依次类推，接着从B、C、D出发进行
搜索。在访问了D之后，由于D的邻接点A和C都已被访问，则搜索回退递归调用返回到
C。由于同样的理由，搜索继续回到BA直至E。此时由于E有没有访问过的邻接点F和H按
照字母序先选F访问了F以后依次访问G、H再从G、F退回到E。此时E已经没有未经访问的
邻接点，并且递归搜索回到了起点，这样我们就完成了一个连通分量的深度优先搜索。访问的顺
序是E→A→B→C→D→F→G→H。
显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标
志数组 Visited 它是全局变量，其Nv个分量初值都是false。一旦某个顶点被访问，则其相应
的分量置为 true。这相当于Tremaux 探索迷宫时点亮交叉点的灯。
实现上述深度优先遍历DFS递归算法的伪码描述如代码所示。
Visited为全局变量，已经初始化为false
void DFSGraph G Vertex V voidVisitVertex
从第V个顶点出发递归地深度优先遍历图G
VisitV 访问第V个顶点·
VisitedVtrue
forV的每个邻接点W
ifVisitedW
对V的尚未访问的邻接顶点W递归调用DFS
DFSGw Visit
代码 深度优先遍历的递归算法——伪码描述
第章 图
其中VisitV是访问顶点V的函数调用，它可以根据不同的应用改变。算法DFS是对抽象
数据结构“图”的一个连通分量进行遍历的操作，与选择的存储图的具体数据结构无关。
更具体地，如果选择邻接表作为图的数据结构，则代码用打印顶点编号作为访问函数
VisitV的任务，实现了对一个连通分量的DFS遍历。
void visitVertex V
printf·正在访问顶点名dnV
Visited为全局变量，已经初始化为false
void DFSLGraph Graph Vertex V voidVisitVertex
以V为出发点对邻接表存储的图Graph进行 DFS搜索
PtrTOAdjVNode W
VisitV 访问第V个顶点
Visitedvtrue 标记V已访问
forWGraphGVFirstEdge WWWNext对V的每个邻接点WAdjV·
ifVisitedWAdjv 若WAdjV未被访问
DFSGraphWAdjv Visit 则递归访问之·
代码 邻接表存储图的深度优先遍历
如果要列出图中所有连通分量，则可以用一个for 循环遍历图中所有顶点，对每个顶点V如
果其 VisitedV是false即还没有被打印过就从它开始进行一次 DFS遍历，从而打印出包含
V的连通分量中的所有顶点。
在遍历时，对图中每个顶点至多调用一次DFS 函数，因为一旦某个顶点被标志成已被访问，
就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。其
耗费的时间则取决于所采用的存储结构。当用邻接矩阵作为图的存储结构时，查找所有顶点的
邻接点所需时间为VI。而当以邻接表作图的存储结构时，找邻接点所需时间为E。
由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为VE。
广度优先搜索
广度优先搜索Breadth First SearchBFS类似于树的按层次遍历的过程。本章最后的应用
实例，即验证六度空间理论问题，就是广度优先遍历的一个富有成效的应用。
假设从图中某顶点v。出发，在访问了v之后依次访问v。的各个未曾访问过的邻接点，然后分
图的 遍 历
别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问
的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚
有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶
点都被访问到为止。换句话说，广度优先搜索遍历图的过程中以v。为起始点，由近至远，依次访
问和v。有路径相通且路径长度为……的顶点。
为了能够使得这种访问次序得以实现，需要一个队列把访问过的顶点依次保存下来，以便下
次依次访问它们的邻接点。利用队列先进先出的特性，可以保持访问的次序。队列为空的时候
表明一个连通分量遍历完成。
例对图a所示无向图G进行广度优先搜索遍历，假设从顶点E出发进行搜索
建议读者从其他顶点出发，自行练习在访问了顶点E之后，接着访问E的未曾访问过的所有邻
接点，此时E的未曾访问过的邻接点有A、F和H理论上说，选哪个邻接点先访问都是可以的，与深
度优先搜索同样的原因，有多种选择的时候，采用字母序的策略选择邻接点的访问次序：A、F和H。
在访问了距离E路径长度是的A、F和H以后，接下去要访问的是距离E路径长度是的A
的邻接点、F的邻接点和H的邻接点，次序仍然是A的所有邻接点未曾访问过的、F的所有邻接
点未曾访问过的、最后才是H的所有邻接点未曾访问过的。如此等。得到的顶点访问序列为
E→A→F→H→B→D→G→C对应距离E的路径长度为、、、、、、如图所示。
⑥ ④ ⑦
C D H G
B A E F
⑤ ② ③
图 无向图G对应的一种广度优先遍历顺序
与深度优先搜索类似，在遍历的过程中也需要二个访问标志数组Visited 它是全局变量，
其Nv个初值都是false。一旦某个顶点被访问，则其相应的分量置为true。
采用队列的实现过程如下：假如首先访问顶点E然后E进队列。接下来对非空队列进行如
下循环：
删除队列头元素EE的未曾访问过的邻接点A、F和H相继被访问并进队列；
删除队列头元素AA的未曾访问过的邻接点B和D相继被访问并进队列；
删除队列头元素FF的未曾访问过的邻接点G被访问并进队列；
删除队列头元素HH没有未曾访问过的邻接点；
删除队列头元素BB的未曾访问过的邻接点C被访问并进队列；
删除队列头元素DD没有未曾访问过的邻接点；
删除队列头元素GG没有未曾访问过的邻接点；
删除队列头元素CC没有未曾访问过的邻接点。
第章 图
此时队列为空，循环结束，表明一个连通分量访问结束。由于本例的图是连通图，所有顶点
都被访问，由此完成了图的遍历。
实现上述广度优先遍历BFS的算法如代码所示。
bool ISEdgeMGraph GraphVertexV Vertex W
return GraphGvWINFINITYtruefalse
Visited为全局变量，已经初始化为false
void BFSMGraph Graph Vertex SvoidVisitVertex
以S为出发点对邻接矩阵存储的图Graph进行BFS搜索
Queue Q
Vertex VW
QCreateQueueMaxsize 创建空队列，MaxSize为外部定义的常数
访问顶点S此处可根据具体访问需要改写
VisitS
VisitedStrue 标记S已访问
AddQQSS入队列
whileISEmptyQ
VDeleteQQ 弹出V
forWWGraphNVW 对图中的每个顶点W
若W是V的邻接点并且未访问过
ifVisitedW ISEdgeGraphV W
访问顶点W
VisitW
VioitedWtrue标记W已访问
AddQQWW人队列
while结束
代码 邻接矩阵存储图的广度优先遍历
函数IsEdgeGraphVW检查VW是否图Graph 中的一条边，即W是否V的邻接点。
此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。代码中
的实现是针对有权图的，其中不存在的边被初始化为INFINITY。
最小生成树
若选择邻接表作为图的数据结构，则对代码的改造会与代码相似，该工作留给读者
作为练习。
分析上述算法，每个顶点至多进一次队列。遍历图的过程实质是通过边或弧找邻接点的过程，因
此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问
的顺序不同。当用邻接矩阵表示图的存储结构时，所需时间为V而当以邻接表作图的存储
结构时，找邻接点所需时间为E广度优先搜索遍历图的时间复杂度为VE。
综上所述，由于图结构的复杂性，所以图的遍历操作也较树的遍历复杂，主要表现在以下四
个方面。
在图结构中，没有一个“自然”的首结点，图中任意一个顶点都可作为第一个被访问的
结点，所以遍历的序列通常还要指出从哪个顶点出发。
在非连通图中，从一个顶点出发，只能够访问它所在的连通分量上的所有顶点，因此，还
需考虑如何选取下一个出发点以访问图中其余的连通分量。
在图结构中，如果有回路存在，那么一个顶点被访问之后，有可能沿回路又回到该顶点。
因此需要标记已经被访问的顶点，比如点亮交叉点的灯或者用Visited 数组。
在图结构中，一个顶点可以和其他多个顶点相连，当这样的顶点访问过后，存在如何选
取下一个要访问的顶点的问题。比如通道的门是否打开表示是否已经尝试该通道，或者对应具
体的存储结构控制下一个尝试的邻接点。
图的遍历可以有许多应用，比如求连通分量、欧拉回路、生成树、DAG的判定、DAG的根、桥
边、关节点等的计算都可以通过遍历来进行。具体内容参见相关习题。
最小生成树
图的生成树和生成森林的概念在节中已经作了介绍，本节将介绍如何从图中导出生
成树或生成森林并且介绍很有用的最小生成树的概念与生成算法。并解决节引出的公
路村村通问题。
生成树的构建与最小生成树的概念
由生成树的定义可知，无向连通图的生成树不是唯一的。连通图的一次遍历所经过的边的
集合及图中所有顶点的集合就构成了该图的一棵生成树，对连通图的不同遍历，就可能得到不同
的生成树。
例对图a所示的无向图的深度优先的一种访问的顺序是：E→A→B→C→D→F
→G→H根据遍历时的递归过程，这相当于得到了图a所示的生成树。例对图
的广度优先的一种访问的顺序是：E→A→F→H→B→D→G→C根据遍历算法引入队列的父子
关系孩子由其父顶点引入队列这相当于得到了图b所示的生成树。
第章 图
E E
② A ⑥ F
② A ③ F ④H
③ B ⑦ G ⑥
⑤ B D
⑦ G
◎ ⑧ H
⑧ C
⑤ D
a b
图 无向图G的一棵深度优先生成树与一棵广度优先生成树
如果例和例不采用“有多个未访问邻接点可选时以字母序策略”那么图是
无向图G的另一棵深度优先生成树与另一棵广度优先生成树。
但是图的a、b两图都不可能是G的深度优先生成树与广度优先生成树。图a
中D到B是没有边的，不可能出现在生成树中，所以它根本就不是G的生成树。图b中D
到C是G的边，所以它是G的生成树，但是根据广度优先遍历顺序，B在D前的话，B的邻接点就
应该在D的邻接点之前，换句话说，C应该作为B的邻接点被访问，所以应该是B的孩子。
E O
E
②H ⑤ A
② H ③ F ④A
③ G ⑥ D
⑤G ⑥ B D⑦
④ F
B
a b
图 无向图G的另一棵深度优先生成树与另一棵广度优先生成树
E
E
eH ⑤ A
②E ③ F ◎A
G③ ⑥ D
◎F ⑦
区
B
G⑤ ⑥ B D⑦
⑧
×
C
C
a b
图 无向图G错误的深度优先生成树与错误的广度优先生成树
最小生成树
显然，对于有n个顶点的无向连通图，无论其生成树的形态如何，只要是树，就都有且仅有
n条边。
如果无向连通图是一个网图，那么它的所有生成树中必有一棵边的权值总和最小的生成
树，我们称这棵生成树为最小生成树Minimum Spanning TreeMST。当然，对任意一个带权的
连通网图来说，最小生成树也未必是唯一的。
对一个网图来讲，边上权值总和最小的连通子图是不是一定是一棵树呢我们一般假定权
值非负，连通图上如果存在回路，那么删去回路上的任意一条边仍然是连通图，但权值和可以减
少。因此，权值总和最小的连通图一定是没有环的，它也就是一棵生成树。
回忆节的图和图表示的公路村村通问题，目标是要选择建设哪几条公路，既能
够连通所有村子，又能够使投资最少。就是要找到一个连通子图，边上权值总和最小，也即要找
对应网图的最小生成树。
图和图都是图的生成树，前者的权值和为后者的权值和只有。所以
我们选择图的方案解决公路村村通问题，要比选择图的方案节省万元的投入。
但是，我们还有两个疑问；图是不是就是唯一的最佳答案我们又该如何找到一个最佳答
案呢通过观察可以知道，即便图就是最佳答案，它也不是唯一的，因为用边HC代替
YC得到的也是权值和为的生成树，见图j。至于第二个问题，就是本节要介绍的
重点。
② ②
X X
W
B
W
× B
H
D ①
H
D
①
F
C
F
图 权值和为的一棵生成树 图 权值和为的一棵生成树
下面介绍两种常用的构造最小生成树的方法——普利姆Prim算法和克鲁斯卡尔
Kruskal算法。
构造最小生成树的Prim算法
我们先从实例的最小生成树构造过程入手，介绍不是证明构造过程的正确性，然后再用
严格的符号表达方式描述，最后给出Prim算法的代码。
对n个顶点的连通图来说，其最小生成树可以由图中的n条边当然还包括相关的顶点
构成，我们要做的就是如何从图中的边里面选择适当边的方法。从任何一个顶点出发，构建过程
从初始只有这个顶点的“当前树”开始，不断加入边和相关顶点到当前树中，使得当前树不断“生
第章 图
长最终成为最小生成树。
例用Prim算法构造网图的最小生成树的生长过程如图所示。各图的
“粗线边”构成了当前树，“虚线边”表示当前树的所有邻接点与当前树的最短边。我们用T
EV来表示一棵树T其中E是T的边集合，V是T的结点集合。
对图a从顶点Z开始，当前树TZI从所有与当前树有关顶点Z相连的
边图a中用虚线表示，一端在当前树，另一端不在当前树中，选择权重最小的边
ZW加入到当前树T当前树成了TZWZWI同时修改“虚线边”如图
b所示。
②
B
D
②
B
D
⑦
B
D
W
H
L
F
a
w
H
L
F
c
W
H
①
F
e
X
X
×
C
X
Y
B
D
②
B
D
②
B
D
W
H
L
F
b
W
H
L
F
d
W
H
D
X
X
Y
C
X
×
C
F
f
最小生成树
② ②
x x
w
B
w
B
H
D
①
H
D
D
y
C C
F F
g h
②
② ×
w
×
B
w
B
H
D
① H
D
L
C
F F
i ①
图 Prim算法构造最小生成树的过程
修改“虚线边”的规则是：对新加入的顶点W考察其所有的邻接点BHX这些邻接点到
当前树的距离是否会因为W的加入而变的更近。邻接点B到当前树的距离原来是现在成了
所以把边BW改成虚线边的同时，边BZ改成实线边。
为什么边ZW必定是最小生成树中的边呢其正确性可以这样理解：假如除Z以外的
全部顶点已经找到了一棵最小生成树，那么把Z加入该树的最小代价是用边ZW。
对图b考虑当前树T从所有T的邻接点与T相连的最短边图b中用虚线
表示中，选择权重最小的边WH加入到当前树T当前树成了TlZWWH
ZWH同时修改“虚线边”如图c所示。“WH必定是最小生成树中的边”的
正确性同样可以与前面类似地理解。
完全类似地考虑图c和图d不过图d中加入边HF以后，增加虚线
边FL同时边LH改成了实线，因为该边的两端都在当前树中了，如图e所示。
对图e考虑当前树T日ZWWHHFFLZWHFL从
所有T邻接点与T相连的最短边图e中用虚线表示中，选择权重最小的边LB
关于这种选择的解释见后加入到当前树T当前树成了TZWWH
HFFLLBZWHFLBIl同时修改“虚线边”如图f所示。
上面考虑权重最小的边有两条：LB和LD选择哪一条加入到当前树T中，应该
都是可以的，本质上得到的都是最小生成树。不同选择可能会导致两种情况，一种是这几条边都
第章 图
是最小生成树的边，这次不选，以后的步骤中也会选到——LB和LD就是属于这种情
况，先选哪条不会影响最终结果；另一种是选了其中的一条边，其余的边可能在以后的步骤中就
不会再选到，这也是导致最小生成树不唯一的原因。
最后，图j粗线边就构成了Prim算法得到的最小生成树。
由此可见，Prim算法构建最小生成树的过程就是当前树的生长过程。n个顶点的网图只要
通过 n步的生长就可以完成。图中用“虚线边”表示当前树的所有邻接点与当前树的最
短边每个邻接点只有一条这是Prim算法的关键。下面是Prim算法的形式化描述。
假设GVE为一网图，其中为网图中所有顶点的集合，E为网图中所有带权边的集合。
设置两个新的集合V和E其中集合V用于存放G的最小生成树中的顶点，集合E存放G的最
小生成树中的边即当前树TEVl。令集合V的初值为VlvF假设构造最小生成树
时，从顶点v。出发集合E的初值为O。Prim算法的思想是，从所有u∈Vv∈VV的边算法
中只需考虑虚线边中，选取具有最小权值的边u将顶点v加入集合V中，将边uv加入
集合E中，如此不断重复，直到VV时，最小生成树构造完毕，这时集合E中包含了最小生成
树的所有边。
Prim算法可用下述过程描述，其中用W表示顶点u与顶点》边上的权值。
VvlE
whileV≠V
nvminWu∈Vv∈VVI
EEu
VV
结束。
为实现Prim算法，顶点用V编号，顶点之间没有边用权值表示，并设置两个辅助
一维数组 parent和dist。其中数组 parent用来保存当前树的顶点生长过程中，每个顶点的父顶
点，parent表示 v。为根。distj用来保存顶点v到V顶点的边的最小权值即图中
的虚线边的权值即存储各顶点与当前树的“距离”——如果v属于当前树，则distj如果
v不属于当前树且不是当前树所有顶点的邻接点，则用 distj表示。
在程序中我们用顶点编号代表顶点，假设初始状态时，Vv。为出发的顶点这时有
dist它表示顶点v已加人集合V中；数组 dist的其他各分量的值是顶点v。到其余各顶点
所构成的直接边的权值，可以从图的存储结构中直接复制。
然后从 dist 中不断选取权值最小的边ww∈VveVV数据存储在 dist中每选
取一条边，就将distv置为当前树生长至v。由于顶点v从集合VV进入集合V后，这两
个集合的内容发生了变化，就需对每个weVV更新数组 parent 和 dist 的内容：若收录o使得
distw变小，则将distw更新为vw的权值，并且将v设置为w的父顶点。
用邻接矩阵存储图的Prim算法的实现如代码所示，其中求当前树和非当前树顶点之间
最小生成树
的最小距离的算法由代码给出。由于最后产生的最小生成树肯定是个稀疏图只有Nv
条边所以我们用邻接表存储它。
define ERROR错误标记，表示生成树不存在
int PrimMGraph GraphLGraph MST
将最小生成树保存为邻接表存储的图MST返回最小权重和·
WeightType distMaxVertexNumTotalweight
Vertex parentMaxVertexNumV W
int VCount
Edge E
初始化。默认初始点下标是
forVVGraphNvV
这里假设若V到W没有直接的边，则GraphGVW定义为INFINITY
distVGraphGV
parentv 暂且定义所有顶点的父结点都是初始点
TotalWeight 初始化权重和
Vcount 初始化收录的顶点数
创建包含所有顶点但没有边的图。注意用邻接表版本人
MSTCreateGraphGraphNv
EEdgemallocsizeofstruct ENode 建立空的边结点
将初始点收录进MST
dist
VCount
parent 当前树根是
while
VFindMinDistGraphdist
V未被收录顶点中dist 最小者
ifVERROR 若这样的V不存在
break 算法结束
·将V及相应的边parentvV收录进MST
EVparentv
EVV
第章 图
EWeightdistV
InsertEdgeMSTE
TotalWeightdistV
distV
VCount
forWWGraphNv W 对图中的每个顶点W
ifdistW GraphGVWINFINITY
若W是V的邻接点并且未被收录
ifGraphGvWdistW
若收录V使得 distW变小
distWGraphGvW 更新distW
parentWV 更新树
while结束
ifVCount GraphNvMST中收的顶点不到v个
TotalWeightERROR
return TotalWeight 算法执行完毕，返回最小权重和或错误标记
代码 邻接矩阵存储图的Prim算法
Vertex FindMinDistMGraph Graph WeightType dist
返回未被收录顶点中dist最小者
Vertex MinvV
WeightType MinDiatINFINITY
forVVGraphNVVI
ifdistvdistvMinDistI
若V未被收录，且diatV更小
MinDistdistV 更新最小距离
MinvV 更新对应顶点
ifMinDistINFINITY若找到最小 dist
return Minv 返回对应的顶点下标·
else return ERROR若这样的顶点不存在，返回作为标记
代码 FindMinDist 函数
最小生成树
表给出了用上述算法构造网图例的最小生成树的过程中数组parent、dist 的变
化情况，读者可进一步加深对Prim算法的理解。
表 例中用Prim算法构造最小生成树过程中各参数的变化示意
vaZ vB vW vX vD vL w。H vY vF
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
dist
parent
vC
初始
选v
选v
选n
选v
选，
选
选v
选v
选
在这个以邻接矩阵为存储结构的Prim算法中，第一个初始化辅助数组的for 循环的执行次
数为VICreateGraph用IV建立起一个空的邻接表表示的MST接下来的while 循环
最多执行V次，但是其中又要执行 FindMinDist 和一个for 循环，执行次数为V
所以Prim算法的时间复杂度为VI。这对稠密图来说是比较好的方法，也因此我们用邻
接矩阵表示Graph。
对于稀疏图来说，这个时间界未必是理想的。一个改进是：改用邻接表作为存储结构并更换
代码求VV中到V最小距离的点的FindMinDist 函数改用第章介绍的最小堆结构。另一
第章 图
个做法是采用随后介绍的Kruskal算法，它们的时间复杂度都可以改进为ElogV。
构造最小生成树的Kruskal算法
Kruskal算法是一种按照网图中边的权值递增的顺序构造最小生成树的方法。其基本思想
是：设无向连通网图为GVE令G的最小生成树为T其初态不是树，可以看成生成森林
为T日空边集VI即开始时，T由图G中的全部V个顶点构成，顶点之间没有一条边，这
样T中各顶点各自构成仅有一个顶点的连通分量。然后，按边的权值由小到大的顺序，按照贪
心原则考察G的边集E中的各条边。
所谓贪心原则就是既然我们要找“最小”生成树，那么每次就选取权值最小的边作为T的候
选边。然而同时我们要求最后生成的是一棵“树”树中不可以有回路，所以我们必须确认候选
边不在现有的T集合中构成回路。要检查这一点，就要注意到一个事实：如果两个顶点属于同
一个连通分量，那么在它们之间加一条边就必定构成回路。所以，若候选边的两个顶点属于T
的两个不同的连通分量，则此边是可以作为最小生成树的边加入到T中的同时也就把两个连
通分量连接为一个连通分量否则舍去此边，以免构成回路。如此下去，当T中收集到V
条边时——也即T中连通分量个数为时，T便成为G的一棵最小生成树。
可见，与Prim算法从根结点长出一棵树的过程不同，Kruskal方法是把初始仅包含V个孤
立顶点的森林逐步合成一棵生成树的过程。
例用Kruskal算法构造网图的最小生成树的过程如图所示。图的全部顶
点以及由“粗线边”连成的树构成了“当前森林”。最终，当前森林成为最小生成树。由于顶点集
合V始终不变，我们以T的边集变化来记录树的生成过程，即记TE。
图a当前森林是由全部顶点但没有边构成的V棵树T从所有的边图中
用虚线表示中，选择权重最小的边LF合并两棵树，把虚线边LF改成“粗线边”当前
森林成了V棵树的森林TLF如图b所示。
权重最小的边，如果该边的两个端点不在当前森林的同一棵树中，那么它必定是最终最小生
成树中的边。其正确性比较显然，因为我们是在用最小的代价连通两棵树。
图b考虑当前森林TLF从所有的边图b中用虚线表示中，选
择权重最小的边HF合并两棵树，把虚线边HF改成粗线边当前森林成了V
棵树的森林TLFHF如图c所示。
图c考虑当前森林T从所有的边图中用虚线表示中，选择权重最小的边，最小
权重是的边共有条：HW、HL、LB和LD。其中边HL的两端已
经是同一棵树，加入它将导致回路，所以不能选。而其他条边都不会出现上述情况，因而都是
可选的，比如我们先选边LB合并两棵树，把虚线边LB改成“粗线边”当前森林成了
V棵树的森林TILFHFLB如图d所示。
当出现有多条权重最小的边不会导致回路的边可选时，选择哪一条来合并两棵树，应该
都是可以的，本质上得到的都是最小生成树。不同选择可能会导致两种情况，一种是这几条边都
是最小生成树的边，这次不选，以后的步骤中也会选到，先选哪条不会影响最终结果，这里的条
最小生成树
② ②
X
w
B
w
Y B
j H
D ① s
H
D
①
F F
a b ② ②
X
w
B w
B
H
D
D
H
D
L
C
F F
c d
② ②
X
W
X
B
W
s
Y B
H
D
D
sj H
D
C
F F
e
② ⑦
X
W
B
W
B
i H
D
L
s
H
D
①
C
F F
g h Z ②
X
w
B
w
B
H
D
D
H
D
L
C
F F
图 Kruskal 算法构造最小生成树的过程
X
Y
C
X
Y
Y
C
X
Y
C
Y
X
C
第章 图
边HW、LB和LD就是属于这种情况；另一种是选了其中的一条边，其余的边可
能在以后的步骤中就不会再选到，比如后面的图j用HC代替YC也是最小生
成树，这也是导致最小生成树不唯一的原因。但是，在我们选定了一种存储结构并实现了具体算
法以后，事实上已经确定了将会选择哪一条最小边，即便它们有相同的最小权值。
完全类似地考虑图d到图i。最后，图j粗线边就是Kruskal算法得到
的最小生成树。
综上所述，实现Kruskal算法的核心工作有三点：
选择一条权重最小的边。因为权值是不变的，所以所有边可以事先按照权值升序排列，这
项工作如果采用第章效率较高的方法，时间复杂性是ElogE。如果不把所有的边事先
排序，也可以采用第章介绍的优先队列最小堆数据结构。建初始堆的时间复杂性是E删
除堆顶元素后重组一个堆的时间是logE所以总的时间复杂性还是ElogE。
判定一条边的两端是否属于同一棵树。这项工作可以用第章中并查集的运算Find
的返回值是否相同来检验。需要一个辅助的数组parents记录每个顶点的父顶点。
合并两棵树。这项工作可以用第章中并查集的合并运算Union来实现。
代码给出了Kruskal算法的伪代码。在第章的节将给出一个具体应用问题的
详细实现代码。
int KruskalLGraph GraphLGraph MST
将最小生成树保存为邻接表存储的图MST返回最小权重和
whileMST中收集的边不到GraphNv条原图的边集E非空
从E中选择最小代价边V W 引入最小堆完成
从E中删除此边VW
ifVW的选取不在MST中构成回路此判断由并查集的Find完成
else
彻底丢弃VW
结束while
ifMST 中收集的边不到GraphNv条
return ERROR
else
return最小权重和；
MST包含所有顶点但没有边的图；
将VW加入MST此步由并查集的Union完成
代码 Kruskal算法的伪代码
在上面的Kruskal算法中，时间复杂性主要体现在while循环中，其循环次数最多为E次
数；其内部调用的最小堆操作的复杂度为每次logE回路判断及边的收集由并查集中带路
径压缩的Find 函数和按秩合并的Union 函数完成，最快需要OlogV所以总体时间复杂度为
最 短路 径
ElogV。可见当图比较稀疏例如EV时，用Kruskal算法的效率会比用
Prim算法好，也因此我们在代码中将Graph的类型写为LGraph即用邻接表表示的图。
最短路径
我们经常会面临路径选择的决策问题。如果你去过上海世博会，相信你一定还记得曾经精
心计划过到上海以后如何前往世博会的交通线路。不论你是上海本地游客，还是乘飞机、火车或
是汽车到达上海的外地游客，通常都会最后选择地铁交通。地铁网络有许多条线路交错布置，不
同线路换乘站作为图的顶点，如图所示。我们要在其中选择一条前往世博会的路径。
高定西站
白银路站
高定新城站 事、直城站 美重年等站
研之常能的悟站
虹桥国际机场
管指困站 龙柏新村站 龙重有站
洒冬站
站
事 中事路站 七重站
经站
江大学城站
江新域站
酷陆日 作贾前
参虹路站 的淫毒护
机通文通线
满带种站
雷站
武威磊站
蛋山关路站
上大路站
场中硒站
良满交道号线 大场镇站
行知路站
。祁连山盛站 事子国站 上海西站站
真如站
城重盗等 大华三路站
新村路站
枫桥路对 中重害
镇坪路站鼓
金沙江路站 自福站
长寿路
所德路贴
中山公国站
顾安西路站〇
水藏落靠 言肆嘴站 宋配路站 上意运 宜山路站
星中路站 合川路站 重河泽开发区站 柱林路站
情江乐园处 蓬花路站
外环路站
事庄站〇
交通天学的
上海南站站 意西于 潜溪路站
龙潜路站
石龙路站
上路南站
轨道交通号线 中路站
重起路站
等露排 T轴路
水产路站 新江湾城站 地滨路站
张华澡站股离东路贴
股发路站 三门路站
长辽路站 江考体商场站 服高与路站 繁寻真且口 五角场站 江考满站
大帕站 国权路站
费峰清站 问济大学站
东宝兴路站 品等看山舞 曲阳路站□四平路站 酒端落。 藏某腾光。 电新村站
上海火车站
汉中路站
满平路站
黄置情说 室山籍站
曲单路站
静安寺站 南京民路站人民广场站
天油路站 旧北腾站 表伦青箭 章暗站
常熟路站 大世界站 陕西南路站 黄皱率路
词
新天地达 衡山路站 名西门站
嘉浜路站
律家汇站 车安灌站 置年路的 事零指 小南门贴
阳家浜路站
B
上海体育场站
船厂路站 。内年相明酷 国
低满 临沂新村洁 同
轨道交通号线成山路站 东明路站
思站 高青路站 壹高情肆站
液兆新村站 华夏西路站
芦慢路站 着风 上责卷
图 城市地铁交通图
家道略晰
宝安公路站
共富新村站
呼兰路站
通河新村站
共滩路站
彭满断村站
能指
汉水晒站
上海马戏城站
上海火车站站 延长路站
中正糖站 中深 西藏正路站 口及雄坏的
江苏路结
上者电丹信着
市光路站
江路站 外高情
用股路站
黄兴公四站 外高析
中路站
醋家事站 奔的站 航通交通号
世大道P 民生路站。 北样浮腾。 德平路。 a山病站。 金预路比 繁覆法曲 电路 扬离中路站
：站参着 盒村路站
中路站
世纪公四站
上海料技馆站
上海儿童医学中心站 张工壹科站 金相路站
磁洋
轨道交通号线
大连路站
杨树浦路站
浦东大道站
意深体育中心站。
花木睛时口
龙阳路站
箭器害指 若接路话
第章 图
每个人的想法不同，选择的方案不尽相同。有的人选择换乘次数最少的线路不计时间和
路程有的人选择能最快时间内到达的线路要选择地铁发车时间间隔小的线路，而路程也不
能太远有的人选择花钱最省的线路假如票价与距离成正比，就是选择最短距离。实际上，
以上各种选择考虑问题的差异，仅仅是对网图边上的权值的含义的理解不同而已。选择最快时
间的，权值理解为时间；选择花钱最省的，权值理解为价格；而选择换乘次数最少的，可以理解为
任意两个换乘站之间的距离都是。它们都属于本节要介绍的“最短路径问题”。
最短路径问题是图的又一个比较典型的应用问题。一般来说，对于一个无向网图也可以
是有向网图边上的权值可以理解为距离自然约定为非负。那么这个问题就可归结为：在
网图中，求两个不同顶点的所有路径中，边的权值之和最短的那一条路径。这条路径就是两点之
间的最短路径Shortest Path并称路径上的第一个顶点为源点Source最后一个顶点为终点
Destination。在非网图中，最短路径是指两点之间经历的边数最少的路径。
边上权值有负数的情况要复杂一些，此时必须限定网图中任意回路上的权值和为正值，否则
最短路径长度可能是∞。即便有这个限定，用来寻找最短路径的算法时间复杂度也更大。
下面讨论两种最常见的最短路径问题。
单源最短路径
从一个源点到其他各顶点的最短路径问题称为“单源最短路径问题”。本小节先来讨论这
类问题，下一小节再讨论任意两个顶点之间的最短路径问题。
单源最短路径问题可描述为：给定带权有向图GVE和源点t。∈V求从v到G中其余
各顶点的最短路径。在下面的讨论中均假设源点为v。
观察图你能够很快找出从源点v。到终点v的最短路径吗如果不能，暂时也没有关
系，让我们一同来研究计算机如何解决这个问题；如果你能找出v。到v的最短路径，那也是仅仅
表示你的智商还不错，仍然得好好学习，毕竞现实的许多问题要比这个图复杂得多。我们要找到
一种对任意复杂的网图都可以找到两个顶点之间最短路径的方法。
v
以
vs
W
U
图 一个无向网图
下面就介绍解决这一问题的经典算法，即由迪杰斯特拉Dijkstra提出的一个按路径长度递
增的次序产生最短路径的算法。
我们先通过对网图的计算过程陈述，来介绍 Dijkstra算法的思想，然后再比较形式化地
最短路 径
描述该算法，最后给出程序。
例用Dijkstra方法求网图中注意：权值均是正的v。到所有其余顶点的最短
路径。
这是一个按距离递增的顺序逐步找出v到各个顶点的最短距离路径的过程，实际上整个
过程完全类似于Prim算法求最小生成树。我们用两个数组 dist和path分别存储v。到其余顶点
的“当前最短距离”和相应的最短路径邻接于哪个顶点。两个数组分别类似于Prim算法的 dist
和 parent。V个顶点要经过V步完成，如表所示，计算从左至右推进。
初始时第步数组 dist的内容就是该图邻接矩阵表示时v对应的行向量：v到和v的
距离分别是和distdist其余都是四；数组P的内容就是记录到v和v的路
径父顶点是v。pathpath。在数组 dist中选择到v距离最小的顶点v可以断定，顶
点v已经找到了到v。的最终的最短距离，因为不可能通过绕行别的顶点使 v。到v的距离会变得
更小由权值均是正数容易推得。
因此，v作为已经求得最短路径的顶点，通过绕行D。到其余顶点的当前最短距离可以更
新：考虑v的邻接点v和v不需考虑已经求得最短距离的邻接点v。dist由原来的的变成
了dist由原来的变成了到v和v的路径父顶点是vpathpath。如表
的第步。表中 dist表格项用深色底纹，表示 v已经求得最短路径，dist不参与下
一步最短距离的选择。在后面的算法中，我们用一个数组 collectedvtrue 表示顶点v已经求
得最短路径。
因此，下一步在dist 中选择到v。距离最小的顶点是v最小距离是表示到v已经找到了
最短路径。接下去，v。到其余顶点的当前最短距离可以用一样的思想方法更新：考虑v的邻接点
v和v不需考虑已经求得最短距离的邻接点v。和vdist由原来的变成了dist由原
来的○变成了到v和v的路径父顶点是vpathpath。如表的第步。
表 例的最短距离数组 dist 和记录最短路径的结点序列数组 path的变化过程
从v。到各终点的dist值D和最短路径父顶点path 值P的变化过程
过程 初始
第步
选B 选v
第步第步
选o
第步
选p
第步
选v 选v
第步
选
第步
选v
第步 第步
D P D P D P D P D P D P D P D P D P D
选v。
终点 第步
P
s
第章 图
续表
从。到各终点的dist 值D和最短路径父顶点path值P的变化过程
过程「 初始
第步
选v
第步
选v
第步
选v。
第步
选v
第步
选v
第步
选
第步
选v
第步
选v
第步
D P D P D P D P D P D P D P D P D P D
更新v更新v更新vs更新v更新v更 新更新v更新v更新 vg
。是，是：是v是父顶v是父顶vvs是B是父顶。是父顶 是父顶 是最短距
父顶点，父顶点， 父顶点， 点， 点， 父顶点， 点， 点， 点，
最小值 最小值最小值最小值最小值最小值最小值 最小值 最小值径父顶点
选
终点 第步
P
结束。D
说明 离，v是路
用同样的方法一直做到第步。distdist表示从v到vv的最短距离，比如dist
的意思就是v。到v的最短距离是。可以通过搜索数组 path 得到最短路径，比如，v到
v的最短路径可以这样得到：path、path、path、path、path、
path顺序倒过来就是：D、U、U、U、U、。
上述例子使我们熟悉了算法的大概过程，现在我们比较容易理解 Dijkstra算法的更一般化
的描述：假设有向图GVE无向图可以看成所有边都是双向边的有向图设置两个顶点的
集合S和TTVS集合S中存放已找到最短路径的顶点，集合T存放当前还未找到最短路径
的顶点。初始状态时，集合S中只包含源点v然后不断从集合T中选取到顶点v路径长度最短
的顶点a加人到集合S中。集合S每加入一个新的顶点u表中用深色底纹表示的D值
都要修改顶点v。到集合T中剩余顶点的最短路径长度值，集合T中各顶点新的最短路径长度值
为原来的最短路径长度值与顶点u的最短路径长度值加上u到该顶点的路径长度值中的较小
值。此过程不断重复，直到集合T的顶点全部加入到S中为止。
Dijkstra算法的正确性可以用反证法加以证明。假设下一条最短路径的终点为v那么该路
径必然或者是弧v或者是中间只经过集合S中的顶点而到达顶点v的路径。因为假若此
路径上除v之外还有一个或一个以上的顶点不在集合S中，那么必然存在另外的终点不在S中
而路径长度比此路径还短的路径，这与我们按路径长度递增的顺序产生最短路径的前提相矛盾，
所以此假设不成立。
下面介绍Dijkstra算法的实现。
首先，用distv表示当前所找到的从始点s到终点b的最短路径的长度。它的初态为：若从
s到》有弧，则distv为弧上的权值；否则置 dist为的。然后，从dist 数组中选取路径长度最
小的distv满足：
最 短 路 径
distvmin distww∈Vs
的路径就是从s出发到v的长度最短的一条最短路径。此路径为sv。
那么下一条长度次短的最短路是哪一条呢假设该次短路径的终点是w则可想而知，这
条路径或者是sw或者是svw。它的长度或者是从s到w的弧上的权值，或者是distv
和从v到w的弧上的权值之和。
依据前面介绍的算法思想，在一般情况下，下一条长度次短的最短路径的长度必是：
distnmindistww∈VS
其中，distw或者是弧sw上的权值，或者是distvveS和弧vw上的权值之和。
根据以上分析，可以得到如下描述的算法：
假设用带权的邻接矩阵C来表示带权有向图，Gvw表示弧vw上的权值。若《vw
不存在，则置Gw为INFINITY。S为已找到从s出发的最短路径的终点的集合，它的初
始状态为。那么从s出发到图上其余各顶点终点v可能达到最短路径长度的初值为：
distvGsv veV
pathv表示v尚无父顶点
选择v使得
distvmindistww∈VS
则》就是当前求得的一条从s出发的最短路径的终点。令SSU即 collectedntrue。
修改从s出发到集合VS上任一顶点w可达的最短路径长度 distw如下：
distwmindistwdistnGvwl
同时更新w的父顶点：pathwv。
重复操作、共V次。由此求得从s到图上其余各顶点的最短路径是依路径长
度递增的序列。
代码为用C语言描述的Dijkstra算法。
Vertex FindMinDistMGraph Graphint distint collected
返回未被收录顶点中dist最小者
Vertex MinvV
int MinDistINFINITY
forVVGraphNvV
ifcollectedvfalse distVMinDist
若V未被收录，且distV更小
MinDistdistv 更新最小距离
MinVV·更新对应顶点·
ifMinDistINFINITY若找到最小dist·
return MinV返回对应的顶点下标
第章 图
else return ERROR若这样的顶点不存在，返回错误标记
boo DijkstraMGraph Graphint distint path Vertex S
int collected MaxVertexNum
Vertex VW
初始化：此处默认邻接矩阵中不存在的边用INFINITY 表示·
forVVGraphNvV
distvGraphGsv
pathV
collectedvfalse
先将起点收入集合·
dists
collectedstrue
whileI
V未被收录顶点中dist最小者
VFindMinDistGraphdistcollected
ifVERROR 若这样的V不存在·
break 算法结束·
collectedvtrue收录V
forWWGraphNv W 对图中的每个顶点W
若W是V的邻接点并且未被收录
ifcollectedWfalse GraphGvwINFINITY
ifGraphGvw若有负边·
return false不能正确解决，返回错误标记
· 若收录V使得 diatW变小
ifdistVGraphGvWdistW
distWdistvGraphGvw 更新distW
pathWV更新S到W的路径
while结束
return true算法执行完毕，返回正确标记
代码 Dijkstra算法
最 短 路 径
下面分析一下这个算法的时间复杂度。第一个for 循环的时间复杂度是OV随后
while循环共进行V次，每次执行的时间是V。所以总的时间复杂度是IV。
如果用带权的邻接表作为有向图的存储结构，则虽然修改 dist的时间可以减少，但由于在
dist 中选择最小分量的时间不变，所以总的时间仍为V对稠密图来说这是很好的
结果。
但对于稀疏图来说，这个时间界未必是理想的。一个改进是：改用邻接表作为存储结构并改
用第章介绍的优先队列最小堆的DeleteMin操作。查找最小值的时间是logV它的
时间界可以改进为ElogV。
如果只希望找到从源点到某一个特定的终点的最短路径，从上面我们求最短路径的原理来
看，这个问题和求源点到其他所有顶点的最短路径一样复杂，其时间复杂度也是IVl稀
疏图可以改进为ElogVI。
每一对顶点之间的最短路径
要求每一对顶点之间的最短距离，可以每次以一个顶点为源点，重复执行 Dijkstra算法V次。
这样，便可求得每一对顶点的最短路径。总的执行时间为VI。
这里要介绍由弗洛伊德Floyd提出的另一个算法。这个算法的时间复杂度也是V
但形式上非常简洁、优雅，而且对于比较稠密的图，实际运行效率更快。
为了能很快理解 Floyd算法的精妙所在，先从一个简单的例子开始。
例图给出了一个简单的有向网及其邻接矩阵G。用Floyd算法求该有向网中
每对顶点之间的最短路径长度及其最短路径。
o
图 一个有向网图及其邻接矩阵G
显然，最后得到的每对顶点之间的最短路径长度及其最短路径都应该分别是一个二维矩阵，
分别用二维数组D和二维数组 path 表示。Dij表示从v到v的最短路径长度，pathij表
示从v到v的最短路径上v的父顶点号。
这两个数组都是从初始数组演变到最终数组的。数组D的初始值就是邻接矩阵G为了方
便记录演变过程，把初始数组D写成D通过依次考察个顶点对应的行列，如图D
演变成D就是最终的各顶点之间的最短路径长度矩阵。
考察v。行列以外的非对角线元素，D垂直和水平方向往列行投影的两
个元素之和DD因为所以D保持不变。而另一个
元素D水平和垂直方向往列行投影的两个元素之和DD因
第章 图
为∞所以D要替换成。这个替换的含义是：原来从v到v的距离是∞现在替换成
v到v。再到v这样的距离是变成更小。D演变成 D。
考察v行列以外的非对角线元素，D水平和垂直方向往列行投影的两
个元素之和DD因为所以D保持不变。而另一个
元素D水平和垂直方向往列行投影的两个元素之和DD
因为所以D要替换成。这个替换的含义是：原来从v。到v的距离是现
在替换成v。到v再到v这样的距离是变成更小。D演变成D。
考察v行列以外的非对角线元素，D水平和垂直方向往列行投影的两
个元素之和DD因为所以D保持不变。而另一个
元素D水平和垂直方向往列行投影的两个元素之和 DD
因为所以D要替换成。这个替换的含义是：原来从v到v。的距离是现在
替换成v到v再到v这样的距离是变成更小。D演变成D。
Vov V
V 且
V
D
v
v演变：行列以外的元素，水平和垂直方向
往列行投影的两个元素之和是否比原值小
V V v
V
V
③
v演变：行列以外的元素，水平和垂直方向
往列行投影的两个元素之和是否比原值小
V V v
④
Y
v
D演变：行列以外的元素，水平和垂直方向
往列行投影的两个元素之和是否比原值小
图 Floyd算法把邻接矩阵演变成目标矩阵的过程
最 短路 径
最后，D给出的是每对顶点之间的最短距离。
下面考察最短路径矩阵path。与D的演变过程对应，初始路径矩阵记为path然后经过
次依次对应个顶点演变成path。初始 path如图所示，pathijk的含义是：
从v到v的最短路径中，v的前驱结点父顶点为v即初始假设直接的边就是最短路径如果
不存在直接的边，Dij∞最终也不会混淆。图给出了最短路径矩阵path图
中简写为P的演变过程。其路径上的父顶点的修改完全取决于D矩阵中元素的修改。
一维一淮
图 Floyd算法把初始路径矩阵演变成最短路径矩阵的过程
下面考察一般情况下的Floyd算法。同样，我们从图的带权邻接矩阵出发，其基本思想
如下。
假设求从顶点e到v的最短路径。如果从v到v有弧，则从v到v存在一条长度为Gij
的路径，该路径不一定是最短路径，尚需进行V次试探。首先考虑路径voD是否存在即
判别弧vv和vD是否存在。如果存在，则比较vD和vvoD的路径长度取长度较
短者为从v到v的“中间顶点的序号不大于的最短路径”。
假如在路径上再增加一个顶点v也就是说，如果D…v和v…分别是当前找到
的“中间顶点的序号不大于的最短路径”那么v…D…v就有可能是从 v到v的“中间
顶点的序号不大于的最短路径”。将它和已经得到的从v到v“中间顶点序号不大于的最短
路径”相比较，从中选出“中间顶点的序号不大于的最短路径”之后，再考察下一个顶点v依
次类推。
在一般情况下，若v…v和v…分别是从v到v和从v到v的“中间顶点的序号不
大于k的最短路径”则将v…v…v和已经得到的从v到v且中间顶点序号不大于k
的最短路径相比较，其长度较短者便是从v到v的“中间顶点的序号不大于k的最短路径”。这
样，在经过V次比较后，最后求得的必是从v到v的最短路径。
按此方法，可以同时求得各对顶点间的最短路径。
现定义一个V阶方阵序列。
DD°D…DDM
其中：
DijGij
DijminDijD“ikDkjl≤k≤V。
从上述计算公式可见，Dij是从v到v的中间顶点的序号不大于的最短路径的长
度；Dij是从v到v的中间顶点的序号不大于k的最短路径的长度；Dij就是从
第章 图
v到v的最短路径的长度。
由此得到求任意两顶点间的最短路径的代码。显然，算法的时间复杂度是VI。
boo FloydMGraph Graph WeightType DMaxvertexNumVertex path MaxVertex
Vertexijk
初始化·
foriiGraphNVi
forjjGraphNVj
DjGraphGij
pathij
forkkGraphNvk
foriiGraphNvi
forjjGraphNvj
ifDikDkjDii
DijDikDkj
ifij Dij若发现负值圈
return false 不能正确解决，返回错误标记
pathjk
return true算法执行完毕，返回正确标记·
Num
代码 Floyd 算法
注意：当图中存在负值圈即存在顶点v有Dii时，Floyd 算法是无法得到正确结果
的，这时程序要返回错误标记。
拓扑排序
在现实生活中，某些事物可以用有向无环图Directed Acyclic GraphDAG表述。这种有向
无环图通常也称作“流程图”比如，施工流程图、生产流程图，图中每个顶点可以代表一个具体
的工序，每条有向边则反映了两个工序的前后次序。
我们所要讲的拓扑排序是指用有向无环图中各顶点构成有序序列。设图中一顶点v到另一
顶点v存在一条路径，那么v在此图的拓扑排序序列中位于v之后。
拓 扑排 序
如果不是无环图，拓扑排序将不存在，因为如果有环路的话，那么对于环路上的两个顶点D
和w既可以认为v在w之前，也可以认为w是在v之前，它们之间的先后顺序是不确定的。
图为某大学计算机专业学生必修的课程以及这些课程之间的先后顺序关系。其中顶
点为课程编号，两顶点间的有向边表示它们之间的预修关系。比如，课程C到C以及C到C分
别有两条有向边，表明学习C之前，必须已经完成C和C的学习，以具备一定的基础。表
列出了课程名称及其各课程要求具备的先修基础。
G
G
G
C
图 课程设置
表 课 程 列 表
课程编号 课程名称
程序设计基础
离散数学
数据结构
高等数学
高等数学
线性代数
汇编语言
数据库
操作系统
计算机组成原理
编译原理
计算机网络
先修课程
C 无
C 无
C CC
C 无
C C
C C
C CC
C C
C。 C
C C
C C
C口 C
按拓扑排序的定义，下列两种顶点序列都是图的拓扑排序：
CCCCCCCCCCCC
CCCCCCCCgC。CCC
当然图的拓扑排序并不只是上述两种，还可以列出其他许多有效序列。
可以采用一种十分简单的思想实现拓扑排序，只要先找到任何一个人度为的顶点，然后输
第章 图
出该顶点，并从图中删除该顶点以及与其相连的所有边。对改变后的图重复这一过程，直到所有
顶点输出为止。可以这样实施的依据是基于下面的结论：一个顶点数的有向图，如果每
个顶点的入度都大于那么它必定存在回路。
代码给出了拓扑排序算法的伪代码。用数组 Indegree存储各顶点的人度，当IndegreeV
为时，表示顶点v可作为拓扑序列的输出点；TopOrder顺序存储排序后的顶点下标所以在拓
扑排序完成后直接顺序打印 TopOrder 就得到了拓扑有序序列的输出。
bool TopSortGraph GraphVertex Toporder
对Graph进行拓扑排序，Toporder顺序存储排序后的顶点下标
遍历图，得到各顶点的入度Indegree
forcntcntGraphNv cnt
V未输出的入度为的顶点；
if这样的V不存在「
printf·图中有回路
break
十
TopordercntV将V存为结果序列的下一个元素
将V及其出边从图中删除
forV的每个邻接点W
IndegreeW
ifcnt GraphNv
return false 说明图中有回路，返回不成功标志
else
return true
代码 拓扑排序算法的伪代码
在TopSort中，比较耗时的是找到下一个“未输出的入度为的顶点”如果要检查整个Inde gree 数组，所需时间是vl且循环结构决定了这一步要进行次，因此，本算法的时间代
价为vl。
而实际上，每次图的改变往往只会涉及少数顶点的入度发生变化，没有必要每次都查看整个
Indegree 数组。为了提高算法的时效，可以改进上述算法，将入度为的顶点单独存放，每当删
除一个顶点而改变其他顶点的入度时，检测到入度为的顶点，就存放到这个专门开辟的存储区
域，而这个区域可以用各种不同的结构实现。
例如，我们可以用一个队列实现这个特定存储。开始时将所有入度为的顶点插入队列；当
队列不为空时，取出一个顶点v并输出；然后将与v相邻的顶点入度减。当产生新的入度为
拓 扑 排序
的顶点时，将其插入队列。重复这一过程直到队列为空时算法终止。所要寻找的拓扑排序为各
顶点从队列取出的顺序。改进后的算法如代码所示，这里我们用邻接表表示图。
bool TopSortLGraph Graph Vertex Toporder
对Graph 进行拓扑排序，Toporder顺序存储排序后的顶点下标
int IndegreeMaxVertexNumcnt
Vertex V
PtrTOAdjVNode W
Queue QCreateQueueGraphNv
初始化 Indegree
forVVGraphNvV
IndegreeV
遍历图，得到Indegree·
forVVGraphNvV
forWGraphGVFirstEdgeWWWNext
IndegreeWAdjv 对有向边V WAdjV累计终点的入度
将所有入度为的顶点入列·
forV VGraphNvV
下面进入拓扑排序
cnt
whileISEmptyQ
VDeleteQQ 弹出一个人度为的顶点
TopordercntV 将之存为结果序列的下一个元素
forWGraphGVFirstEdgeW WWNext
ifIndegreeWAdjv若删除V使得WAdjV入度为
AddQQWAdjV则该顶点人列
while结束·
ifcntGraphNv
return false说明图中有回路，返回不成功标志
return true
ifIndegreev
对V的每个邻接点WAdjV
else
AddQQV
代码 改进后的拓扑排序算法
第章 图
图ai详细列出了有向图a的拓扑排序过程。
表概括了上述过程，表的上方“顶点入度变化”包含列数据，对应于图bi。
表的底端两行列出了顶点出入队列的情况，与图中每图下面队列的形象表示是一致的。从
顶点出队列的结果可以得到图a的一种拓扑排序为vDavsvVvs。
V
② ② ②
S S
a顶点、入队 b顶点出队，顶点入队 c顶点出队，顶点入队
V v
以
哆
② O 哆
d顶点出队 e顶点出队，顶点、入队 顶点出队
O②哆 O s O
g顶点出队，顶点入队 h顶点出队，顶点入队 顶点出队
图 有向无环图的拓扑排序过程
关键路径计算
表 拓扑排序过程列表
顶点入度变化初始→结束 顶点
D
入队列 v s P
出队列 B s V
如果图的表示采用邻接表，改进后的算法所付出的时间代价为EV。拓扑排序
算法可以用来检测一个有向图是否是DAG。
关键路径计算
通过节介绍的拓扑排序，我们知道，现实生活中，许多任务可以分解为一系列活动，各个
活动之间是相互关联的，关系可以是串行的，也可以是并行的。合理地调度和安排各活动，保证
在计划时间内完成任务是十分重要的。
本节所要讲的关键路径分析，适合于规划工程项目，解决类似“工程完成的最早时间是什么
时候”“一个工程中哪些活动可以适当延迟，可以延迟多长时间，而不影响整个工期”等问题。
仿照拓扑排序给出的网络表示，一个工程可以用无环有向图表示。图中的顶点代表活动，并
记录完成它的时间。图中的边表示活动的先后关系，有向边vw意味着活动v必须在活动w
开始之前完成。这种顶点表示活动或任务的图也称为AOVActivity On Vertex图。图是
一个AOV图，图也是一个AOV图。
例图中结点内大写字母AH表示活动，字母右下角括起来的数字表示完成
此活动所需的时间。分析图中活动时间可知道，完成路径A、C、F、H上的各活动需要个时间
单位，这几个活动中任意一个的延迟都会延长整个工期，实际上这是一条“关键路径”。但活动
B可以延迟个时间单位，并不会影响整个工程的完成进度，相对于关键路径，包含活动B的路
径是非关键路径。
第章 图
C Fa
Am H 完成
开始、 Da Ga
Ba
E
k
图表示一个工程活动关系的AOV图
为了便于分析关键路径，我们将活动为顶点的AOV图转换为活动为边的AOEActivity On
Edge图，有向边表示任务或活动，边上的权表示该活动持续的时间。在AOE图中顶点表示事
件，每个事件对应一个活动及其与之相关的其他活动的完成。图是对应于图的AOE
图，顶点和顶点分别表示工程的开始和完成事件。
如果一个活动是在几个活动完成后才能开始的话，需要增加虚构的边和结点，来表示活动之
间的这种依赖关系。例如，从图中我们知道，活动D是在活动A和B都完成后才能进行。
A和B两个活动的完成在图中表示为结点和两个事件，在这两个事件之间引入虚构结
点灰色表示和两条标识该活动所需时间为的虚构活动边，使得活动D是在A、B完成
后才能开始。同样还有活动F、G、H它们也是依赖多个先前的活动，因此，引人虚构结点、、
和相应的虚构边。
C ④ F
A ⑦
① D HI
⑩
B
G
③ EI ⑨
⑤ K
图 对应于图的AOE图
可以用以下方法简化图对出度为的顶点，如果其出边的权重是的话，可以删去该
顶点及其出边，该顶点的入边直接指向后面的顶点。比如，顶点、、和就可以删去而不会影
响整个图的意义。调整顶点序号如图所示。
为了能够确定工程的最早完成时间，只需在开始事件到完成事件间寻找最长有向路径，它的
长度就是答案。路径长度是指这条路径上所有活动时间的总和。
可以通过求解树中每个结点事件的最早完成时间，来计算整个工程的最早完成时间。若
Earliesti表示结点i的最早完成时间，C表示vw边的权重，则有：
Earliest
EarlieswmaxEarliestVc
关键路径计算
按照AOE图中各事件的先后次序，从起始事件开始，依次用上式求出各事件结点的最早完
成时间，直到最后推算到结束事件为止，也就得到了整个工程的最早完成时间。图中各顶
点的上方标出了我们所举例子的各事件最早完成时间，在结束事件上方标出的个时间单位是
整个工程的最早完成时间。
② C
A
①
D ⑦ F
B
G
③ EI
H
⑩
⑤ K
图 各顶点事件最早完成时间
同样，还可以求解每一事件i在不影响整个工程完成情况下的允许最晚完成时间Latesti。
计算是从结束事件开始，设结束顶点为事件n按事件拓扑的相反次序逐个顶点推算，直到工程
的初始顶点为止。结束顶点的最晚完成事件等于它的最早完成时间，其他顶点按下式计算：
LatestnEarliestn
LatestvminLatestwc
图标识出了上面例子中各事件的最晚开始时间，具体数值是标注在各顶点的下方。
A
②
C
⑦ F
① ④
D
B
③ E
G
HI ⑩
⑤
K
图 各顶点事件最晚完成时间
各顶点的最早和最晚完成时间被求出以后，能够很容易地确定在不影响工程进度的前提下，
每一活动最多能耽误的时间长短。这个时间是否为决定了该活动是否为关键路径。求vw
边上的允许耽误的最大时间Delay采用的计算公式为：
DelayLatestwEarlieatvC
图标识出了各活动的允许耽误时间，其数值添加在图中各边活动所需时间的后面，并
用斜杠“”分割开来。而Earliesti和Latesti仍然标注在顶点的上方和下方。
显然，最多能耽误的时间为即不允许有时间耽误的活动都是关键活动Critical Activity
由关键活动构成的从头至尾的路径就是关键路径Critical Path。本例中A、C、F、H是关键活
动，而其他活动的允许耽误时间都大于所以不是关键活动。
第章 图
② C Z
A
① ④
D
⑦ F
B
③ E
G
H ⑩
K
图 活动的可延迟时间
应用实例
六度空间理论
六度空间理论又称作六度分隔Six Degrees of Separation理论。这个理论可以通俗地阐述
为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个中间人你就
能够认识任何一个陌生人。”该理论产生于世纪年代，由美国心理学家米尔格伦 Stanley
Milgram—提出。六度分隔现象又称为小世界现象small world phenomenon。
有这么一个故事，几年前一家德国报纸接受了一项挑战，要帮法兰克福的一位土耳其烤肉店
老板，找到他和他最喜欢的影星马龙·白兰度的关联。结果经过几个月，报社的员工发现，这两
个人只经过不超过六个人的私交，就建立了人脉关系。原来烤肉店老板是伊拉克移民，有个朋友
住在加州，刚好这个朋友的同事，是电影《这个男人有点色》的制作人的女儿在女生联谊会的结
拜姐妹的男朋友，而马龙·白兰度主演了这部片子。
用无向图的路径来描述上述的“关联关系”如图所示。S表示烧烤店老板，D表示影星
马龙·白兰度，中间间隔了个人。
⑤ O
朋友 同事 男友干姐妹 父女 同事 ①
图 关联关系的路径
“六度空间”理论的应用价值越来越受到人们的关注。无论是人际网络，还是万维网的架
构，还是通过超文本链接的网络、经济活动中的商业联系网络、生态系统中的食物链，甚至人类脑
神经元以及细胞内的分子交互作用网络，有着完全相似的组织结构。通过网络使“六度分隔”理
论对人与人之间都可以构成弱纽带，当然理想的状态是人人都置身在连接的世界中，这个目标在
应用 实 例
不断接近。社会中普遍存在“弱纽带”通过弱纽带人与人之间的距离变得非常“相近”这在社
会关系中发挥着非常强大的作用。经常运用六度分隔理论的领域有：直销网络、电子游戏社区、
SNS网站和BLOG网站等。
但是，在过去的数十年的时间里，米尔格伦的理论从来没有得到过严谨的证明，虽然屡屡应
验，虽然很多社会学家一直都对其兴趣浓厚，但它只是一种假说。现在，美国两所不同大学的社
会学家们正在分别对此进行研究，它们都不约而同地使用了网络时代的新型通信手段——
Email——来对“小世界现象”进行验证。
年，哥伦比亚大学社会学系的登肯·瓦兹主持了一项最新的对“六度分隔”理论的验证
工程。个不同国家的六万多名志愿者参加了该研究。瓦兹随机选定名目标比如一名美
国的教授、一名澳大利亚警察和一名挪威兽医等要求志愿者选择其中的一名作为自己的目
标，并发送电子邮件给自己认为最有可能发送邮件给目标的亲友。到目前为止，瓦兹在世界
顶级的科学学术期刊《科学》杂志上发表最新论文表明邮件要达到目标，平均也只要经历
个人。
“六度分隔”假说的出现使得人们对于自身的人际关系网络的威力有了新的认识。但为什
么偏偏是“六度分隔”而不是“七度”、“八度”或者“千百度”呢这可能要从人际关系网络的小
世界性质的另外一个特征“定律”来寻找解释。其数学解释但并不是证明如下：若每个人
平均认识人，其六度就是 人。这个数字远超过人类历史上所有各
代的人数总和。
“定律”可以简单描述为“人类可以与大约人左右建立比较合适的人际关系”。从
《纽约客》杂志的专栏作家马可姆·格兰德威尔在他的著作《引爆流行》中考证了一个名为“郝特
兄弟会”的欧洲农民组织，这个组织有个约定俗成的规定：一个聚居点的人员规模超过个人
时，就要将该聚居点变成两个，这两个点再进行“分离”的循环。格兰德威尔说：“把人
群控制在人以下似乎是管理人群的一个最佳和最有效的方式”。古往今来，许多团体建制
都无意识地采用了这条规律。例如：在世纪以后瑞典陆军编有旅，每旅辖个营，每营辖个
连，每连编人。人们不免要问为什么偏偏是人这个数字呢人类学家特蕾茜·H·约
菲研究发现人类所能处理的社会信息与人类的大脑的视觉和社会认知能力的发达程度有关。由
罗宾·邓巴领导的研究小组年报道了动物种群的规模与其大脑新皮层相对于整个大脑
比例相关，在现代人，这个规模是人左右。进而，邓巴在年通过西方人比较熟悉圣
诞卡片交换行为的调查发现这个人数在左右。类似的大量研究都表明“定律”的科
学性。
六度分隔理论的验证
显然，社会学家主持的验证研究，都不约而同地使用了网络时代的新型通信手段——Email。
然而，这样的研究具有太大的局限性和困难。其一，使用Email保持社会关系的人群有较大的局
限性。其二，我们很难记录和跟踪所有Email的走向，这是一个信息量太过巨大的工程，即便只
第章 图
涉及数万名志愿者，也需要一个非常长的周期才能完成。其三，志愿者很可能会遗漏一些与之相
识的人，而这些人或许刚好就是快速通往目标人的中间人。其四，整个过程有赖于志愿者的意
愿，部分或许是重要的中间人，可能没有兴趣为这个验证转发Email。
现代人用电话和短信保持联络的远远大于用Email保持联络。截至年初，我国三大运
营商的手机和固话用户数大约在亿中国移动的用户数量已经接近亿，联通和电信各超过
亿除去部分重复使用者，应该有亿用户左右。基本上覆盖了全部成年人口。由于电话
和短信的通信都有一个运行服务商，从而人脉关系的数据已经集中在服务商那儿，不需要再进行
跟踪。因此采用现成的电话和短信通信信息，很容易建立两个人是否为“认识”的关系。比如，
假定任意两个人在一年内，电话或短信相互收发两次以上定义为两人“认识”这可以排除绝大
部分的广告电话和广告短信。
实际操作中，由于竞争和保密的原因，运营商对用户的通信数据不会公开。因此，我们只能
理论上介绍并分析验证“六度空间理论”的思想方法。
“六度空间理论”可以形式化描述成以下图论中的最短距离问题：首先，用一个无向图G来
表示N个人的人际关系网络。假定有NN亿个人，用图G的一个顶点表示一个人，那么
该图有N°个顶点。两个人“认识”与否，用代表这两个人的顶点之间是否有一条边来表
示，如果平均每个人“认识”其他个人，则该图大约有×N×°条边，并假定边上
的权值都是。“六度空间理论”可以陈述为：在人际关系网络图G中，任意两个顶点之间都
有一条最短距离不超过的路径。在实际验证过程中，可以改用一定的百分比比如
陈述：在人际关系网络图C中，任意一个顶点到其余上的顶点都有一条最短距离不超
过的路径。
要求每一对顶点之间的最短距离，理论上采用节的Floyd算法，就可以完全解决问
题。但是由于这个算法的空间复杂度是N时间复杂度是N这对于N°规模的问
题来说，这个复杂性太大，没有实施的可能。
另一种思路是，随机抽样部分人进行验证。每次以某个顶点为源点，执行节的Dijkstra
算法，可以计算一个人到其余所有人之间的最短距离。因为这个图是稀疏图，可以用邻接表作为
存储结构并用第章介绍的优先队列进行 DeleteMin 操作。它的时间界大约可以改进为
ElogV××log °×× C。对于现代每秒万亿次运算速度的计
算机来说，在几秒钟可以验证一个顶点，每天可以验证近万人。从存储的角度看，采用邻接表存
储该图，如果每个顶点平均有个左右的邻接点，大体上会有数百个吉G的存储量。因此在有
太T数量级存储的超大型计算机上可以实现。为了解决存储的问题，还
可以考虑把这个邻接表存储在外存的数据库上需要付出增加时间的代
价内存中只存储当前的最短路径长度和当前路径表中的D向量和
P向量它们分别需要数吉G的存储量。 微视频
六度空间 求得一个人到其余所有人的最短距离以后，就很容易计算出最短距离
不超过的顶点所占比例。
应 用 实 例
还有一种更好的思路是，不用Dijkstra算法。首先，我们把人际关系网络图G看成是一个不
带权的图。然后，“六度空间理论”也可以陈述为：在人际关系网络图G中，任意两个顶点之间都
有一条路径长度不超过的路径。可以采用节广度优先搜索BFS的方法，对任意一个
起点，通过对图G的“层”遍历，就可以统计出所有路径长度不超过的顶点数。从而得知这些
顶点在所有顶点数中的所占比例。代码是算法的实现。该算法的时间复杂度是E
V≈×°≈ G对于现代每秒万亿次运算速度的计算机来说，每秒钟可以验证数个顶
点，每天可以验证数万人。空间复杂度与Dijkstra算法相当，需存储 Visited 向量和当前队列向
量，它们分别需要数个吉G的存储量。
define SIX
int visitedMaxVertexNum
void InitializeVisitedint Nv
Vertex V
forVVNvV
VisitedVfalse
一
int SDSBFSLGraph GraphVertex S
以S为出发点对Graph进行层BFS搜索
Queue Q
VertexV LastTail
PtrTOAdjVNode W
int CountLevel
QCreateQueueMaxSize创建空队列，MaxSize为外部定义的常数
Count
Level
统计人数从开始人
LastS
AddQQs
该层只有s一个顶点，是该层被访问的最后一个顶点·
whileISEmptyQ
VDeleteQQ 弹出V
forWGraphGvFirstEdgeWWWNext对V的每个邻接点WAdjV
ifVisitedWAdjvI若WAdjV未被访问
Visitedstrue标记S已访问·
起始点定义为第层
S入队列
第章 图
VisitedWAdjvtrue 标记WAdjV已访问
Count ·统计人数
TailWAdjV 当前层尾
AddQQWAdjV WAdjV入队列
ifVLastI·如果上一层的最后一个顶点弹出了·
Level 层数递增
LastTail 更新当前层尾为该层被访问的最后一个顶点
ifLevelSIXbreak层遍历结束，退出搜索·
while结束
DestroyQueueQ
return Count返回统计数据·
void SixDegreesofSeparationLGraph Graph
用邻接表存储图，对每个顶点检验六度空间理论
Vertex V
int count
forVVGraphNvVI 对图中的每个顶点V
InitializeVisitedGraphNv
countSDSBFSGraphV
printf·顶点者d的六度覆盖比例fnvdoublecountdouble
GraphNv
代码 统计路径长度不超过的顶点数比例
算法SDSBFS没有给出路径上的这六个中间人是谁，需要这些信息的话，也不难修改算法
得到它们。
现在回到原始问题，“六度空间”理论中所指的“每个人”应该是指全球的亿人口，上述的
讨论从原理上可以应用于全球每个人。但是，出于比较现实的可获得原始数据的原因，我们把范
围暂时限定在国内，或者相对容易实现的某一个“电话运营商”用户的范围内。有兴趣的研究学
者不妨寻求与运营商合作来验证一下。
本 章小 结
本 章 小 结
相对于线性表和树，图这种数据结构具有更强的描述现实问题的能力。正如线性表是树的
特例一样，线性表和树都可以看成图的特例，因而利用图数据结构能解决更为广泛和复杂的问
题。相应地，在计算机中表达一个图及其相关的操作也要复杂得多。
存储一个图的常用方法主要有两种，即邻接矩阵和邻接表。前者属于顺序存储，需要θVI
的存储空间；后者属于顺序存储和链式存储的结合，需要θIVIE的存储空间。对于稠
密图来说，两者差别不大，由于前者的结构简单，所以是首选；对于稀疏图来说，后者比较省空间，
当V比较大的时候，节省的空间就相当可观，对于超级巨大的V来说比如节的应用实
例前者可能就无能为力，你非选择后者不可了。
不同的存储结构也会影响算法的时间复杂性。一般来说，稀疏图采用邻接表存储可以大大
提高从顶点寻找邻接边的处理效率，从而提高算法的时间性能；稠密图可以首先考虑较为简单的
邻接矩阵存储结构。
节迷宫探索的思路很好地表达了深度优先搜索DFS的过程，其实现的核心技巧是
利用一个辅助的堆栈。实现广度优先遍历BFS的核心技巧是利用一个辅助的队列。应用中，
选择 DFS还是BFS进行遍历，主要看遍历的目的是什么。如果仅仅为了访问每个顶点，选用哪
个方法都可以。但是如果图的顶点和边的数量庞大，遍历的目的也只是寻找某合适的顶点，那么
选择哪种遍历方式就有讲究了。如果估计目标顶点离开起始顶点不会太远，那么选择广度优先
遍历是比较合适的，因为它是一种由近及远的搜索策略，有较大的可能性快速找到目标；如果估
计目标顶点与起始顶点没有太大的关系，那么选择深度优先遍历是比较合适的，深度优先是通过
邻接点尽快接近较远目标的搜索策略。举个未必十分准确却也类似的例子，在野外寻找失踪人
员，搜索方法也可以有两种。假如失踪时间不长，可以采用类似于广度优先策略的“地毯式”搜
索，因为我们估计失踪人员短时间内不会离开很远，快速搜索成功的可能性也比较大；假如失踪
时间已经很长久，最好的策略是沿着失踪人员留下的“足迹线索”不断跟踪搜索，这类似于深度
优先策略，而费时盲目的“地毯式”搜索显然无助于快速找到失踪者。
节的最小生成树不仅解决了本章一开始提出的公路村村通问题，其现实应用非常广泛，
一般的最小连通成本问题都可以通过最小生成树算法求得最优解。普利姆Prim算法和克鲁
斯卡尔Kruskal算法分别从顶点出发和从边出发，最后“扩展”成一棵代价最小生成树，算法思
想都是采用“贪婪”的方法，从时间效率上来说，前者适合稠密图，后者适合稀疏图。
节讨论最短路径问题。主要讨论了两个问题，即边上正权值图的“单源最短路径问题”
和“任意两个顶点的最短路径问题”。前者采用迪杰斯特拉Dijkstra算法，算法思想是“贪婪”
方法，时间和空间效率都比较高；后者采用弗洛伊德Floyd算法，算法思想是“动态规划”方法。
最短路径问题算法的应用也很广泛，现代人们常用的汽车导航系统就是一个直接的应用。
节的拓扑排序是解决一个“项目流程规划图”的合理性问题，即判断其是否属于有向无
第章 图
环图DAG若是则给出一种可行的顺序。而节的关键路径问题是在此基础上，进一步找
出哪些活动是影响项目工期的关键活动。不过，如果仅仅是拓扑排序问题的话，DAG可以描述
成不带权的AOV顶点表示活动就可以了，而如果要进一步解决项目工期问题，那么“项目流
程规划图”就应该描述成一个带权的AOE边表示活动才比较方便。
在涉及全图的问题中，算法的时间代价CEV通常是最优了，因为考察每个顶点和
边一次就需要这个时间复杂性。如果是稠密图，则VI的时间代价算法也是最优的了。
另外一个问题，应用非常广。理论上是哈密尔顿回路Hamilton Cycle问题，它的提法可以
简单陈述为“是否存在仅仅经过各个顶点一次的回路”。但是它的一些变形的提法可能更具现
实应用背景：“寻找至少经过各个顶点一次的最短回路”。我们把它叫做巡回售货员问题Trave ling Salesman ProblemTSP也叫货郎担问题。它不是最短路径问题，也不属于最小生成树问
题。令人遗憾的是，至今没有找到解决TSP的多项式时间界的方法。事实上，到目前为止的研
究表明，这类问题很可能需要指数时间界的算法才能解决，但这个结论仍然只是一个猜测。同属
于哈密尔顿回路的变形问题还有：最佳旅游线路问题、最佳灾情巡视路线选择问题、印刷电路板
最优穿孔问题等。
同样非常著名、并且也有相同难度的问题还有：装箱问题、背包问题、图的着色、团问题等，读
者如果有兴趣，建议查阅有关文献或网站资料。
欧拉回路Euler Cycle问题看起来似乎与哈密尔顿回路问题有点相似，它的提法简单陈述
为“是否存在仅仅经过各条边一次的回路”所以也叫图的“一笔画”问题。它的一个著名应用就
是“哥尼斯堡七桥问题”。然而令人惊奇的是，判断是否存在欧拉回路和寻找一条欧拉回路的时
间界只需要EV理论的结果非常简单：存在欧拉回路的充分必要条件是所有顶点
的度均为偶数。找到一条欧拉回路的算法同样不复杂：采用一次深度优先搜索可以得到一个回
路，在原图中删去这个回路后再次进行深度优先搜索，拼接得到的各个回路就可以得到覆盖所有
边的欧拉回路。具体算法读者可以查阅有关资料。
习 题
判断正误。
用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。
用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。
无向连通图所有顶点的度之和为偶数。
在任一有向图中，所有顶点的入度之和等于所有顶点的出度之和。
如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。
如果从有向图G的每一点均能通过深度优先搜索遍历到所有其他顶点，那么该图一定不存在拓扑序列。
如果e是有权无向图G唯一的一条最短边，那么边e一定会在该图的最小生成树上。
填空题。
在用邻接表表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度为。
习题
如果G是一个有条边的非连通无向图，那么该图顶点个数最少为。
在一个有权无向图中，如果顶点b到顶点a的最短路径长度是顶点c与顶点b之间存在一条长度
为的边。那么c与a的最短路径长度。
设无向图为GVE其中Vvv西，IEBpnnvvvv。请
回答下列问题：
画出该图。
分别写出每个顶点的度。
画出相应的邻接矩阵。
已知有向图如图所示，请给出该图的
每个顶点的入度和出度。
邻接矩阵。
邻接表。
逆邻接表。
各个强连通分量。
已知一个无向图的顶点集为VV…VI其邻接矩阵如下所示：
v
V
画出该图的图形。
给出从V。出发的深度优先遍历序和广度优先遍历序。
设有图的数据逻辑结构 BKR其中：顶点Kkk…kI有向边集Rkkkkg
kkkkkkkkkkkgkkkkakkk。
请在图中完成，画出这个逻辑结构的图示。
① ⑤
A
② ④
③
图 题图 图 题图
第章 图
对该DAG图，分别举出四个拓扑序列的例子开始结点和结束结点不完
全相同。 a
给出从顶点k出发深度优先搜索遍历该图的顶点序列有多种遍历方式
时，顶点标号小者优先。
e
b
①
根据图所示的无向带权图回答下列问题：
d
写出它的邻接矩阵。
画出图的最小生成树。 c
h
给出从顶点a出发深度优先搜索遍历该图的顶点序列多个顶点可以选
择时按字母序。 图 题图
给定一个图的邻接矩阵如下：
v V V V V V V V V。 V
V
V
V
V
v
v
V
V
V
V
在图中画出该图的边：
从V出发的深度优先遍历序列DFS有多种选择时小标号优先。
从V出发的宽度优先遍历序列BFS有多种选择时小标号优先。
试利用Dijkstra算法求图中从顶点A到其他顶点的最短距离及对应的路径，写出计算过程中各
步状态。
B
E
A
C G
D
F
图 题图 图 题图
习题
给出如图所示的具有个结点的网G。请；
画出该网的邻接矩阵。
采用Prim算法，从号结点开始，给出该网的最小生成树画出Prim算法的执行过程及最小生成树的
生成示意图。
①
②
③ ④
⑤
图 题图
试利用 Floyed算法，求如图所示有向图的各对顶点之间的最短路径，并写出在执行算法过程
中，所得的最短路径长度矩阵序列和最短路径矩阵序列。
给定如图所示的有向图，请问其不同的拓扑排序序列有几种，请给出按字母序从小到大的拓扑
序列。
A
D
a
④
B
C e ①
图 题图 图 题图
一个工程项目由下列AL共个活动构成，各活动的持续时间和前驱活动如表所示。
表 题表
活动 持续时间 前驱活动 活动 持续时间
G
无无A H
I
J
CD K
B L
B
前驱活动
A
B
C
D
E
G
E
I
E F
F HJK
第章 图
画出表示该工程项目的AOE网络图。
列出图中各顶点状态的最早发生时间和最迟发生时间。
计算完成该项目的所需时间；指出哪些是关键活动。
参考代码和代码把它们修改成根据问题的大小顶点数n动态分配一维 Data数组和二维
G矩阵的大小。
参考例以图a的无向图G为例，进行图的深度优先搜索。假设从顶点C出发进行搜索。
参考例以图a所示无向图G进行广度优先搜索遍历，假设从顶点C出发进行搜索。
若选择邻接表作为图的数据结构，请改造代码。
第章
排 序
引子
前面我们已经学习过线性表、树、图等数据结构，数据结构和算法是密不可分的，特定的算法
需要特定的数据结构才能发挥出应有的效率。本章我们来谈谈最常见的一类算法：排序。
在计算机中，所谓排序就是将一组无序的记录序列调整为有序的记录序列，是计算机处理问
题时经常会遇到的一项工作。一个排序算法是指一种能将一串记录序列按照某种特定的方式进
行调整的一种方法。
请大家试想下，如何让计算机将这组序列排成从小到大的序列就算完全
没有排序算法的概念，相信读者也能找到办法来解决这个问题。有些读者可能已经学过一些简
单的排序方法，比如冒泡排序、直接插入排序等，这些简单排序方法都可以很好地解决类似前面
这种数据量比较小的排序问题。那么现在换个问题，如果要对Google的搜索关键词进行排序，
选出大热门关键词，请问该如何实现对于这类数据量很大的问题，排序算法的效率就非常
关键。
接下来让我们通过例子来了解与排序密切相关的一个问题，从中可以看到，相同的问题，由
于采用的算法思路不同，最终问题求解的效率差别会很大。
例有亿个随机给出的浮点数，请找出其中最大的万个。假设每个浮点数占个
字节。
分析解决该问题的办法有很多，下面列举种。这里我们重点分析问题的求解思路，并
关注它们的时间复杂度。读者通过本章的学习可以编写出具体的程序。
方法
每个浮点数占个字节，亿个浮点数需要 MB。最直接的方法是：每次通过一轮循环
比较，选择其中最大的数据，这样进行万次选择，就可以得到最大的万个数。这种思路就是
选择排序的基本思想。由于从N个数的序列中选择一个最大的数需要经过N次的比较，故此
方法总比较次数为NN…N 次。当N为亿时，比较次数大约为万亿
次。这样的时间复杂度和排序效率都是不能忍受的，可见，一些简单的排序算法在海量数据面前
是不适用的。
方法
对于如此规模的排序，一种比较好的方法是采用“分而治之”的策略。比如，以百万为一
第章 排序
个块，分为块，分别对这块数据进行排序。由于只需要得到最大的万个数，故每块排
完后可以只要前万个数，再从这块共万个数中取最大的万个就可以了。后面我们
会讲到的快速排序和归并排序都是这种“分而治之”算法设计思想的体现。如果数据是完全没
有规律的话，快速排序的平均复杂度是NlogN。当N为万时，NogN是万，所
以求解块百万数据的排序问题以及随后对万数据的再排序，时间复杂性大约是亿，
与前一种方法比较已经有很大的改进。
方法
还有一种更为精巧的方法：先读出百万个数，可以利用快速排序等高效算法进行排序，找
出最大的万个数。然后维护好这万个数，对剩下的近I亿个数进行过滤：每次读入剩下的一
个数，如果该数小于等于这万个数的最小值，则继续读下一个数；否则，用该数替代万个数里
的最小值。这里的关键问题是如何维护好这万个数，使之能随时知道这万个数的最小值并
方便删除它，以及加入新的数。从前面节可以知道，堆结构就可以很好地完成这个任务。因
此，基于堆结构也有一种好的排序算法，那就是堆排序。如果最早选取的这百万个数据够理想
的话，其中最大万个数里面的最小数应该接近最终所求的万个最大数里面的最小数，故可以排
除掉剩下近亿个数中的大部分数。假设有右的数被排除了，那么也就只有千万个左右
的数入堆，堆的操作效率是logN。由于堆里只有万个数，每次堆操作复杂性是log 约
等于所以这个方法的效率大致是：万百万数排序亿顺序过滤千万，共约
亿，比第种方法在计算效率上又提高了不少。
另外，这种方法也不用把所有数都一次性放到内存里来处理，因此在大数据量情况下可以节
省内存空间。这种思想就是本章最后要提到的外部排序的思路。
由上例可以看出，不同的方法，其效率可以相差很多，而效率其实是跟数据的特点直接或间
接相关的。本章的任务就是向大家介绍几种经典的排序算法，同时分析它们各自的优缺点。需
要特别指出的是：没有一种排序算法在任何情况下都是最优的，我们必须学会根据实际情况选择
最优的算法来解决问题。
这里还有个常用的概念要解释下。排序算法的“稳定性”是指：在一组待排序记录中，如果
存在任意两个相等的记录R和S且在待排序记录中R在S前，如果在排序后R依然在S前，即
它们的前后位置在排序前后不发生改变，则称该排序算法为稳定的。
为了叙述方便，本章随后讨论的排序问题都约定为从小到大的排序。
选择排序
简单选择排序
简单选择排序Simple Selection Sort是一种直观的排序算法，其思想是在未排序的序列中
选择 排 序
选出最小的元素和序列的首位元素交换，接下来在剩下的未排序序列中再选出最小元素与序列
的第二位元素交换，依次类推，最后形成从小到大的已排序序列。
代码给出了这个算法的C语言实现。
void SwapElementTypeaElementType·b
ElementType taab bt
void simpleSelectionsortElementType Aint N
简单选择排序·
int ijmin
foriiNi寻找最小元素
mini
forji jNj
ifAjAmin
mínj min记录最小元素位置
将第i个元素与最小元素交换
SwapAiAmin
代码 简单选择排序的C语言实现
可以看出，简单选择排序无论在什么情况下，都需要比较NN次，故其时间复杂度
为N。事实上，在将第i个元素与最小元素交换之前，我们可以判断一下，如果mini则
不用交换，那么简单选择排序移动元素的次数在最好的情况下是次待排序的元素序列已经
是有序在最坏的情况下为N次除了最后一个元素外，每个元素都要经过步交换
位置。
堆排序
堆排序Heap Sort是由年计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯
特·弗洛伊德Robert WFloyd和威廉姆斯JWilliams在年共同提出的。
堆排序是指利用堆这种数据结构所设计的一种排序算法。在第章中我们已经介绍了堆，
是一种特殊的二叉树，每个子结点的值总是小于或者大于它的父结点，相应地分为最大堆和
最小堆。由于堆是一个完全二叉树，一般情况下堆排序都是用数组的方式来实现。
堆排序的核心思想是：利用最大堆或者最小堆输出堆顶元素，即最大值或最小值将剩
第章 排 序
余元素重新生成最大堆或者最小堆继续输出堆顶元素，重复此过程，直到全部元素都已输
出，得到的输出元素序列即为有序序列。
实现堆排序方法一种简单的做法是额外开辟一个辅助的数组空间，将堆顶元素逐一放
入辅助数组里，最后再把辅助数组的内容复制回原始的数组。这种方法的额外空间复杂度
是N。下面我们讨论一种更聪明的方法，只用的额外空间即可。
如图所示，首先将一个无序的序列生成一个最大堆，如图a所示。接下来我们
不需要将堆顶元素输出，只要将它与堆的最后一个元素对换位置即可，如图b所示。这
时我们确知最后一个元素一定是递增序列的最后一个元素，而且已经在正确的位置上。
现在问题变成了如何将剩余的元素重新生成一个最大堆——也很简单，只要依次自上而下进
行过滤，使其符合最大堆的性质。图c是调整后形成的新的最大堆。要注意的是，
已经被排除在最大堆之外，即在调整的时候，堆中元素的个数应该减。结束第轮调整
后，再次将当前堆中的最后一个元素与堆顶元素换位，如图d所示，再继续调整成
新的最大堆……如此循环，直到堆中只剩个元素，即可停止，得到一个从小到大排列的有
序序列。
⑩ ⑩
a原始最大堆 b将与换位
⑩ ⑩
c调整后形成新的最大堆 d将与换位，继续调整
图 最大堆的调整
这个方法的时间复杂度与前一种方法相同，仍然是OMlogN但是不需要额外的辅助数
组，所以额外空间复杂度是。
代码给出了堆排序的实现。注意到第章的最大堆代码不能直接调用，因为这里的
数据是从第个单元开始存放的，所以代码需要做相应的改动。这时对于第i个单元的结点，
选 择 排 序
其左孩子的编号不再是i而是i右孩子编号是i其父结点的编号是Li」。又
注意到无论是建立堆还是删除堆顶元素，其核心部分都是“下滤”所以我们把这个核心函数
抽取出来，用PercDownAiN来实现对A 中的前N个元素从第i个元素开始向下迁移调
整的过程。
void PercDownElementType Aint pint N
改编代码的PercDownMaxHeap Hint p
将N个元素的数组中以Ap为根的子堆调整为最大堆
int ParentChild
ElementType x
xAp取出根结点存放的值
forParentpParentNParent Child
ChildParent·
ifChildNAChildAChild
Child Child指向左右子结点的较大者
ifXAChildbreak找到了合适位置
else 下滤X
A ParentAChild
AParentx
void HeapSortElementType A int N
· 堆排序·
int i
foriNii建立最大堆
PercDownAiN
foriNii
删除最大堆顶
SwapAAi 见代码·
PercDownAi
代码 堆排序
第章 排序
插入排序
简单插入排序
简单插入排序的核心思想是：将待排序的一组序列分为已排好序的和未排序的两个部分；初
始状态时，已排序序列仅包含第一个元素，未排序序列中的元素为除去第一个以外N个元素；
此后将未排序序列中的元素逐一插入到已排序的序列中。如此往复，经过N次插人后，未排
序序列中元素个数为则排序完成。
具体到第k次插入，对应待插入元素应为第k个元素，也就是未排序序列中的第一个元
素，插入的基本过程是：将它和第k个元素也就是已排序序列的最后一个元素进行比较，若
大于第k个记录，则该次循环结束；否则，将两个元素交换，再比较该数和第k个元素之间
的大小，依此往复，直到该数比它当前位置的前一个元素大，或该数已交换到了第个位置，则第
k次循环结束。
下面我们来看一个例子。表显示了对进行简单插入
排序的前次循环的情况。在第次循环结束后，已排序序列中有个记录。第次循环第步，
将未排序序列中的第一个记录和已排序组中的最后一个记录进行比较，因满足因此
交换这两个记录；第步，仍然小于一个记录则继续交换；直到大于前一个记录则停止交
换，第次循环结束。已排序序列中新增记录未排序序列中删除该记录，记录数量减。
表 简单插入排序示例
排序前
已排序序列 未排序序列
已排序序列 未排序序列
经过次循环
第次循环结束后
第次循环第步
第次循环第步
第次循环结束
经过次这样的循环，未排序序列的所有记录逐个插入到已排序序列中，则排序结束。简
单插入排序的算法实现由代码给出。注意到在程序实现时，不需要每次做步赋值实现交
换，而是将未排序序列中的第一个元素先取出来，依次与已排序序列中元素比较，将需要交换的
元素右移，最后把未排序序列中的第一个元素放进合适的位置即可。
插入 排 序
void InsertionSortElementType Aint N
插入排序
int P
ElementType Tmp
forPPNP
TmpAD取出未排序序列中的第一个元素·
foriPiAiTmpi
AA依次与已排序序列中元素比较并右移
ATmD放进合适的位置
代码 插入排序
由该算法代码可以看出，空间复杂度上，简单插入排序仅需要常数个额外空间；时间复杂度
上，函数中有个嵌套的循环，每个循环进行N次比较和交换，因此整个简单插入排序的平
均时间复杂度为N。在最坏的情况下，对应每一个P要进行P次比较和交换，总共要花
费N次操作；在最好的情况下，也就是对已经排好序的序列进行排序，第二个循环在第一个
AiTmp比较时就跳出，因此总共花费ON次操作。
此外，简单插入排序是稳定的排序，我们发现，数值相同的两个记录不会发生相对位置上的
改变。
希尔排序
简单插入排序效率不高的一个重要原因是每次只交换相邻的两个元素，这样只能消去一对
错位的元素。希尔排序对插入排序进行改进，试图通过每次交换相隔一定距离的元素，达到排序
效率上的提升。
希尔排序的基本原理是，将待排序的一组元素按一定间隔分为若干个序列，分别进行插入排
序。开始时设置的“间隔”较大，在每轮排序中将间隔逐步减小，直到“间隔”为也就是最后一
步是进行简单插入排序。
希尔排序将“间隔”定义为一组增量序列，用来分割待排序列，即将位置之差等于当前增量
的元素归属于同一个子序列，并分别进行插入排序；排好后再选取下一个增量，划分子序列再次
排序，直到最后一个增量一般为。
例 对于待排序列我们可设定增量序列为
。
第一个增量为因此、、、、分别隶属于同一个
子序列，子序列内部进行插入排序；然后选取第二个增量因此、
第章 排序
、分别隶属于同一个子序列；最后一个增量为这一次排序相当于简单插入排序，
但是经过前两次排序，序列已经基本有序，因此此次排序时间效率就提高了很多。希尔排序过程
如表所示。
表 希尔排序示例
排序前
第一个增量排序后
第二个增量排序后
第三个增量排序后
代码给出了用Sedgewick 增量序列进行希尔排序的实现。
void shelsortElementType AintN。
希尔排序用Sedgewick增量序列·
int siDPi
ElementType Tmp
这里只列出一小部分增量
int Sedgewick
forSiSedgewicksiN Si
初始的增量SedgewickSi不能超过待排序列长度·
forDSedgewicksiDDSedgewicksi
forPDPNP插入排序
TmpAP
foriPiDADTmpiD
AAD
AiTmp
代码 希尔排序
由该算法代码可以看出，空间复杂度上，和简单插入排序一样，希尔排序只需要的额
外空间；时间复杂度上，每一次针对某增量进行插入排序，而随着增量逐渐变小，整体序列逐渐有
序起来，每次插入排序的比较和交换次数变少。
希尔排序算法的整体时间复杂度和增量序列的选取有关，目前并没有统一的最优增量序列。
当使用增量序列LNJLN…进行希尔排序时，最差情况下时间复杂度为N而当
交 换 排序
使用增量序列z…时，最差情况下时间复杂度为ON其平均时间复杂度尚无
定论，猜想结果为N。除此以外，还有不少其他的增量序列选取方法，在各自特定的排序
对象中有较好的时间复杂度的表现。代码中用到的Sedgewick 增量序列中的每一项或者是
××的形式、或者是×的形式，关于它的复杂度分析目前也是尚无定论，只
有猜想其平均时间复杂度为N最差情况下时间复杂度为N。经验表明，希尔排序
对规模以万计的待排序列会体现出比较好的效率。
此外，和简单插入排序不同的是，希尔排序不是稳定的排序，选取不同增量进行排序时，可能
导致数值相同的两个元素发生相对位置上的改变。
交换排序
冒泡排序
冒泡排序是最简单的交换排序。对元素个数为N的待排序序列进行排序时，共进行N
次循环。在第k次循环中，对从第到第Nk个元素从前往后进行比较，每次比较相邻的两
个元素，若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变。这样一次循
环下来，就把第k大的元素移动到第Nk个位置上，称为第k趟的冒泡。整个过程一共进
行N趟冒泡，直到第个和第个元素比较完成，最终剩余最小的元素，留在第个位置
上，排序结束。
我们来看例中对给定初始序列的冒泡排序过程，会有十分直观的理解：第趟冒泡后，
最大的记录被移动到了第N个位置上，它将不参与接下来的冒泡；第趟冒泡后，剩余N
个记录中最大的记录被移动到了第N个位置上；经过N趟冒泡后，剩余的最小记录留
在第个位置上，排序结束，如表所示。
表 冒泡排序示例
排序前
第趟冒泡后
第趟冒泡后 …
第N趟冒泡后
第N趟冒泡后
第N趟冒泡后
第章 排 序
代码给出了冒泡排序的算法实现。注意到这里增加了一个flag标记，检查一趟扫描有
没有元素需要交换。如果没有任何元素交换，说明序列已经全部有序，不需要继续执行下一趟扫
描，可直接结束。在序列基本有序的情况下，增加一个flag虽然在每次交换时增加了一次赋值操
作，但可以避免大量冗余的扫描，总体上还是合算的。
void BubbleSortElementType Aint N
I冒泡排序
int Pi
bool flag
forPNPPF
flagfalse 标记该次循环中是否发生交换，若无，则说明整个序列有序
foriiPi一趟冒泡
每次循环找出一个最大元素，被交换到最右端·
ifAAi
SwapAiAi
flagtrue 标识发生了交换·
ifflagfalsebreak若全程无交换，则跳出循环
代码 冒泡排序
显而易见，冒泡排序最坏的情况下序列是逆序排列的在每一次比较都要进行一次交换，
时间复杂度为N最好的情况下，序列已经是排好序的，这时由于应用了flag标记只要进行
N次比较就可以从循环中跳出来，完成排序；程序的平均时间复杂度为N。空间复杂度
方面，冒泡排序只需要常数个额外空间用于保存中间变量。此外，冒泡排序是稳定的，因为元素
关键字相等的两个记录在比较时并不会发生交换，即相对位置不会发生变化。
快速排序
快速排序也是交换排序的一种，但和冒泡排序不同的是，冒泡排序只比较相邻两个记录
的顺序，而快速排序的原理是：将未排序元素根据一个作为基准的“主元”Pivot分为两个子
序列，其中一个子序列的记录均大于主元，而另一个子序列均小于主元，然后递归地对这两个
子序列用类似的方法进行排序，如图所示。这种思路我们在第章最后讨论集合中位
数的时候已经见到过了。本质上，快速排序使用分治法，将问题的规模减小，然后再分别进
行处理。
交 换排 序
递归解决
图 快速排序示意
子序列的划分方法也与我们在第章讨论过的方法类似，从原序列中选择一个主元，将比主
元大的元素从右向左放置，而比主元小的元素从左向右放置。
表给出了对例序列进行一趟主元调整的过程。具体步骤为：
选择一个主元，并与最后一个元素交换。
设置两个指针 Low 和 High初值分别指向第一和倒数第二个元素。
Low从左向右扫描，其位置左侧为已遍历或交换过的比主元小的元素；High 从右往
左扫描，其位置右侧为已遍历或交换过的比主元大的元素。首先从Low指向的位置向右扫
描，若遇到比主元大的元素，则停止；然后从 High 指向的位置向左搜索，若遇到比主元小的元
素，则停止。
若Low和 High 没有错位即LowHigh则High 和Low指向的元素互换位置。
重复、直至High 和Low 错位，将基准与ALow对换位置。这就完成了一次划分，以
主元为边界分别划分成大于和小于主元的两个子序列。
递归地对两个子序列用同样方法进行快排。
主元的选取有多种方法。表中用最简单的办法，即选择第一个记录为第一趟快速
排序的主元，经过次交换后，移动到了A位置，左边都是比主元小的记录，右边是比主
元大的记录，此时原序列划分为两个子序列。下一趟快速排序分别对两个子序列进行快排，
依次递归下去直至当前子序列只有一个元素时结束递归，这样就达到了分而治之的算法
目的。
表 快速排序示例
一趟快速排序：
Low High
Low High
Low High
基准
排序前
第次交换
第次交换
第章 排 序
续表
一趟快速排序：
Low High
High Low
High Low
基准
第次交换
第次扫描发现错位
交换ALow和最后
一个主元，一趟结束
快速排序的时间复杂度分析略显复杂。最好的情况下，每一次划分都将原序列分成两个基
本等长的子序列，随着递归层次的加深子序列的数量翻倍，但在每一递归层次上比较总次数都是
N次，而递归层次深度是logN由此可见，快速排序的最好时间复杂度应为NlogN。
更复杂一些的证明显示，快速排序的平均时间复杂度也是NlogN。相对于其他的内部排序，
快速排序的平均时间效率是最高的。但在最坏的情况下，例如每次划分都近似于和N快速
排序的执行时间复杂度就接近于冒泡排序，可能导致N的时间效率。
为了避免最坏结果，在确定主元时需要有一定技巧。一种比较好的方
法是，将Alow、Ahigh、Alowhigh三者关键字的中值作为主元，
这样有可能避免在基本有序的序列中进行快速排序时时间复杂度出现最坏
情况的问题。
微视频
快速排序选
主元
另外一个问题是，由于快速排序一般是用递归实现的，如果待排序列的
规模比较小，递归的副作用就会凸显出来，效果甚至还不如简单的插入排
序。所以更专业一些的处理，是在递归过程中检查当前子问题的规模，当其
小于某个阈值时就不继续递归，而是直接调用插入排序解决问题。
代码给出了快速排序算法的实现。其中Median函数的作用是确定主元，将最左边、最
右边、中间的三个元素的中位数作为主元，并且把三个元素调整成“最左元≤主元≤最右元”的
状态。此时由于最右元肯定不小于主元，所以在后面的集合划分中我们根本无须再考虑它，于
是我们不是把主元与最后一个元素交换，而是把它换到倒数第二个元素的位置上，并且返回
主元的值。
QSort完成关键的排序功能。我们当然可以直接把QSort 函数给用户使用，但是必须告诉用户
以QSortAN的方式调用，而这与其他几个排序函数的接口不一致。为了用户界面的一致
性，我们给QSort加了一个外包装，这样用户就可以通过与其他排序函数一致的接口“某SortA
N”来调用快速排序函数了。这个外包装不是必须的，但却是专业程序员应该有的编程风格。
交 换 排 序
ElementType MedianElementType A int Leftint Right
int CenterLeftRight
SwapALeftACenter
ifALeftARight
SwapALeftARight
SwapACenterARight
此时ALeftACenterARight
SwapACenterARight·将基准Pivot 藏到右边·
八·只需要考虑ALeft…ARight
return ARight 返回基准Pivot
void QsortElementType A int Leftint Right
核心递归函数·
int PivotcutoffLowHigh
ifCutoffRightLeft如果序列元素充分多，进人快排·
Pivot MedianALeftRight 选基准·
LowLeftHighRight
while将序列中比基准小的移到基准左边，大的移到右边
whileALowPivot
whileAHighPivot
ifLowHighSwapALowAHigh
else break
SwapALowARight 将基准换到正确的位置·
QsortA LeftLow递归解决左边
QsortALowRight递归解决右边·
else InsertionSortALeftRightLeft元素太少，用简单排序·
void QuickSortElementType Aint N
统一接口
QsortAN
ifALeftACenter
ifACenterARight
代码 快速排序
第章 排 序
空间复杂度上，由于快速排序需要进行至少 logN层的递归，因此需要至少logN深度
的栈空间。若每次划分的子组大小不够平均，则栈空间的深度更大，在最坏的情况下将导致
接近ON的栈空间深度。
此外，快速排序是不稳定的。因为在和主元进行比较时，可能导致一个元素交换到和它等值
的另一个元素位置以前，导致两者的位置发生相对变换，因此快速排序是不稳定的。
归并排序
归并排序是建立在归并操作基础上的一种排序方法。归并操作，是指将两个已排序的子序
列合并成一个有序序列的过程。
归并排序的基本原理是：将大小为N的序列看成N个长度为的子序列，接下来将相邻子
序列两两进行归并操作，形成N个长度为或的有序子序列；然后再继续进行相邻子
序列两两归并操作，如此一直循环，直到剩下个长度为N的序列，则该序列为原序列完成排序
后的结果，如图所示。
…
图 归并排序示意
归并排序的核心在于归并操作的实现。归并操作的过程如下：首先申请额外的空间用于放
置两个子序列归并后的结果，接着设置两个指针分别指向两个已排序子序列的第一个位置，然后
比较两个指针指向的元素，将较小的元素放置到已申请的额外空间内，并将当前位置向后移动一
格，重复以上过程，直到某一个子序列的指针指向该序列的结尾。这时候将另一个指针所指向序
列的剩余元素全部放置到额外空间内，归并操作结束。
表仍然使用例的序列，应用路归并排序。一开始将所有记录看成单独的N个有
序子序列；每一趟归并操作，将相邻的两个已排序子序列两两进行归并，形成一个规模扩大一倍
的已排序子序列，直到最后归并成一个完整序列。
…
归 并排序
表 归并排序示例
排序前
第趟归并操作结束
第趟归并操作结束
第趟归并操作结束
第趟归并操作结束
从特定角度看，归并排序也可以用分治法的思想去自下而上地理解，就是将原序列划分成两
个等长子序列，再递归地排序这两个子序列，最后再调用归并操作合并成一个完整的有序序列。
归并排序的递归实现由代码给出。其中Merge是对两个有序序列的归并操作，MSort 是核心
的归并排序递归函数，而MergeSort是使用了统一用户接口的排序函数。
注意到，我们只在Merge 函数中才用到那个额外的数组TmpA来存储归并后的序列，但却在
MergeSort 中开辟了这个额外空间，并且一直将其地址作为参数在MSort的递归调用中反复传送。
为什么要这样做为什么不直接在Merge 函数内部开辟一个数组，并且在使用结束后释放如
果真的这样做了，那么程序需要多少额外的空间呢
L左边起始位置，R右边起始位置，RightEnd右边终点位置·
void MergeElementType AElementType TmpAint Lint Rint RightEnd
I将有序的ALAR和ARARightEnd归并成一个有序序列·
int LeftEnd NumElementsTmp
int i
LeftEndR左边终点位置
TmpL 有序序列的起始位置·
NumElementsRight EndL
whileLLeft End 反 RRightEnd
ifALAR
TmpATmpAL 将左边元素复制到TmpA
else
TmpATmpAR·将右边元素复制到TmpA
whileLLeftEnd
TmpATmpAL直接复制左边剩下的·
whileRRightEnd
第章 排序
TmpA TmpAR直接复制右边剩下的·
foriiNumElementsiRightEnd
ARightEndTmpARightEnd将有序的TmpA复制回A
void MsortElementType AElementType TmpA int Lint RightEnd
核心递归排序函数
int Center
ifLRight End
CenterLRightEnd
MsortATmpALCenter 递归解决左边·
MsortATmpACenterRigheEnd递归解决右边
MergeATmpALCenterRightEnd合并两段有序序列
void MergeSortElementType Aint N
I归并排序
ElementType·TmpA
TmpAElementTypemallocNsizeofElementType
ifTmpANULL
MsortATmpAN
freeTmpA
else printf空间不足“
代码 归并排序
由非递归的算法描述可以看到，每一趟归并操作图中的一行需要进行N次比较，
而一共将进行logN趟归并操作，因此整个归并排序的时间复杂度为NlogN哪怕在最
坏情况下时间复杂度也是一样。递归的时间复杂度分析略复杂，不过结果也是NlogN。
空间复杂度上，由于归并操作过程中需要额外的空间用于保存已排序的子序列，因此，如果
实现方法正确的话，整个归并排序的空间复杂度为N。若使用递归方法进行实现并在Merge
函数内部申请空间，如果不及时释放，则可以证明将耗费MlogN的额外空间；若每次都执行
基 数 排 序
申请和释放，则除了耗费N的额外空间以外，还增加N次 malloc和 free操作。这就是为
什么我们不嫌麻烦地在Merge 之外MergeSort 中申请了额外空间，并且一
直将这个数组的地址通过指针方式传递给递归函数的原因。此外，相对于
快速排序和堆排序，归并排序虽然耗费更多的额外空间，但整体的排序过程
是稳定的，关键字值相同的两个元素在排序过程中并不会发生相对位置上
微视频 的变化。 归并排序的 归并排序虽然看上去稳定而且时间复杂度不高，但是在实际应用中，开
辟大块的额外空间并且将两个数组的元素来回复制却是很耗时的，所以归
并排序一般不用于内部排序。但它是进行外部排序详见节的非常
有用的工具。
额外空问耗
费
…
基数排序
基数排序Radix Sort可以看成是桶排序Bucket Sort的推广，所以让我们先看一下桶排序
的思想。
桶排序
如果已知N个关键字的取值范围是在到M之间，而M比N小得多，则桶排序算法将为
关键字的每个可能取值建立一个“桶”即建立M个桶；在扫描N个关键字时，将每个关键字放
入相应的桶中，然后按桶的顺序收集一遍就自然有序了。所以桶排序效率比一般的排序算法
高——当然需要的额外条件是已知关键字的范围，并且关键字在此范围内是可列的，个数还不能
超过内存空间所能承受的限度。
例已知某门公共选修课有学生选修，其成绩为分布于之间的整数。
现需要将学生名单按其成绩从低到高顺序打印出来。
分析若将学生名单按成绩排序再打印，则至少需要ONlogN的时间，这里N。
而用桶排序的方法，可为每一个分数建立一个“桶”共建个桶——具体实现时可定义一个
链表指针数组 Bucket。顺序扫描学生名单，若当前这个学生的成绩是i分，则将他的记录
插入 Bucketi所指的链表头部，这一操作只需步。整个扫描的过程用去N的时间。然后
顺序扫描每个Bucketi将链表中的学生名单逐一打印，该过程用NM的时间，其中
M是桶的个数。可见桶排序只需要NM的时间就可以完成名单的顺序打印，特
别当MN时，这个时间复杂度是线性的。
基数排序
基数排序是桶排序的一种推广，它所考虑的待排记录包含不止一个关键字。例如对一副牌
第章 排序
的整理，可将每张牌看作一个记录，包含两个关键字：花色、面值。一副理顺的牌是按如下顺序排
放的：
…A ◆…◆A v…A ……A
可见一个有序列是先按花色划分为四大块，每一块中又再按面值大小排序。这时“花色”就
是一张牌的“最主位关键字”而“面值”是“最次位关键字”。
对于一般有K个关键字的情况，基数排序通常有两种方法：主位优先法Most Significant Dig it Sort简称MSD和次位优先法Least Significant Digit Sort简称LSD。
仍以整理扑克牌为例，顾名思义，所谓主位优先法，是先为最主位关键字花色建立桶，将
牌按花色分别装进个桶里；然后对每个桶中的牌，再按其次位关键字面值进行排序，最后将
个桶中的牌收集，顺序叠放在一起。
而次位优先法，是先为最次位关键字建立桶，即按面值建立个桶，将牌按面值分别放于
个桶中；然后将所有桶中的牌收集，顺序叠放在一起；再为主位关键字花色建立个桶，顺序
将每张牌放入对应的花色桶中，则个花色桶中的牌必是有序的，最后只要将它们收集，顺序叠
放即可。
从上述例子可见，两种方法具有不同的特点。主位优先法基本上是分治法的思路，将序列分
割成子列后，分别排序再合并结果。而次位优先法是将“排序”过程分解成了“分配”和“收集”
这两个相对简单的步骤，并不需要分割子列排序，故一般情况下次位优先法的效率更高一些。
单关键字的基数分解
从上面可以看到，基数排序主要是对有多关键字的对象进行排序。其实可以将单个整型关
键字按某种基数分解为多关键字，再进行排序。这也是“基数排序”名称的由来。例如可以
根据基数分解为、、这三个关键字，其中是最主位关键字，是最次位关键字；还可以根
据基数分解为、、A这个关键字，其中第一个是最主位关键字，A是最次位关键字。
典型问题是给定N个记录，每个记录的关键字为一整数，其取值范围在到M之间。若M
比N大很多例如MN这时桶排序需要M个桶，会造成巨大的空间浪费；而以R为基数对
关键字进行分解后则只需要R个桶就可以了。让我们通过一个具体的例子来理解什么是基数
分解。
例给定范围在到之间的个关键字
现用基数排序算法进行递增排序。
我们可以将每个关键字看成一个位的进制整数不足位的在左边补从而将每个十
进制整数关键字分解成个关键字，其个位数为最次位关键字，百位数为最主位关键字。这就是
以为基数的分解。
对给定的个记录用次位优先法进行基数排序，首选对最次位个位关键字建立个
桶，将记录按其个位数字的大小放入相应的桶中，如图a所示。此时个数字恰好均匀分
布于个桶中，当然一般情况下不是总有这么好的运气。每个“桶”实际上是一个链表，一趟排
基 数 排 序
序后，将桶中记录重新收集成为一个新的记录链。
接下去按下一个次位关键字十位排序，所得结果如图b所示。注意到此时桶中记
录的分布不再均匀。向桶中插入的新记录需排在链表尾部。将桶中记录收集形成新的记录链
。
最后按最主位百位关键字排序，结果如图c所示，再收集所得的记录链就是最终有
序的。
a基数排序第一趟——按个位数字排序结果
b基数排序第二趟——按十位数字排序结果
s
c基数排序第三趟——按百位数字排序结果
图 基数排序次位优先法演示
代码给出了按次位优先法进行基数排序的算法实现。这里假设元素最多有MaxDigit个
关键字，基数全是同样的Radix。我们用桶B承载分配的记录，再用链List 进行收集。函数
GetDigit 的作用是返回整型关键字X的第D位数字，次位优先从D开始。
·假设元素最多有MaxDigit个关键字，基数全是同样的Radix
define MaxDigit
define Radix
·桶元素结点
第章 排 序
typedef struct Node PtrToNode
struct Nodel
int key
PtrTONodenext
I
桶头结点
struct HeadNodel
PtrTONode head tail
I
typedef struct HeadNode BucketRadix
int GetDigitint xint D
I默认次位D主位 DMaxDigit·
int di
foriiDi
dX号 Radix
XRadix
return d
void LSDRadixSortElementType A int N
基数排序次位优先
int DDi
Bucket B
PtrTONode tmppListNULL
foriiRadixi初始化每个桶为空链表
BheadBtailNULL
foriiNi将原始序列逆序存入初始链表Liat·
tmpPtrToNodemallocsizeofstruct Node
tmpkeyAi
tmpnextList
Listtmp
F
基数 排 序
下面开始排序
forDDMaxDigitD对数据的每一位循环处理·
下面是分配的过程
pList
whilep
DiGetDigitpkeyD·获得当前元素的当前位数字·
从List 中摘除
tmppppnext
插人 BDi号桶尾
tmpnextNULL
ifBDiheadNULL
BDiheadBDitailtmp
elsel
BDitailnexttmp
BDitailtmp
下面是收集的过程
ListNULL
forDiRadix DiDi将每个桶的元素顺序收集入List
ifBDihead如果桶不为空
整桶插入List 表头
BDitailnextList
ListBDihead
BDiheadBDitailNULL清空桶
—
将List 倒入A并释放空间
foriiNi
tmpList
ListListnext
Aitmpkey
freetmp
代码 次位优先的基数排序算法
第章 排 序
对N个关键字用R个桶进行基数排序时，其时间复杂度为DNR其中D为分配收
集的趟数，也就是关键字按基数分解后的位数。当记录的个数N与桶的个数基本是同一数量级
时，基数排序可以达到线性复杂度。但注意到由于链表指针操作的引入，这个N的常数项可
能会超过logN从而实际效果也未必比前面讲过的几种算法要好很多。
另一方面，基数排序用链表实现的好处是不需要将记录进行物理移动，对于大型记录的排序
是有利的，代价是需要N额外空间存放指针。
总之，基数排序的效率与基数的选择密切相关，而基数的选择需要综合考虑待排记录的规模
和关键字的取值范围。
外部排序
外部排序是指大文件排序，即待排序的数据记录以文件的形式存储在外存储器上。由于文
件中的记录很多、信息容量庞大，所以整个文件所占据的存储单元往往会超过了计算机的内存容
量，因此，无法将整个文件调入内存中进行排序。于是，在排序过程中需进行多次的内外存之间
的交换。在实际应用中，由于使用的外设不一致，通常可以分为磁盘文件排序和磁带文件排序两
大类。
外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含N个记
录的文件分成若干长度为LN的子文件，依次读入内存，利用内部排序算法进行排序。然后，
将排序后的文件写入外存，通常将这些文件称为归并段Run或“顺串”对这些归并段进行逐步
归并，最终得到整个有序文件。可见外部排序的基本方法是归并排序法，例给出了一个简单
的外部排序解决过程。
例给定磁盘上有大块记录需要排序，而计算机内存最多只能对个记录块进行内
排序，则外部排序的过程如图所示。
有序 有序
输入块
输出块
b归并策略
磁盘
有序 有序
内存
a分段内排序的结果
磁盘
内存
周转盘
图 外部排序示意
排序的比较和应用
首先将连续的大块记录读人内存，用任何一种内部排序算法完成排序，再写回磁盘。经过
次大块记录的内部排序，得到图a的结果。然后另用一个可容纳大块记录的周转盘，
辅助最后的归并。方法是将内存分成块，其中块用于输入，块用于输出，指定一个输入块
只负责读取一个归并段中的记录，如图b所示。归并步骤为：
当任一输入块为空时，归并暂停，将相应归并段中的一块信息写入内存；
将内存中个输入块中的记录逐一归并入输出块；
当输出块写满时，归并暂停，将输出块中的记录写入周转盘。
如此可将个归并段在周转盘上归并成一个有序的归并段。
例的解决方法是最简单的归并法，事实上外部排序的效率还可以进一步提高。要提高
外排的效率，关键要解决以下个问题：
如何减少归并轮数；
如何有效安排内存中的输入、输出块，使得机器的并行处理能力被最大限度地利用；
如何有效生成归并段；
如何将归并段进行有效归并。
针对这四大问题，人们设计了多种解决方案，例如采用多路归并取代简单的二路归并，就可
以减少归并轮数；例如在内存中划分出个输出块，而不是只用一个，就可以设计算法使得归并
排序不会因为磁盘的写操作而暂停，达到归并和写周转盘同时并行的效果；例如通过一种“败者
树”的数据结构，可以一次生成倍于内存容量的归并段；例如利用哈夫曼树的贪心策略选择归
并次序，可以耗费最少的磁盘读写时间等。有兴趣的读者可以自行了解更详细的解决过程，本书
就不再赘述。
排序的比较和应用
排序算法的比较
本章前节介绍了种不同的内部排序方法，它们在时间复杂度、空间复杂度和稳定性上各
有优劣。不存在绝对意义上最佳的排序方法，种排序方法分别适用于不同的条件下。我们首
先从时间复杂度、空间复杂度和是否稳定上比较这几种排序方法。
基数排序是时间复杂度最低的排序方法，借助NRR为每个关键字不同取值的个数
的辅助空间和严格限制的元素数据类型，基数排序仅仅需要DNR的时间复杂度。基数
排序适用于处理数量大、关键字取值范围有限的序列，例如扑克牌排序等。同时，基数排序也是
稳定的排序方法。
除了基数排序以外的其余种排序方法都是建立在比较和交换操作上的，决定其性能的
第章 排 序
是比较、交换主要是比较的次数和是否需要额外空间用于保存临时值。显而易见的是，对
任意两个元素进行关键字的比较就可以确定两者的相对位置，而对一个序列的全部N个元素
进行两两比较则可以确认所有元素之间的相互位置关系，从而对所有的元素完成排序。这种
情况下，总的比较次数为NN因此，如果对全部元素进行两两比较的话，其时间效率
下限是N。
具有N时间复杂度的，是简单选择排序、直接插入排序和冒泡排序这种排序。
元素规模N较小或基本有序时，它们是较好的排序方法。同时，由于相邻的两个元素总是
进行比较，因此在比较两个关键字相等的元素时可以确定两者的相对位置，从而保证排序
后它们不会发生相对位置的变化，因此理论上，这些时间复杂度为N的排序都是稳
定的，然而简单选择排序在进行最小元素和第一个位置交换时，却改变了被交换元素和
其他元素的相对位置，因此简单选择排序是不稳定的，而直接插入排序和冒泡排序是稳
定的。
希尔排序是最早从N时间复杂度中提升的排序方法之一，它使用一个增量序列进行
多次的规模逐渐变大的排序。在规模较小的排序时使用直接插入排序将序列基本有序化，这
样一来，在规模较大的排序时就避免了过多的比较和交换，从而将时间复杂度减少到N
其中d的取值同增量序列和排序对象的具体情况有关，在最差的情况下接近即时间复杂度
接近直接插入排序。由于希尔排序无法保证总是将相邻的两个元素进行比较，可能出现一个
元素在排序过程中“跳跃”到和它等值且初始位置在前的另一个元素之前，因此，希尔排序是
不稳定的。
时间效率表现较好的是快速排序、堆排序和归并排序三种排序，它们都使用分而治之
的方法，将原序列分成两个部分，在排序过程中，这两个部分之间只进行复杂度为N的
划分或归并操作，其他的比较或交换操作集中在两个部分各自内部，因此大大减少了比较
或交换的次数。例如，堆排序在堆顶元素输出以后需要寻找下一个堆顶元素，在寻找的过
程中不断地将问题规模减小，直到跳出循环；快速排序在寻找基准后，序列划分为两个部
分，两个部分内部各自进行比较交换，两个部分之间并没有进行比较；同样的，归并排序始
终将规模减半再进行排序，在规模为N时再进行复杂度为N的归并操作。此三种排序
均实现了NlogN的时间复杂度。但具体到实际的平均时间效率上，快速排序无疑是最
佳的排序方法。
然而，在最坏情况下，快速排序的时间效率却不如堆排序和归并排序，可能导致N的最
差结果。此外，快速排序需要logN深度的栈空间，归并排序也需要N的额外空间，堆排
序在空间复杂度上表现出色，仅需要常数个额外空间。
在稳定性上，归并排序是稳定的，而堆排序和快速排序却是不稳定的。
因此，每一种排序都有其自身优点，适用于不同的情况。应该根据具体的条件，选择相应的
排序方法，甚至将种以上的排序方法结合使用。表给出了各种排序算法时空效率及稳定
性的比较。
排序的比较和应用
表 排序算法效率比较
排序方法 平均时间复杂度 最坏情况下时间复杂度 额外空间复杂度
N N
N N
N N
N N
MlogN NlogN
NlogN N logN
MlogN MlogN N
DNR DNR NR
稳定性
简单选择排序 不稳定
直接插入排序 稳定
冒泡排序 稳定
希尔排序 不稳定
堆排序 不稳定
快速排序 不稳定
归并排序 稳定
基数排序 稳定
排序算法应用案例
Google十大热门关键词的排序
在iGoogle里面，有一个叫“Google飙升热搜”的应用，提供Google热门关键词在一段时间
内的排行榜。由于是商业机构的应用，原算法我们不得而知，但是我们可以分析下该应用的
算法原理。
Google数据库中的关键词记录大概是天文数字数据库中大约存有亿网页对于这种
数量级的排序，首先应该想到的是分块处理。若要得到天内的关键字排行榜，我们只要得到每
个小时内的十大关键词排行榜；同理只要知道每分钟内的关键词排行榜，便可知道每个小
时内的排行榜。Google每分钟全球搜索次数大约在千万级，因此每分钟的关键词数量应该在十
万级左右，问题就转化为对这万个左右的关键词排序。
初次排序可以采用快速排序，以后每分钟对其进行更新即可。在更新的过程中，可以选择采
用冒泡排序，因为此时的数据已经相对有序，快速排序的性能会因此而急剧恶化。特别是我们只
需要知道前十名的关键词，进行十趟冒泡排序便可得到结果。同理可得周内、个月内的关键
词排序。
富豪排行榜
所谓富豪排行榜，即指对一个地区内的富豪财富总量进行排序，最后得到前若干名的榜单。
其本质与上文是一致的，都是海量数据排序，其核心思想依旧是分治。
现假设要得到年中国十大富豪排行榜。一种方法是采用分治，该问题可以转化为得到
各个省份的十大富豪排行榜，一直分割到某一地区的十大富豪排行榜，将一个海量数据的排序问
题分块为普通的排序问题，最后将每块的排序结果进行归并，并可得到最终的十大富豪排行榜。
当然，这里还可以做一些优化，比如可以对资产超过万的人进行排序， 万以下的人不
第章 排序
需要进行排序，这样便可剔除掉许多数据。
而在某一个小区域内统计公民财富前十名时，我们不需要对全体公民财富进行完全的排序。
注意到堆排序是可以得到部分有序序列的，我们只要把全体公民财富做成一个最大堆，经过
次删顶操作就可以得到前十名了。
本 章 小 结
排序是计算机常用的一种重要操作，本章介绍了几种基本的排序算法，让各位读者对排序有
基本了解。排序算法的效率与初始待排序列的特性有关，不存在绝对意义上最佳的排序方法。
随着计算机技术的迅猛发展，排序算法依旧在不断改进，比如冒泡排序在年就已被研
究，大部分人都认为这是一个已经解决的问题，然而很多有用的算法依旧不断地被提出，比如
年图书馆排序Library Sort又名Gapped Insertion Sort的发表。随着新的应用的不断涌现，
特别是当前互联网行业的快速发展，为排序算法的发展提供了十分有利的土壤。
总之，本章介绍的内容对各位读者来讲只是个开始，有兴趣的读者可以进一步的阅读相
关文献。
习 题
判断正误。
对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。
采用递归方式对顺序表进行快速排序，每次划分后，先处理较短的分区可以减少递归次数。
填空题。
对于个数的简单选择排序，最坏情况下需要交换元素的次数为。
在快速排序的一趟划分过程中，当遇到与基准主元相等的元素时，如果左右指针都会停止移动，那么当
所有元素都相等时，算法的时间复杂度是。
给定初始待排序列。如果希尔排序第一趟结束后得到序列为
则该趟增量为。
有组记录的排序码为则利用堆排序的方法建立的初始堆为
判断简单选择排序是否稳定，并举例说明。提出任何改进方案，使选择排序稳定；提出空间复杂度为
的改进方案，使选择排序稳定。
判断快速排序是否稳定，并举例说明。提出至少一种改进方案，使快速排序稳定。
给定数组请分别用简单选择排序、直接插入排序和
冒泡排序分别进行排序，写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是
否稳定。
给定数组请分别用堆排序、快速排序和归并排序分别
进行排序，写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是否稳定。
习题
给定数组请用种不同的增量序列分别进行希尔排序，
写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是否稳定。
对堆排序的改进：堆排序在元素出堆过程中，每选出一个堆顶元素，就要从堆底交换一个元素至堆顶
假设最小堆而实际上，排在堆底的往往是较大的元素，因此即使被交换到了堆顶，仍然要经过数次交换调整
至最小堆。提出一种改进方案，使得调整过程中内存写的次数尽量少。
请用非递归的方法实现归并排序。
堆排序、归并排序、快速排序在最坏情况下的时问复杂度是多少，请举例证明。
如何在n时间内，对到n个整数进行排序。
请实现基数排序的MSD算法，分析与ISD的优缺点。
除了基数排序外，在线性排序算法中，还有什么常用的算法，请举一两种算法，并分析其时间复杂度
和空间复杂度，最后和基数排序比较，分析优缺点和适用情况。
现想对新浪微博每天信息转发情况进行一个排序，得到被转发最多的前十条信息，而微博上每日信
息量在亿的数量级，属于海量数据问题，请给出一个解决方案。
某名企的面试题有一道是这样的：从个数字中找出最大的个数字，最快的算法是。
A归并排序 B快速排序 C堆排序 D选择排序
答案是C。但是这个答案真的对吗
第章
综合应用案例分析
本章将给出两个生活中的实际案例，提出层层加难的问题以及相应的解决方案，从而帮助读
者体会本书中介绍的数据结构与算法在解决实际问题中的应用。
银行排队问题
银行排队已经成为一个日益令人头痛的问题，甚至受到不少媒体的关注。图展示了
某银行营业大厅一角排队的人群。为了解决这个问题，不同银行采取了不同的解决方法。下
面就让我们利用学过的数据结构与算法，编程模拟这些解决方案，从而比较分析不同方法产
生的效果。
图 银行排队景象
对于下面将要讨论的各种排队策略，我们的输入都是顾客总人数N以及这N位顾客的到达
时间T和事务处理时间P并且假设输入数据已经按到达时间先后排好了顺序。另外我们还定
义每位顾客事务被处理的最长时间为MaxProc分钟，银行最多可开设MaxWindow个营业窗口。
要求输出所有顾客的平均等待时间。
单队列多窗口服务
策略描述假设银行有K个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄
银行排队问题
线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。图给出了这种排
队策略的示意。
银行窗口 银行窗口
…
顾客 顾客
银行窗口
顾客
黄 线
顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客
顾客
顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客
顾客
顾客 顾客 顾客 顾客 顾客 顾客
图 单队列多窗口服务
实现方法这种策略比较简单，我们只需要用一个队列模拟即可。队列的基本接口定义
与第章中的定义一致，代码列出了程序必需的部分类型定义和操作。
typedef struct People ElementType
struct Peoplel·顾客类型·
int T顾客到达时间
int P 顾客事务被处理的时间
I
typedef int Position
struet QNodel队列结点
ElementType Data顾客数组
Position FrontRear队列的头、尾指针
int MaxSize 队列最大容量
I
typedef struct QNodeQueue
以下函数的实现见代码
Queue CreateQueueint MaxSize
bool ISFuQueue Q
bool AddoQueue QElementType X
bool ISEmptyQueue Q
ElementType DeleteQQueue Q
代码 单队列多窗口服务模拟队列定义
第章 综合应用案例分析
代码给出了主函数。注意到核心处理函数为QueueingAtBank它接受传入的参数包括
顾客队列和人数，返回顾客平均等待时间。
int main
int N顾客总数
Queue Q顾客队列
int i
ElementType X
scanfdN读入顾客人数
QCreateQueueN建立空的顾客队列·
foriiNi顾客依次人列
scanfdtdXTXP
AddQQx
打印出N位顾客平均等待时间
printfAverage waiting timeIf minutesnQueueingAt BankQN
DestroyQueueQ
return
代码 单队列多窗口服务模拟主函数
核心函数QueueingAtBank 由代码给出，其处理过程非常直观，描述如下。
我们用一个数组Window记录当前每个营业窗口需要处理事务的时间长度，通过调用
函数FindNextWindow得到下一个空闲窗口的位置WinAvail 以及在相邻两次窗口空闲之间所等
待的时间WaitTime然后更新当前时间CurrentTime为上一次的当前时间累加上等待时间；
下一位顾客Next 出队列。这时有两种情况：
①顾客早已经到达银行，等在队列里。则该顾客的等待时间就是当前时间与其到达时间的
差，累加到等待总时间TotalTime上。
②窗口空闲，但是下一位顾客还没有到，则刷新所有窗口至下一位顾客到达时的状态，并更
新当前时间。
顾客Next到WinAvail 窗口接受服务。
以上步对每一位顾客重复，直到队列为空。最后用等待总时间TotalTime除以总人数N
银行排队问题
得到每位顾客的平均等待时间并返回。
double QueueingAtBankQueue Qint N
根据顾客队列Q和人数N返回顾客平均等待时间
struct People Next下一位顾客·
int K 营业窗口个数·
int TotalTime 全体顾客等待总时间
int CurrentTime 当前时间，开门营业时为
int windowMaxwindow营业窗口需要处理事务的时间长度人
int WaitTime 相邻两次窗口空闲之间所等待的时间
int winAvail 空闲窗口的位置
int ij
scanfdK读人营业窗口个数
ifNKreturn 如果窗口比人多，则无须等待
初始化
TotalTime
whileISEmptyQ当队列非空时，持续处理·
第步：处理掉当前最短的事务，得到下一个空闲窗口
第步：下一位顾客出列
NextDeleteQQ
ifCurrentTime NextT 如果顾客已经到达等待·
TotalTimeCurrentTimeNextT· 累计等待时间
else 如果顾客还没到
WaitTimeNextTCurrentTime 空闲窗口等待顾客的时间
WindowWaitTime
ifWindowjWindowj
foriiKi
winAvailFindNextWindowWindowKwaitTime
forjjKj 刷新所有窗口至顾客到达的状态
window
CurrentTimeWaitTime
第章 综合应用案例分析
currentTimeNextT 更新当前时间为顾客到达时间
第步：顾客Next到WinAvail窗口接受服务
windowWinAvailNextP
返回每位顾客的平均等待时间
returndoubleTotalTimedoubleN
代码 单队列多窗口服务模拟核心处理函数
函数FindNextWindow的作用，是把当前窗口事务中耗时最短的一个处理掉，得到这个空闲
窗口的位置WinAvail并且这个最短事务的耗时就是从上一次有空闲窗口到产生下一次空闲窗
口之间所等待的时间WaitTime。代码给出了这个函数。
int FindNextwindowint Wint Kint WaitTime
给定K个窗口W的状态，返回下一个空闲窗口的位置
以及在相邻两次窗口空闲之间所等待的时间WaitTime
int WinAvail下一个空闲窗口的位置·
int MinWMaxProc最短事务处理时间，初始化为超过最大值
int i
foriiKi扫描每个窗口，找到最短事务
ifWiMinW
MinWWiWinAvaili
WaitTimeMinW最短事务处理时间就是两次空窗间的等待时问
foriiKi刷新所有窗口的事务处理状态
WMinW
return WinAvail返回下一个空闲窗口的位置·
代码 单队列多窗口服务模拟FindNextWindow 函数
注意到我们可以用一个最小堆来更快速地找到最短事务，使得这个步骤的复杂度从OK
降到OlogK。但是另一方面，由于这个最短事务被处理掉以后，每个窗口的状态都需要随之更
新，所以时间复杂度无论如何都会是ΩK。从渐进意义上看，没有必要维护一个堆结构，用最
银行排队问题
简单的一维数组即可。但建议有兴趣的读者自己尝试用最小堆实现，并与代码的版本做比
较，看效率究竟相差多少
复杂度分析程序主要部分由代码给出，其中代码中主函数复杂度由建立
队列和核心处理两个函数决定。
代码中建立队列的过程包含了一个for 循环，将N个顾客人列，所以时间复杂度显然是
ON。
代码的初始化窗口部分用了OK之后的while循环对N个顾客进行了处理，每一次
处理需要调用代码中复杂度为θK的函数，并且有可能需要用θK时间处理顾客未到达
的情况，所以while循环的总体时间复杂度是θNK。
综上所述，程序的时间复杂度是NOKONKNK。
程序需要存储N个顾客和K个窗口的信息，所以空间复杂度是ONK。
测试数据测试数据至少应包含种类型：
窗口数比顾客数多，这时平均等待时间必定是
顾客人数多，且到达时间密集，每次空窗口都有顾客等待；
顾客人数多，但到达时间稀疏，出现有若干个空窗口但需要等待下一位顾客的
情况；
随机混合数据。
由于篇幅所限，在此仅列出少量测试数据以及答案如表所示供读者参考。输入数
据格式为：第行给出N后面N行给出N位顾客的到达时间T和事务处理时间P最后一行给
出该银行的营业窗口个数K。
表 单队列多窗口服务模拟部分测试数据
Average waiting time
minutes
Average waiting time
minutes
Average waiting time
minutes。
输人
输出 Average waiting time
minutes
第章 综合应用案例分析
单队列多窗口VIP服务
策略描述有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大
限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服
务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。
同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口。
实现方法我们仍然可以用一个队列模拟排队的情况。不同的是，这个问题中有一个隐
形的VIP子队列——每当VIP窗口空闲时，我们不是简单地令下一位顾客出列，而是必须查找
队列中排在最前面的VIP客户。如果我们只是简单地顺序检查队列中的顾客，那么最坏情况是
队列中根本没有VIP客户，而我们必须问过每一位才能确定没有，所以这种查找的方法需要的
时间复杂度是N。更糟糕的情况是，如果银行只开一个VIP窗口，那么这个窗口就要处理全
部N位顾客，总时间复杂度就会是N。
显然存在更好的解决方案。我们可以将标准的队列结构稍做修改，增加一个VIP子队列的
定义。这个子队列并不重复存储客户信息，只存储该客户在队列中的位置。当VIP窗口空闲
时，我们首先检查VIP子队列，如果非空，则令队首的VIP客户出列，同时将之从全体顾客队列
中删除；如果为空，则令下一位普通顾客出列。
理解了这个过程后，我们只需要对队列的结构和操作做内部修改，而无须改变对外接口。
代码给出了程序必须的部分类型定义和操作，这里只对增加的部分内容做了注释。注
意到顾客信息增加了一个VIP标志，为时表示是VIP客户，为时是普通顾客，为时标志该
顾客已经被删除。
typedef struct People ElementType
struct Peoplel
int T
int P
int VIP VIP标志：VIP普通；删除
I
typedef int Position
struct QNodel队列结点
ElementType Data顾客数组
Position FrontRear队列的头、尾指针·
int Maxsize 队列最大容量
下面是VIP子列的相应元素
Position VIPFrontVIPRear
int VIPCustomer
int VIPSize队列中VIP的数量·
银行排队问题
I
typedef struct QueueRecordQueue
bool VIPIsFullQueue Q 判断VIP队列是否为满
boo AddVIPQueue QPosition P对VIP客户的人列操作·
bool VIPISEmptyQueue Q 判断VIP队列是否为空
ElementType DeleteVIPQueue Q 对VIP客户的出列操作
Queue CreateQueueint MaxSize
bool AddoQueue QElementType X
bool IsFuQueue Q
bool ISEmptyoueue Q
ElementType DeleteQQueue Q
代码 单队列多窗口VIP服务模拟队列定义
在代码的基础上，顾客依次入列部分需要增加建立VIP子列的内容，即当读入
的顾客是VIP时输人在T和P的后面增加了一项VIP的值需要将此顾客在队列中的位
置Qrear存到VIP子列中。具体代码留给读者作为练习。
代码给出了新的QueueingAtBank 函数，并用粗体标出了与代码不同的部分。最主
要的区别是当VIP窗口空闲时，用IsVipHere 检查当前时刻有没有VIP在等待，如果有，则调用
DeleteVIP函数令VIP客户出列，否则做普通顾客处理。注意，当空闲窗口不是VIP窗口时，下一
位顾客无论是否VIP都当作普通顾客处理。
double QueueingAt BankQueue Qint N
根据顾客队列Q和人数N返回顾客平均等待时间
struct People Next
int K 营业窗口个数
int TotalTime 全体顾客等待总时间
int CurrentTime 当前时间，开门营业时为
int windowMaxWindow营业窗口需要处理事务的时间长度
int WaitTime 相邻两次窗口空闲之间所等待的时间
int WinAvail 空闲窗口的位置
int ii
int VIPWindowVIP窗口编号
scanf“d dKVIPWindow 读入营业窗口个数和VIP窗口编号
第章 综合应用案例分析
ifNKreturn ·如果窗口比人多，则无须等待
初始化
foriiKi
Window
TotalTime
whileISEmptyQ
第步：处理掉当前最短的事务，得到下一个空闲窗口
WinAvailFindNextwindowWindowKWaitTime
CurrentTimeWaitTime
第步：下一位顾客出列
ifWinAvailVIPWindowIsVipHereQcurrentTime
NextDeleteVIPQ 如果VIP窗口空且有VIP在队伍中等·
else
NextDeleteQQ
ifNextTEmptyQbreak 如果收到队列已空的信号，退出循环·
ifCurrentTimeNextT 如果顾客已经到达等待·
TotalTimeCurrentTimeNextT 累计等待时间·
else 如果顾客还没到
WaitTimeNextTCurrentTime空闲窗口等待顾客的时间
forjjKj刷新所有窗口至顾客到达的状态
WindowjWaitTime
ifWindowi Windowi
currentTimeNextT·更新当前时间为顾客到达时间·
第步：顾客 Next到WinAvail窗口接受服务
WindowWinAvailNextP
returndoubleTotalTimedoubleN
代码 单队列多窗口VIP服务模拟核心处理函数部分代码
银行排队问题
注意，如果我们用数组实现队列，则从普通顾客队列中真正删除VIP客户，将可能涉及大量
数组元素的位移，使得删除操作的时间复杂度从升到N同时VIP子列中其他元素的
位置值也需要调整，这是不可接受的。为了避免这种情况，我们可以改用链表实现队列，但是同
时又要面对指针操作的危险性和效率的降低。一般情况下，我们假设银行不会有太多的VIP客
户否则VIP就失去了意义这时可以采用懒惰删除Lazy Deletion即用一标记表示该顾客已
经被删除，而并不实际将该元素删去。
于是在令顾客出列时，我们必须检查标记，直到找到一位存在的顾客出列。而这时候有可能
出现全部队列中的顾客都已经被删除的情况，所以出列函数中还必须准备一个空队列信号用以
返回。在这里我们用到达时间T为负数来标志队列已经为空。
代码给出了DeleteVIP函数的懒惰删除实现方法；代码给出了相应的DeleteQ函数
的实现。
bool VIPIsEmptyQueue Q
returnQVIPSize
ElementType DeleteVIPQueue Q
令VIP子列队首的客户出列·
ElementType X
Position P
ifVIPISEmptyQ如果存在VIP客户
获得队首客户在顾客队列中的位置
PQVIPCustomerQVIPFront
将该位置从VIP子列中删除
QVIPFront
QVIPSize
QDataPVIP 懒惰删除顾客队列中的VIP
XTQDataPT
XPQDataPP
else 如果没有VIP客户，则做普通出列
XDeleteQQ
return X
代码 单队列多窗口VIP服务模拟 DeleteVIP函数
第章 综合应用案例分析
define EmptyQ队列空的信号·
ElementType DeleteQQueue Q
令Q队首的顾客出列·
ElementType X
将位于队列前端的被懒惰删除的顾客真正删除
whileQDataQFrontVIP
QFront
ifISEmptyQ·如果清除后发现队列已空，返回空信号·
xTEmptyQ
return X
ifQDataQFrontVIP
XDeleteVIPQ 令队首的VIP客户出列
elsel 普通顾客出列
XTQDataQFrontT
XPQDataQFrontP
·删除队首的顾客·
QFront
return X
代码 单队列多窗口VIP服务模拟 DeleteQ 函数
复杂度分析本节程序与节的程序的复杂度分析十分相似，当然前提是各个功能
函数均正确实现。
函数IsVipHere只需要常数时间即可判断当前时刻是否有VIP在等待。根据代码和
的实现方法，DeleteQ和DeleteVIP都可以在常数时间内完成。虽然在DeleteQ中出现了一个
while 循环，但这个循环在QueueingAtBank 中执行的总次数不超过VIP的个数，即N。所以
时间复杂度不变，仍然是NK。
程序需要的存储空间为VIP客户的子列增加了N个单元，从渐进意义上讲，空间复杂度
也不变，仍然是ONK。
测试数据测试数据至少应包含种类型：
重复上一节的测试，令全体顾客为普通顾客，结果应不变；
重复上一节的测试，令全体顾客为VIP结果应不变；
VIP窗口空闲时，有VIP顾客在普通顾客后面等待的情况；
VIP窗口空闲时，有普通顾客等待，但下一位VIP还未到达的情况；
畅通工程问题
最后一位顾客是VIP且在VIP窗口接受服务的情况——这时队列中会残留一个被懒
惰删除的元素；
随机混合数据。
由于篇幅所限，在此仅列出第类少量测试数据以及答案如表所示供读者参考。
输入数据格式为：第行给出N后面N行给出N位顾客的到达时间T、事务处理时间P以及是
否VIP的标志；最后一行给出该银行的营业窗口个数K、VIP窗口的编号。
表 单队列多窗口VIP服务模拟部分测试数据
Average waiting time
minutes
Average waiting time
minutes。
Average waiting time
minutes
输入
Average waiting time 输出 minutes。
畅通工程问题
某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工
程”的目标：使整个地区任何两个城镇间都可以实现快速交通但不一定有直接的快速道路相
连，只要互相间接通过快速路可达即可。由于实现畅通目标时要考虑的侧重点不同，使得相应
的解决方法也不相同。
解决各种问题的共同点是：我们总可以把各城镇看成图中的结点，连接两城镇的快速路看成
边，于是畅通工程问题就转化为各种版本的图论问题。
建设道路数量问题
问题描述现有城镇道路的统计数据表中列出了每条快速路直接连通的城镇，问最少还
需要建设多少条快速路就可以达到畅通目标
输入数据包括城镇数目N和快速路数目M随后的M行对应M条快速路，每行给出一对正
整数，分别是该条快速路直接连通的两个城镇的编号。为简单起见，城镇从到N编号。要求
第章 综合应用案例分析
输出需要建设的快速路的条数。
实现方法我们把已经连通的一片城镇区域看成图的一个连通集，这个问题就等价于问
目前给定的图中有多少个独立的连通集，而连通K个集合，最少需要K条边。
数图的连通集个数有多种方法。最直接的方法，是根据输人数据建立一个图的结构，然后用
深度优先搜索遍历整个图，从而得到连通集的个数。我们可以用邻接矩阵，也可以用邻接表来实
现图结构。代码给出了邻接表实现下连通集个数的计算函数。其中图的基本定义与第章
相同；函数InitializeVisited是将标志数组Visited初始化为DFS则是标准的深度优先搜索函数，
将访问过的结点的标志设为cnt是一个整型变量，作为连通集的计数器。而主函数需要输出
的快速路的条数是cnt。
int CountconnectedComponentsLGraph Graph
计算图Graph 中连通集的个数
VertexV
int cnt
将全局变量Visited初始化为 false
InitializeVisitedGraphNv
每一次DFS对应一个连通集
forVVGraphNvV
ifVisitedV
DFSGraphV
cnt
return cnt
代码 连通集个数计算函数
还有另外一种更简单的方法，即利用并查集，将有边相连的结点都并入同一集合，最后数一
下有多少个集合即可。代码给出了并查集的实现，其中并查集的标准函数Union和Find与
第章中定义相同。
typedef Vertex ElementType
void InitializationSetType sint N
集合初始化
int i
foriiNi
畅通工程问题
si
void InputConnectionSetType sint M
读入M条边，并将有边相连的结点并人同一集合·
Vertex UV记录输人的结点
Vertex RootRoot 记录输入结点所在的集合的根结点·
int i
foriiMi
scanfddUV
RootFindSU
RootFindSV
ifRootRoot
Unions Root Root
int CountconnectedComponentsSetType sintN
计算集合S中连通集的个数·
int icnt
foriiNi
ifsi
cnt
return cnt
int main
SetType S
int NM
scanfd dNM
InitializationsN
InputConnectionSM
第章 综合应用案例分析
printf需要建设道路d条nCountConnectedComponentsSN
return
代码 利用并查集统计连通集个数
复杂度分析无论是用图的邻接表深度优先搜索，还是用并查集，两种方法的时间复杂度
都是NM。
在图的邻接表实现中，我们需要NM的时间建立邻接表，再用NM的时间遍历图
中的每个结点和每条边。在并查集实现中，我们用N时间初始化集合，用M时间合并每
条边对应的一对结点，最后用N时间扫描每个结点以统计集合根结点的个数。所以总的时
间也是NM。虽然从渐进的意义上看，两种算法效率基本相同，但由于图的邻接表涉及大
量指针操作，且每条边需要存两遍，所以实际运行效果会比并查集实现慢很多。
在空间利用上，并查集也占有明显优势，因为我们只需要N的整型数组来存放集合，而
图的邻接表需要存储ONM个结点。
测试数据测试数据至少应包含以下种类型：
完全连通图，不需要新建道路；
完全没有边的图，需要N条道路；
随机产生的大数据量测试。
最低成本建设问题
问题描述】现有城镇道路的统计数据表中列出了有可能建设成快速路的若干条道路的成
本，求畅通工程需要的最低成本。
输入数据包括城镇数目N和候选道路数目M随后的M行对应M条道路，每行给出个正
整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城
镇从到N编号。要求输出畅通工程需要的最低成本。如果输入数据不足以保证畅通，则输出
“需要建设更多道路”。
实现方法我们把道路建设成本看成图中对应边的权重。要保证图中N个结点的连通，
我们至少需要构建N条边，使得结点连接成一棵树；而要求成本最低，就意味着N条边的
总权重最小。这个问题就等价于求给定带权图的最小生成树问题。
求最小生成树的算法伪码已经在第章给出，在此我们选择 Kruskal算法。代码给出
了核心Kruskal算法的实现。
int KruskalLGraph GraphLGraph MST
将最小生成树保存为邻接表存储的图MST返回最小权重和
WeightType TotalWeight
畅通工程问题
int ECount NextEdge
InitializeVSetVSetGraphNv初始化顶点并查集
MSTCreateCraphGraphNv
TotalWeight初始化权重和
ECount
NextEdgeGraphNe原始边集的规模
whileECountGraphNv 当收集的边不足以构成树时
NextEdgeGetEdgeESetNextEdge 从边集中得到最小边的位置
ifNextEdge 边集已空
break
如果该边的加入不构成回路，即两端结点不属于同一连通集·
ifCheckcycleVSetESetNextEdgeVESetNextEdgeVtrue
将该边插入MST
InsertEdgeMSTESetNextEdge
TotalweightESetNextEdgeWeight 累计权重
ECount 生成树中边数加·
ifECountGraphNv
TotalWeight设置错误标记，表示生成树不存在·
return Totalweight
SetType Vset顶点数组
ESetEdgemallocsizeofstruct ENodeGraphNe
初始化收录的边数
Edge ESet边数组·
InitfalizeESetGraphESet 初始化边的最小堆
·创建包含所有顶点但没有边的图。注意用邻接表版本·
代码 Kruskal算法函数
代码中，结点集合的初始化留给读者练习。我们知道Kruskal算法的关键在于两个函
数的实现，即GetEdge——用最快速度找出权重最小的边以及CheckCycle——判断该边的加入是
否会构成回路。
找出权重最小的边，可以通过先按边的权重排序，再顺序取出的方法，这种方法取出边比较
方便，只要的时间，但排序一般需要的时间复杂度是MlogM。如果图中边比较密集，例
第章 综合应用案例分析
如完全图中有MN则这一步就需要MNlogN。即使最后结果需要的N条边都排
在最前面，也不能降低时间复杂度，因为我们需要事先对M条边进行完全的排序。
另一种方法是维护一个关于边权重的最小堆。我们有M时间复杂度的算法建立这个最
小堆，每次从堆中取出最小元的方法与堆排序类似。这样做的好处是不需要对全部M条边进行
排序。在最好情况下，如果结果需要的N条边都排在最前面，我们只需要ONlogM的时间就
可以得到结果。在最坏情况下，这种方法与排序的方法持平。所以我们选择用最小堆实现Get Edge函数。代码给出了实现，其中PercDown函数与第章代码中给出的函数相似。
void PercDownEdge ESetint pint N
改编代码的PercDownMaxHeapHint p
将N个元素的边数组中以 ESetp为根的子堆调整为关于Weight的最小堆·
int ParentChild
struct ENode x
XESetp取出根结点存放的值·
forParentpParentN ParentChild
childParent
ifChild N
ESetchildWeightESetchildWeight
Child Child指向左右子结点的较小者
ifXWeightESetChildWeightbreak·找到了合适位置
else 下滤X·
ESetParentESetChild
ESetParentx
void InitializeESetLGraph GraphEdge ESet
将图的边存人数组 ESet并且初始化为最小堆·
VertexV
PtrTOAdjVNode W
int ECount
将图的边存入数组ESet
ECount
forVVGraphNvV
forWGraphGVFirstEdgeWWWNext
ifVWAdjV 避免重复录入无向图的边，只收VV的边
畅通工程问题
ESet ECountVV
八初始化为最小堆
forECount GraphNeECountECount
PercDownESet ECountGraphNe
int GeLEdgeEdge ESetint CurrentSize
给定当前堆的大小Currentsize将当前最小边位置弹出并调整堆
将最小边与当前堆的最后一个位置的边交换
SwapESetESetCurrentSize
将剩下的边继续调整成最小堆
PercDownESetCurrentsize
return Currentsize╱返回最小边所在位置
ESet ECountVWAdjV
ESetECountWeightWWeight
代码 快速得到最小边的函数
如第章中已经介绍过的，对每一条待收入的边，我们用并查集来判断该边的加入是否会构
成回路。代码给出了CheckCycle 函数的实现。
bool CheckCycleSetType VSetVertex VVertex V
检查连接V和V的边是否在现有的最小生成树子集中构成回路·
RootFindVSetV得到V所属的连通集名称
RootFindVSetV得到V所属的连通集名称
ifRootlRoot若V和V 已经连通，则该边不能要
return false
elsel否则该边可以被收集，同时将V和V并入同一连通集·
UnionVSetRootRoot
return true
Vertex RootRoot
代码 检查回路的函数
第章 综合应用案例分析
复杂度分析程序的总体复杂度是由代码给出的核心函数Kruskal决定的。
首先我们需要NM的时间初始化结点和边的集合。收集边的while循环最坏情况下需
要遍历全部M条边。在循环内部，取得最小边的GetEdge 函数的时间复杂度为logM而检
查回路的函数CheckCycle的时间复杂度不会超过logN。于是总体时间复杂度在最坏情况下
是NMMlogMlogNMlogN。如果图中边比较稀疏，即MN或者while循环
只用N次即可完成最小生成树的构造，则算法复杂度可降低为MlogN。所以说Kruskal
算法在边比较稀疏的情况下有比较好的效率。
由于结点集合、边的集合均用一维数组实现，所以空间复杂度是NM。
测试数据测试数据至少应包含以下种类型：
给出的边数不足N需要建设更多道路；
给出的边数不少于N但图不连通，需要建设更多道路；
随机产生的大数据量测试。
由于篇幅所限，在此仅列出少量测试数据以及答案如表所示供读者参考。输入数
据格式为：第行给出城镇数目N和候选道路数目M随后的M行对应M条道路，每行给出个
正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。
表 最低成本建设畅通工程问题部分测试数据
Must construct more roads Must construct more roads
输入
输出 Minimum Cost
习题
本 章 小 结
本章通过对银行排队问题的不同解决方案的模拟，展示了队列的灵活应用方法；通过对城镇
畅通工程的不同要求进行分析和解决，展示了图论在实际生活中的应用。
希望读者能通过本书的学习提高实践能力，使数据结构与算法成为用计算机解决实际问题
的有效工具。
习题
试修改节中单队列多窗口服务的模拟程序，使得不仅能计算顾客平均等待时间，还能输出最长
等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。
试在代码的基础上，使得在建立顾客队列的同时，建立VIP子列。
试实现节中的IsVipHere 函数，检查当前时刻即CurrentTime在队列Q中有没有VIP在等待。
如果有，则返回否则返回。
· 银行排队的另一种解决方案是“多队列多窗口服务”即在黄线到每个窗口之间允许排M位顾客，形
成K条队列。如果K个窗口前的队列全排满了，其他顾客只好在黄线后的多队列入口处排成一列。在多队列人
口处的顾客总会选择K条队列中最短的一条加入。试编写程序模拟这种策略，并计算顾客的平均等待时间。
排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行排队的问题中，如果已知第
i位顾客与排在后面的第j位顾客是好朋友，并且愿意替朋友办理事务的话，那么第位顾客的事务处理时间就
是自己的事务加朋友的事务所耗时间的总和。在这种情况下，后面顾客的等待时间就可能被影响。试编写程序
模拟这种现象，并计算顾客的平均等待时间。
试实现节中初始化函数InitializeVSet初始化结点并查集 VSet即将N个结点看成N个只有单
独元素的独立的集合。
试给出解决节问题的完整代码，使能至少通过表中的测试。
· 畅通工程问题的另一个版本是，在得到现有每条快速路直接连通的城镇，并测算出其他有可能建设成
快速路的若干条道路的成本后，求畅通工程需要的最低成本。试编写程序解决这个问题。
附录
PTA 使用说明
本书正文中部分以及习题中的程序设计题目可以在PATProgramming Ability Test计算机
程序设计能力考试的配套练习平台PTAProgramming Teaching Assistant上进行练习。
PAT与PTA
什么是PAT
PAT旨在通过统一组织的在线考试及自动评测方法客观地评判考生的算法设计与程序设
计实现能力，科学地评价计算机程序设计人才，为企业选拔人才提供参考标准。目前PAT已成
为IT界的标准化能力测试，得到包括Google、Microsoft、雅虎、网易、百度、腾讯等在内的百余家大
中小型各级企业的认可和支持，他们纷纷开辟了求职绿色通道，主动为PAT成绩符合其要求的
考生安排面试，免除计算机程序设计方面的笔试环节。同时，PAT甲级一年内的成绩可作为浙
江大学计算机学院硕士研究生招生考试上机复试成绩。
PAT在每年的春季、月间、秋季、月间和冬季、月间组织场统一考试。考试
为小时、闭卷、上机编程测试，总分为分。考试分为个不同的难度级别：顶级Top Level、
甲级Advanced Level、乙级Basic Level。顶级考试题，题目描述语言为英文；甲级考试题，题
目描述语言为英文；乙级考试题，题目描述语言为中文。要求考生按照严格的输入输出要求提交
程序，程序须经过若干测试用例的测试，每个测试用例分配一定得数。每题的得分为通过的测试用
例得分之和，整场考试得分为各题得分之和，提交错误不扣分。
PAT不设合格标准，凡参加考试且获得非零分者皆有成绩，可获得统一颁发的证书。证书
中包含“考试分数满分”和“排名考生总数”两个指标。PAT提供官方证书查验功能，在官网相
应位置输人证书编号即可查验真伪。
PAT官网网址：httpwwwpatestcn。
什么是PTA
PTA是PAT的配套练习平台，支持更丰富的题目类型，其编程类题目具有与PAT相同的判
题系统环境，配有方便的辅助教学工具，并由全国高校程序设计与算法类课程群的教师们共同建
设内容丰富的题库。本书的题目集就部署在PTA上见附录图读者进入题目集后，单击右
侧我是读者并输入验证码，即可进行练习见附录图。
PTA官网网址：httpptapatestcn。
PTA 工作机制
PTA系统中，提交的程序代码由服务器自动判断正确与否，判断的方法如下。
附录 PTA使用说明
程序设计类实验辅助教学平台
首页 题目集列表
题目集 新建肥日来
题库
标题 开放状态
用户组 浙大版露结构第版》题目集 一直可用
中国大学MC、问钦铬数据结构起步能力自测
理 一直可用
浙大蚯C语言程序进计第》题目果 一直可用
渐大版《O语言程序设计实益与习题指导第版》
超目架 一直可用
附录图 从PTA首页进入系统后，可查看“浙大版《数据结构第版》题目集”
姓日仅供看，话举山我是读长班，输入该若验证码，即可答躁。
函数题 摇程题 紫是读
编号 标题 知识点 分 通 提
数 过 交 通过率
习题 谨墙的数序临的插入
习题 两个有序稀表序列的井
链表·绩性结构·数据
娅表一统性绪构→数惩
附录图 读者单击右侧“我是读者”并输人验证码，即可进行练习
服务器收到提交的源代码后，将源代码保存、编译、运行。
运行的时候会先判断程序的返回是否为如果不是表明程序内部出错了。
运行的时候用预先设计的数据作为程序的输入，然后将程序的输出与预先设定的输出
做逐个字符的比较。
如果每个字符都相同，表示程序正确，否则表示程序错误。
每一题的测试数据会有多组，每通过一组将获得相应得分。
PTA的服务器采用位的Linux操作系统，C语言编译器采用gce版本是。gec 使用
的编译参数中含有：fnotreechWallstdc。
如果没有特别说明，程序应该从标准输入stdin传统意义上的“键盘”读入，并输出到标准
附录 PTA使用说明
输出stdout传统意义上的“屏幕”。也就是说，用scanf做输入，用printf做输出就可以了；不要
使用文件做输入输出。
在服务器上的测试数据有多组，但提交的程序只要处理一组输入数据的情况，不需要考虑多
组数据循环读入的问题。
PTA可能的反馈信息
程序在每一次提交后，都会即时得到由PTA的评分系统给出的得分以及反馈信息，可能的
反馈信息见附录表。
附录表 PTA可能的反馈信息
结 果 说 明
提交成功 对于判断、选择、填空题，系统已经接收到您的提交
稍后显示 对于判断、选择、填空题，在题目集关闭之前，不显示判题结果
对于判断、选择、填空题，该提交已经被您的当前提交所覆盖，系统将只评判题目集
关闭前对该题目的最后一次提交
评测系统还没有评测到这个提交，请稍候
评测系统正在评测，稍候会有结果
您提交的代码无法完成编译，单击“编译错误”可以看到编译器输出的错误信息
恭喜您通过了这道题
您的代码只通过了部分测试点，继续努力
您的程序输出的格式不符合要求比如空格和换行与要求不一致
您的程序未能对评测系统的数据返回正确的结果
您的程序未能在规定时间内运行结束
您的程序使用了超过限制的内存
您的程序运行时发生了错误
您的程序结束时返回值非如果使用C或C语言要保证int main函数最终return
您的程序发生段错误，可能是数组越界、堆栈溢出比如，递归调用层数太多等情
况引起
您的程序运行时发生浮点错误，比如遇到了除以的情况
您的程序输出了过多内容，一般可能是无限循环输出导致的结果
评测系统发生内部错误，无法评测。工作人员会努力排查此种错误
已被覆盖
等待评测
正在评测
编译错误
答案正确
部分正确
格式错误
答案错误
运行超时
内存超限
异常退出
非零返回
段错误
浮点错误
输出超限
内部错误
附录 PTA使用说明
程序常见问题
main的问题
错误的例子：
void main
printfhellon
函数main的返回类型必须是int在main里一定要有语句
return
用来返回。
很多教材基于Windows的C编译器，还在使用语句void main这是无法接受的。main
的返回值是有意义的，如果返回的不是就表示程序运行过程中错误了，那么服务器上的判题
程序也会给出错误的结论。
另外，某些IDE需要在main的最后加上一句：
systempause
或
getch
来形成暂停。在上传程序时一定要把这个语句删除，不然会产生超时错误。
多余的输出问题
错误的例子：
int main
int ab
printf请输入两个整数：
scanfd ab …
printf名d的最大公约数是dnabc
return
程序的输出不要添加任何提示性信息，必须严格采用题目规定的输出格式。
读者可以运行自己的程序，采用题目提供的输入样例，如果得到的输出和输出样例完全相
同，一个字符也不多，一个字符也不少，那么这样的格式就是对的。
附录 PTA使用说明
汉字问题
程序中不要出现任何汉字，即使在注释中也不能出现。服务器上使用的文字编码未必和读
者的计算机相同，读者认为无害的汉字会被编译器认为是奇怪的东西。
输出格式问题
仔细阅读题目中对于输出格式的要求。因为服务器是严格地按照预设的输出格式来比对程
序输出的。需要注意的输出格式问题包括：
●行末要求不带空格或带空格
●输出要求分行或不分行
● 有空格没空格要看仔细
●输出中的标点符号要看清楚，尤其是绝对不能用中文全角的标点符号，另外单引号
和一撇要分清楚
● 当输出浮点数时，因为浮点数会涉及输出的精度问题，题目中通常会对输出格式做明确
要求。一定要严格遵守
· 当输出浮点数时，有可能出现输出的情况，需要在程序中编写代码判断，保证不出
现
不能用的库函数
某些库函数因为存在安全隐患是不能用的，目前主要指库函数 itoa和gets。
过时的写法问题
某些教材上提供的过时写法也会在编译时产生错误，例如：
int f
int a