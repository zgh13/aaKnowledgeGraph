目 录
第1章 概论……………………………1 3.2.1 线性表的定义 ………………55
1.1 引子…………………………1 3.2.2 线性表的顺序存储实现……56
1.2 数据结构………………………7 3.2.3 线性表的链式存储实现……60
1.2.1 定义 …………………………7 3.2.4 广义表与多重链表…………66
3.3 堆栈…………………………70
3.3.1 堆栈的定义 …………………70
3.3.2 堆栈的实现 …………………73
3.3.3 堆栈应用：表达式求值 ……78
3.4 队列…………………………、83
3.4.1 队列的定义 …………………83
3.4.2 队列的实现…………………83
3.5 应用实例………………………88
3.5.1 多项式加法运算……………88
3.5.2 迷宫问题……………………90
本章小结……………………………95
习题…………………………………96
第4章 树……………………………98
4.1 引子…………………………98
4.1.1 问题的提出 …………………98
4.1.2 查找………………………99
4.2 树的定义、表示和术语 ………103
4.3 二叉树………………………106
4.3.1 二叉树的定义及其逻辑
表示 ………………………106
4.3.2 二叉树的性质………………106
4.3.3 二叉树的存储结构…………107
4.3.4 二叉树的操作………………110
4.4 二叉搜索树……………………125
4.4.1 二叉搜索树的定义 …………125
1.2.2 抽象数据类型 …………………8
1.3 算法………………………9
1.3.1 定义 ………………………9
1.3.2 算法复杂度 …………………10
1.3.3 渐进表示法 …………………12
1.4 应用实例：最大子列和问题……15
本章小结…………………………21
习题…………………………………21
第2章 数据结构实现基础……………23
2.1 引子…………………………23
2.2 数据存储基础 …………………26
2.2.1 数组…………………………26
2.2.2 类型定义 typedef ……………28
2.2.3 指针………………………28
2.2.4 结构………………………30
2.2.5 链表………………………32
2.3 流程控制基础…………………37
2.3.1 分支控制……………………37
2.3.2 循环控制 ……………………39
2.3.3 函数与递归 …………………42
本章小结…………………………50
习题………………………50
第3章 线性结构………………………52
3.1 引子…………………………52
3.2 线性表的定义与实现…………55
Ⅱ 目录
4.4.2 二叉搜索树的动态查找…126 6.4 图的遍历……………………215
4.4.3 二叉搜索树的插人 …………128 6.4.1 迷宫探索………………215
4.4.4 二叉搜索树的删除 ………130 6.4.2 深度优先搜索……………218
4.5 平衡二叉树…………………133 6.4.3 广度优先搜索……………220
4.5.1 平衡二叉树的定义 ………134 6.5 最小生成树…………………223
4.5.2 平衡二叉树的调整 ………134 6.5.1 生成树的构建与最小
4.6 树的应用…………………141 生成树的概念……………223
4.6.1 堆及其操作………………141 6.5.2 构造最小生成树的Prim
4.6.2 哈夫曼树………………151 算法 ………………………225
4.6.3 集合及其运算………………159 6.5.3 构造最小生成树的Kruskal
本章小结…………………………163 算法……………………232
习题………………………………164 6.6 最短路径…………………235
第5章 散列查找 ………………………166, 6.6.1 单源最短路径………………236
5.1 引子………………………166 6.6.2 每一对顶点之间的最短
5.2 基本概念…………………169 路径……………………241
5.3 散列函数的构造方法………172 6.7 拓扑排序………………………244
5.3.1 数字关键词的散列 6.8 关键路径计算………………249
函数构造…………172 6.9 应用实例……………………252
5.3.2 字符串关键词的散列 6.9.1 六度空间理论……………252
函数构造………………175 6.9.2 六度分隔理论的验证 ……253
5.4 处理冲突的方法……………176 本章小结…………………………257
5.4.1 开放定址法…………………176 习题………………………………258
第7章 排序…………………………263
7.1 引子………………………263
7.2 选择排序……………………264
7.2.1 简单选择排序……………264
7.2.2 堆排序…………………265
7.3 插入排序…………………268
7.3.1 简单插入排序……………268
7.3.2 希尔排序………………269
7.4 交换排序…………………271
7.4.1 冒泡排序……………………271
7.4.2 快速排序……………………272
7.5 归并排序……………………276
7.6 基数排序…………………279
5.4.2 分离链接法………………183
5.5 散列表的性能分析…………188
5.6 应用实例…………………189
本章小结……………………………195
习题………………………………196
第6章 图…………………………198
6.1 引子……………………198
6.2 图的基本概念………………199
6.2.1 图的定义和术语……………199
6.2.2 图的抽象数据类型 ………205
6.3 图的存储结构………………205
6.3.1 邻接矩阵………………206
6.3.2 邻接表……………………210
习题…………………………………288
第8章 综合应用案例分析……………290
目 录 Ⅲ
7.6.1 桶排序…………………279 8.1 银行排队问题………………290
7.6.2 基数排序………………279 8.1.1 单队列多窗口服务………290
7.6.3 单关键字的基数分解 ……280 8.1.2 单队列多窗口+VIP服务…296
7.7 外部排序…………………284 8.2 畅通工程问题………………301
7.8 排序的比较和应用…………285 8.2.1 建设道路数量问题 ………301
7.8.1 排序算法的比较……………285 8.2.2 最低成本建设问题 ………304
7.8.2 排序算法应用案例…………287 本章小结……………………………309
本章小结…………………………288 习题………………………………309
附录 PTA 使用说明……………………310
参考文献………………………………315
第1章
概 论
1.1 引子
什么是数据结构?事实上，这个问题在计算机科学界至今没有标准的定义。
如果你的好奇心充分强，不妨打开各种版本的有关"数据结构“的教材首页，看到的会是五
花八门的描述。而在你深入阅读本书之前，大多数的描述对你而言可能太过晦涩——例如 Sartaj
Sahni在他的《数据结构、算法与应用》一书中称：“数据结构是数据对象，以及存在于该对象的实
例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。”Clif ford A.Shaffer在《数据结构与算法分析》一书中的定义是：“数据结构是ADT(抽象数据类型，Ab stract Data Type)的物理实现。”互联网上的中文维基百科写道：“数据结构(Data Structure)是计
算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。”
作为初学者，让我们暂且把那些由专业术语组成的各种定义抛开，先尝试解决下面几个简单
的问题。在解决问题的过程中，或许可以得到对于数据结构的理解。
[例1.1]书店往往是书的海洋，图1.1显示了著名的圣保罗Livraria da Vila书店一角。如
果你是书店的主人，该如何摆放你的书，才能让读者很方便地找到你手里这本《数据结构》?
[分析]解决的办法有很多，下面只列举3种最简单的。
方法1:随便放。
这种方法使得放书非常方便，任何时候有新书进来，哪里有空就把书插到哪里。但是这种方
法显然使得查找非常痛苦。最不走运的时候，是你的书架上根本没有这本书，但是你需要翻遍整
个书架的每一本书，才能确定地说真的找不到。
方法2:按照书名的拼音字母顺序排放。
这种方法使得查找方便了一些。我们可以随便抽取一本书，检查书名的拼音首字母。例如
书名是L开头的《离散数学》,我们就知道以S开头的《数据结构》一定排在L的后面；再从它后
面随便抽取一本书，例如是W开头的《网络技术基础》,那么《数据结构》一定排在W的前面，我
们的查找范围就迅速缩小到L和W之间的区域内。
但是这种方法会使得新书的插入成为一种痛苦。如果买的新书是Z开头的《“做中学”程序
员攻略》还好，如果新买的一本是A开头的《阿Q正传》就惨了，为了给新书腾出空间，要把多少
本书向后挪动啊!
2 第1章 概论
开，0,+树润
一
二三
面即
南
T.-
F都1
i鸭ITt W1
rn
图1.1 圣保罗的Livraria da Vila书店一角
方法3:把书架划分成几块区域，每块区域指定摆放某种类别的图书；在每种类别内，按照书
名的拼音字母顺序排放。
这种方法与方法2相比，无论是查找还是插入，工作量都减少很多，因为类别一旦确定，要处
理的书架范围就大大缩小了。但是仍然存在问题——因为我们不可能事先知道每种类别的图书
会有多少本，所以划分区域的时候最好给每种类别预留足够的新书空间，这可能造成空间上的
浪费。
另一方面，类别分得越细，属于同一类的书就越少，在某一类内部查找或插入的工作量就越
小。但是如果类别太多，要找到某一类所在的区域又会成为一件麻烦事……你还有更好的解决
方案吗?
[例1.2]写程序实现一个函数PrintN,使得传入一个正整数为N的参数后，能顺序打印从1
到N的全部正整数。
[分析]只要略有编程基础的人都可以很容易实现这个函数。代码1.1给出了一个用C语
言循环语句实现的版本。
void PrintN(int N)
/*打印从1到N的全部正整数·/
int i;
for(1-1;i<-N;i++)
printf("d\n",1):
return;
代码1.1 用C酒言循环语句实现的 PrinIN 函数
1.1 引子 3
另一个用C语言递归语句实现的版本看上去更简洁，甚至不需要临时变量的帮助，如代码
1.2所示。
void PrintN(int N)
I/*打印从1到N的全部正整数*
if(N>0)
PrintN(N-1);
printf(*d\n",N);
代码1.2 用C语言递归语句实现的PrintN函数
问题看上去很简单，上述两种方法似乎都可以完成任务。然而，事实真的如此吗?我们可以
运行代码1.3,来比较一下两种实现方法。
#include <stdio.h>
void PrintN(intN);
int main()
/*读入整数N,并调用PrintN函数*/
int N;
scanf("od",&N);
PrintN(N);
return 0;
代码1.3 函数PrintN的测试程序
把代码1.1和代码1.2分别(不是同时)贴到代码1.3的尾部，分别编译运行。测试输入N
为100、1000、10000、100000的情况——如果还不能发现问题那么继续测试更大的N……终于，
我们将发现，对于充分大的N,代码1.2中的递归函数拒绝工作了!而此时代码1.1仍然正常
运行。
为什么会这样?请读者思考其中的原因。
[例1.3]一元多项式的标准表达式可以写为：f(x)=ao+a,x+…+a-x?1+ax"。现给定一
个多项式的阶数n,并将全体系数{aI。存放在数组a[]里。请写程序计算这个多项式在给定
点x处的值。
4 第1章 概 论
f(x)=ax [分析]最直接的办法是根据多项式的标准表达式 通过循环累计求和来实
现这个函数。代码1.4给出了这个直接实现的版本。
double f(int n,double a[],double x)
/* 计算阶数为n,系数为a[0]...a[n]的多项式在x点的值/
int i;
double p=a[0];
for(i=1;i<=n;i++)
p+=a[i]·pow(x,i);
return p;
代码1.4 计算多项式函数值的直接法
然而早在800年前，中国南宋的数学家秦九韶就提出了一种更快的算法，他通过不断提取公
因式x来减少乘法的运算次数，把多项式改写为：
f(x)=a。+x(a?+x(…(a-1+x(a))…)) (公式1.1)
代码1.5给出了按照公式1.1编程的多项式求值算法。
double f(int n,double a[],double x)
1/计算阶数为n,系数为a[0],…,a[n]的多项式在x点的值/
int i;
double p=a[n]:
return D;
for(i=n;i>0;i--)
p=a[1-1]+x*P:
代码1.5 计算多项式函数值的秦九韶法
看上去代码1.4、代码1.5两个版本的程序一样简单，都只要5行语句
就可以了。问题是，秦九韶算法究竟比简单的直接算法快了多少?要回答
这个问题，我们需要先学习clock()工具的使用。
微视频1-1
clock()工具
的使用
要获得一个程序的运行时间，常用的方法是调用头文件 time.h.其中提
供了clock()函数，可以捕捉从程序开始运行到clock()被调用时所耗费的
时间。这个时间单位是cloek tick,即“时钟打点”,在C/C++中定义的数据
类型是olock_。同时还有一个常数CLK_TCK(或是CLOCKS_PER_SEC).
给出了机器时钟每秒所走的时钟打点数。代码10给出丁一个常用范侧。
1.1 引子 5
#incIudecstd1o.h
clock_t atart,atop;/+ clock_e是cloek()函数返回的变量类型
int main()
1/·不在测试范围内的准备工作写在clock()调用之前+/
start=clock();/开始计时*/
MyFunction():/* 把被测函数加在这里，使用时这个函数必须被替换*/
duration=((double)(stop-start))/CLK_TCK:/*计算运行时间*/
/+其他不在测试范围的处理写在后面，例如输出duration的值·/
Hinclude ctIme.
doublo duration:/*记录被测函数运行时间，以秒为单位*/
stop=clock();/* 停止计时*/
/s注意CLK_TCK是机器时钟每秒所走的时钟打点数，/
return 0;
/*在某些IDE下也可能叫CLOCKS_PER_SEC。*/
代码1.6 测试函数 function()的运行时间
下面我们可以通过一个具体多项式函数值的计算，来比较秦九韶算法与直接法的效率差别：
令f(x)=∑i·x,计算f(1.1)的值。代码1.7给出了测试函数。
#include <stdio.h>
#include <time.h>
#include <math.h>
clock_t start,stop;
double duration;
#define MAXN 10 /*多项式最大项数，即多项式阶数+1*/
#define MAXK 1e7/*被测函数最大重复调用次数*/
double f1(int n,double a[],double x)
I/* 代码1.4的算法*/
int i;
double p=a[0];
for(i=1;i<=n;i++)
6 第1章 概论
p+=(a[i]*pow(x,i));
return p;
double f2(int n,double a[],double x)
1/ 代码1.5的算法·/
int i;
double p=a[n];
for(i=n;i>0;4--)
p=a[i-1]+x*p;
return p;
void run(double(*f)(int,double*,double),double a[],int case_n)
|/*此函数用于测试被测函数(*f)的运行时间，并且根据case_n输出相应的结果
/*case_n是输出的函数编号：1代表函数f1;2代表函数f2
int i;
start=clock();
for(i=0;i<MAXK;i++)/*重复调用函数以获得充分多的时钟打点数·/
(*f)(MAXN-1,a.1.1);
stop=clock():
duration=((double)(stop-start))/CLK_TCK;
printf("tickstd=8fn",case_n,(double)(stop-atart));
printr("durationtd=86.2en",case_n,duration);
int main()
inti:
double a[MAXN]:+存储多项式的系·
人为木题的多项式系数赋值，即a[1]=1*
for(i=0;1<MAXN: 1++)a[1]=(double)1:
run(I1.a,1):
1.Z 数 据结 构 7
run([2. a.Z):
retun0
代码1.7 测试多项式求值函数的运行时间
因为我们要比较两种算法的效率，又不想把相似的测试代码重复写两遍，所以把测试函数运
行时间的代码写成了一个函数 run,将被测函数(*f)作为参数(函数指针类型)传入，测试其运
行时间，并且根据case_n输出相应的结果。
注意到被测函数运行一次所花费的时间有可能小于两次时钟打点的间隔，这时我们就有可
能得到stop-start=0的情况，从而测不出真正的运行时间。
解决这个问题的方法是，让被测函数重复运行充分多次，使得测出的总的时钟打点间隔充分
长，最后计算被测函数平均每次运行的时间即可。在代码1.7中，我们令函数运行10'次，读者
可以根据自己机器配置选择其他的MAXK值。
注意到测试结果取决于机器的配置，在不同的机器上运行，得到的具体数据是不一样的。但
可以肯定的是，秦九韶算法的计算速度明显比直接法快了一个数量级。
为什么会这样?请读者思考其原因。
通过对上面3个例子的研究，我们可以发现，即使解决一个非常简单的问题，往往也有多种
方法，且不同方法之间的效率可能相差甚远。解决问题方法的效率，跟数据的组织方式有关(如
例1.1),跟空间的利用效率有关(如例1.2),也跟算法的巧妙程度有关(如例1.3)。
本章将要向大家介绍的，就是有关数据组织、算法设计、时间和空间效率的概念和通用分析
方法，是后续所有数据结构及其相关算法的基础。
1.2 数据结构
1.2.1 定义
从例1.1中我们发现用不同方法摆放图书，会直接影响查找、插入等工作的效率。在计算机
的世界里，“图书”就是待处理的“数据对象”,“查找”、“插入”等工作就是对数据进行的“操作”,
完成这些操作所用的方法就是“算法”。
“数据结构”的定义，首先应该包含数据对象在计算机中的组织方式——这类似于图书的摆
放方法。另一方面，数据对象必定与一系列加在数据对象上的操作相关联，就如我们在书架上摆
放图书是为了能找到想要的书，或者是插入一本新买的书。我们讨论数据对象的各种不同的组
织方式，是为了得到处理这些数据对象的最高效的算法。所以我们在讨论“数据结构”这个概念
的时候，关心的不仅仅是数据对象本身以及它们在计算机中的组织方式，还要关心与它们相关联
8 第1章 概 论
的一个操作集，以及实现这些操作的最高效的算法。
关于数据对象在计算机中的组织方式，其实还包含了两个概念：一是数据对象集的逻辑结
构；二是数据对象集在计算机中的物理存储结构。
例如我们把一本书看成一个数据对象，如果所有的书是一本挨一本排成一大排的，从最左边
第1本书开始向右顺序编号，每本书的位置可以由它的编号唯一确定，那么这个数据对象集的逻
辑结构就被称为是“线性(Linear)”的，因为数据对象都串在一条线上，并且编号跟书是“1对1”
的关系。当我们把这些书的信息存进计算机时，可以设计一个结构体来记录一本书，而书的集合
可以用结构体的数组来存储，也可以用结构体的链表来存储。数组或者链表就是数据对象集在
计算机中的物理存储结构。
在后面的章节中，大家还会见识到更多样的数据对象逻辑结构。例如在例1.1的解决方法
3中，把图书先按类别编号，在同一类中再按字母序编号，那么一个类别编号就对应多本图书，类
别编号跟书是“一对多”的关系。这种数据对象集的逻辑结构就是“树(Tree)”状的，将在第4章
中讨论。如果还需要统计买书人的兴趣关系，即买了某本图书的人同时还买了哪些其他的书，那
么这些图书之间就构成了一个“多对多”的关系网，这种逻辑结构被称为“图(Graph)”,是第6章
中将要介绍的内容。而如何在计算机中有效地存放“树”和“图”这样的结构，则是这两章要讨论
的另一个有趣的话题。
1.2.2 抽象数据类型
顾名思义，抽象数据类型(Abstract Data Type)是一种对“数据类型”的描述，这种描述是“抽
象"的。
首先，“数据类型”描述两方面的内容：一是数据对象集；二是与数据集合相关联的操作集。
“抽象”的意思是指，我们描述数据类型的方法是不依赖于具体实现的，即数据对象集和操作集的
描述与存放数据的机器无关、与数据存储的物理结构无关、与实现操作的算法和编程语言均无关。简
而言之，抽象数据类型只描述数据对象集和相关操作集“是什么”,并不涉及“如何做到”的问题。
[例1.4]“矩阵”的抽象数据类型定义
类型名称；矩阵(Matrix)
数据对象集：一个m xn的矩阵Amn=(a)(i=1,…,m;j=1,…,n)由m xn个三元组<a,1.J>
构成，其中a是矩阵元素的值，是元素所在的行号，j是元素所在的列号。
操作集：对于任意矩阵A、B、CeMatrix,以及整数jM、N,仅列出几项有代表性的操作。更
多关于矩阵的操作不是我们讨论的重点，故在此略去。
1.Matrix Create(int M,int N):返回一个MxN的空矩阵；
2.int GetMaxRow(Matrix A):返回短阵A的总行数；
3.intCetMaxCol(Matrix A):返回矩阵A的总列数：
4.ElementType CetEntry(Matrix A.int i.int j):返回短阵A的第1行、第1列的元素；
5.Matrix Add(Matrix A.Matrix B):如果A和B的行、列数一致，则返回矩阵G-A+D,否则
1.3 算法 9
返回错误标志!
6.Matrix Multiply(Matrix A,Matrix B):如果A的列数等于B的行数，则返回矩阵C=AB,否
则返回错误标志；
7.……
通过例1.4,我们可以这样理解“抽象”的含义：
(1)当我们在数据对象集中描述矩阵元素的时候，刻画了它的取值和二维位置，但是这个描
述并没有规定矩阵元素是整数还是浮点数，这个元素甚至可能是一个特殊的结构体!但无论什
么类型的矩阵元素，都可以用这个数据对象集来描述。相应于数据对象的抽象描述，操作4的类
型描述被写为ElementType,即“元素类型”,意味着当具体实现某一种矩阵的时候，这个类型可
以用相应的具体类型替换掉。而其他操作如加法、乘法的具体实现也可能需要随着元素类型的
不同而不同——想一想，如果矩阵元素是某种特殊的结构体，我们怎么定义两个结构体的相加?
这样的描述方法，忽略元素类型这种细节问题，适用于任何一种类型的矩阵。
(2)对于数据对象的描述不依赖于其在计算机中具体的存储方法。例如我们可以用二维数
组存储，也可以用一维数组存储，还可以用十字交叉的链表来存储一个矩阵。抽象数据类型的描
述不涉及这样的细节，但是适用于任何具体的存储方式。
(3)在描述操作的时候，我们只描写了这个操作是做什么用的，并不涉及操作的具体实现方
法。例如矩阵相加的时候，我们是先按行加还是先按列加?抽象数据类型的描述也不涉及这样
的细节，更与实现操作的编程语言没有关系。
综上所述，抽象数据类型描述的重要特征是“抽象”。抽象是计算机求解问题的基本方式和
重要手段，它使得一种设计可以应用于多种场景。而且通过抽象可以屏蔽底层的细节，使设计更
加简单、理解更加方便。
抽象数据类型的描述方法与面向对象的思想是一致的，它把数据对象和相关操作封装在一
起，对于需要调用这个数据类型的用户而言，无论内部的具体实现如何改变，只要对外描述的接
口不变，就不影响使用。
在后面的章节中，每当我们介绍一种新的数据结构时，会首先用抽象数据类型来描述这个结
构，以方便读者理解。
1.3 算法
1.3.1 定义
“算法”(Algorithm)一词是由 Algorism衍生而来，而Algorism源自一本波斯数学教材，原意
为“算术”。算法的设计是一门艺术。解决同一个问题，一般有多种算法，但漂亮的算法与其他
算法相比往往有天壤之别。
10 第1章 概 论
一般而言，算法是一个有限指令集，它接受一些输入(有些情况下不需要输入),产生输出，
并一定在有限步骤之后终止。算法的每一条指令必须有充分明确的目标，不可以有歧义；必须在
计算机能处理的范围之内；且其描述应不依赖于任何一种计算机语言以及具体的实现手段。
当然，用某一种计算机语言进行伪码描述往往使算法更容易被理解，本书即采用C语言的
部分语法作为描述算法的工具。例如代码1.8给出了选择排序算法的伪码描述。
void SelectionSort(int List[],int N)
1/*将N个整数List[0],…,List[N-j]进行非递减排序·/
int i;
for(i=0;i<N;i++)
/*从List[i]到List[N-1]中找最小元，并将其位置赋给MinPosition*/
MinPosition=ScanForMin(List,1,N-1);
/* 将未排序部分的最小元换到有序部分的最后位置*/
Swap(List[i],List[MinPosition]);
代码1.8 选择排序算法的伪码描述
通过代码1.8的描述可以看到，选择排序基本上分两步，首先找出未排序部分的最小元，然
后将之换到有序部分的队尾。但上述描述并不依赖于具体的实现手段，例如 List 到底是数组还
是链表(虽然看上去很像数组),Swap用函数还是用宏去实现等。
算法不是程序。
一个显然的区别是，程序可以无限运行(例如操作系统),但算法必须在有限步后终止。
算法与程序的更重要不同之处，还在于算法比程序“抽象”,强调表现“做什么”,而忽略细节
性的“怎么做”。这样做的好处是使整体思路清晰易懂，形成模块化的风格，在注重团队配合的
软件开发过程中，显得特别重要。把所有过程都写在一个main 函数中的程序是调试员的噩梦!
特别是当程序员自己已无法发现错误，而不得不请同事帮助调试的时候，没有模块化的程序往往
牵一发而动全身，越改越混乱，最后只好推翻重写。
1.3.2 算法复杂度
什么是好的算法?
除了算法的描述风格之外，具体衡量、比较算法优劣的指标主要有以下两个：
(1)空间复杂度S(n)——根据算法写成的程序在执行时占用存储单元的长度。这个长度
往往与输人数据的规模n有关。空问复杂度过高的算法可能导致使用的内存超限，造成程序非
正常中断。
(2)时间复杂度T(n)——根据算法写成的程序在执行时耗费时间的长度。这个长度住往
1.3 算法 11
也与输人数据的规模n有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运
行结果。
现在，让我们回过头仔细审视第1.1节中的例1.2和例1.3。
例1.2给出了实现函数PrintN的两种算法，为什么代码1.2的递归实现会在N比较大时遭
遇非正常中断?关键的原因是，计算机在一个函数A内部处理另一个函数B的调用时，必须先
把A的当前状态保存在内存中，当B被调用完成后，再释放内存恢复状态，继续执行A的其余语
句。于是代码1.2的执行过程就是这样的：要计算PrintN(N),必须先保存这个函数的状态，然
后调用PrintN(N-1);而在执行 PrintN(N-1)时，又必须先保存它的状态，然后调用PrintN(N-
2);……如此类推，直到执行 PrintN(0)时，函数才直接返回，系统开始逐级释放内存。假设存储
每个函数的状态占用1个单位的内存空间，那么执行PrintN(N)就需要N个单位的内存空间，所
以当N非常大时，计算机内存不足就造成程序的非正常中断。
根据定义，代码1.2给出的递归算法的空间复杂度就是S(N)=C·N,其中N是需要打印的
整数的个数，是变量；C是1个单位的内存空间占用存储单元的长度，是个固定常数。我们可以
清楚地看到，根据该算法写成的程序在执行时占用的空间将随着N的增大而增大。而代码1.1
则没有这个问题，该程序执行时占用的空间是不随N的增大而变化的。所以虽然表面上看来两
种函数同样简单，但实际上空间复杂度有很大差别。
例1.3给出了计算多项式值的秦九韶算法和简单直接算法，通过运行程序，我们发现秦九韶
算法在速度上胜出一筹。当我们仔细分析两种算法的运行时间时，不难发现，直接算法(代码
1.4)执行了n次语句"p+=a[i]*pow(x,i);"——每次涉及《次乘法*和1次加法运算，于是全
部计算涉及n次加法和(1+2+…+n)=(n2+n)/2次乘法。而秦九韶算法(代码1.5)执行了n次
语句"p=a[i-1]+x*p;"——全部计算只涉及n次加法和n次乘法。
根据定义，秦九韶算法的时间复杂度就是T?(n)=C·n,其中n是输人多项式的阶数，是个
变量；C是执行1次加法和乘法需要的时间，是个固定常数。简单直接算法的时间复杂度是
T?(n)=C?n2+C?n,其中n是输入多项式的阶数，是个变量；C?是执行1/2次乘法需要的时间，C?
是执行1次加法和1/2次乘法需要的时间，都是固定常数。所以对于充分大的n,T?(n)总会比
T?(n)小，也即秦九韶算法比简单直接算法快，而且n越大，快得越明显。如果我们一开始就通
过时间复杂度来分析两种算法，就不需要运行程序也可以直接知道它们的优劣了。
在分析一般算法的效率时，我们经常关注下面两种复杂度：
(1)最坏情况复杂度T(n);
(2)平均复杂度T..(n)。
例如当我们用顺序查找的方法在一排混乱无序的书架上找一本书的时候，最好情况是一次
就找到了，最坏情况是翻遍了n本书都没找到，即T(n)=C·n,其中C是查看一本书的时间，
·事实上，pow(x,i)函数最快可以用log(i)次乘法计算得到，这使得每一步的乘法次数降为(log(i)+1),总体计算次数跟
nlogn一个数量级。但是由于涉及递归实现，所以当i不是非常大时，实际效果比直接乘法更慢。细节分析在此略去。
12 第1章 概 论
不妨认为是个常数。要得到平均查找次数，略麻烦一些，我们要把每一种可能的情况都考虑到
(有可能需要查找两次，也可能需要查找三次，等等),把所有情况下需要查找的次数加起来，最
后除以所有可能情况的个数。
显然T(n)≤Tm(n)。对T(n)的分析往往比对T(n)的分析容易，因为很多时候定
义"平均"不是一件容易的事。
1.3.3 渐进表示法
如果程序A执行了(3N+4)步，程序B执行了(3N+2)步，A一定比B慢吗?
[例1.5]给定N个整数，存放于数组 List[]中，求它们的和。
代码1.9和代码1.10分别给出了函数的循环和递归实现的版本。
int IterativeSum(int List[1,int N)
/*循环求N个整数的和/
int i;/*执行1步*/
int Sum=0;/*执行1步*/
for(i=0;i<N;i++)/*共执行N+1步*/
Sum+=List[i];/*共执行N步*/
return Sum;/执行1步·/
代码1.9 循环求和
int RecursiveSum(int Liat[],int N)
/ 递归求N个整数的和*/
if(N)/执行1步*/
return(RecursiveSum(List,N-1)+List[N-1]);/·执行x+2步·
return 0:/* 执行1步*/
代码1.10 递归求和
[分析]根据代码1.9中的注释，我们可以很容易看到程序一共执行了(3N+4)步。
代码1.10的情况略微复杂一点，在每次非零N的递归调用中，除了固定的3步外，还有一个
X——即递归调用RecursiveSum(List,N-1)时执行的总步数。如果我们把执行RecursiveSum
(List,N)的总步数记为T(N)的话，就应该有X=T(N-1)。于是我们得到递推式T(N)-
T(N-1)+3。按此递推下去，易得T(N)=T(N-1)+3=T(N-2)+3+3=…=T(0)+3N=3N+2.即
程序一共执行了(3N+2)步。
1.3 算法 13
然而如果你因此就认为递归程序比循环程序快，那么建议对10°个整数(不妨令所有整数为
1)分别用两种方法求和，观察效果……
事实上，精确地比较程序执行的步数是没有意义的，因为每步执行时间可能不同。比如递归
调用的“1步",实际上涉及到对系统堆栈的很多处理，比循环中的“1步”计算慢很多。所以在比
较算法优劣时，人们只考虑宏观渐近性质，即当输入规模n“充分大”时，我们观察不同算法复杂
度的“增长趋势”,以判断哪种算法必定效率更高。为此引入下面几种数学符号。
[定义1.1] T(n)=0(f(n))表示存在常数C>0,n。>0,使得当n≥n。时有T(n)≤
C(f(n))。
如例1.5中的两种程序的时间复杂度均为0(n);例1.3中秦九韶算法的时间复杂度是
0(n),而简单直接法的时间复杂度是0(n2)。
[定义1.2] T(n)=Ω(g(n))表示存在常数C>0,n。>0,使得当n≥n。时有T(n)≥
C(g(n))。
如例1.5中的两种程序的时间复杂度均为Ω(n)。
[定义1.3]T(n)=0(h(n))表示同时有T(n)=0(h(n))和T(n)=Ω(h(n))。
如例1.5中的两种程序的时间复杂度均为θ(n),亦称为具有“线性”复杂度。
事实上，这三种符号不仅用于分析时间复杂度，对空间复杂度也同样适用。如例1.2的循环
算法具有常数级的空间复杂度S(n)=0(1),而递归算法具有线性空间复杂度S(n)=0(n)。
需要注意的是，0(*)和Ω(*)分别表示上界和下界，但一个函数可以有很多不同的上界
和下界。例如3n+2既可以写为0(n),也可以写为0(n2)、0(e")……同样的，既可以写为
Ω(n),也可以写为Ω(log n)、Ω(1)……在此我们希望上下界越接近真实函数越好，所以通常取
最小的上界作为0函数，最大的下界作为Ω函数。
为了帮助初学者更直观地了解不同级别函数的表现，我们给出表1.1和对应的图1.2。
表1.1 常用函数增长表
输入规模n
函数 1 2 4 8 16 32
1 1 1 1 1 1 1
log?n 0 1 2 3 4 5
n 1 2 4 8 16 32
n log?n 0 2 8 24 64 160
n2 1 4 16 64 256 1024
n3 1 8 64 512 4096 32768
2° 2 4 16 256 65536 4294967296
n! 1 2 24 40326 2092278988000 26313×10"
14 第1章 概论
60 2" n2
50
40
30 p n logn
0
0
20
D 0
10 0 n
8 0 e
%
4生 00 logn
1 2 3 4 5 6 7 8 9 10
图1.2 常用函数增长曲线
通过观察表1.1和图1.2,我们需要牢记，在设计算法时，必须全力避免指数级如0(2")复
杂度的算法，更不用说O(n!)的算法了。数学上可以严格证明log*n=0(n)对任意正整数k成
立，这说明对数函数log n的增长是非常缓慢的。而面对0(n2)复杂度的算法时，计算机科学家
的本能反应就是将之优化为一个0(nlog n)的算法，因为后者效率高很多。
如果前面的图1.2和表1.1对不同函数运行的时间效率的表示还不够直接，那么让我们观
察一下表1.2,其中给出了7种函数在每秒可执行10亿指令的计算机上运行的时间。
表1.2 10亿指令每秒计算机的运行时间表
微秒(μs)=10*s,毫秒(ms)=103。
n f(n)=n nlog?n n2 n2 n n1
0.01μs
0.02μs
0.03μs
0.04μs
0.05μs
0.10μs
1.00μs
10μs
100μs
1.0ms
0.03μs
0.09μs
0.15μs
0.21 μs
0.28μs
0.66μs
9.96 μs
130.03μs
1.66ms
19.92ms
0.1μs
0.4μs
0.9μs
1.6 μs
2.5μs
10μs
1 ms
100 ms
10s
16.67 min
I μs
8μs
27 μs
64μs
125μs
1 ms
1s
16.67 min
11.57日
31.71年
10μs
160μs
810μs
2.56ms
6.25ms
100 ms
16.67 min
115.7日
3171年
3.17×10'年
10s
2.84h
6.83日
121.36日
3.1年
3171年
3.17×10°年
3.17×10"年
3.17×10"年
3.17×10年
2*
10 1 μs
20 I ms
30 1s
40 18.3min
50 13日
100 4×10年
1,000 32×10°年
10,000
100,000
1.000,000
在对给定的算法做渐进分析时，有几个小窍门可以与大家分享。
1.若两段算法分别有复杂度T?(n)=0(f?(n))和T?(n)=0(f?(n)),那么
1.4 应用实例：最大子列和问题 45.
(1)两段算法串联在一起的复杂度T,(n)+T?(n)=max(O?(n)),0(J?(n),即出领博的
那个算法决定了申联后的效率：
(2)两段算法嵌套在一起的复杂度T?(n)×T?(n)=0(f?(n)xf?(n))。
2.若T(n)是关于n的k阶多项式，那么T(n)=0(n?)。
3.一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度。例如这个循环的复
杂度是0(N):for(i=0;i<N;i++)|x=y*x+z;k++;1。
4.若干层嵌套循环的时间复杂度等于各层循环次数的乘积再乘以循环体代码的复杂度。
例如下列2层嵌套循环的复杂度是0(N2):
for(i=0:i<N;i++)
for(j=0;j<N;j++)
Ix=y*x+z;k++;
5.if-else结构的复杂度取决于if的条件判断复杂度和两个分枝部分的复杂度，总体复杂度
取三者中最大。即对结构
if(P1)/* P1的复杂度为0(f?)*/
P2;/*P2的复杂度为0(F?)*/
else
P3;/* P3的复杂度为0(f?)*/
总复杂度为max(O(f),0(?),0(J?))。
1.4 应用实例：最大子列和问题
在这一节里，我们将讨论最大子列和问题的解。解决这个问题至少有4种不同算法，我们将
看到这些算法效率的巨大差别，从而对算法的复杂度分析有更深刻的理解。
[问题描述]给定n个整数的序列{a,,a,…,a,I,求函数f(ij)=max{0,∑a} }的最大值。
在这里，“子列”被定义为原始序列中连续的一段数字，我们要找的是具有最大和的一段连
续的子列，并且返回它的和。如果这个最大和是负数，那么我们取0为最终答案。例如给定序列
1-2,11,-4,13,-5,-2|,其最大子列为|11,-4,13|,和为20%
[算法1.1] 让我们从最直接的方法开始，就是穷举所有子列和，从中找出最大值。代码
1.11给出了这个算法的实现。
int MaxSubseqSum1(int List[],int N)
int i,j,k;
int ThisSum,MaxSum=0;
16 第1章 概 论
hor(i=0;i<N;i++)/*i是子列左端位置*/
for(j=i;j<N; j++)|/*j是子列右端位置·/
ThisSum=0;/* ThisSum是从List[i]到List[]的子列和*/
for(k=i;k<=j;k++)
ThisSum+=List[k];
if(ThisSum>MaxSum)/* 如果刚得到的这个子列和更大*/
MaxSum=ThisSum;4,则更新结果/
|/*j循环结束*/
F/*i循环结束*/
return MaxSum;
代码1.11 最大子列和算法1.1的实现
观察代码1.11,我们发现程序的时间复杂度是由3层嵌套的 for循环决定的，即
r(N)=1=0(w)
注意到最内层的k循环涉及大量重复计算，是最大的浪费点。因为对于固定的i,当j增大
了1之后，k 循环要重新从i加到j。而事实上第j-1步的计算结果完全可以存下来，第j步只要
在此基础上累加一个List[j]就可以了，没有必要再从头加起。于是有了下面改进的算法。
[算法1.2]部分存储中间值的穷举。代码1.12给出了这个算法的实现。
int MaxSubseqSum2(int List[],int N)
| inti,j;
int ThiaSum,MaxSum=0;
for(i=0;i<N;i++)1/*i是子列左端位置*/
ThieSum=0:/ Thissum是从List[1]到List[]的子列和 
for(j=1:j<N:J++)/* 1是子列右端位置 */
/8对于相同的1,不同的j,只要在J-1次循环的基础上累加1项即可/
ThisSum+-Lio[1];
if(ThiaBum>MaxSum)八 如果刚得到的这个子列和更大+人
MaxSum=ThiaSum;/则更新结果*人
1/*j循环结束/
1/* 1循环结束*
return NaxSum;
代码1.12 最大子列和算法1.2的实现
1.4 应用实例：最大子列和问题 17
观察代码1.12,我们发现程序的时间复杂度是由2层嵌套的for循环决定的，易见该算法复
杂度降低到0(N2)。读者如果有兴趣，可以自己试验N=103时两种算法的差别。
但这仍不是最快的算法。
[算法1.3]分而治之。
顾名思义，分而治之法(简称“分治法”)的基本思路就是将原问题拆分
成若干小型问题，分别解决后再将结果合而治之，用递归实现非常方便。
就此题而言，我们可以把问题理解为：如果我们把原始序列一分为二，
那么最大子列或者在左半边、或者在右半边、或者是横跨中分线的一段。分
治法的概要描述为：
0…
微视频1-2
最大子列和 第1步：将序列从中分为左右两个子序列； 的分治法
第2步：递归求得两子列的最大和S左和S若；
第3步：从中分点分头向左、右两边扫描，找出跨过分界线的最大子列和S中；
第4步：S=max|S左，S,,S1。
代码1.13给出了这个算法的实现。
int Max3(int A,int B. int c)
1/*返回3个整数中的最大值·/
return A>B?A>C?A:C:B>C?B:C;
1
int DivideAndconquer(int List[ ].int left,int right)
1/分治法求List[left]到List[right]的最大子列和*人
int MaxLeftSum,MaxRightSum;/*存放左右子问题的解·/
int MaxLeftBorderSum,MaxRightBordersum;/*存放跨分界线的结果*/
int LeftBorderSum,Right BorderSum;
int center,i:
if(left==right)|/*递归的终止条件，子列只有1个数字·/
if(List[left]>0) return List[left];
else return 0;
/*下面是“分的过程·/
center=(left+right)/2;/*找到中分点*/
/*递归求得两边子列的最大和·/
MaxLeftSum=DivideAndConquer(List,left,center);
18 第1章 概论
MaxRightSum=DivideAndconquer(List, center+1,right);
/*下面求跨分界线的最大子列和*/
MaxLeftBorderSum=0;LeftBorderSum=0;
for(i=center;i>=left;i--)1/*从中线向左扫描*/
LeftBorderSum+=List[i];
if(LeftBorderSum>MaxLeftBorderSum)
MaxLeftBorderSum=LeftBordersum;
!/*左边扫描结束·/
MaxRightBorderSum=0;RightBorderSum=0;
for(i=center+1;i<=right;i++)/*从中线向右扫描·/
RightBorderSum+=List[i];
if(RightBorderSum>MaxRightBorderSum)
MaxRightBorderSum=RightBorderSum;
1/*右边扫描结束*/
/*下面返回"治"的结果*/
return Max3(MaxLeftSum,MaxRightSum,MaxLeftBorderSum+MaxRightBorderSum);
int MaxSubseqSum3(int List[],int N)
/*保持与前2种算法相同的函数接口*/
return DivideAndconquer(List,0,N-1);
代码1.13 最大子列和算法1.3的实现
注意到解决问题的核心函数是DivideAndConquer,但是作为专业程序员，令具有相同功能的
函数保持相同风格的函数接口是一个好习惯，所以我们沿用前两种算法的接口，用MaxSubseq Sum3进行了包装。这样做的好处是，用户调用不同算法时，输入的参数足不变的，一直都是数组
List 和数据个数N.不需要改变。
算法1.3的复杂度分析略有难度：若记整体时间复杂度为T(N),则函数 DivideAndConquer
中递归进行“分”的复杂度为ZT(N/2),因为我们解决了2个长度减半的子问题。求跨分界线的
最大子列和时，有两个简单的for 循环，所用步骤一共不超过N,所以可以在0(N)时问完成。其
他步骤都只需常数O(1)时间。
综上分析则有递推式：
T(1)=0(1);
1.4 应用实例：最大子列和问题 19
T(N)=2T(N/2)+0(N)
=2[2T((N/2)/2)+0(N/2)]+0(N)=22T(N/22)+2·0(N)
=…=2*T(N/2*)+k·0(N)
当我们不断对分直到N/2*=1,即2*=N时，就得到T(N)=N·T(1)+logN·0(N)=0(Mog N)。
此算法比算法1.2又快了一些，当N=10?时，效果会非常明显。
然而这仍然不是最快的算法!
[算法1.4]在线处理。
“在线”的意思是指每输人一个数据就进行即时处理，得到结果是对于
当前已经读人的所有数据都成立的解，即在任何一个地方中止输入，算法都
能正确给出当前的解。
0…
微视频1-3
最大子列和 前面所给出的3种算法都必须等所有的N个整数都读入并存储后才
可以进行，而下面将介绍的算法甚至无须存储输人序列就可以得到任何时
刻的最大子列和。
的在线算法
该算法的核心思想是基于下面的事实：如果整数序列|a?,a?,…,a|的最大和子列是
a≥0对任意i≤I≤j成立。因此，一旦发现当前子列和为负，则 {a,,a…,a,,那么必定有
可以重新开始考察一个新的子列。代码1.14给出了这个算法的实现。
int MaxSubseqSum4(int List[],int N)
inti;
int ThisSum,MaxSum;
ThisSum=MaxSum=0;
for(i=0;i<N;i++)
ThisSum+=List[i];/ 向右累加·/
if(ThisSum>MaxSum)
MaxSum=ThisSum;/* 发现更大和则更新当前结果/
ThisSum=0;/* 则不可能使后面的部分和增大，抛弃之*/
return MaxSum;
else if(ThisSum<0)/ 如果当前子列和为负*/
代码1.14 最大子列和算法1.4的实现
易见该算法只有一个for 循环，复杂度只有0(N),虽然算法的正确性不如前面3种算法那
么显然。
让我们通过一个具体的整数序列{-1,3,-2,4,-6,1,6,-1|来理解这个算法。图1.3的
20 第1章 概 论
(a)-(h)显示了for 循环8步中ThisSum和MaxSum的变化过程。
注意到这个算法的特点，是无论我们停在中间哪一步，返回的MaxSum 都会是当前输入数据
的正确解——例如当我们在第(c)步停止输入时，对于1-1,3,-2|这个序列，正确的最大和就是
3;如果在第(e)步停止，对于|-1,3,-2,4,-6|这个序列，正确的最大和就是5。这就是所谓“在
线"算法的意思。
i 0 1 234 5 6
List 1 3 -24 -6 1 6
(a)i=07ThisSum=0,MaxSum=0,List[0]被抛弃
0 1 2 3 4 5 6
List 1 3 -2 4 -6 1 6
(b)i=1:ThisSum=3,MaxSum=3,当前最大子列为List[1]
i 0 1 2 3 4 5 6
List -1 3 -2二4 -6 1 6
(c)i=2:ThisSum=1,MaxSum=3,当前最大子列仍为List[1]
i
List
0 1234 5 6 7
1 3 -24 -6 1 6 -1
(d)i=3:ThisSum=5,MaxSum-5,当前最大子列为List[1~3]
0 1 2 3 4 5 6
List 1 3 2 4 6 1 6 1
_
(e)i-4:ThisSum=0,MaxSum=5,当前最大子列仍为List[1~3]。
因ThisSum小于0,故此段被抛弃，因为它不可能使后面的和变大
i
List
0 1 2 3 4 5 6 7
1 3 2 4 6 1 6 -1
()i-5:ThisSum-1,MaxSum=5,当前最大子列仍为List[1~3]
0 1 2 3 4 5 6 7
List -1 1 4 0 1 6 -1
(g)i-6:ThisSum-7,MaxSum=7.当前最大子列变为Lisi[S~0]
0 1 2 3 4 5 6T
List 1 2 4 6 16 -1
(h)i=7:ThisSum=6.MaxSum=7.当前最大子列仍为List[5~0]
图1.3 最大子列和算法1.4的演示
另外，这种算法实际上并不要求存储序列中的数据，我们只需要将数字一个一个读入，同时
一个一个处理即可，处理过的数据没必要存起来。整个算法只把输人数据扫描工1遍，这应该是
习题 21
我们能得到的最快的算法了。
这个例子是告诉大家，解决同一个问题，不同的算法会有很大的差别。提高效率的窍门之
一，是让计算机“记住”一些关键的中间结果，避免重复计算。
本 章 小 结
本章介绍了两个重要的概念：“数据结构”与“算法”。
"数据结构"包括数据对象集以及它们在计算机中的组织方式，即它们的逻辑结构和物理存
储结构，同时还包括与数据对象集相关联的操作集，以及实现这些操作的最高效的算法。抽象数
据类型是用来描述数据结构的重要工具。
“算法”是解决问题步骤的有限集合，通常用某一种计算机语言进行伪码描述。我们用时间
复杂度和空间复杂度来衡量算法的优劣，用渐进表示法分析算法复杂度的增长趋势。
习 题
1.1 判断正误。
(1)N(log N)2是0(N2)的。
(2)N2log N和Nlog N2具有相同的增长速度。
1.2 填空题。
(1)给定N×N的二维数组A,则在不改变数组的前提下，查找最大元素的时间复杂度是_____。
(2)斐波那契数列F。的定义为：F?=0,F?=1,Fx=Fai+Fx2,N=2,3,…。用递归函数计算F。的空间复杂
度是___;时间复杂度是_____。
1.3 试分析下面一段代码的时间复杂度：
if(A>B)
for(i=0;i<N;i++)
for(j=N*N;j>i;j--)
A+=B;
else 
for(i=0;i<N*2;i++)
for(j=N*2;j>i;j--)
A+=B;
1
1.4 分析例1.2中两个版本的PrintN 函数的时间、空间复杂度，并测试它们的实际运行效率。对N=100,
1000,10000,100000运行程序，将两版本的N-时间曲线绘在一张图里进行比较分析。
f(x)=1+S×n, 1.5 测试例1.3中秦九韶算法与直接法的效率差别。令 ,计算f(1.1)的值。利用
22 第1章 概 论
clock()函数得到两种算法在同一机器上的运行时间。
1.6 试分析最大子列和算法1.3的空间复杂度。
1.7 测试最大子列和4种算法的实际运行效率。简单起见，可令List 中全部整数为1。当N=2,4,6,8,
10,…,28,30时，将各算法的N-时间曲线绘在一张图里，其中时间以毫秒为单位；当N=1000,2000,…,10000
时，以秒为单位绘出各算法的时间增长曲线。两幅图有什么不同?为什么?
1.8 查找算法中的“二分法”是这样定义的：给定N个从小到大排好序的整数序列List[],以及某待查找整
数X,我们的目标是找到X在List中的下标。即若有List[i]=X,则返回i;否则返回-1表示没有找到。二分法
是先找到序列的中点List[M],与X进行比较，若相等则返回中点下标；否则，若List[M]>X,则在左边的子系列
中查找X;若List[M]<X,则在右边的子系列中查找X。试写出算法的伪码描述，并分析最坏、最好情况下的时
间、空间复杂度。
1.9 给定存储了N个从大到小排好序的整数数组 List[ ],试给出算法将任一给定整数X插入数组中合适
的位置，以保持结果依然有序。分析算法在最坏、最好情况下的时间、空间复杂度。
1.10 试给出判断N是否为质数的0(√N)的算法。
1.11 试给出计算x"的时间复杂度为0(log.N)的算法。
第2章
数据结构实现基础
2.1 引子
上一章我们讲过，所谓“数据结构”,涉及的不仅仅是数据对象本身以及它们在计算机中的
组织方式，还要考虑与它们相关联的一个操作集，以及实现这些操作的最高效的算法。数据结构
的实现需要依赖具体的程序设计语言，本教材数据结构的实现语是C语言。本章先简要回顾一
下C语言在对支持数据逻辑关系存储以及相关操作实现方面的基础。
我们先来看一个例子，理解抽象与实现之间的关系。
[例2.1] 在日常数据处理中经常碰到的问题是需要对一组数据进行基本的统计分析。比
如，分析一个课程班学生的平均成绩、最高成绩、最低成绩、中位数、标准差等。同样的统计要求
也可能发生在其他领域，比如，统计家庭每年各月的开支情况、生产线上各位员工计件任务的完
成情况、各省的人均GDP数据等。总之，在工作和生活的许多方面都会涉及数据的这类统计。
为每个具体应用都编一个程序显然不是一种很好的方法，因为这些程序有很大的相似性。
数据结构的处理方法是从这些具体应用中抽象出共性的数据组织与操作方法，进而采用某种具
体的程序设计语言实现相应的数据存储与操作。比如，对于上述例子我们可以从各种不同的应
用背景中抽象出一种针对基本统计要求的数据类型。
类型名称：统计数据集 数据对象集：N个元素x?,x?,…,xl的集合S。
操作集：
1.ElementType Average(S,N):求S中N个元素的平均值；
2.ElementType Max(S,N):求S中N个元素的最大值；
3.ElementType Min(S,N):求S中N个元素的最小值；
4.ElementType Median(S,N):求S中N个元素的中位数。这里的中位数指：如果将S
中的元素按从大到小的顺序依次排列，处在中间位置(「N/27,大于等于N/2的最小
整数)的那个元素。
可以看到，针对上述数据抽象方式的具体程序，可以用来求解不同领域的基本统计问题，这
样既使得我们程序设计的逻辑清晰，也在很大程度上实现了代码的重用。
如何利用程序设计语言实现上述抽象类型?首先，必须首先考虑数据如何存储——在我们
这个例子中，即考虑集合S的数据在C语言中怎么存储；其次必须考虑操作如何实现，即在确定
24 第2章 数据结构实现基础
好数据存储方式的基础上，相应的操作(如Average、Max等函数)如何实现。
1.数据存储
对于上述问题，其数据对象集是集合S,这也是最简单的一种数据组织方式。今后我们会介
绍一些更复杂的数据组织方式，比如树、图。以集合方式组织不要求数据有序(比如从小到大)
存放。
C语言(包括其他高级语言)提供了数据组织的几种基本实现方式，包括数组、链表、结构体
等。事实上，数据组织的基本存储方式主要是利用数组和链表方式来实现的，包括很复杂的数据
结构，如图、树，也都不外乎应用数组和链表来实现。
在这个例子中，我们可以简单地使用数组来存储一个集合。这样，相关的操作(包括求平均
值、最大值等)就都可以在数组上进行。
必须注意：数据的存储方法是与要实现的操作密切相关的。对于上述问题，用数组存储集合
可以很方便地实现我们列举出的相关统计操作。如果同样是基于集合，但要求的操作发生了变
化，则相应的数据存储方法也有可能需要采用不同的方式。例如：
(1)若要实现的操作不是基本统计，而是集合运算，如判别一个元素是否属于某集合、计算
两集合的“并”和“交”运算、将某元素插入集合等。这些操作(运算)虽然在简单的数组上也可
以实现，但效率不高。有种更好的表示方法是使用“树”,在4.6.3节中我们将应用树的组织方
式方便地实现集合的上述运算。
(2)若除了基本的统计操作外，我们还需要动态地维护一个集合，即经常往集合里加入一个
元素或删除一个元素，这时简单地使用数组存储就会遇到问题；我们应该事先设计多大的数组来
保存这些元素?数组太大浪费空间，太小有可能会不够用；当删除元素时，还需要移动其后面的
元素，所需要的时间相对比较长。这时，另一种方法是使用链表来保存数据，可以根据需要随时
申请和释放空间。但链表存储也有缺点：由于需要记录下一元素(结点)的地址，所以，跟同样数
据的数组存储相比，链表需要更多的存储空间，同时在程序实现方面也比数组复杂。
所以，数据结构的存储实现跟所需要的操作密切相关，没有最好的存储方式，只有最合适的
存储方式。
2.操作实现
在确定数据的存储方式后，数据结构涉及的另一个问题是相关的操作(运算)如何实现。这
些操作的实现需要利用程序设计语言提供的另一个功能，即流程设计功能。
任何高级程序设计语言(包括C语言)都提供丁一种的基本流程控制语句.即分支控制语句
(如if-cloc、owitch语句)和循环控制语句(如for、while、do-while 语句)。分支控制结构、循环控
制结构加上程序自然的语句顺序执行结构，是实现任何算法流程的基本结构。
虽然分支控制、循环控制和顺序执行结构可以实现任何算法流程，但当流程很复杂时.程序
设计会变得非常困难。所以，模块化的程序设计方法就自然产生了。模块化程序设计方法以功
能块为单位进行程序设计。模块化的日的是为了降低程序结构的复杂度，使程序设计、调试和维
护等燥作简单化。函数是程序设计语言提供的模块化程序设计的基本手段。在程序中，我们可
2.1 引子 25
以将程序的某个基本功能设计为函数，这一方面降低了程序设计的复杂性，另一方面也提高了程
序设计的重用性。
回到我们例子中的基本统计问题，就操作集中列举的四种操作而言，如果数据存储在一个数
组S里，显然相关的Average(S,N)、Max(S.N)、Min(S,N)操作都可以很容易地用循环实现。代
码2.1展示了Average 函数的实现。
ElementType Average(Element Type s[].int N)
I/求N个集合元素s[]的平均值
int i;
BlementTypo Sum=0;
for(i=0:i<N:i++)
Sum+=s[i]:/ 将数组元素累加到Sum中*/
return Sum/N;
代码2.1 求集合元素的平均值
而对于求中位数Median(S,N)问题则相对比较复杂，没法用一个循环简单地实现。有两种
基本的解决思路。
方法1:基于排序
首先将集合S(数组)中的元素从大到小排序，取第[N/27(大于等于N/2的最小整数)处的
元素就是中位数。
方法2:基于问题分解
求集合中位数问题实际上是另一个问题的特殊情况，即求集合中的第K大数问题。当
K=[N/2]时，集合的第K大数就是中位数。这个问题当然也可以用排序解决，但还有另一种更
巧妙的方法，基本思路是：用一个基准数e将集合S分解为不包含e在内的两个小集合S,和S?,
其中S,的任何元素均大于等于e,S?的任何元素均小于e。记ISI代表集合S元素的个数，这样，
如果|S,|≥K,则说明第K大数在S?中；如果IS?I正好等于K-1,说明e是第K大数；否则第K大
数在S?中，并且是S?中的第K-IS,1-1大数。然后，可以用类似的思路继续在S,或S?中查找。
[例2.2]利用问题分解思想，求集合{659821734|的中位数。
由于该集合有9个元素，所以中位数应该是集合从大到小排序后的第[9/2]=5个元素。首
先，选取集合的第一个元素6,根据这个元素从集合中分解出S?=|9,8,7|,S?=|5,2,1,3,4|。
由于|S,|=3<5且不等于4,所以该中位数应该在集合S?中，且是S?中第5-3-1=1大数。
继续选取S?中的第一个整数5,将S?分解出两个集合S',=1|,S'?=|2,1,3,41。由于IS',I=0,
所以5就是S?集合的第1大数，也就是集合|659821734|的中位数。
26 第2章 数据结构实现基础
上述思路是一种将大问题分解为小问题的求解方法。由于小问题的求解采用与大问题相同
的思路，所以可以采用函数递归的程序设计方法实现。代码2.2给出了基于函数递归的求第K
大数的算法。
ElementType FindKthLargest(ElementType s[],int K)
1/*此为伪代码·/
选取s中的第一个元素e;
根据e将集合S(不包含e)分解为大于等于e的元素集合S,和小于e的元素集合S?;
if(IS,I≥K) return FindKthLargest(S?,K);
else if(IS,J<K-1)return FindKthLargest(S?,K-IS,I-1);
else return e;
代码2.2 求第K大数的算法
上述方法应用函数递归比较简洁地实现了算法流程的控制。今后大家可以了解到递归是数
据结构算法设计的很重要的手段。
本章后面两节跟大家一起回顾一下C语言程序设计中数据存储的实现基础，包括数组、结
构、指针、链表；以及流程实现的主要方法，包括分支控制、循环控制、函数以及递归。重点是进一
步巩固链表和递归中的相关内容。
2.2 数据存储基础
变量是数据存储的基本单位，而变量是有类型的。C语言事先定义了几种基本的数据类型，
供程序员直接使用，如整型、实型(浮点型)、字符型等。为了使程序员能更充分地表达各种复杂
的数据，C语言还提供了构造复杂数据类型的手段，如数组、结构、指针等，为有限能力的程序设
计语言表达客观世界中多种多样的数据提供了良好的基础。
2.2.1 数组
数组是最基本的构造类型，它是一组相同类型数据的有序集合。数组中的元素在内存中连
续存放，每个元素都属于同一种数据类型，用数组名和下标可以唯一地确定数组元素。
一维数组定义的一般形式为：
类型名 数组名[数组长度]
例如，下列语句定义了大小为10的整型数组a。
int a[10]:
数组元索的引用要指定下标，形式为：
2.2 数据存储基础 27
数组名[下标]
数组元素的使用方法与同类型的变量完全相同。C语言的编译器不检查数组下标是否越
界，因此在编程时不要让下标越界。因为，一旦发生下标越界，就会把数据写到其他变量所占的
存储单元中，有可能造成不可预料的运行结果。
和简单变量的初始化一样，在定义数组时，也可以对数组元素赋初值。其一般形式为；
类型名 数组名[数组长度]={初值表；
初值表中依次放着数组元素的初值。
C语言支持多维数组，最常见的多维数组是二维数组，主要用于表示二维表和矩阵。
二维数组的定义形式为：
类型名 数组名[行长度][列长度]
引用二维数组的元素要指定2个下标，即行下标和列下标，形式为：
数组名[行下标][列下标]
二维数组的元素在内存中按行优先方式存放，即先存放第0行的元素，再存放第1行的元
素……其中每一行的元素再按照列的顺序存放。
数组的应用离不开循环。在程序实现中，往往将数组的下标作为循环变量，通过循环，就可
以对数组的所有元素逐个进行处理。对二维数组，可以将行下标和列下标分别作为循环变量，通
过二重循环，就可以遍历二维数组，即访问二维数组的所有元素。由于二维数组的元素在内存中
按行优先方式存放，将行下标作为外循环的循环变量，列下标作为内循环的循环变量，可以提高
程序的执行效率。
数组具有随机存取元素效率较高的优点，即存取第i个元素只需常数时间。也就是说，存取
A[i]所需时间与下标i无关。
[例2.3]求集合元素的最大值。集合元素存放在数组A中，数组大小为N。
代码2.3给出的函数在类型为ElementType的数组A中查找最大的元素。这里的Element Type并不是C语言提供的数据类型。这样写法的好处是通用，我们不需要对每个具体的数据类
型(如int、float、double等)都实现一个求最大值的函数，读者在使用这个函数解决具体问题之
前，只要把 ElementType定义成自己需要的类型就可以了。
函数参数是2个，即数组A和数组大小N。这也是C语言传递数组的基本形式，因为A代表
了数组的第一个元素的地址，并不包含数组元素个数的信息，因此还需要传递一个参数N。该函数
以数组第一个元素为基准(作为当前最大值CurMax),通过循环控制变量i从数组的第二个元素
(下标为1)开始逐个查找，每次都与当前已知的最大值进行比较，当发现更大值时更新CurMax。
ElementType Max(ElementType s[],int N)
1/*求N个集合元素s[]中的最大值*/
int i;
ElementType CurMax=s[0];
28 第2章 数据结构实现基础
for(i=1;i<N;i++)
if(S[i]>CurMax)/·若A[i]比当前最大值还要大·/
return CurMax;
curMax=s[i]:/* 则更新当前最大值·/
代码2.3 求N个元素数组(集合)中的最大值
2.2.2 类型定义 typedef
在编程过程中，除了使用C语言提供的标准类型和自己定义的一些结构体、枚举等类型外，
还可以用typedef语句来建立已经定义好的数据类型的别名：
typedef 原有类型名 新类型名
利用typedef来建立基本数据类型的别名能够使得程序具有更好的可阅读性和移植性。比
如在上述求集合元素最大值问题中，当我们需要求整数集合的最大值时，就可以利用 typedef定
义代码2.3中的ElementType:
typedef int ElementType;
把上述语句写在函数之前，我们就可以直接使用代码2.3,而不需要把代码中的每个
ElementType换成int 去编译运行。
2.2.3 指针
指针是C语言中一个非常重要的概念，也是C语言的特色之一。使用指针可以对复杂数据
进行处理，能对计算机的内存进行分配控制，在函数调用中使用指针还可以返回多个值。
定义指针变量的一般形式为：
类型名 *指针变量名
例如，下列语句定义了指向float类型的指针变量p。
floatp;
指针变量用于存放变量的地址。由于不同类型的变量在内存中占用不同大小的存储单元.
所以如果只知道内存地址，还不能确定该地址上的对象。因此在定义指针变量时，除了指针变量
名，还需要说明该指针变量(如p)所指向的内存空问上所存放数据的类型(如flont)。
指针被定义后，必须将指针和一个特定的变量进行关联后，才可以使用指针，也就是说，指针
变量也要先赋值再使用.当然指针变量被赋的值应该是地址。
1.指针的基本运算
如果指针的值是某个变量的地址，通过指针就能间接访问那个变量。这些操作由取地址运
算符&和问接访问运算符中完成。此外，相同类型的指针还能进行赋值和比较。
2.2 数据存储基础 29
指针可以同整数进行加、减操作。例如，如果变量p是指向 float类型变量的指针，那么表达
式 p+i代表了从p这个位置开始的第i个Hoat类型变量的地址。
两个类型相同的指针也可进行相减操作，表示两个指针之问相隔的变量个数。两个相同类
型指针还可以使用关系运算符比较大小。
2.指针与数组
在C语言中，数组名本身就是数组的基地址，即第1个元素(下标为0)的地址。
在访问内存方面，指针和数组几乎是相同的，当然也有不同：指针是以地址作为值的变量，而
数组名的值是一个特殊的固定地址，可以把它看作是指针常量，不能改变指针常量(数组名)
的值。
在函数定义中，被声明为数组的形参实际上是一个指针。当传递数组时，按值调用传递它的
基地址，数组元素本身不被复制。
数组名作为函数的实参，在被调用函数中，就能访问实参数组所在的存储单元，不但可以引
用，还能改变这些单元的内容。返回主调函数后，相应数组元素的值就改变了。
3.用指针实现内存动态分配
变量在使用前必须被定义且安排好存储空间(包括内存中起始地址和存储单元大小)。比
如，在定义数组时就需要声明数组的大小。但有些情况下，运行中的存储要求在写程序时无法确
定，因此需要一种可以根据运行时的实际存储需求来动态分配适当存储区的机制。C语言为此
提供了动态存储管理，允许程序动态申请和释放存储空间。
在动态存储分配方面，C语言提供了一组标准函数，定义在stdio.h里面，主要有：
(1)动态存储分配函数 void *malloc(unsigned size):在内存的动态存储区中分配一连续空
间，其长度为size。若申请成功，则返回一个指向所分配内存空间的起始地址；若申请内存空间
不成功，则返回NULL(值为0)。该函数的返回值为(void *)类型，在具体使用中，需要将malloc
的返回值转换到特定指针类型，并赋给一个指针变量。
(2)动态存储释放函数 void free(void *ptr):释放由动态存储分配函数申请到的整块内存
空间，ptr为指向要释放空间的首地址。
为了保证动态存储区的有效利用，在动态分配的存储块不再使用时，就应及时将它释放。特
别注意：
(1)指针只有在被赋值以后才能被正确使用。指针如果没有被赋值，它的值是不确定的，即
它指向一个不确定的单元，使用这样的指针，可能会出现难以预料的结果，甚至导致系统操作错
误。例如，下列语句中，指针p没有被事先赋值(如指向一个字符数组),函数调用strepy可能会
出现难以预料的结果。
char *p;
strcpy(p,"This is Wrong!");
(2)在C语言中，指针的算术运算只包括两个相同类型的指针相减以及指针加上或减去一
个整数，其他的操作如指针相加、相乘和相除，或指针加上和减去一个浮点数都是非法的。
30 第2章 数据结构实现基础
2.2.4 结构
结构类型是一种允许程序员把一些数据分量聚合成一个整体的数据类型，它能够把有内在
联系的不同类型的数据统一成一个整体，使它们相互关联。同时，结构又是一个变量的集合，可
以按照与成员类型变量相同的操作方法单独使用其变量成员。结构与数组的区别在于，数组的
所有元素必须是相同类型的，而结构的成员可以是不同的数据类型。
结构类型定义的一般形式为；
struct 结构名{
类型名 结构成员名1;
类型名 结构成员名2;
……
类型名 结构成员名n;
I;
在定义结构成员时所用的数据类型也可以是结构类型，这样就形成了结构类型的嵌套。
在C语言中定义结构体变量的一种方式是：先定义一个结构类型，再定义一个具有这种结
构类型的变量，基本形式是：
struct 结构名 结构变量名表；
当然也可以在定义结构类型的同时定义结构变量。另外，也允许在定义结构变量时省略结
构名。要注意的是，这种方式由于没有给出结构名，在以后无法再定义这个类型的其他结构变
量，除非把定义过程再写一遍。
结构变量也可以初始化，即在定义时对其赋初值。结构变量的初始化采用初始化表的方法，
大括号内各数据项间用逗号隔开，将大括号内的数据项对应地赋给结构变量的各个成员，要求数
据类型一致。
1.结构变量的使用
使用结构变量主要就是对其成员进行操作。在C语言中，使用结构成员操作符“.”来引用
结构成员，格式为；
结构变量名，结构成员名
对嵌套结构成员的引用方法和一般成员的引用方法类似，也是采用结构成员操作符”。”进行
的，每个成员按从左到右、从外到内的方式引用。
由于结构成员运算符的优先级属最高级别，所以一般情况下都是优先执行，即和一般运算符
混合运算时，结构体成员运算符优先。
结构变量不仅可以作为函数参数，也可以作为函数的返回值。此外，结构成员变量也能作为
函数参数，与普通变量作为函数参数一样。
2.结构数组
可以将具有相同结构类型的变量组织起来，形成一个结构数组。结构数组是结构与数组的
31
结合.与普通数组的不同之处在于每个数组元素都是一个结构类型的数据，包括各个成员项。
结构数组的定义方法与普通数组的定义方法相同，此时的类型是结构。在定义结构数组时，
也可以同时对其进行初始化，其格式与二维数组的初始化类似。
对结构数组元素成员的引用是通过使用数组下标与结构成员操作符","相结合的方式来完
成的，其一般格式为：
结构数组名[下标].结构成员名
3.结构指针
结构指针就是指向结构类型变量的指针。有了结构指针，既可以通过该指针访问结构，也可
以通过指针直接访问结构成员。具体有两种形式：
(1)用·方式访问，形式；
(*结构指针变量名).结构成员名
(2)用指向运算符“->”访问指针指向的结构成员，形式：
结构指针变量名->结构成员名
结构指针也可以作为函数参数传递。相比于通过参数直接传递结构，将结构指针作为参数
传递不仅可以在函数中修改结构指针所指向的内容，而且参数传递的效率会更高。
4.共用体
共用体同结构体在声明形式和访问方式上有些类似，但是它和结构体是完全不同的。所谓
共用体类型是指将不同的数据项组织成一个整体，它们在内存中占用同一段存储单元。其定义
形式为：
union共用体名
类型名 成员名1;
类型名 成员名2;
……
类型名 成员名n;
};
由于各个成员变量在内存中都使用同一段存储空间，因此共用体变量的长度等于最长的成
员的长度。共用体的访问方式同结构体类似。
下面是一个共用体的例子：
union key
int k;
char ch[2];
|u;
该共用体变量占用空间是int类型占用空间与2字节的最大值。读者可以运行一下代码
2.4,看看输出结果是什么?为什么?
32 第2章 数据结构实现基础
#include <stdio.h>
int main()
union key 
int k;
char ch[2];
lu;
u.k=258;
printf("?d\n",u.ch[0],u.ch[1]);
return 0;
代码2.4 共用体的一个例子
2.2.5 链表
链表是一种常见而重要的基础数据结构，也是实现复杂数据结构的重要手段。它不按照线
性的顺序存储数据，而是由若干个同一结构类型的“结点”依次串接而成的，即每一个结点里保
存着下一个结点的地址(指针)。
使用链表结构可以克服数组需要预先知道数据大小的缺点，可以充分利用计算机内存空间，
实现灵活的内存动态管理。但链表失去了数组方便随机存取的优点，同时链表由于增加了结点
的指针域，空间开销比较大。
链表有很多种不同的类型：单向链表、双向链表以及循环链表。
1.单向链表的结构
单向链表的组成如图2.1所示。一个表头变量hoad,用来存放链表首结点的地址，链表中每
个结点由数据部分和下一个结点的地址部分组成，即每个结点都包含指向下一个结点的指针。
链表中的最后一个结点称为表尾.其下一个结点的地址部分的值为NULL(表示为空地址》。链
表的各个结点在内存中可能是不连续存放的，具体存放位置由系统分配。
head A
图2.1 单向链表的组成示意图
通常使用结构的该套来定义单向链表结点的数据类型。如：
typedef struet Node xPuToNode:
B c D NULL
2.2 数据存储基础 33
struct Node
ElementType Data:* 存储结点数据*/
PtrToNode Next;* 指向下一个结点的指针*
1:
结构类型 Node中的Next分量又是该结构类型的指针，称之为结构的递归定义。为了阅读
方便，我们将指针重命名为PtrToNode,即“指向Node的指针”之意。除了Next分量外还有其他
表示结点信息的分量(如本例中的Data)。
通常我们说“给定一个单链表",就是给定一个指向该链表头结点的指针，所以“单链表类
型"List可以定义为链表结点结构的指针，即：
typedef PtrToNode List;
链表是一种动态数据结构。在进行动态存储分配的操作中，C语言提供了几个常用的函数：
malloc()、free()。例如，要申请大小为struct Node 结构的动态内存空间，可由下面语句实现：
PtrToNode p=(PtrToNode)malloc(sizeof(struct Node));
若申请成功，p指向被分配内存空间的起始地址；若未申请到内存空间，则p的值为NULL。
2.单向链表的常见操作
(1)插入结点。
在单向链表 head的某个结点p之后插入一新结点的基本过程是：首先找到正确位置p,然后
申请新结点t并对t的结点信息赋值，最后将t插在p之后，如图2.2所示。
head
P
t
图2.2 p之后插入新结点t
将结点t插在结点p之后的语句为：
t->Next=p->Next;
p->Next=t;
注意：上述两个语句的顺序不能颠倒。
如果需要在链表的头上插入一个结点t,其基本语句是：
t->Next=head;
head=t;
(2)删除结点。
从单向链表 head 中删除一个结点的基本过程是：首先找到被删除结点的前面一个结点p,
然后删除p之后的那个结点。基本语句为：
t=p->Next;
34 第2章 数据结构实现基础
p->Next=t->Next;
free(t);
注意：删除一个结点后必须释放该结点的空间，为此在上述语句中首先将待删除结点保留在
t中，最后再释放t。
如果删除的是链表的第一个结点，其基本语句是：
t=head;
head=head->Next;
free(t);
(3)单向链表的遍历。
对单向链表最常见的处理方式是逐个查看链表中每个结点的数据并进行处理，因此，链表的
遍历是非常基础的链表程序设计方法。
单向链表遍历的基本程序结构为：
p=head;
while(p!=NULL) ……
对p所指的结点信息进行处理； ……
p=p->Next;
(4)链表的建立。
应用链表进行程序设计时，往往需要先建立一个链表。建立链表的过程实际上就是不断在
链表中插入结点的过程。
在构建链表时，有两种常见的插人结点方式：①在链表的头上不断插入新结点；②在链表的
尾部不断插入新结点。如果是后者，一般需要有一个临时的结点指针一直指向当前链表的最后
一个结点，以方便新结点的插入。
前面提到的单向链表都是一种不带头结点的单向链表。有时为了程序处理方便，比如在删
除结点时希望不需要特别区分是否是链表的第一个结点还是其他结点，可以在单向链表的头上
加一个“空结点”,该结点的Data空置，而Next指向链表的第一个真正结点。这种链表叫带头结
点的单向链表。
3.双向链表
单向链表的构成使得结点访问要按链的指向进行，某一单元的后继单元可以直接通过链
指针(Next指针)找到，而要找到其前驱单元，必须从链头开始查找。如果结点增加一个指针
域指向其前驱结点，将在牺牲空间代价的前提下，减少操作的代价。这种在单向链表基础上
增加指向前驱单元指针(Previous指针)的链表叫做双向链表。图2.3是双向链表的图示表示
形式。
2.2 数据存储基础 35
head
“
2 a3 a
图2.3 双向链表
双向链表结点的数据类型与单向链表相似，只是多了一个前驱单元指针：
typedef struct DNode *PtrToDNode;
struct DNode 
/* 存储结点数据*/ ElementType Data;
*指向下一个结点的指针+/ PtrToDNode Next;
PtrToDNode Previous; /*指向前一个结点的指针*/
typedef PtrToDNode DList;
如果将双向链表最后一个单元的Next指针指向链表的第一个单元，而第一个单元的Previ ous 指针指向链表的最后一个单元，这样构成的链表称为双向循环链表(图2.4所示)。
head a a? a
图2.4 双向循环链表
对双向链表的插入、删除和遍历基本思路与单向链表相同，但需要同时考虑前后两个指针。
比如，在图2.5所示的双向链表的p指向的a?结点后插入新结点t的方法是：
t->Previous=p;
t->Next=p->Next;
p->Next->Previous=t;
p->Next=t;
同样，这其中4个语句之间也需要保持一定的执行顺序，否则可能得不到正确结果。
head a1 a? a3 a
P
t
图2.5 双向链表的插入
[例2.4]给定一个单链表L,请设计函数Reverse将链表L就地逆转，即不需要申请新的结
点，将链表的第一个元素转为最后一个元素，第二个元素转为倒数第二个元素，以此类推。
36 第2章 数据结构实现基础
[分析]比较明显，解决这个问题的基本思路是：利用循环，从链表头开始逐个处理。循环
设计中，最核心的要点是如何把握住循环不变式。循环不变式表示一种在循环过程进行时不变
的性质，不依赖于前面所执行过程的重复次数的断言。对于本题，我们可以想象到的场景是：在
每轮循环开始前我们都面临两个链表，其中Old_head是一个待逆转的链表(即“旧”的链表头),
而New_head是一个已经逆转好的链表(即“新”的链表头),如图2.6所示。每轮循环的目的是
把Old_head中的第一个元素插入到New_head的头上，这轮循环执行好后，0ld_head和New_
head 还是分别指向新的待逆转链表和已经逆转好的链表。
New_head Old_head
图2.6 单向链表的逆转
循环程序的主体部分就是将Old_head的第一个元素插入到New_head头上，同时更新Old_
head、New_head值。当将Old_head的第一元素插入到New_head头上后，我们需要知道Old_
head 链表新的头结点在哪里，因此，还需要使用一个临时变量Temp。所以，循环程序的主体部
分是：
Temp=Old_head->Next;
Old_head->Next=New_head;
New_head=Old_head;
Old_head=Temp;
在循环执行前，0ld_head、New_head应该正确初始化，即：待逆转的链表Old_head 就是原始
链表，已经逆转好的链表New_head开始时为空。而循环结束后，需要将逆转后的链表头指针
(New_head)返回。单向链表逆转函数如代码2.5所示。
List Reveroe(Liat L)
1八将单链表工逆转/
PtrTONode 01d nead. New_head. Temp;
o1d_head-L;人初始化当前旧表头为L+
New_head=NULL;初始化逆转后新表头为空*
while(01d_head)l/*当旧表不为空时
Temp=01d_head->Next;
01d_head-Neat=New_head,
Now_head-01d_head,将当前旧表头逆转为新表头
01Ahaad=Temp:一更新旧表头
2.3 流程控制基础 37
L=New_head;八更新L
return L:
代码 2.5 单向链表的逆转
2.3 流程控制基础
程序设计语言除了能表达各种各样的数据外，还必须提供一种手段来表达数据处理的过程，
即程序的控制过程。程序的控制过程通过程序中的一系列语句来实现。
按照结构化程序设计的观点，任何程序都可以将程序模块通过三种基本的控制结构进行组
合来实现。这三种基本的控制结构是顺序、分支和循环。
顺序结构是一种自然的控制结构，通过安排语句或模块的顺序就能实现。所以，对一般程序
设计语言来说，需要提供表达分支控制和循环控制的手段。C语言为分支控制提供了 if-else和
switch两类语句，而为循环控制提供了for、while和do-while三类语句。
以上3种控制方式称为语句级控制。它实现了程序在语句间的跳转。
当我们要处理的问题比较复杂时，为了增强程序的可读性和可维护性，常常将程序分为若干
个相对独立的子程序。在C语言中，子程序的作用由函数完成。函数通过一系列语句的组合来
完成某种特定的功能(如求整数n的阶乘)。当程序需要相应功能时，不用重新写一系列代码，
而是直接调用函数，并根据需要传递不同的参数(如求阶乘函数中的n)。同一个函数可以被一
个或多个函数(包括自己)多次调用。函数调用时可传递零个或多个参数，函数被调用的结果将
返回给调用函数。这种涉及函数定义和调用的控制称为单位级控制。所以，程序设计语言的另
一个功能就是提供单位级控制的手段，即函数的定义与调用手段。
2.3.1 分支控制
1.if-else 语句
if-else语句的一般形式为：
if(表达式)
语句1;
else
语句2;
该语句用于实现分支结构，根据表达式的值选择语句1或语句2中的一条执行。if-else语
句首先求解表达式，如果表达式的值为“真”,则执行语句1;如果表达式的值为“假”,则执行语
38 第2章 数据结构实现基础
句2。if-else语句的else部分可以省略。
可以通过多个二路分支语句 if-else的嵌套组合实现多路选择，其一般形式为：
if(表达式1)
语句1;
else if(表达式 2)
语句2;
**=
else if(表达式 n-1)
语句n-1;
else
语句n;
它的执行流程是：首先求解表达式1,如果表达式1的值为“真”,则执行语句1,并结束整个
if语句的执行，否则，求解表达式2,……,最后的else处理给出的条件都不满足的情况，即表达
式1、表达式2、……和表达式n-1的值都为“假”时，执行语句n。
在嵌套的 if-else 语句中，如果内嵌的 if省略了else 部分，会存在后面的else与哪个if配对
的问题。在C语言中，else和if的匹配准则是：else与最靠近它的、没有与别的else匹配过的 if
相匹配。
2.switch 语句
switch语句可以处理多分支选择问题，典型的形式是：
switch(表达式)[
case 常量表达式1:语句段1;break;
case 常量表达式2:语句段2;break;
……
…
casc常量表达式n:语句段n;break;
default: 语句段n+1;break;
该switeh 语句首先求解表达式，如果表达式的值与某个常量表达式的值相等，则执行该常量
表达式后的相应语句段，如果表达式的值与任何一个常量表达式的值都不相等，则执行 default
后的语句段。当碰到break 语句时，跳出switeh 语句。
在switch语句中，表达式和常量表达式的值一般是整型或字符型，所有的常量表达式的值都
不能相等。每个语句段可以包括一条或多条语句，也可以为空。
switeh语句中default 可以省略，如果省略了 default,当表达式的值与任何一个常量表达式的
值都不相等时，就什么都不执行。
break 语句在owitch 语句中是可选的。如果在switeh 语句中不使用break,那么该switeh 语
2.3 流程控制基础 39
句的执行流程将会不一样：求解表达式后，如果表达式的值与某个常量表达式的值相等，则执行
该常量表达式后的所有语句段(包括别的常量表达式后面的语句段),如果表达式的值与任何一
个常量表达式的值都不相等，则执行 default 后的所有语句段。
由此可见，在switch 语句所有语句段的末尾使用break,可以简单清晰地实现多分支选择，这
也是switch 语句的主要使用方法。
2.3.2 循环控制
在程序设计中，如果需要重复执行某些操作，就要用到循环结构。C语言提供了3种循环语
句(for,while和 do-while)。
1.for语句
在C语言中，for 语句是一种常用的循环语句。它的一般形式为：
for(表达式1;表达式2;表达式3)
循环体语句；
for语句先计算表达式1;再判断表达式2,若值为“真”,则执行循环体语句，并接着计算表达
式3,然后继续判断表达式2,如此循环；若值为“假”,则结束循环，继续执行 for的下一条语句。
2.while语句
while 语句的一般形式为：
while(表达式)
循环体语句；
对于while 语句，当表达式的值为“真”时，循环执行，直到表达式的值为“假”,循环中止，并
继续执行 while的下一条语句。
while语句的构成简单，只有1个表达式和1条循环体语句，分别对应循环的两个核心要素：
循环条件和循环体。
循环的实现一般包括4个部分，即初始化、条件控制、重复的操作以及通过改变某些量的值
最终改变条件的真假性，使循环能正常结束。这4个部分可以直接和 for语句中的4个成分(表
达式1、表达式2、循环体语句和表达式3)相对应。当使用while语句时，由于它只有2个成分
(表达式和循环体语句),就需要另加初始化部分，至于第4个部分，while语句的循环体语句可包
含for语句的循环体语句和表达式3,所以 while的循环体语句中必须包含能最终改变循环条件
真假性的操作。
可以把for语句改写成while 语句：
表达式1;
while(表达式2){
for 的循环体语句；
表达式3;
40 第2章 数据结构实现基础
for 语句和while 语句都能实现循环。一般情况下，如果问题比较明显地蕴含了循环次数，使
用 for语句更清晰，循环的4个组成部分一目了然。其他情况下多使用 while语句。
3.do-while 语句
do-while语句与上述2种循环语句略有不同，它先执行循环体，后判断循环条件。所以无论
循环条件的真假如何，至少会执行一次循环体。其一般形式为：
do{
循环体语句；
while(表达式)
do-while语句第一次进入循环时，首先执行循环体语句，然后再检查循环控制条件，即计算
表达式，若值为“真”,继续循环，直到表达式的值为“假”,循环结束，执行 do-while的下一条
语句。
do-while语句的使用方法和 while 语句类似，语句中的表达式可以是任意合法的表达式，使
用时要另加初始化部分，循环体语句必须包含能最终改变条件真假性的操作。
do-while语句适合于先循环后判断循环条件的情况，一般在循环体的执行过程中明确循环
控制条件。它每执行一次循环体后，再判断条件，以决定是否进行下一次循环。
4.break 语句和 continue 语句
break 语句强制循环结束，一旦执行了break 语句，循环提前结束，不再执行循环体中位于其
后的其他语句。break 语句应该和if语句配合使用，即条件满足时，才执行 break 跳出循环；不然
的话，若break 无条件执行，意味着永远不会执行循环体中break 后面的其他语句。
continue语句的作用是跳过循环体中continue后面的语句，继续下一次循环。continue语句
一般也需要与if语句配合使用。
continue语句和 break 语句的区别在于，break 结束循环，而continue只是跳过后面语句，继续
循环。break 除了可以终止循环外，还用于结束switch 语句，而continue只能用于循环。
5.嵌套循环
嵌套循环(或多重循环)是指大循环中嵌套了小循环。在处理许多比较复杂问题时经常会
使用嵌套循环，三种循环(for、whilo、do-while)都可以相互嵌套。
[例2.5]求单链表L中所有结点Data的阶乘和。这里保证所有结点的Data值非负。
[分析]可以设定两重循环：大循环(外层循环)控制指针P遍历单链表的每个结点(用
while语句),而小循环(内层循环)则用来求每个结点Data的阶乘(用for语句)。程序结构如代
码2.6所示。
1nt Factoria1Sum(List L)
I Int ract,sum,I
DErToNode D-L,
Sum=0:
2.3.流程控制基础 41
whiIe(P)
Fact=1:
for(1=2;I<=P->Data;1++)
Fact=1;
Sum+-Pact;
P=P->Noxt;
return sum;
代码2.6 求单链表L中所有结点Data的阶乘和
[例2.6] 基于排序的方法求一组数的中位数。
[分析]前面提到过，可以先对一组数排序，然后就可以很方便地找出这组数的中位数。目
前排序的算法很多，比较简单的有选择排序、插入排序以及冒泡排序。这里我们以简单的选择排
序为例。选择排序的基本思路是：从待排序列中找出值最大的元素，然后将该最大值元素跟待排
序列的第一个元素交换。一直重复上述过程，使待排序列越来越短，当待排序列只剩一个元素时
排序就完成了。我们同样可以使用两重循环来实现上述算法。外循环控制变量i代表(i,n-1)
为数组中待排序列的下标区间，i初值为0,每循环一次i加1;内层循环主要目标是在数组
[i,n-1]区间里找出一个最大值。代码2.7给出了这个方法的实现。
ElementType Median(ElementType A[],int N)
inti,j,MaxPosition;
ElementType TmpA;
for(i=0;i<N-1;i++)
MaxPosition=i;
for(j=i+1;j<N;j++)/ 内循环找出最大值的下标MaxPosition·/
if(A[j]>A[MaxPosition])MaxPosition=j;
/* 下面将最大值与待排序列的第一个元素A[]交换/
TmpA=A[1];A[1]=A[MaxPosition];A[MaxPositign]=TmpA;
/*排序结束*/
/*数组中下标为(N-1)/2位置的元素就是序列中第N/2个元素·/
return A[(N-1)/2];
代码2.7 基于排序方法求中位数
42 第2章 数据结构实现基础
更多的关于排序的算法将在第7章中介绍。
2.3.3 函数与递归
函数是一个完成特定工作的独立程序模块。程序中一旦调用了某个函数，该函数就会完成
一些特定的工作，然后返回到调用它的地方。函数包括库函数和自定义函数两种。例如，scanf、
printf 等库函数由C语言系统提供定义，编程时只要直接调用即可。在程序设计中，往往根据模
块化程序设计的需要，需要用户自己定义函数，属于自定义函数。
函数定义的基本形式是：
函数类型 函数名(形参表)/* 函数首部*/
1
/* 函数体*/ 函数实现过程；
函数的定义包括函数首部和函数体两部分。其中，函数首部由函数类型、函数名和形参表组
成；函数体包括函数实现过程和 return语句(return表达式；),体现为一对大括号内的若干条
语句。
在函数首部，函数类型指函数返回值的类型，一般与return语句中表达式的类型一致；函数
名是一个合法的标识符；形参表中给出函数所有形参的名称和类型，它的格式为：
类型1 形参1,类型2 形参2,……,类型n 形参n
形参表中各个形参之间用逗号分隔，每个形参前面的类型必须分别写明。函数的形参的数
量可以是0~n个，即根据具体情况，形参可以是1个，也可以是多个，或者没有形参。
在函数体中，函数的实现过程是一些完成特定工作的语句，return语句中的表达式反映了函
数运算的结果，通过 return语句结束该函数的运行并将该结果回送给主调函数。return语句的作
用有两个：一是结束函数的运行；二是带着运算结果(表达式的值)返回主调函数。在函数定义
中也可以没有returm语句，此时函数执行时的最后一个语句的值作为函数的返回值。
return 语句只能返回一个值，如果函数产生了多个运算结果.将无法通过 return直接全部返
回。如果函数要返回多个运算结果，一般有以下几种方法：①通过全局变量；②通过函数参数传
递变量地址，在函数中通过这个参数给变量赋值；③把准备返回的多个结果组成一个结构返回。
有些函数可以不返回任何值，仅仅是执行一个过程。这类函数的类型可以说明为 void.其函
数体中的return语句后面的表达式可以省略。
注意：在函数定义时，若不说明函数类型(即函数类型缺省),该函数的类型被缺省定义
为int。
1.函数的调用
定义一个函数后，就可以在程序中调用这个函数。调用函数时，将实参传递给形参并执行函
数定义中所规定的程序过程，以实现相应的功能。
在C语言中，调用标准库函数时，只需要在程序的最前面用#include命令包含相应的头文
2.3 流程控制基础 43
件；调用自定义函数时，程序中必须有与调用函数相对应的函数定义。
函数调用的一般形式为；
函数名(实参表》
实参可以是常量、变量和表达式。
计算机在执行程序时，从主函数main开始执行，如果遇到某个函数调用，主函数被暂停执
行，转而执行相应的函数；该函数执行完后，将返回主函数，然后再从原先暂停的位置继续执行。
函数定义中的参数被称为形参，函数调用时的参数被称为实参。形参和实参必须一一对应，
要求两者数量相同、类型一致。在程序运行中，遇到函数调用时，将实参的值按依次传给形参，这
就是参数传递。
函数的形参必须是变量，用于接受实参传递过来的值，形参的使用方法和普通变量相同；而
实参可以是常量、变量或表达式，其作用是把常量、变量或表达式的值传递给形参。
按照C语言的规定，在参数传递过程中，将实参的值复制给形参。这种参数传递是单向的，
只允许实参把值复制给形参，而形参的值即使在函数中改变了，也不会反过来影响实参。
[例2.7]设计一个函数Swap实现两个整数变量值的交换。
代码2.8直接将待交换的两个整数传入函数Swap中。由于C语言的函数参数是值传递，所
以尽管函数Swap 中将形参X和Y的值进行了交换，但是main 函数中的X和Y的值始终没有改
变。程序输出结果为：
X=10,Y=20
#include <stdio.h>
void Swap(int x,int Y)
/*错误的交换函数·/
int tmp;
tmp=X;X=Y;Y=tmp;
int main()
int X=10,Y=20;
Swap(X,Y);
printf("X=8d,Y=8d",X,Y);
return 0;
代码2.8 无法实现变量值交换的Swap 函数
44 第2章 数据结构实现基础
为了真正达到交换这两个变量的值，就需要将变量的地址作为函数参数，然后通过访问变量
地址来修改变量的值。代码2.9可以输出正确结果：
X=20,Y=10
#include <stdio.h>
void Swap(int *X,int *Y)
/*正确的交换函数/
int tmp;
tmp=*X;*X=*Y;*Y=tmp;
int main()
int X=10,Y=20;
Swap(&X,&Y);
printf("X=8d,Y=d",x,Y);
return 0;
代码2.9 通过传递变量地址实现变量值交换
Swap 函数之所以能够实现main 函数中X和Y的数值交换，是因为Swap 函数的指针形参接
受了实参传送过来的X和Y的地址，并通过两个指针对换了main 函数中的X和Y的数值。
C语言要求函数先定义后调用，将主调函数放在被调函数的后面，就像变量先定义后使用一
样。如果主调函数放在自定义函数的前面，就需要在函数调用前，加上函数原型声明。如果不声
明，编译时会默认调用函数是int类型。
函数声明的目的主要是说明函数的类型和参数的情况，以保证程序编译时能判断对该函数
的调用是否正确并进行相应的编译处理。函数声明的一般格式为：
函数类型 函数名(参数表);
在设计函数时，注意掌握以下原则。
(1)函数功能的设计原则：结合模块的独立性原则，函数的功能要单一，不要设计多用途的
函数，否则会降低模块的聚合度。
(2)函数规模的设计原则：函数的规模要小，尽量控制在50行代码以内，这样可以使得丽数
更易于维护。
(3)函数接口的设计原则：结合模块的独立性原则，函数的按口包括函数的参数(入口)和
2.3 流程控制基础 45
返回值(出口),不要设计过于复杂的接口，合理选择、设置并控制参数的数量，尽量不要使用全
局变量.否则会增加模块的耦合度。
2.递归函数
一个函数除了可以调用其他函数外，C语言还支持函数直接或间接调用自己。这种函数自
己调用自己的形式称为函数的递归调用，带有递归调用的函数也称为递归函数。
从递归函数的程序编写角度看，有两个关键点必须紧紧抓住。
(1)递归出口：即递归的结束条件，到何时不再递归调用下去。
(2)递归式子；当前函数结果与准备调用的函数结果之间的关系，如求阶乘函数
Factorial(N)=N* Factorial(N-1)。
递归程序设计是一个非常有用的工具，可以解决一些用其他方法很难解决的问题。但递归
程序设计的技巧性要求比较高，对于一个具体问题，要想归纳出递归式子有时是很困难的，并不
是每个问题都像求阶乘函数Factorial那样直截了当。
当函数调用自己时，每一次调用都会产生一个新的、同先前调用相独立的版本。因此递归调
用并不能减少空间消耗，相反大多数情况下采用递归操作会大大消耗内存；同样，递归也无法提
高程序运行速度。递归函数的主要优点是可以把算法写的比使用非递归函数时更清晰更简洁，
相对其他方法，递归能更加自然的反映问题的解决过程，而且在程序的理解和调试方面，递归也
更容易让人接受。
下面我们来看几个有关递归程序的例子。
[例2.8]设计函数求N!
利用递归函数求整数的阶乘是个很经典也很简单的问题。这个问题的递归函数设计相对直
接，如代码2.10所示。
int Factorial(int N)
if(N==0)
return 1;
else
return N* Factorial(N-1);
代码2.10 阶乘函数的递归实现
图2.7表示了调用Factorial求4!的过程。从Factorial(4)到Factorial(0)的各箭头表示递
归过程，而从Factorial(0)到Factorial(4)的箭头是从基础求解返回的过程和结果。
在上述递归过程中，N=0是递归函数Factorial的出口条件，即递归结束条件。
[例2.9]汉诺塔(Tower of Hanoi)问题。
汉诺塔问题来自于一个古老的传说。传说印度的主神梵天做了一个汉诺塔，它是在一个黄
46 第2章 数据结构实现基础
铜板上插3根宝石针，其中一根针上从上到下按从小到大的顺序串上了64个金片。梵天要求僧
侣们轮流把金片在3根针之间移来移去，规定每次只能移动一片，且不许将大金片压在小金片
上，并说如果这64片金片全部移至另一根针上时，世界就会在一声霹雳之中毁灭。
24
Factorial(4) 6-
4·Factorial(3) 2
3*Factorial(2) 1
1
2* Factorial(l)
1+Factorial(O)
图2.7 递归求解4!的过程
图2.8(a)表示了有n个金片汉诺塔的初始状态，n个金片串在第一根针上。问题要求将金
片从第一根针上挪到第三根针上。
(a)初始状态 (b)中间状态
图2.8 汉诺塔问题
即使金片的片数n不大，如果按要求一步步挪动起来，其过程也是十分繁琐的。但从递归的
角度考虑，问题将变得简单。我们先不要考虑小金片如何移动，而是看最下面的金片要完成从第
一根针(起始位置)到第三根针(目标位置)的移动所必须满足的状态。此时，一定会移成图
2.8(b)所示的情况，即起始位置上只剩一个最大的金片，其余 n-1个移到第二根针(过渡位置)
上.目标位置没有任何金片。这样.n个金片移动问题变成了，n-1个金片从起始位置移到过渡
位置，然后将起始位置上剩下的一个金片移到目标位置。最大一个金片移好后，问题变成了n-1
个金片如何从第二个针(被看作新的起始针)移到目标位置的问题了。依次类推，直到完成整个
移动为止。
根据上述分析，我们可以用递归方法来求解汉诺塔问题.也就是将n个金片的移动问题转换
为2个n-1个金片的移动问题。首先需要考虑的是函数参数的设计。当然，金片个数肯定是一
个参数：金片移动涉及到起始位置和目标位置，所以这些位置也应该是参数。另外，在将n个金
片的移动问题转换为n-1个金片的移动问题时还需要一个过渡针，所以过渡针也需要作为参
数。这三类针我们可以用整数1.2、3来表示。因此，拟设计的递归函数Move应该由四个整型变
量作为参数，即：
2.3 流程控制基础 47
void Move(int n,int start,int goal,int temp)
其中，n代表金片个数，start、goal和 temp分别代表当前的起始针、目标针和过渡针。这样，
汉诺塔问题实际上就是求解：
Move(64,1,3,2);/*将64个金片从1号针移到3号针，2号针为过渡针*/
按上述递归分析过程，这个问题可以转变为：
Move(63,1,2,3);/*将63个金片从1号针移到2号针，将3号针为过渡针*/
printf("Move disk 64 from tower I to tower 3.\n");
Move(63,2,3,1);/*将63个金片从2号针移到3号针，1号针为过渡针 */
此时，问题已变成比原始问题少一个金片的汉诺塔移动问题了。照此递归地求解下去，当
n=1时，就不需要再递归了。代码2.11给出了递归求解汉诺塔问题的函数。
void Move(int n.int start,int goal,int temp)
if(n>1)|
Move(n-1,atart,temp,goal);
printf("Move disk d from d to d.n",n, start,goal);
Move(n-1, temp,goal,start);
/* else当n==1时不需要做任何事*/
代码2.11 汉诺塔问题的递归函数
为了加深对递归的理解，我们跟踪一下n=3时，函数的执行过程。
设金属片数为3,在主程序中用语句Move(3,1,3,2)调用递归函数，程序的执行过程可用图
2.9所示的递归树表示。在图2.9中，函数Move用一个黑盒子表示，我们称之为树的结点，第一
次进入Move 函数的点称为树的根结点，在函数内部再次调用进入 Move的点称为子结点，反过
来引起子结点调用的函数点是父结点，它们之间边表示这种父子(或调用和被调用)关系。可以
看出，除了根结点外，每个结点都有父结点。
每次递归调用进入一个黑盒子表示的结点，在结点内执行程序可能的行为为：
(1)当n>1时，执行函数中的第一个递归调用语句，递归层次加深。图2.9中用有向实线表
示进入其子结点，并在相应的边的右侧用函数调用形式 Move(a,b,c,d)标识出参数的具体值。
(2)当n=1时，程序不执行任何语句，递归返回上一层。图2.9中用有向虚线表示进入其
父结点。
(3)每当递归返回，紧接着执行printf语句输出一次移动金片结果。图2.9中用输出图形符
号列出输出结果，并在其旁边用带圈的数字标识出输出的顺序。
48 第2章 数据结构实现基础
Move disk 2 from I to 2 Move
(3,1,3,2) ④|Move disk 3 from I to 3
①
②
Move 口
(2,1,2,3) Move
(2,2,3,1) Move disk 2 from 2to 3
⑥
①
Move Move D Move
(1,3,2,1) Move
(1,1,3,2) (1,1,3,2) (1,2,1,3)
■
Move Move I Move Move
(0,1,2,3) (0,2,3,1) (0,1,2,3) (0,3,2,1) Move
Move Move (0,2,3,1) Move
(0,3,1,2) (0,2,3,1) (0,1,2,3)
0 I
①
①
① Move disk I from 2 to1
Move disk I from I to 3
j③
①
⑦
j①
Move disk I from 3 to2 Move disk I from I to 3
图2.9 Move(3.1.3.2)的递归树
[例2.10]用递归方法求集合的中位数。
在本章开头的基本统计问题中，有一个操作是求集合的中位数。这个问题可以建立在求集
合笫K大元素问题上，也就是当K等于集合大小一半时，第K大元素就是中位数。
在2.1节中我们也给出求集合S中第K大数的基本算法思路，也就是；选取S中的第一个元
索e,根据e将集合S分解为{e|和大于等于c的元素集合S?、小于。的元素集合S?;然后通过判
别集合S,的大小，将从S集合中找第K大数问题转换为在S,或S,中的查找问题。由于S?或S?
的集合规模都比S小，这样就将复杂问题转换为规模相对小的问题.这也是递归函数设计的
基础。
2.3 流程控制基础 49
在我们确定好用递归方法解决上述问题时，还需要解决以下两个关键问题：
(1)如何根据元素e将集合S分解为S?和S?两个集合?一种简单的方法是，应用一个临时
数组，对集合S(也存放在数组中)的元素进行遍历，如果当前元素比e大(或值相等，但不是e),
则放到临时数组的一头，否则放到临时数组的另一头。这种方法思路比较简单且分解集合的时
间复杂性是0(n),但需要一个额外的数组空间。而代码2.12给出了一种保持时间复杂性是
O(n)且不需要额外数组空间的集合分解方法：先从数组左边扫描，如果发现比e小的元素则暂
停；再从数组右边扫描，遇到大于等于e的元素则哲停。此时左右两个暂停点的元素是错位的，
把它们交换一下。然后从左右暂停点开始重复上述步骤，直到左右扫描在中间某处相会。此时
相会的位置就是基准e把两个集合分开的位置，把e换到这个位置上，S?中的元素就被放在e的
左边，S?中的元素就被放在e的右边。
(2)如何设计递归函数的参数?如果我们用数组S来存储集合，当然S需要作为参数，K也
是个参数；在递归过程中，我们将集合S分解为S,和S,两个集合，而这两个集合也是存放在数组
S中，所以我们需要用集合S在数组中的左右边界来表示当前处理的集合。
代码2.12给出了求第K大数的递归函数。
void Swap(ElementType·x,ElementType *Y)
1/*交换X和Y两个元素*/
ElementType tmp;
tmp=*X;X=*Y;Y=tmp;
ElementType FindKthLargest(ElementType s[],int K,int Left,int Right)
1/*在S[Left]...S[Right]中找第K大元素*/
ElementType e=S[Left];/*简单取首元素为基准*/
int L=Left,R=Right;
while(1)/*将序列中比基准大的移到基准左边，小的移到右边*/
while((Left<=Right)&&(e<=s[Left])) Left++;
while((Left<Right)&(e>S[Right])) Right--;
if(Left<Right)
Swap(&S[Left],&S[Right]);
else break;
Swap(&S[ Left-1],&S[L]);/* 将基准换到两集合之间·/
if((Left-L-1)>=K)/*(Left-L-1)代表了集合S1的大小*
return FindKthLargest(S,K,L,Left-2):/* 在集合S1中找*/
else if((Left-L-1)<K-1)/* 在集合S2中找*/
50 第2章 数据结构实现基础
return FindKthLargest(S,K-(Left-L-1)-1,Left,R);
else
return e;/*找到，返回*/
代码2.12 求第K大数的递归函数
求集合S的中位数就可以简单调用代码2.12中的函数实现，如代码2.13所示。
ElementType Median(ElementType s[],int N)
return FindKthLargest(s,(N+1)/2,0,N-1);
代码2.13 通过调用第K大数的函数求中位数
本 章 小 结
本章回顾了作为本课程重要基础的C语言程序设计的一些重点内容，包括数据存储、流程
控制、函数及递归等方面的基础知识。
C语言除提供标准数据类型外，还提供了数组、结构、指针等构造复杂数据类型的方法。数组
是同类数据在存储空间上的连续有序组织，是实现数据结构的重要存储手段。结构可以将不同类
型的数据组织在一起形成一个整体。结构与指针的结合是构成链表的基础。链表不仅在存储有序
序列方面具有动态、灵活的特点，而且也是实现更复杂数据结构(比如树、图)的重要方法。
程序设计语言的流程控制是算法实现的基本依赖。按照结构化程序设计的观点，任何程序
都可以将模块通过顺序、分支和循环这三种基本的控制结构组合来实现。一般程序设计语言都
提供了表达分支控制和循环控制的手段。程序设计语言还提供了描述程序独立模块的方法，即
函数。函数通过一系列语句的组合来完成某种特定的功能，并可以被一个或多个函数(包括自
已)多次调用。其中，自已直接或者间接调用自已的函数称为递归函数。递归是一项非常重要
的编程技巧，将在数据结构的后继内容中大量出现。递归函数设计时需要注意：递归的出口、每
次调用应该是更接近于解。另外，每次递归时，递归函数会占用一些资源(如系统内存、系统堆
栈空间)。当递归函数退出时，这些资源才会破释放。所以，当函数的递归层次过多时，就有可
能会用尽所有可用的资源。
通过本章学习，重点是要深入掌握链表和递归方面的内容，从而为后继内容的学习打下基础。
习题
2.1 请编写程序模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数.4
习题 51
种运算符的优先级相同，按从左到右的顺序计算。
2.2 请编写程序将一个大小为n的整数数组循环左移m位。如：1,2,3,4,5,6,7,8循环左移三位后结果
是：4,5,6,7,8,1,2,3。
2.3 请编写程序，输人整数n和a.输出S=a+aa+aaa+…+aa…a(n个a)的结果。
2.4 请编写函数在递增的整数序列链表中插入一个新整数，并保持该序列的有序性。
2.5 请编写函数将两个链表表示的递增整数序列合并为一个递增的整数序列。请直接使用原序列中的
结点。
2.6 请编写一个递归函数计算下列式子：
f(x,n)=x-x2+x3-x+…+(-1)?'x".(n>0)
2.7 设有一个球从高度为h米的地方落下，碰到地面后又弹到高度为原来0.9倍的位置，然后又落下，再
弹起，再落下……请编写递归和非递归函数，求初始高度为h的球下落后到基本停下来(高度小于10:°米)时在
空中所经过的路程总和。
2.8 请编写递归函数，输出1,2,3,…,n的全排列(n小于10),并观察n逐步增大时程序的运行时间。
2.9 请思考一下，是否可以设计一个递归过程，实现对n个整数的排序。可以考虑两种不同的递归过程：
(1)将n个整数的排序问题转换为对n-1个整数排序问题的递归；(2)将n个整数的排序问题转换为对两个
n/2个整数排序问题的递归。
第3章
线性结构
3.1 引子
在数据的逻辑结构中，有种常见而且简单的结构是线性结构，即数据元素之间构成一个有序
的序列。下面我们先看一个例子。
[例3.1]一元多项式及其运算。 一元多项式的标准表达式可以写为：f(x)=ao+a,x+…+ax1+a.x°。与一元多项式相关的
主要运算是：多项式相加、相减、相乘等。如何在计算机中表示一元多项式并实现相关的运算?
[分析]首先，我们考虑一下如何表示多项式的问题。可以看出，决定一个多项式的关键数
据是：多项式项数n、每一项的系数a,(当然也涉及相应指数i)。如果能直接或间接地保存这些
数据，那就意味着在计算机里保存了一个一元多项式。我们来讨论3种不同的方法。
方法1:采用顺序存储结构直接表示一元多项式。
用一个数组a存储多项式的相关数据：数组分量a[i]表示项x的系数a,即用数组分量下
标对应相应项的指数，而数组分量值就是系数。数组中非零的分量个数就等于多项式的项数。
例如，4x3-3x2+1可以用图3.1中的数组表示。
下标
a[i]
0 1 2 3 4 5
1 0 -3 0 0 4
…
图3.1 多项式的数组直接表示法
这种表示方法，在一般情况下对实施多项式运算还是比较方便的。比如，要实现两个多项式
相加，只要把两个数组对应分量项相加就可以了，显然程序很容易编写。但它存在着重大的问
题，即在多项式比较稀疏*的情况下，时间和空问效率都会比较差。比如表示1+2x00这样的多
项式，就必须采用一个大小至少为30001的数组，而在这个数组中绝大部分数据为0,只有两项
不为0,显然空间浪费很厉害。而要将之与多项式x+3x200加在一起，则必须遍历30001+2001个
数组元素.虽然这两个多项式一共只有4个非零项，可见时间效率也很低。
因此，在多项式比较稀疏的情况下，最好只存储非零项的信息，其他项不用为之浪费空间。
指多项式有比较高的阶，但只有很少非零项。
3.1 引 子 53
于是有了第二种表示方案。
方法2:采用顺序存储结构表示多项式的非零项。
每个非零项a,x2涉及两个信息：指数i和系数a,。因此，可以将一个多项式看成是一个(a:,i)
二元组的集合。为了以后多项式运算方便，我们可以按照指数下降的顺序组织这个二元组。所
以，可以把多项式看成是(a,i)二元组的有序序列|(a,n),(a1,n-1),….(a。,0)|。
我们可以用一个结构数组来存储以上系数非零项二元组的有序序列。数组的大小可以根据
非零项的最多个数来确定，而不是根据多项式的阶数来确定。显然，这样的表示方法，对于稀疏
多项式的情况能节省大量空问。但是如果多项式不是很稀疏，则空间节省的优势就没有了，甚至
需要的空间更多。
图3.2给出了用结构数组表示两个给定多项式P,(x)=9x"+15x*+3x2和P?(x)=26x1"-4x?-
13x°+82的例子。
数组下标i 0 1 2
9 15 3
12 8 2
…
数组下标 0 1 2 3
…
系数 系数
指数 指数
(a)P?x)-9x2+15x+3x2 (b)P?(x)=26x1°-4x2-13x?+82
图3.2 多项式非零项的结构数组表示
当多项式的存储采用方法2时，相应的运算实现(如多项式相加)显然就比方法1更加复杂
一些。
例如，实现两个多项式相加，可采用以下策略：分别从头开始查看两个多项式中的每一项，如
果当前两项的指数不一样，那就将指数大的那一项“拷贝”到结果多项式中；如果它们的指数一
样而且对应系数和不为0,那么就在结果多项式中增加一个系数为它们之和的新项。
对于图3.2中的例子，这两个多项式的相加过程基本是这样：
(1)比较(9,12)和(26,19),将(26,19)移到结果多项式；
(2)继续比较(9,12)和(-4,8),将(9,12)移到结果多项式；
(3)比较(15,8)和(-4,8),15+(-4)=11,不为0,将新的一项(11,8)增加到结果多项式；
(4)比较(3,2)和(-13,6),将(-13,6)移到结果多项式；
(5)比较(3,2)和(82,0),将(3,2)移到结果多项式；
(6)将(82,0)直接移到结果多项式。最后得到的结果多项式是：((26,19),(9,12),(11,
8),(-13,6),(3,2),(82,0)),即多项式：
P?(x)=26x1°+9x2+ 11x?-13x?+3x2+82
用数组表示的一个问题是灵活性不够。由于事先无法知道多项式可能的非零项数，因此我
们只能根据可能的最大值事先确定数组大小；如果实际非零项数比较小时，空间的浪费同样严
重。更进一步的解决方法是利用链表存储一维的有序序列，相比于数组表示，更具有灵活性。
26 -4 -13 82
19 8 6 0
54 第3章 线 性 结 构
方法3:采用链表结构来存储多项式的非零项。
用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数和指数两个数据
域以及一个指针域，其结点结构可以表示为：
对应的数据结构定义为：
typedef struct PolyNode*PtrToPolyNode;
typedef struct PolyNode
int Coef;
int Expon;
PtrToPolyNode Next;
typedef PtrToPolyNode Polynomial;
例如，前面提到的两个多项式P?(x)=9x2+15x?+3x2和P?(x)=26x1-4x?-13x?+82的链表
存储形式如图3.3所示。
PI
P2
9 12
26 19
图3.3 多项式非零项的链表表示
如果要实现链表表示的两个多项式相加，采用的方法与结构数组表示的方法非常相似，具体
实现见本章最后一节。
从前面例子中，读者应该能感受到，数据结构的操作与数据结构的存储方式是密切相关的。
不同的数据存储方式，相应的操作实现方法是不一样的。比如，如果用数组直接存储，那么多项
式的加法运算通过简单的数组相加就可以实现，而如果采用链表来记录非零项.那么多项式的相
加运算就要复杂得多。这两种方式比较起来，在多项式非零项相对较少的情况下，前者实现简
单，但时间和存储空问浪费大；后者实现起来复杂，但时间和空间效率较高。所以，数据结构的设
计往往需要在算法可理解性与时间、空间效率之间做出折中，针对具体问题选择合适的数据结构
及设计相应的算法。
[例3.2]前面我们分析了一元多项式的表示，更进一步地，二元多项式该如何表示?比如，
给定二元多项式；9x2y2+4x"+15x"y3-x"y+3x2。
[分析]可以拓展一元多项式的表示方法来表示二元多项式，即我们可以把二元多项式按照
一元多项式方法来组织。比如，可以将上述二元多项式看成关于x的一元多项式：(9y2+4)x"+
(15y'-y)x+3x2。其中，一元多项式中的常量系数在这里就成了关于y的一元多项式。同样，我
们可以采用链表结点表示多项式的各个非零项，原来结点中的表示系数的域就成了指向关于y
的一元多项式链表的指针域。所以，上述二元多项式可以用链表表示如图3.4所示。
Coef Expon Next
15 8 3 2 NULL
-4 8 -13 6 82 0 NULL
3.2 线性表的定义与实现 55
P 12
9 2
图3.4 二元多项式非零项的链表表示
上述二元多项式是按照x的指数组织的一个有序序列。在该序列中，既包含纯粹的“(系
数，指数)"项，也有包含一元多项式(当然也是个有序序列)的项。类似这种可能包含子序列的
有序序列就是一种广义表，本章第2节中将有进一步介绍。
在前面关于多项式的例子中，我们将多项式问题抽象为由系数和指数所构成的二元组有序
序列的存储与操作问题。有序序列的存储与操作问题，是一类比较有共性的问题，如：银行等候
队列的管理、班级学生的管理、计算机中空闲内存的管理等。
我们可以研究更一般的有序的对象序列的组织与管理方法，其基本操作包括：插人元素、删
除元素等，这类问题就是我们本章要研究的线性表，也是一类典型的数据结构。
本章将介绍线性表的抽象定义，并分别讨论基于顺序存储和链式存储的线性表的实现方法。
同时将介绍两种典型且应用广泛的线性表：堆栈和队列。线性表的基本操作是插入和删除，堆栈
是插人和删除操作只发生在同一端的线性表，而队列的插入和删除操作则分别发生在有序序列
的两端，即一端只做插入，另一端只做删除。
3.2 线性表的定义与实现
3.2.1 线性表的定义
线性表(Linear List)是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素
的个数称为线性表的长度；当一个线性表中没有元素(长度为0)时，称为空表；表的起始位置称
表头，表的结束位置称表尾。
线性表的抽象数据类型描述为：
类型名称：线性表(List)
数据对象集：线性表是n(n≥0)个元素构成的有序序列(a?,a?,…,a。),其中a,是表的第一
个元素(表头),a。是表的最后一个元素(表尾);a.称为a,的直接后继，a为a,的直接前驱；直
接前驱和直接后继反映了元素之间一对一的邻接逻辑关系。
操作集：对于一个具体的线性表L∈List,一个表示位序的整数i,一个元素X∈ElementType
15 3 -1 1 NULL
8 3 2 NULL
4 0 NULL
56 第3章 线性结 构
线性表的基本操作主要有：
(1)List MakeEmpty():初始化一个新的空线性表；
(2)ElementType FindKth(List L,int i):根据指定的位序i,返回L中相应元素a?;
(3)Position Find(List L,ElementType X):已知X,返回线性表L中与X相同的第一个元素
的位置；若不存在则返回错误信息；
(4)bool Insert(List L,ElementType X,int i):在L的指定位序i前插入一个新元素X;成功则
返回true,否则返回 false;
(5)bool Delete(List L,int i):从L中删除指定位序i的元素；成功则返回 true,否则返回 false;
(6)int Length(List L):返回线性表L的长度。
3.2.2 线性表的顺序存储实现
线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素。在
程序设计语言中，一维数组在内存中占用的存储空间就是一组连续的存储区域，因此，用一维数
组来表示顺序存储的数据区域是再合适不过的。
考虑到线性表的运算有插入、删除等，即表的长度是动态可变的，因此，数组的容量需设计得足
够大。假设用Data[MAXSIZE]来表示，其中MAXSIZE是一个根据实际问题定义的足够大的整数，
线性表中的数据从Data[0]开始依次顺序存放。由于当前线性表中的实际元素个数可能未达到
MAXSIZE多个，因此需用一个变量Last 记录当前线性表中最后一个元素在数组中的位置，即Last
起一个指针(实际是数组下标)的作用，始终指向线性表中最后一个元素。表空时Last=-1。
这样表示的顺序表如图3.5所示。当前表长为Last+1,数据元素a?,a?,…,a。分别存放在
Data[0]到Data[ Last]中。
i 0 1
…
-1 1
…
n-1
…
a? a?
…
a, a
…
a
… MAXSIZE-1
Data
Last
图3.5 线性表的顺序存储示意
为了体现数据组织的整体性，通常将数组 Data和变量Last 封装成一个结构作为顺序表的类型：
typedef int Position;
/*这里的位置就是数组的整型下标，从0开始。前面提到的位序是指第几个，从1开始*
typedef struct LNode+PurToLNode;
struct LNode
ElementType Data[MAXSIZE]:
Position Last:
:
3.2 线性表的定义与实现 57
typedef PtrToLNode List;
由于LNode是一个包含数组的结构，当我们实现各种针对顺序表的操作时，直接将该结构
作为函数参数传递显然不是个好方法，使用结构指针传递效率更高，所以我们把List 定义为结构
指针。这样，我们可以利用List 定义线性表L:
List L;
通过L我们可以访问相应线性表的内容。比如下标为i的元素可以通过L->Data[i]访问，
线性表的长度可以通过L->Last+1得到。
下面将介绍在上述存储方式基础上相应主要操作的实现。
1.初始化
顺序表的初始化即构造一个空表。首先动态分配表结构所需要的存储空间，然后将表中
Last指针置为-1,表示表中没有数据元素。具体实现如代码3.1所示。
List MakeEmpty()
I List L;
L=(List)malloc(sizeof(struct LNode));
L->Last=-1;
return L;
代码3.1 顺序表的初始化
2.查找
顺序存储的线性表中，查找主要是指在线性表中查找与给定值X相等的数据元素。由于线性
表的元素都存储在数组 Data中，所以这个查找过程实际上就是在数组里的顺序查找：从第一个元
素a,起依次和X比较，直到找到一个与X相等的数据元素，返回它在顺序表中的存储下标；或者查
遍整个表都没有找到与X相等的元素，则返回错误信息ERROR。顺序表的查找如代码3.2所示。
#define ERROR-1/*将错误信息 ERROR的值定义为任一负数都可以*/
Position Find(List L,ElementType x)
Position i=0;
while(i<=L->Last &&L->Data[i]!=X)
i++;
if(i>L->Last) return ERROR;/*如果没找到，返回错误信息*/
else return i;/*找到后返回的是存储位置*/
代码3.2 顺序表的查找
58 第3章 线性 结 构
在Find 函数中的主要运算是比较。显然比较的次数与X在表中的位置有关，也与表长有
关。当a,恰好等于X时，比较一次成功；当a。等于X时比较n次成功。查找成功的平均比较次
数为(1+2+…+n)/n=(n+1)/2,即平均时间复杂度为0(n)。
3.插入
顺序表的插入是指在表的第i(1≤i≤n+1)个位序上插入一个值为X的新元素(也可以
理解为在第i个元素之前插人新元素),插入后使原长度为n的数组元素系列(a?,a?,…,
a,a,,a…,a)成为长度为n+1-的序列(a?,a?,…,a,X,a,,a体…,a)。当插入位
序i为1时，代表插入到序列最前端；为n+1时，代表插入到序列最后。
顺序表的插入如代码3.3所示，完成这一运算是通过以下步骤进行的：
(1)将a,~a,顺序向后移动(移动次序是从a。到a),为新元素让出位置；
(2)将X置入空出的第i个位序；
(3)修改Last 指针(相当于修改表长),使之仍指向最后一个元素。
bool Insert(List L,ElementType x,int i)
I/在L的指定位序i前插入一个新元素x;位序1元素的数组位置下标是i-1*/
Position j;
if(L->Last==MAXSIZE-1)I
/*表空间已满，不能插人*/
printf("表满“);
return false;
if(i<1|i>L->Last+2)I
/*检查插入位序的合法性：是否在1-n+1。n为当前元素个数，即Last+1*/
printf(·位序不合法");
return falce;
for(j=L->Last:j>=i-1:1--)/*Last 指向序列最后元素a.·/
L->Data[3+1]=L->Data[1]:/x将位序1及以后的元素顺序向后移动·
L->Data[1-1]=x:/市新元素插入第1位序，其数组下标为1-1+/
L->Last++; +Laot仍指向最后元素·
return true;
代码3.3 顺序表的插人
本函数中注意以下问题：
(1)顺序表中数据区域有MAXSIZE 个存储单元，所以在向顺序表中做插入时先检查表空间
3.2 线性表的定义与实现 59
是否满了，在表满的情况下不能再做插入，否则产生溢出错误。
(2)要检验插人位序的合法性，这里i是指元素序号而非数组中的下标，有效范围是1≤i≤
n+1,其中n为原表长。所以，代码3.3中i检查的是1到L->Last+2这个范围(L->Last 值是
n-1),当i为n+1时代表插入到现有表的表尾。
(3)注意数据的移动次序和方向。
顺序表上的插入运算，时间主要消耗在数据的移动上。在第；个位序上插人X,从a,到a。
都要向后移动一个位置，共需移动n-i+1个元素，而的取值范围为1<i<≤n+1,即有n+1个位置
D(a-i+1)。 可插人。设在第i个位置上做插人的概率为p,,则平均移动数据元素的次数为
D.(a-i+1)-(a-i+1)=2。 在等概率情况下，即p=1/(n+1)时，平均移动次数则为
这说明：在顺序表上做插入操作平均需移动表中一半的数据元素，显然时间复杂度为
0(n)。
4.删除
顺序表的删除运算是指将表中位序为i(1≤i≤n)的元素从线性表中去掉，删除后使原长
度为n的数组元素序列(a?,a?,…,a,a,,a…,a.)成为长度为 n-1的序列(a?,a?,…,
a,a…,a)。
顺序表的删除如代码3.4所示，完成这一运算的步骤如下：
(1)将a~a。顺序向前移动，a,元素被a.覆盖；
(2)修改Last 指针(相当于修改表长)使之仍指向最后一个元素。
bool Delete(ListL,int i)
1/从L中删除指定位序i的元素，该元素数组下标为i-1*/
Positionj;
if(i<1 |i>L->Last+1)1/*检查空表及删除位序的合法性*/
printf(·位序8d不存在元素",i);
return false;
1
for(j=i;j<=L->Last;j++)
L->Data[j-1]=L->Data[j];/*将位序i+1及以后的元素顺序向前移动·/
L->Last--;/*Last仍指向最后元素*/
return true;
代码3.4 顺序表的删除
60 第3章 线 性 结 构
本函数中注意以下问题：
(1)删除位序为i的元素，i的取值必须为1≤i≤n,否则该元素不存在，因此，要检查删除位
置的合法性。代码3.4中的i检查的是1到L->Last+1这个范围的值。
(2)当表空时不能做删除，因表空时L->Last的值为-1,条件(i<1|li>L->Last+1)也包括
了对表空的检查。
(3)删除a,之后，该数据已不存在。如果需要用，可先取出a,再做删除。
与插入运算相同，其时间主要消耗在了移动表中元素上，删除位序为i的元素时，其后面
的元素a~a。都要向前移动一个位置，共移动了n-i个元素，所以平均移动数据元素的次数
p(n-i)=—(n-i)= 为∑p(n-i)。在等概率情况下，即p.=1/n时，平均移动次数则为 “。
这说明顺序表上作删除运算时平均需要移动表中一半的元素，显然该算法的时间复杂度为
0(n)。
3.2.3 线性表的链式存储实现
由于顺序表的存储特点是用物理上的相邻实现了逻辑上的相邻，它要求用连续的存储单元
顺序存储线性表中各元素，因此，对顺序表插入、删除时需要通过移动数据元素来实现，影响了运
行效率。本节介绍线性表链式存储结构，它不需要用地址连续的存储单元来实现，因为它不要求
逻辑上相邻的两个数据元素物理上也相邻，它是通过“链”建立起数据元素之间的逻辑关系，因
此对线性表的插入、删除不需要移动数据元素，只需要修改“链”。
用链表结构可以克服数组表示线性表的缺陷。图3.6为单向链表的图示表示形式，它有
n个数据单元，每个数据单元由数据域和链接域两部分组成。数据域用来存放数值，图中用
a1,a?,…,a。表示。链接域是线性表数据单元的结构指针，用一带箭头的线段表示，线性表的
顺序是用各结点上指针构成的指针链实现的。
head a a? NULL
图3.6 线性表的链表表示
为了访问链表，必须先找到链表的第一个数据单元，因此实际应用中常用一个称为“表头
(Header)”的指针指向链表的第一个单元，并用它表示一个具体的链表。
在第2章中我们已经定义过单链表的结构，线性表的链式存储其实就是单链表结构，这里为
了跟顺序存储结构的接口样式保持一致，我们重新将结点的结构定义如下：
typedef struct LNode-PuToLNode;
struct LNode|
3.2 线性表的定义与实现 61
ElementType Data;
PtrToLNode Next;
I;
typedef PtrToLNode Position;/*这里的位置是结点的地址*/
typedef PtrToLNode List;
同样也可以用List定义具体的表头结点指针，该指针就代表了一个链式表：
List L;
注意到，无论是用顺序存储还是链式存储，我们都用一致的接口(例如都命名为LNode、List、
Position等)定义线性表，因为这两种具体的存储方式都是对同一个抽象概念的实现。
1.求表长
在顺序存储表示的线性表中求表长是容易的事，直接返回Last+1值就可以了。但在链式存
储表示中，需要将链表从头到尾遍历一遍：设一个移动指针p和计数器cnt,初始化后，p从表的
第一个结点开始逐步往后移，同时计数器 cnt加1。当后面不再有结点时，cnt的值就是结点个
数，即表长。具体实现如代码3.5所示，函数的时间复杂度为0(n)。
int Length(List L)
Position p;
int cnt=0;/*初始化计数器·/
p=L;/*p指向表的第一个结点*/
while(p)1
p=p->Next;
cnt++;/*当前p指向的是第cnt个结点*/
return cnt;
代码3.5 求链式表的表长
2.查找
在线性表抽象类型说明中，我们提到线性表的查找有两种，即按序号查找(FindKth)和按值
查找(Find)两种。
(1)按序号查找FindKth。
对于顺序存储，按序号查找是很直接的事情，要得到第K个元素的值，直接取L->Data[K-1]
就可以了。但对于链式存储则需要采用跟求表长类似的思路：从链表的第一个元素结点起，判断
当前结点是否是第K个；若是，则返回该结点的值，否则继续后一个，直到表结束为止。如果没
有第K个结点则返回错误信息。函数实现如代码3.6所示。
62 第3章 线 性 结 构
#define ERROR-1/*一般定义为表中元素不可能取到的值*/
ElementType FindKth(List L,int K)
/*根据指定的位序K,返回工中相应元素·/
Position p;
int cnt=1;/*位序从1开始*/
p=L;/*p指向L的第1个结点*么
while(p &k cnt<K)
p=p->Next;
cnt++;
if((cnt==K) p)
return p->Data;/*找到第K个*/
else
return ERROR;/*否则返回错误信息/
代码3.6 链式表的按序号查找
(2)按值查找，即定位Find。
按值查找的基本方法也是从头到尾遍历，直到找到为止：从链表的第一个元素结点起，判断
当前结点其值是否等于X;若是，返回该结点的位置，否则继续后一个，直到表结束为止。找不到
时返回错误信息。函数实现如代码3.7所示。
#define ERROR NULL/*用空地址表示错误·/
Position Find(ListL,ElementType x)
|Position p=L;/*p指向L的第1个结点*/
while(p && p->Data!=X)
D=p->Next;
下语句可以用 return p;替换*/
if(p)
return p;
else
return ERROR;
代码3.7 链式表的按值查找
3.2 线性表的定义与实现 63
上述两种查找算法的时间复杂度均为0(n)。
3.插入
线性表的插入是在指定位序i(1≤i≤n+1)前插入一个新元素X。当插入位序i为1时，
代表插入到链表的头；i为n+1时，代表插入到链表最后。其基本思路是：如果i不为1,则找
到位序为i-1的结点pre;若存在，则申请一个新结点并在数据域填上相应值X,然后将新结点
插入到结点pre之后，返回结果链表；如果不存在则返回错误信息。函数实现如代码3.8
所示。
Hderine ERROR NULL/*用空地址表示错误。
Liat Insert(ListL,ElementType x,int i)
Position tmp,pre;
tmp=(Position)malloc(sizeof(struct LNode));/申请、填装结点·/
tmp->Data=x;
if(i==1)|/*新结点插入在表头*/
tmp->Next=L:
return tmp;/*返回新表头指针*/
elsel
/*查找位序为i-1的结点*/
int cnt=1;/*位序从1开始*/
pre=L; /*pre指向L的第1个结点*/
while(pre && cnt<i-1)
pre=pre->Next;
cnt++;
if(pre==NULL ||cnt!=i-1)I/*所找结点不在L中*/
printf("插入位置参数错误n");
free(tmp);
return ERROR;
1
else I/*找到了待插结点的前一个结点pre·/
/s.插入新结点，并且返回表头L*/
tmp->Next=pre->Next;
pre->Next=tmp;
return L;
64 第3章 线性 结 构
代码3.8 链式表的插人
注意：在上述函数中表头指针L的值可能会发生变化——当插人发生在表头结点时，L需要指
向新的表头结点(可利用函数返回值对L重新赋值);其他情况下L值不变。所以，在本函数中我
们将L既作为函数参数，同时也作为函数返回值，保证新的L值能够被带回来。但是因为当插
入操作不成功时，返回的指针为NULL,所以我们不能直接用“L=Insert(L,X,i)”来调用函数，而
是必须用一个临时指针接收插入函数的返回值，根据该指针的值判断应该进行什么样的处理。
但是，这样插入函数的接口就跟顺序表的插入函数(见代码3.3)不一致了，也不符合第
3.2.1节中线性表的定义。那么如何与定义的风格保持一致，避免将表头插入作为一种特殊情
况处理呢?一种解决的方法是为链表增加一个空的“头结点”,真正的元素链接在这个空结点之
后。这样做的好处是，无论在哪里插入或者删除，L的值一直指向固定的空结点，不会改变。代
码3.9给出了带头结点的链式表的插人函数，插入算法的时间复杂度为0(n)。
bool Insert(List L,ElementType x,int i)
|/*这里默认L有头结点·/
Position tmp, pre;
int cnt=0;
/*查找位序为i-1的结点·/
pre=L;/*pre指向表头·/
while(pre cnt<i-1)
pre-pre->Next;
cnt+;
if(pro==NULL lcnt!=1-1)/+所找结点不在工中·
printr(“桶人位置参数错误n”);
returnfalae;
else1/找到了待插结点的前一个结点pre:若1为1.pre就指向表头-
/*插人新结点*/
tmp=(Position)malloc(olzeof(struct LNode));人申请、填装结点*
tmp->Data=X;
tmp->Next=pre->Next;
pro->Next=tmp:
3.2 线性表的定义与实现 65
return true;
代码3.9 带头结点的链式表的插入
4.删除
在单向链表中删除指定位序i的元素，首先需要找到被删除结点的前一个元素，然后再删除
结点并释放空间。代码3.10是带头结点的链式表的删除。函数的时间复杂度为0(n)。
bool Delete(Llst L.int i)
1/·这里默认L有头结点·/
Position tmp,pre;
int cnt=0;
/*查找位序为i-1的结点*/
pre=L;/*pre指向表头*/
while(pre && cnt<i-1){
pre=pre->Next;
cnt++;
if(pre==NULL |Ⅱcnt!=i-1|l pre->Next==NULL)
/*所找结点或位序为i的结点不在L中*/
printf("插入位置参数错误n");
return false;
else |/*找到了待删结点的前一个结点pre*/
/*将结点删除·/
tmp=pre->Next;
pre->Next=tmp->Next;
free(tmp);
return true;
代码3.10 带头结点的链式表的删除
从链式线性表的插人、删除的程序实现中可以看出：
(1)在单链表上插入、删除一个结点，必须知道其前驱结点。
(2)单链表不具有按序号随机访问的特点，只能从头指针开始一个个顺序进行。
66 第3章 线性 结 构
前面我们讨论的主要是以单向链表的形式存储线性表，这样的结构可以使每个结点找到
其后继结点很容易，但要找到其前驱结点，必须从链表头开始查找。如果我们需要前后查找
都很容易，则可以采用双向链表表示，但它占用的空间也相对大些，因为每个结点都需要两个
指针域。
3.2.4 广义表与多重链表
1.广义表
首先我们来看一个例子，就是如何表示一个单位的人员情况。一种简单的表示方法是用一
个线性表来表示，其先后顺序按照进单位的时间顺序排列：
(张三，李四，王五，钱六，孙七，……)
但如果这些人又分布在同一单位的三个不同部门，比如办公室、生产部、销售部，我们又希望
表示每个人与哪些人是一个部门的，那么可以用三个有序序列的子表构成的线性表来表示：
((张三，……),(李四；孙七，……),(王五，钱六，……))
如果想突出表示这个单位的负责人是谁，可将负责人作为表的第一元素：
(丁一，(张三，……),(李四，孙七，……),(王五，钱六，……))
上述这类表就是一种广义表(Generalized List)。广义表是线性表的推广。广义表与线性
表一样，也是n个元素组成的有序序列。其不同点在于，对于线性表而言，n个元素都是基本
的单元素；而在广义表中，这些元素不仅可以是单元素也可以是另一个广义表。广义表在人
工智能、文本处理等领域有广泛的应用。例如，人工智能领域中的表处理语言LISP的实现就
是将广义表作为基本的数据结构。广义表不仅跟线性表一样可以表达简单的线性顺序关系，
而且可以表达更复杂的非线性多元关系。比如，以后我们会讲到的树，就可以用广义表的方
式来表示。
广义表一般记为：GList=(a?,a?,…,a-,a,a…,a),其中，a,可以是单元素，也可以是广
义表。
由于广义表中的元素可以有不同的结构(单元素或者广义表),因此不适合采用顺序存储方
式表示，通常采用链式存储结构，也就是用由结点组成的链表来表示广义表，结点对应每个元素；
如果该元素还是一个广义表，则通过该结点引申出另一个链表。
广义表中的结点可能有两种情况：
(1)单元素，需要有一个域来存储该单元素的值；
(2)广义表，需要有一个域来指向另一个链表。对于每个结点来说，上述两个域只可能需要
其中的一种，所以.我们可以利用C语言中的共用体(Union)来实现这两个域的复用。
这样.广义表的数据结构可以定义如下：
typedef struct GNode sPrToGNode;
typedef PtrToGNode GList;
struct GNode f
3.2 线性表的定义与实现 67
int Tag:/*标志域：0表示该结点是单元素；1表示该结点是广义表*/
union
/*子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/
ElementType Data;
CList Sublist;
URegion;
PurT?CNode Next;/+指向后继结点*/
图3.7(a)表示上述结点结构，图3.7(b)表示了前面提到的单位员工情况的链表表示
方式。
Tag Data Next Sublist
(a)GNode的结点结构
0 丁一
0 张三
I
…
0 李四
(b)按部门组织的单位员工广义表
图3.7 广义表结构
2.多重链表
在图3.7的例子中，广义表采用链表存储的方式实现，其中代表子表的元素结点(如指向
“张三”,以及指向“李四”、“王五”的结点),不仅是这个广义链表中的一个结点，而且还是它所
代表的子表的起点。像这种存在结点属于多个链的链表叫“多重链表”。一般来说，多重链表中
每个结点的指针域会有多个，如前面的例子包含了Next和Sublist 两个指针域；但包含两个指针
域的链表并不一定是多重链表，比如在双向链表中每个结点都包含了向前和向后的两个指针域，
但由于每个结点还是都属于同一个链表，所以双向链表尽管结点有多个指针域，但不是多重
链表。
多重链表在数据结构实现中有广泛的用途，基本上如树、图这样相对复杂的数据结构都可以
采用多重链表的方式实现存储。
下面，我们以稀疏矩阵的表示为例，来进一步说明多重链表的实现方式。
0 王五 0 钱六
1 NULL
0 孙七
68 第3章 线 性 结 构
[例3.3] 矩阵最直观的表示方法是用二维数组，但二维数组表示有两个缺陷：一是数
组的大小需要事先确定，另一个是当矩阵包含许多0元素时，要存储这些“意义不大”的0
元素，将造成大量的存储空间浪费。例如，图3.8(a)和(b)即为两个0元素占多数的矩阵
A和B。对于A和B这样的稀疏矩阵*最好是只存储非0元素。如何用多重链表方式实现
存储?
住湘
(a)P;(x)=9x12+15x2+3x2 (b)P?(x)-26x1-4x?-13x?+82
图3.8 稀疏矩阵
[分析]我们可以采用一种典型的多重链表——十字链表来存储稀疏矩阵。链表中用
于存放矩阵非0元素的每个结点有两个指针域，一个是行指针(或称为向右指针)Right,另
一个是列指针(或称为向下指针)Down,结点的数据域存放元素的行坐标Row、列坐标Col和
数值Value。
对应每个行链表和列链表都有一个表头结点，在这里我们将行列两种表头结点合并成一
个，即第i行的表头结点也是第i列的表头结点Head。各行链表和列链表均是一个带头结点
的单向循环链表，以相应的表头结点 Head为头结点，通过Right(或 Down)域用循环链表将各
行(或列)的结点连接起来。而且各表头结点Head本身也用链接域Next链起来，构成一个带
头结点的循环链表，该头结点作为整个矩阵结构的入口。由这三种循环链表实现了矩阵的多
重链表表示。
在稀疏矩阵的十字链表实现中，存在头结点和非0元素结点两种不同结构的结点。我们同
样也可以考虑用union来融合不同类型的结点。为了区分头结点和非0元素结点，可以使用一
个标识域Tag,头结点的标识值为Head,矩阵非0元素结点的标识值为Term。图3.9(a)是union
后的结点总体结构，图3.9(b)给出了两种结点的组成示意图。
Tag
Down URegion Right
(2)结点的总体结构
·指大部分元素为零的炬阵。
Term
Down
Row| Col
Right
Value
(b)矩阵非0元系结点
图3.9 稀疏矩阵多重链表结点结构
Head
Down Next Right
(C)头结点
3.2 线性表的定义与实现 69
稀疏矩阵的数据结构可定义为：
typedef enum{Head.Term|NodeTag:
struct TermNode {/*非零元素结点*/
int Row,Col;
ElementType Value;
I;
typedef struct MNode*PtrToMNode;
struct MNode |/*矩阵结点定义*/
PtrToMNode Down,Right;
NodeTag Tag:
union |/*Head对应Next指针；Term 对应非零元素结点*/
PtrToMNode Next;
struct TermNode Term;
|URegion;
I;
typedef PtrToMNode Matrix;/*稀疏矩阵类型定义*/
Matrix HeadNode [MAXSIZE];
/*MAXSIZE 是矩阵最大规模，即行数、列数的最大值/
/*HeadNode是为了能快速指向各行或列链表头结点的指针数组*/
上述定义中用结点标识Tag和一个共用体URegion将两种结点统
一在一起定义。对于某一个具体结点，当它是头结点时，其结点标识域
Tag赋值为Head,相应的共用体URegion为结点指针 Next;否则是一个
非0元素结点，结点标识域赋值为Term,相应的共用体URegion取元素
项Term。 微视频3-1
图3.10为图3.8(a)中矩阵A的多重链表表示形式。头结点Head的
个数为矩阵行列数的较大者，这里为5。需要一提的是，头结点链表的头结
稀疏矩阵的
多 重 链 表
表示
点(图3.10中A所指结点),它指向并代表了一个具体的稀疏矩阵，而且它
的结构与非0元素结点是一样的，但它的Row、Col和Value域的值分别为矩阵的行数、列数和非
0元素总个数。
为了表示清晰起见，图3.10中画出了两组头结点，用水平排列的头结点表示列链表，它们的
Down域指向每个列链表的第一个元素结点；而垂直排列的头结点表示行链表，它们的Right 域
指向每个行链表的第一个元素结点。其实，水平和垂直的两组头结点是同一组头结点，它们的
Down域和Right域分别链接列链表和行链表，Next域则链接头结点本身。
70 第3章 线性 结 构
Term
A- s4
7
Head
Head
Head
Head
Head
Head Head Head Head Head
Term Term
00 03
18 2
Term
1
27
1
Term
23
-4
Term
30
23
Term Term
31 3|4
-1 12
图3.10 图3.8(a)中矩阵A的多重链表(十字链表)表示
3.3 堆栈
3.3.1 堆栈的定义
表达式求值是程序设计语言编译中的一个基本问题，即编译程序要将源程序中描述的表达
式转换为正确的机器指令序列或直接求出常量表达式的值。要实现表达式求值，首先需要正确
理解一个表达式.主要是运算的先后顺序。
[例3.4]对于算术表达式来说，其基本规则是；先乘除，后加减；先括号内，再括号外；相同
优先级情况下从左到右。比如，5+6/2-3+4就是一个算术表达式，它的正确理解应该是：5+6/
2-3*4=5+3-3*4=8-3*4=8-12=-4。可以看到这类表达式主要由两类对象构成的，即运算
数(如2、3、4等)和运算符号(如+、一、+、等)。不同运算符号优先级是不一样的，而且运算符号
3.3 堆栈 71
均位于两个运算数中间。那么,计算机编译程序如何才能自动地理解这样的表达式?
[分析]我们先来分析一类仅由两种运算符号和三个运算数构成的相对简单的算术表达式，
比如2+3*4或2*3+4,其基本形式是a?oP,a?oP?a,,其中a,为运算数、op,为运算符号。
当计算机编译程序分析这样的表达式时，一般就是从左到右扫描。当扫描了a?op,a?找到
两个运算数一个运算符号后，并没法做出是否马上进行运算的决定。因为还需要看op?的优先
级是否比op,高。所以，编译程序从左往右扫描时，需要根据前后运算优先级的情况决定：先保
留当前数据和运算符号，还是马上进行计算。比如，对于2+3*4,当扫描了2+3后还不能做出计
算2+3的决定，因为后面“·"的优先级比“+”高，所以必须先将2、3以及“+”保留起来，等到后
面合适机会时再将这些数据和运算符号拿来运算。所以，需要有一种数据结构能够很好地实现
对等待运算或数据的组织。
为了更容易理解表达式的求值方法，我们分析一下更简单的一种表达式：后缀表达式。平常
我们经常使用的表达式是中缀表达式，即运算符号位于两个运算数之间的表达式。而在后缀表
达式中，运算符号位于两个运算数之后。比如，前面提到常量表达式5+6/2-3*4的后缀形式就
是：562/+34*-。还有一种表达式形式叫前缀表达式，运算符号位于两个运算数之前。比
如，5+6/2-3*4的前缀形式就是：-+5/62*34。
可见，后缀表达式运算数出现的顺序与相应中缀表达式一样，但运算符
号出现在不同的位置。
后缀表达式相对比中缀表达式的求值要容易得多。我们先来看一下，
后缀表达式562/+34*-如何求解。
微视频3-2 同样，我们还是从左到右扫描这个表达式，求解过程如下。 后缀表达式 (1)遇见运算数562时均不做计算，同时记住这个序列562。 的求解过程
(2)当遇见运算符号“/”时，把最近遇到的两个数6和2从序列中取
出作运算，并把结果3放到刚才那个序列的后面，即当前序列为：53。
(3)当遇见运算符号“+”时，把序列的最后两个数5和3取出作运算，并把结果8放到当前
序列的后面，因而当前序列为：8。
(4)遇见34时均不做计算，把这两个数放到当前序列的后面，因而当前序列834。
(5)当遇见运算符号“*”时，把当前序列的最后两个数3和4取出作运算，并把结果12放
到当前序列的后面，因而当前序列为：812。
(6)当遇见运算符号“-”时，把当前序列的最后两个数8和12取出作运算，并把结果-4放
到当前序列的后面，因而当前序列为：-4。
(7)当输入中不再有符号时，当前序列中的值(-4)就是表达式的结果值。
大家可以看到，上述方法很简单也很巧妙，关键问题是需要管理一个序列，对该序列的主要
操作是在序列的末尾插入元素和删除(取出)元素。有这类操作要求的序列我们称之为“堆栈”。
堆栈(Stack)可以认为是具有一定约束的线性表，插入和删除操作都作用在一个称为栈顶
(Top)的端点位置。其实，我们日常生活中也可以看到堆栈的例子，比如，我们厨房中叠放的盘
72 第3章 线性 结 构
子，使用盘子(删除操作)时我们是从顶端拿走盘子，用完放回(插入操作)时也是放到顶端。
正是堆栈所具有的这种特性，通常把数据插入称为压入栈(Push),而数据删除可看作从堆
栈中取出数据，叫做弹出栈(Pop)。也正是由于这一特性，最后入栈的数据将被最先弹出，所以
堆栈也被称为后入先出(Last In First Out,LIFO)表。
堆栈的抽象数据类型定义为：
类型名称：堆栈(Stack)。
数据对象集：一个有0个或多个元素的有穷线性表。
操作集：对于一个具体的长度为正整数MaxSize的堆栈SeStack,记堆栈中的任一元素X∈
ElementType,堆栈的基本操作主要有：
(1)Stack CreateStack(int MaxSize):生成空堆栈，其最大长度为MaxSize;
(2)bool IsFull(Stack S):判断堆栈S是否已满。若S中元素个数等于MaxSize时返回 true;
否则返回false;
(3)bool Push(Stack S,ElementType X):将元素X压入堆栈。若堆栈已满，返回 false;否则
将数据元素X插入到堆栈S栈顶处并返回true;
(4)bool IsEmpty(Stack S):判断堆栈S是否为空，若是返回 true;否则返回false。
(5)ElementType Pop(Stack S):删除并返回栈顶元素。若堆栈为空，返回错误信息；否则将
栈顶数据元素从堆栈中删除并返回。
图3.11表示了堆栈的数据存储及其操作。为了形象起见，我们将数据表示为带字符标志的
小球，堆栈用带底的小筒表示。图3.11(a)表示字符ABCD的压栈过程，图3.11(b)是栈内元素
依次弹出栈的过程，Top指向当前操作的元素(称为栈顶元素)。
A B D
C
Top
Top A
Top B
A
Top D
A
(a)宇符ABCD的压找过程
D O D
Top
○回 Top
A
O
A
Top
A
(b)找内元素依次弹出栈的过程
图3.11 堆栈的出入栈操作过程
D
D
A
O
①(
A
Top
Top
A
Top
3.3 堆栈 73
[例3.5]如果将ABCD四个字符按顺序压入堆栈，是不是ABCD的所有排列都可能是出栈
的序列?可以产生CABD这样的序列吗?
[分析]我们先来看一下简单的情况。
(1)当只有一个字符出入栈时，显然只有一种可能，即A人栈也只有A出栈。
(2)当有两个字符AB出入栈时，如果进栈顺序为AB,那么出栈的系列AB、BA都有可能，
即可以A进栈、A出栈、B进栈、B出栈，产生输出序列AB;也可以A进栈、B进栈、B出栈、A出
栈，产生输出序列BA。这两个可能的序列也是正好是两个字符的全排列。
(3)如果有三个字符ABC出入栈时，全排列有3!=6种可能，但其中的CAB是没法生成的。
因为，先输出C,需要C进栈再出栈，而要求按照ABC这样的顺序进栈，所以C出栈时AB必然
还在栈里，而且A还压在B下面。因此，CAB的序列是没法生成的，而其他5种排列都可以
生成。
(4)如果有四个字符ABCD出入栈时，同样不是所有排列都有可能是出栈的序列，象CABD
这样的序列是产生不了的。ABCD的全排列有4!=24种可能，那么这样四个字符出栈的所有可
能序列有几种?这是一个很有趣的计数问题，读者可以在已知n=1~3的出栈序列个数的基础
上推算出n=4时的序列个数。
3.3.2 堆栈的实现
由于栈是线性表，因而栈的存储结构可采用顺序和链式两种形式。顺序存储的栈称为顺序
栈，链式存储的栈称为链栈。
1.栈的顺序存储实现
栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，另外我们还
可以用一个变量来存储堆栈的最大容量MaxSize,这样方便判断什么时候堆栈是满的。我们用一
维数组 Data[MaxSize](下标0~MaxSize-1)存储一个栈的元素。习惯上将栈底放在数组下标小
的那端，栈顶位置用一个整型变量Top记录当前栈顶无素的下标值。当Top 指向-1时，表示空
栈；当Top 指向MaxSize-1时，表示满栈。用C语言描述顺序栈类型 Stack 如下：
typedef int Position;
typedef struct SNode*PtrToSNode;
struct SNode{
ElementType* Data;/*存储元素的数组*/
Position Top; /*栈顶指针*/
int MaxSize; /*堆栈最大容量*/
l;
typedef PtrToSNode Stack;
结构中的数组的长度是由MaxSize决定的。代码3.11给出了创建一个给定容量的空堆栈
的函数。
74 第3章 线性 结 构
Stack Createstack(int MaxSize)
Stack S=(Stack)malloc(sizeof(struct SNode));
S->Data=(ElementType*)malloc(Maxsize·sizeof(ElementType));
S->MaxSize=Maxsize;
S->Top=-1;
return S;
代码3.11 顺序栈的创建
下面我们来看一下，堆栈的两个最主要操作“入栈”和“出栈”是如何实现的。
(1)入栈操作Push。
在执行堆栈 Push操作时，首先判别栈是否满；若不满，Top加1,并将新元素放入 Data数组
的Top位置中。具体实现如代码3.12所示。
bool IsFu1l(Stack s)
return(S->Top==S->MaxSize-1);
bool Push(Stack S, ElementType x)
1
if(ISFu11(S))士
printf("堆栈满“);
return false;
elae 
S->Data[++(S->TOp)]=x:
return true:
代码3.12 顺序栈的人栈操作
(2)出栈操作Pop
执行Pop操作时首先判别栈是否空；若不空，返回 Data[Top],同时将Top减1;否则要返回
一个ElemcntTypc类型的特殊错误标志，即代码3.13中的ERROR——这个值一般根据具体问题
做定义，必须是正常的栈元素数据不可能取到的值。
3.3 堆 栈 75
bool ISEmpty(Stack S)
return(S->Top==-1);
ElementType Pop(Stack S)
11(ISEmpty(S))
printf("堆栈空“);
return ERROR;/ERROR是RlementType的特殊值，标志错误*/
4
else
return(S->Data[(S->TOp)--1):
代码3.13 顺序栈的出栈操作
下面举一个用一个数组实现两个堆栈的例子。
[例3.6] 请用一个数组实现两个堆栈，要求最大可能地利用数组空间，使数组只要有空间
入栈操作就可以成功。写出相应的入栈和出栈操作函数。
[分析]这个问题有多种解决方案，例如可以先将数组空间一分为二地分配给两个堆栈使
用，一个堆栈的底在数组的起始位置，另一个底在数组中间的位置，两个Top 指针都沿同一个方
向增长。这时如果其中一个堆栈先满了，而另外一个堆栈还有空，我们可以顺序移动数据，为满
的那个堆栈腾出空位来。但是这种方法显然不太聪明，因为可能涉及很多数据的移位，而这些麻
烦其实是不必要的。
一种聪明的方法是使这两个栈分别从数组的两头开始向中间生长；当两个栈的栈顶指针相
遇时，表示两个栈都满了。此时，最大化地利用了数组空间。
双堆栈的结构只比标准堆栈多了一个栈顶指针：
typedef int Position;
typedef struct SNode*PtrToSNode;
struct SNode
ElementType*Data;/*存储元素的数组*/
Position Topl; /*堆栈1的栈顶指针*/
Position Top2; /*堆栈2的栈顶指针*/
int MaxSize; /*堆栈最大容量*/
;
typedef PtrToSNode Stack;
76 第3章 线 性 结 构
对双堆栈的创建也与代码3.11是相似的，只是需要初始化两个栈顶指针，方法是令Topl=-1,
Top2=MaxSize。相关的主要操作实现方法如代码3.14所示。
bool Push(Stack S,ElementType X,int Tag)
1/* Tag作为区分两个堆栈的标志，取值为1和2*/
if(S->Top2-S->Topl==1)I/*堆栈满*/
printf("堆栈满n");
return false;
elsel
if(Tag==1)/*对第一个堆栈操作*/
S->Data[++(S->Top1)]=x;
else /*对第二个堆栈操作*/
S->Data[--(S->Top2)]=x;
return true;
ElementType Pop(Stack s,int Tag)
1/* Tag作为区分两个堆栈的标志，取值为1和2*人
if(Tag==1)I/*对第一个堆栈操作*/
if(S->Top1==-1)I/*堆栈1空*/
printf("堆栈1空\n");
return ERROR;
elae return S->Data[(S->Top1)--]:
else l/*对第二个堆栈操作*
if(S->Topz--8->Maxsize)1/+堆栈a空·
printf(·堆栈2空\a");
return ERROR;
eise return s->Data[(S->Topz)++];
代码3.14 在一个数组中实现两个堆栈
注意；在上述问题中，不能用(S->Top2+S->Topl==MaxSize)来判别堆栈是否满(想想为什
么?)。
3.3 堆栈 77
2.堆栈的链式存储实现
栈的链式存储结构(链栈)与单链表类似，但其操作受限制，插人和删除操作只能在链栈的
栈顶进行。栈顶指针 Top 就是链表的头指针。有时为了简便算法，链栈也可以带一空的表头结
点，表头结点后面的第一个结点就是链栈的栈顶结点，栈中的其他结点通过它们的指针Next链
接起来，栈底结点的Next为NULL。
用C语言描述链栈如下；
typedef struct SNode *PtrToSNode;
struct SNode 
ElementType Data;
PtrToSNode Next;
I:
typedef PtrToSNode Stack;
代码3.15给出了带头结点的链栈主要操作的实现。
Stack CreateStack()
1/*构建一个堆栈的头结点，返回该结点指针*/
stack S;
S=malloc(sizeof(struct SNode));
S->Next=NULL;
return S;
—
bool ISEmpty(Stack s)
1/*判断堆栈S是否为空，若是返回true;否则返回false*/
return(S->Next ==NULL);
bool Push(Stack S,ElementType x)
/*将元素X压入堆栈S+/
PtrTOSNode TmpCell;
TmpCel1=(PtrTOSNode)malloc(sizeof(struct SNode));
TmpCel1->Data=X;
TmpCel1->Next=S->Next;
S->Next=Tmpcell;
78 第3章 线 性 结 构
return true;
ElementType Pop(Stack s)
1/·删除并返回堆栈S的栈顶元素·/
PtrToSNode FirstCell;
ElementType TopElem;
if(ISEmpty(S))
printf("堆栈空"):
return ERROR;
else
Firstcell=S->Next;
TopElem=FirstCell->Data;
S->Next=Firstcel1->Next;
free(Firstcel1);
return TopElem;
代码3.15 带头结点的链栈操作实现
3.3.3 堆栈应用：表达式求值
在3.3.1节中，我们给出了后缀表达式计算的基本过程，在这个计算过程中我们需要暂存还
不能马上参与运算的运算数，对这些运算数的管理方法基本是先入后出的原则，即需要使用一个
堆栈对这些暂存的运算数在求值过程中进行管理。
根据3.3.1节中后缀表达式的求值方法，我们可以很容易总结出应用堆栈实现表达式求值
的基本过程：从左到右读人后缀表达式的各项，并根据读入的对象判断执行操作。操作分下列3
种情况：
(1)当读入的是一个运算数时，把它被压人栈中：
(2)当读入的是一个运算符时，就从堆栈中弹出适当数量的运算数，对该运算进行计算，计
算结果再压回到栈中：
(3)处理完整个后缀表达式之后，堆栈顶上的元素就是表达式的结果值。
下面我们给出了利用堆栈求后缀表达式值的完整程序。为了简便起见，我们假设后缀表达
式的对象(运算数或运算符号)之间用空格分割开来，运算数为正实数，比如：
3.3 堆栈 79
1.2 1.3 +2 4.2 *
程序中的堆栈采用数组存储方式，入栈和出栈的操作实现见代码3.12和3.13。这里根据
实际问题需要将堆栈的元素类型(ElcmentType)具体化为double类型，见代码3.16。
#include <stdio.h>
Hinclude <atalib.h
Hinclude sctypa.h>
tdefine MAXOP 100/*操作数序列可能的最大长度
#derine INFINITY 1e9/*代表正无穷·/
typedef double ElementType;人将堆栈的元素类型具体化
/类型依次对应运算数、运算符、字符串结尾
typedef enum |num,opr ,end Type;
八关于顺序堆栈的代码请参见顺序堆栈的定义和代码3.11至3.13,在此略去·
Type Getop(char*Expr,fnt*start,char*str)
1/*从*start开始读入下一个对象(操作数或运算符),并保存在字符串 str中·/
int i=0;
/*跳过表达式前空格*
while((str[0]=Expr[(·start)++])==);
while(str[1]!=1&& str[i]!=+0)
str[++i]=Expr[(·start)++];
if(str[i]==01)/如果读到输入的结尾·/
(*start)--;/*start指向结束符·/
str[1]=0;/*结束一个对象的获取*/
if(i==0)return end;/*读到了结束*/
/*如果str[0]是数字、或是符号跟个数字·/
else if(isdigit(str[0])Ⅱisdigit(str[1]))
/·表示此时 str中存的是一个数字*/ return num;
/*如果str不是空串，又不是数字·/ else
/*表示此时 str中存的是一个运算符*/ return opr;
ElementType PostfixExp(char*Expr)
80 第3章 线 性 结 构
/*调用Getop 函数读入后缀表达式并求值·/
Stack S;
Type T;
ElementType Op1,Op2;
char str[MAXOP];
int start=0;
/*申请一个新堆栈*/
S=CreateStack(MAXOP);
op1=0p2=0;
while((T=Getop(Expr,&start,str))!=end)
/*当未读到输入结束时·/
if(T==num)
Push(S, atof(str));
elsel
if(!ISEmpty(S))Op2=Pop(S);
else Op2=INFINITY;
if(!ISEmpty(S))Op1=Pop(s);
else op2=INFINITY;
switch(str[0])
caset+:Push(S,Op1+Op2);break;
caset*t:Push(S,Op1*Op2):break;
caset-:Push(s, Opl-OpZ);break;
caseI/1:
if(OpZ 1=0.0)/*检查除法的分母是否为0·
Push(S. op1/0pz);
elae
printE("错误；除法分母为零n");
Op2=INFINITY:
break;
default;
printf("错误：未知运算符s n". str):
·事实上，人们一般不直按判断两个 double型实数是否相等或不等，因为从不同渠道获得的两个理论上相等的实数很可
能因为不间的舍人过程而产生微小的误差。一般以两个实数差的绝对值是否小于某给定阙值来判断两数是否相等。在这里，
我们可以用“fabe(Op2)>ZERO”来判断Op2不等于0,其中ZERO可以定义为一个充分小的数字，例如1.0E-10。
3.3 堆栈 81
Op2=INFINITY:
break;
1
if(Op2>=INFINITY)break;
1f(OpZ<INFINITY) /* 如果处理完了表达式*/
if(!I8Empty(S)) (*而此时堆栈正常·
Op2-Pop(s); /记录计算结果·/
elee Op2=INPINITY;八否则标记错误/
froe(S):/*释放堆栈*/
return OpZ:
intmain()
char Expr[MAXOP];
ElementType f;
gets(Expr);
f=PostfixExp(Expr);
if(f<INFINITY)
printf("8.4f\n",f);
else
printf("表达式错误n");
return 0;
代码3.16 利用堆栈求后级表达式
很明显，在计算后缀表达式的过程中，不需要判别运算的优先级。程序
运行时间跟问题规模是线性关系，即时间复杂度为0(n)。
在中缀表示的算术表达式(简称中缀表达式)中，由于不同运算符间存
在优先级，同一优先级的运算间又存在着运算结合顺序的问题(即左结合，
还是右结合),所以简单地从左到右的计算是不可行的。 微视频3-3
我们也可以应用堆栈将中缀表达式转换为后缀表达式。注意到转换前
后运算数的顺序是不改变的，改变的是运算符的顺序，所以此时堆栈里要保
存的是运算符。而在后缀表达式计算中，堆栈里保存的是运算数。
如何将中缀表
达式转换为后
缀表达式
82 第3章 线 性 结 构
应用堆栈将中缀表达式转换为后缀表达式的基本过程为：从头到尾读取中缀表达式的每个
对象，对不同对象按不同的情况处理。对象分下列6种情况：
(1)如果遇到空格则认为是分隔符，不需处理；
(2)若遇到运算数，则直接输出；
(3)若是左括号，则将其压入至堆栈中；
(4)若遇到的是右括号，表明括号内的中缀表达式已经扫描完毕，将栈顶的运算符弹出并输
出，直到遇到左括号(左括号也出栈，但不输出);
(5)若遇到的是运算符，若该运算符的优先级大于栈顶运算符的优先级时，则把它压栈；若
该运算符的优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，
按同样处理方法，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；
(6)若中缀表达式中的各对象处理完毕，则把堆栈中存留的运算符一并输出。
上述处理过程的一个关键是不同运算符优先级的设置。在程序实现中，可以用一个数来代
表运算符的优先级，优先级数值越大，它的优先级越高，这样优先级的比较就转换为了两个数大
小的比较。
表3.1表示了利用堆栈将中缀表达式“2*(9+6/3-5)+4”转换为后缀表达式“296 3/+
5-*4+”的过程。
表3.1 中缀表达式“2*(9+6/3-5)+4”转换为后缀表达式的过程
步骤
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
待处理表达式 堆栈状态
(底一…→顶)
2*(9+6/3-5)+4
*(9+6/3-5)+4
(9+6/3-5)+4 *
9+6/3-5)+4 *(
+6/3-5)+4 *(
6/3-5)+4 *(+
/3-5)+4 (+
3-5)+4 (+/
-5)+4 (+
5)+4 (-
)+4 *(
+4
4 +
+
输出状态
2
2
2
29
29
296
296
2963
2963/+
2963/+5
2963/+5-
2963/+5-
2963/+5-*4
2963/+5-*4+
3.4 队列 83
3.4 队列
3.4.1 队列的定义
在现实生活中，我们经常会遇到为了得到某种服务而排队的情况，比如，食堂买饭时需要排
队，银行存款时也需要排队。在计算机资源管理中也有类似的情景，比如，计算机的CPU资源是
有限的(早先计算机只有一个CPU),但同时有许多程序(进程)需要CPU来运行，这些准备运行
的进程就需要排队。
在许多应用中，排队的基本规则是：新来者排在队伍末尾，排在队伍前面的人先得到服务，期
间不允许插队。对于这类排队问题，需要有一种能解决共性问题的数据序列的管理组织方式，在
这个方式中，多个数据构成一个有序序列，而对这个序列的操作(比如插人、删除)有一定要求：
只能在一端插入，而在另一端删除。这样的数据组织方式就是“队列”。
“队列”(Queue)也是一个有序线性表，但队列的插入和删除操作是分别在线性表的两个不
同端点进行的。比如，人们在银行排队等待服务，后来的人要排在队尾(插入队伍),而先来的排
在头前并先接受服务(从队伍中删除)。
设一个队列Q=(a?,a?,…,a),那么a?称为队头元素，而a。称为队尾元素，a,排在a的后
面(1<i≤n)。如果将元素A、B、C、D依次插入队列，第一个从队列中删除的元素将是A,即先插
人的将被率先删除，因此队列通常又被称为“先进先出”表(Fist In First Out,FIFO)。
队列的抽象数据类型定义为：
类型名称：队列(Queue)。
数据对象集：一个有0个或多个元素的有穷线性表。
操作集：对于一个长度为正整数 MaxSize的队列Q=Queue,记队列中的任一元素X∈Ele mentType,队列的基本操作主要有：
(1)Queue CreateQueue(int MaxSize):生成空队列，其最大长度为MaxSize;
(2)bool IsFull(Queue Q):判断队列Q是否已满。若是返回true;否则返回 false;
(3)bool AddQ(Queue Q,ElementType X):将元素X压入队列Q。若队列已满，返回false;否
则将数据元素X插入到队列Q并返回 true;
(4)bool IsEmpty(Queue Q):判断队列Q是否为空，若是返回 true;否则返回 false;
(5)ElementType DeleteQ(Queue Q):删除并返回队列头元素。若队列为空，返回错误信息；
否则将队列头数据元素从队列中删除并返回。
3.4.2 队列的实现
1.队列的顺序存储实现
队列最简单的表示方法是用数组。用数组存储队列有许多种具体的方法。一般可以选择将
84 第3章 线 性 结 构
队列头放数组下标小的位置，而将队列尾放在数组下标大的位置，并用两个变量 Front 和Rear分
别指示队列的头和尾，如图3.12(a)。一般Front 和Rear先初始化为-1。当有元素入队，Rear向
右移动一格(加1),放入队尾元素；当有元素出队，先将 Front 向右移动一格(加1),再删除队头
元素。所以，入队和出队操作实现都相对简单。
0 1 2 …Front Rear… n-2n-1
(a)队列的一般情况
0 1 2 … Front"n-2 Rear
(b)队列的“假溢出”
图3.12 队列的一种数组表示
随着入队出队的进行，会使整个队列整体向后移动，这样就出现了图3.12(b)的现象：队尾
指针已经移到了最后，再有元素入队就会出现溢出，而事 Front
实上此时队中并未真的“满员”,这种现象称为“假溢出”。 : 为了解决队尾溢出而实际上数组仍然有空余空间的
问题，一般在队列的顺序存储结构中采用循环队列的方
式：Rear和Front 到达数组端点时，能折回到数组开始处，
即相当于将数组头尾相接，想象成环状，如图3.13所示。2
当插人和删除操作的作用单元达到数组的末端后，用公式
“Rear(或Front)??组长度”取余运算就可以实现折返到
起始单元。
Rear
1
n-2
0 n-1
采用循环队列解决了我们前面 图3.13 循环队列
提到的假溢出问题，但在循环队列中，Front和Rear如何初始化却并不是一
个十分显然的问题，如何根据Front和Rear值判别当前队列是否空或者满?
…0 如果队列初始化时，将Front和Rear都初始化为0,当插入一个元素
微视频3-4 时Rcar 加1,删除一个元素时Front加1,则当 Front和Rear相等的时候队
循环队列的
空 满判 断
问题
列为空，如图3.14(a)所示。当Front在Rear前面一个位置时表示队列中
只有一个元素，如图3.14(b)所示。在这种设置方式中，Rear指向的是队尾
元素的位置，而Front 则是指向队头的前一个位置。
当数组中有n-1个元素时(即数组剩最后一个空位时)状态如图3.14(c),此时如果再插入
一个元素，Rear加1,Front 和Rear值就相等了。但我们知道，队列为空的时候 Front和Rear值也
3.4 队列 85
是相等的。因而，按照目前的操作方式，当Front和Rear值相等时，队列可能为空或者为满，我们
无法判别。其根本原因是：我们是根据Rear和Front 之间的差距来判别队列元素个数的，而Rear
和Front 之间的差距最多只有n种情况(n为数组大小),而队列元素个数总共有n+1种情况(0,
1,2,….n个元素),所以仅依靠Front和Rear是没办法区分n+1种情况的。
Front Rear Front Rear Rear Front
重 书 曲 **
1 n2 1 n2 1 n-2
0 n-1 0 n-1 0 n-1
(n)队列为空的状态 (b)队列中只有一个元素 (c)队列满状态
图3.14 循环队列的空与满
可见，无法区分队列满还是空的原因是Front 和Rear提供的信息量不够。解决方法有两种：
方法之一是另外增设一个变量，比如：记录当前队列元素个数的变量Size,或者用一个变量
Flag记录最后一次操作是入队还是出队。根据变量Size,我们就可以直接判断队列是满还是空；
根据变量Flag,就可以知道当Front 等于Rear时是满还是空。
方法之二是少用一个元素空间，把图3.14(c)所示的情况就视为队列满。此时的状态是队
尾指针加1就会从后面赶上队头指针，因此，队满的条件是：(Rear+1)??组长度等于Front。队
空的条件仍然是：Rear 等于Front。
下面我们采用方法二实现循环队列。队列的顺序存储实现结构可以定义为：
typedef int Position;
typedef struct QNode*PtrToQNode;
struct QNode
ElementType*Data; /*存储元素的数组*/
Position Front,Rear; /*队列的头、尾指针*/
int MaxSize; /*队列最大容量*/
I;
typedef PtrToQNode Queue;
循环队列的创建与插入和删除操作实现由代码3.17给出。
Queue createQueue(int Maxsize)
Queue Q=(Queue)malloc(sizeof(struct QNode));
86 第3章 线 性 结 构
Q->Data=(ElementType*)malloc(Maxsize*sizeof(ElementType));
Q->Front=Q->Rear=0;
Q->Maxsize=MaxSize;
return Q;
bool ISFu1l(Queue Q)
return((Q->Rear+1)Q->MaxSize==Q->Front);
bool AddQ(Queue Q,ElementType X)
if(IsFull(Q))
printf("队列满");
return false;
elsel
Q->Rear=(Q->Rear+1)=>Maxsize;
Q->Data[Q->Rear]=x;
return true;
bool IeEmpty(Quoue 0)
return(Q->Front ==Q->Rear):
ElementType DeleteQ(Oueuo 0)
if(ISEmpty(0))1
printE(“队列空“);
roturn ERROR;
else
Q->Front-(Q->Front+1)0Q>Maxize;
3.4 队列 87
return Q->Data[Q->Pront];
代码3.17 循环队列的创建与人队和出队操作
2.队列的链式存储实现
队列与堆栈一样，也可以采用链式存储结构，但队列的头(Front)必须指向链表的头结点，队
列的尾(Rear)指向链表的尾结点(反过来行不行?为什么?)。
用C语言描述链式队列结构如下：
typedef struct Node*PtrToNode:
struet Node (/*队列中的结点*/
ElementType Data;
PtrToNode Next;
l;
typedef PtrToNode Position;
typedef struct QNode*PtrToQNode;
struct QNode 
Position Front,Rear;/*队列的头、尾指针*/
int MaxSize; /*队列最大容量*/
|;
typedef PtrToQNode Queue;
采用链式存储的入队和出队操作实际就是在一个链表的尾部插入结点或者在头部删除结
点。下面代码3.18是不带头结点的链式队列出队操作的一个示例：
bool ISEmpty(Queue Q)
return(Q->Front==NULL);
ElementTypeDeleteQ(Queue Q)
Position FrontCel1;
ElementType FrontElem;
if(ISEmpty(Q))!
88 第3章 线 性 结 构
printf("队列空");
return ERROR;
else1
Frontcel1=Q->Front;
if(Q->Front ==Q->Rear) /*若队列只有一个元素*/
Q->Front=Q->Rear=NULL;删除后队列置为空*/
else
Q->Front=Q->Front->Next;
FrontElem=Frontcel1->Data;
free(FrontCel1); /*释放被删除结点空间*/
return FrontElem;
代码3.18 链式存储队列的出队操作
3.5 应用实例
3.5.1 多项式加法运算
在本章第一节，我们分析了一元多项式的三种可能的存储实现方法。本节我们将给出采用
链表结构来存储多项式的非零项的实现方法。
前面提到，用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数和指
数两个数据域以及一个指针域，其结点结构已在3.1节的方法3中给出。
我们准备采用不带头结点的单向链表结构表示一元多项式，并按照指
数递减的顺序排列各项(示例如图3.3所示)。
…0
微视频3-5
链式存储多
对链表存放的两个多项式进行加法运算可以使用两个指针P1和P2。
初始时P1和P2分别指向这两个多项式第一个结点(指数最高的项)。通
过循环不断比较P1和P2所指的各结点，比较结果为以下3种情况之一，
并做不同处理。 项式的相加 (1)两数据项指数相等。系数相加，若结果不为0,则作为结果多项式 过程
………………对应项的系数，连同指数一并存入结果多项式。沿两结点的链域，使PI和
P2都分别指向两个多项式的下一项，再进行新一轮的比较和处理。
3.5 应用 实 例 89
(2)P1中的数据项指数较大。P2不变，将P1的当前项存入结果多项式，并使P1指向下一
项，再进行新一轮的比较和处理。
(3)P2中的数据项指数较大。PI不变，将P2的当前项存入结果多项式，并使P2指向下一
项，再进行新一轮的比较和处理。
当某一多项式最后一个结点处理完时，停止上述求和过程，将未处理完的另一个多项式的所
有结点依次复制到结果多项式中去。
代码3.19是链表存储的两个多项式加法运算的具体实现，其中函数Attach(coef,expon,
&PtrRear)将系数coef和指数expon 构成的新的项加入结果多项式的末端，同时改变当前结果多
项式末尾项指针 PtrRear值；Compare(PI->expon,P2->expon)比较两个指数的大小，根据大于、
小于、等于三种情况分别返回1,-1,0;PolyAdd(P1,P2)将多项式PI和P2相加，并返回结果多
项式。注意：相加并不改变原有的多项式P1和P2。
int Compare(int e1,int e2)
1/·比较两项指数e1和e2,根据大、小、等三种情况分别返回1,-1,0/
if(e1se2)return 1; /ke1大，返回1*/
else if(el<e2)return-1;/*e2大，返回-1*/
else return 0; /*el和e2 相等，返回0*/
void Attach(int coef,int expon,Polynomial*PtrRear)
1/*由于在本函数中需要改变当前结果表达式尾项指针的值，*/
/*所以函数传递进来的是尾项结点指针的地址，*PtrRear 指向尾项·/
Polynomial P;
/*申请新结点，并赋值*/
P=(Polynomial)malloc(sizeof(struct PolyNode)):
P->coef=coef;
P->expon=expon;
P->link=NULL;
/*将P指向的新结点插入到当前结果表达式尾项的后面*/
(*PtrRear)->link=P;
PtrRear=P;/*修改PtrRear值*/
Polynomial PolyAdd(Polynomial P1,Polynomial P2)
Polynomial front,rear,temp;
int sum;
90 第3章 线 性 结 构
/*为方便表头插人，先产生一个临时空结点作为结果多项式链表头·/
switch(Compare(P1->expon,P2->expon))1
case 1:/*P1中的数据项指数较大*人
Attach(P1->coef,PI->expon,krear);
P1=P1->link;
break;
case-1:/*P2中的数据项指数较大*/
Attach(P2->coef,P2->expon,&rear);
P2=P2->link;
break;
case 0:/*两数据项指数相等*
sum=P1->coef+P2->coef;
if(sum)Attach(sum,P1->expon,&rear);
P1=P1->link;
P2=P2->link;
break;
/·将未处理完的另一个多项式的所有结点依次复制到结果多项式中去*/
for(;P1;P1=P1->link)Attach(P1->coef,P1->expon,&rear):
for(;P2;P2=P2->link)Attach(PZ->coef. P2->expon.brear):
rear->link=NULL:
temp=front:
front =front->link:/+令front 指向结果多项式第一个非零项·/
freq(temp);人释放临时空表头结点/
return front;
rear=(Polynomial)malloc(sizeof(struct PolyNode));
front=rear;/*由front 记录结果多项式链表头结点*/
while(PI && P2)/*当两个多项式都有非零项待处理时*/
代码3.19 链式存储的一元多项式加法运算
"3.5.2 迷宫问题
作为堆栈应用的一个比较有挑战性的例子，我们介绍一下迷宫问题的求解。迷宫问题要求
从一个人口出发，经过若干连通的格子达到指定的出口。
3.5 应 用 实 例 91
首先，我们需要考虑如何在程序中表示迷宫。假定用nxm的二维矩阵表示迷宫，位置(0.
0)为人口，位置(n-1,m-1)为出口。迷宫中的任一位置可以用其行列坐标来指定。某一位置有
障碍，其对应的矩阵元素(i,j)的值为1,否则其值为0。图3.15是某个给定迷宫的矩阵表示
形式。
010001100011111
100011011100111
010000011110011
110111100101100
110100101111111
001101110100101
011110011111011
001101101111101
110001100100000
001111100011110
010000111011110
图3.15 迷宫的矩阵表示
这时迷宫求解问题转换成从矩阵的起始位置(0,0)到结束位置(n-1,m-1)寻找一条连通路
径，路径是由一组两两相邻(每个位置与它周围的8个方向的位置都相邻)的位置构成，这一组
位置的矩阵元素值都为0。
求解迷宫问题的基本思路是“穷尽法”,即从入口出发尝试各种可能，直到找到出口。在从
一个位置尝试走到下一个位置时，有8种可能的走法，图3.16用方向东(E)、西(W)、南(S)、北
(N)、东南(SE)、东北(NE)、西南(SW)、西北(NW)表示这8种情况。
实际上并非每个位置上都有8个可移动的方向，处于迷宫边缘上的位置只有5个可移动方
向，而处于四角的位置只有3个可移动方向。为了一致起见，使得程序设计不必考虑这些边缘和
角落特殊情况，可以人为地环绕迷宫增加一圈障碍。改变后迷宫所对应的矩阵表示见图3.17,
增加部分用涂灰的且值为1的边框表示。
扩大的矩阵并不影响算法寻找通路，只是入口下标为(1,1),出口下标为(n-2,m-2),而不
是原来的左上角和右下角了。n、m为带边界的二维数组大小。
设在迷宫中走到某一位置[Row][Col],Row 表示纵坐标，Col 表示横坐标。如果下一步朝北
走，相对于当前位置将步入位置[Row-1][Col];若朝东南走，下一步将步入位置[Row+1][Col+1]。
以此类推，可得到每一个方向的坐标变化情况。相对于当前位置[Row][ Col],下一位置纵横坐
标的偏移量为0、1或者-1。
表3.2列出了下一位置在8个方向中的具体下标偏移量。为了程序实现简单起见，8个方
向从北开始顺时针依次从0到7编号。
92 第3章 线性 结 构
11111111111111111
10100011000111111
11000110111001111
10100000111100111
11101111001011001
(NW)
西北
北(N) (NE) 11101001011111111 东北 10011011101001011
10111100111110111
西(W) 东(E) 10011011011111011
11100011001000001
1001111100011110
西南
(SW)
南(S) 东南
(SE)
10100001110111101
1 F111111111111111
图3.16 任一位置的8个方向 图3.17 迷宫增加一圈障碍的矩阵表示
表3.2 迷宫中的方向、编号及坐标偏移量
方向 编号 row 偏移 col偏移
北(N) 0 -1 0
东北(NE) 1 -1 I
东(E) 2 0 1
东南(SE) 3 1 1
南(S) 4 1 0
西南(SW) 5 1 -1
西(W) 6 0 -1
西北(NW) 7 -1 -1
求解迷宫路径可以从入口开始尝试各个方向以找到下一个位置，并进而在新的位置再尝试
所有可能找下一个位置。当在某个位置尝试所有可能找不到新位置时，说明进入了“死胡同”需
要返回，即“回溯”。为了记住回溯的位置，需要采用一种数据结构来保存和恢复从前尝试过的
潜在路径的位置信息，这个数据结构应该具有“后入先出”的特点，因而就是堆栈。
应用堆栈求解迷宫路径的基本思路如下。
(1)将初始人口坐标和起始方向信息放入堆栈中。
(2)从堆栈中弹出(上次)位置信息，设定当前位置和当前尝试方向：若堆栈为空而出口尚
未找到，则该迷宫没有解，程序退出。
3.5 应 用 实 例 93
(3)在当前位置.从当前方向起按顺序尝试剩余方向上的可通性：
①若某一方向可通，则将当前位置信息及目前方向信息存入堆栈；
②若该可通位置是出口，则成功退出，堆栈中的从栈底到栈顶的各位置顺序构成迷宫路径；
③若该可通位置不是出口，将该可通位置设为当前位置，并将第一个方向设为当前方向；转
第3步。
(4)若8个方向均不可通，则转第2步。
相应的数据结构为：
#define MAXMATRIXSIZE 100/+迷宫矩阵最大行列数+/
#define MAXSTACKSIZE 100/+堆栈最大规模/
struct Offsets |/*偏移量结构定义*/
short int Vert;*纵向偏移*/
short int Horiz;/*横向偏移*/
I;
struct MazePosition|/*迷宫中的位置结构*/
short int Row;/*行号*/
short int Col;/*列号*/
short int Dir;/*对应偏移量数组的方向号*/
I;
typedef struct MazePosition ElementType;/*堆栈元素类型*/
堆栈的创建及入栈和出栈的函数已经在代码3.11至3.13给出，在此不再赘述。代码3.20
给出了寻找迷宫路径的函数Path。调用该函数时，假设迷宫已经给出，用带边界的二维数组
Maze[][]表示；人口位置为(1,1),出口位置为(EXITROW,EXITCOL)。若迷宫无解，该函数将
输出“该迷宫无解。”;若有解，则将顺序输出从人口到出口的路径上每个位置的横、纵坐标。
为了不重复访问已经走过的路线，我们还需要用一个二维数组Mark[MAXMATRIXSIZE]
[MAXMATRIXSIZE]来标记已经走过的位置，如果位置[Row][ Col]已经被走过，则Mark[Row]
[Col]为1,否则为0。
注意：由于从堆栈弹出的路径是反向的，所以我们从出口向人口反向搜索比较方便。从出口
向入口反向搜索的方法与从入口正向搜索的方法是一样的。下面的代码3.20是从出口反向搜
索的迷宫问题路径求解程序。
void Path(int Maze[][MAXMATRIXSIZE],int EXITROW,int EXITCOL)
/*迷宫8个方向的偏移量数组*/
1/*默认迷宫Maze的入口为(1,1),出口为(EXITROW,EXITCOL)*/
94 第3章 线 性 结 构
struct Offsets Move[8]=
11-1,01,F-1,11,f0,11,|1,11,11,01,{1,-11,10,-11,1-1,-111;
Stack S;/*辅助求解的堆栈*/
struct MazPosition P;
short int Row,Col,NextRow,NextCol,Dir;
bool Found=false;
S=CreateStack(MAXSTACKSIZE);/*初始化空堆栈·/
Mark[EXITROW][EXITCOL]=1;/*从出口位置开始，标记为走过·/
/*将出口位置及下一个方向放入堆栈*/
P.Row=EXITROW;
while(!ISEmpty(S)!Found)1/*当栈非空且没找到入口时*/
/尝试往下一个方向Dir移动*/
NextRow=Row+Move[Dir].Vert:
NextCol=Col+Move[Dir].Horiz:
if(NextRow==1NextCol==1)
/*如果到达人口*/
Found-true;
clse /+下一个位置不是入口·/
八若下一个位置可通，且没走过*/
if(!Ma20[ NextRow][NextCo1]&
1Mark[NextRow][Nextco1])1
Mark[NextRow][Nextco1]-1;标记为走过
/当前位置和下一个方向存入栈/
P.Row=Row;
P.Col=col:
P.Dir=Dir+1:
Push(s,P);
人更新当前位置，从方向0开始*/
int Mark[MAXMATRIXSIZE][MAXMATRIXSIZE];/*标记位置是否走过*/
P.Col=EXITCOL;
P=Pop(S);/取出栈顶元素为当前位置*∠
P.Dir=0;
Row=P.Row; Col=P.Col; Dir=P.Dir;
Push(S,P);
while(Dir<8&!Found)|/*当还有方向可探且没找到人口时*/
本 章 小 结 95
Row-NextRow; Col-NextCol;Dir-0;
/结束if*/
else ++Dir:/*若此路不通，则在当前位置尝试下一个方向*
十/*结束8方向探测*
|/*结束搜素·/
if(Found)|/*找到一个路径，并输出该路径·/
printf("找到路径如下\n");
printf("行列\n"):
printf("1 1\n"):/*打印入口*/
printf("d td\n",Row, co1);7+不要忘记最后一步未入堆栈+
whilo(!ISEmpty(S))
P-Pop(S);
printf("?kd\n",P.Row, P.Col);
else /*若没找到路径*
printf("该迷宫无解。\n");
代码3.20 迷宫求解
注意到程序中有一个细节，当探测到下一个能走的位置时，我们存入堆栈的是当前的位置，
但却不是当前的方向，而是下一个方向——为什么?如果我们在此存入的是当前方向，程序会出
错吗?这个问题留给读者自己去思考。
本 章 小 结
在分析一元多项式及其运算问题的基础上，引入线性表的概念及其基于顺序存储和链式存
储的两种实现方法。线性表是若干数据元素组成的有序序列，其基本操作有插入、删除、查找等。
基于顺序存储的线性表实现方式简单，对元素访问随机，但动态性不够，是实现静态线性数据管
理的理想方式。链表存储方式对频繁增删结点且表长有较大变化的应用来说更加适合。
广义表是对一般线性表的推广，是一种“表中有表”的数据元素组织方式。广义表可以采用
多重链表方式实现，即多个单向链表的综合，其中存在一些结点属于多个链表。稀疏矩阵的典型
实现方式是采用横纵(行列)交错的多重链表(十字链表)。
堆栈是一种只在一端做插入删除的受限的线性表，具有“后进先出”的特点，主要操作包括：
入栈、出栈、栈满和栈空判断。堆栈的实现可以采用顺序存储(数组)和链式存储两种方式。在
实际应用中，顺序存储实现方式更加常见和方便。堆栈的应用非常广，常见的应用包括：表达式
96 第3章 线 性 结 构
求值、函数调用和递归实现、深度优先搜索等。本章重点分析了表达式求值和迷宫问题。
队列是一种在一端进行插入而在另一端进行删除的受限的线性表，具有“先进先出”的特
点，主要操作包括：入队、出队、队满和队空判断。队列的实现也可以采用顺序存储(数组)和链
式存储两种方式。顺序存储实现方式主要采用循环数组实现，其中队空和队满的判断需要特别
关注。队列的应用也非常广，包括：广度优先搜索、操作系统中各种竞争性资源(如CPU)的管
理、实际应用中服务资源的获得(如银行窗口服务)等。
习题
3.1 判断正误。
(1)若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存
储最节省时间。
(2)若一个栈的输入序列为1,2,3,…,N,输出序列的第一个元素是i,则第j个输出元素一定是j-i-1。
(3)在用数组表示的循环队列中，front 值一定小于等于 rear值。
3.2 填空题。
(1)数组A[1..5,1..6]每个元素占5个单元，将其按行优先次序存储在起始地址为1000的连续的内存单
元中，则元素A[5,5]的地址为___。
(2)带头结点的单链表L为空的判定条件是_。
(3)通过对堆栈S操作：Push(S,1),Push(S,2),Pop(S),Push(S,3),Pop(S),Pop(S)。输出的序列为
(4)如果循环队列用大小为m的数组表示，且用队头指针 front和队列元素个数size代替一般循环队列中
的 front和 rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为______。
3.3 给定一个顺序存储的线性表L=(a,,a,.…,a.),请设计一个算法删除所有值大于min而且小于max
的元素。
3.4 给定一个顺序存储的线性表L=(a?,a?..a),请设计一个算法查找该线性表中最长递增子序列。
例如。(1.9.2.5.7.3.4.6,8,0)中最长的递增子序列为(3,4,6,8)。
3.5 请设计时间和空问上都尽可能高效的算法，求链式存储的线性表的倒数第m个元素。
3.6 请设计实现两个链式存储的一元多项式乘法运算的算法，并分析该算法的时间复杂性。
3.7 如果有1、2、3、4、5按顺序人栈，不同的堆栈操作(pop,push)顺序可得到不同的堆栈输出序列。请问
共有多少种不同的输出序列?为什么?
3.8 请编写程序检查C语言源程序中下列符号是否配对：/·与·人、(与)、[与]、1与。输入为C语言源
程序文件。
3.9 假设以S和X分别表示入栈和出栈操作。如果根据一个仅有S和X构成的序列，对一个空堆栈进行
操作，相应操作均可行〈如没有出现删除时栈空)且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请
编写程序，输人S和X序列，判断该序列是否合法。
3.10 利用堆栈可以以非递归方式求解汉诺塔问题。请编写非递归方式的汉诺塔问题求解算法。
3.11 请编写程序将中缀表达式转换为后缀表达式。
习题 97
3.12 如果用一个循环数组表示队列，并且只设队列头指针 Front,不设尾指针 Rear,而是另设Count 记录队
列中元素。请编写算法实现队列的入队和出队操作。
3.13 双端队列(deque,即 double-ended queue的缩写)是一种具有队列和栈性质的数据结构，即可以(也只
能)在线性表的两端进行插入和删除。若以顺序存储方式实现双端队列，请编写例程实现下列操作。
(1)Push(X,D):将元素X插人到双端队列的头；
(2)Pop(D):删除双端队列的头元素，并返回：
(3)Inject(X.D):将元素X插入到双端队列的尾部；
(4)Eject(D):删除双端队列的尾部元素，并返回。
3.14 在栈的顺序存储实现中，另有一种方法是将Top定义为栈顶的上一个位置。请编写程序实现这种定
义下堆栈的入栈、出栈操作。如何判断堆栈为空或者满?
第4章
树
4.1 引子
4.1.1 问题的提出
我们已学过线性表，并知道，所谓线性是指其任何元素至多有一个前驱或一个后继元素。一
般情况下，不管是用数组实现还是用链表实现，对线性表的大多数操作总避免不了线性的时间复
杂度，这是由于其逻辑结构是线性的这一本质特性所决定的。
客观世界中许多事物具有层次关系，例如，人类社会的家族谱、各种社会组织机构、图书馆中
图书的分类存放等，这些事物中各元素之间有分支、层次关系。图4.1部分地表示了图书馆中图
哲学宗數 …
图书
文学 医药卫生 农业科学 工业技术 …
综合
学理论 世界皙学 欧洲皙学 宗教 电工技术 计算机 …
宗教分析研究 宗教理论与概况 …
建筑科学
佛教 般性坟术 计算机软件 电子模拟计算机 微型计算机 …
宗教与社会改治 宗教与科学 … 破除迷信 软件工程 程序语言 … 编评程序 襟作系统
图4.1 图书分类
水利工程
计算机的应用
4.1 引子 99
书的分类，图4.1中省略了绝大多数具体分类，而只是说明一个层次框架。在各分类层次中，具
体分类标识在方框(称为结点)内，而它们之间的隶属关系用连线(分支)表示出来。
图4.1中灰颜色方框列出了具体类型的图书实体，而白色方框表示的是分类实体隶属关系。
如果我们只用线性表来存储图书实体，而忽视隶属关系的话，得到图4.2所示的线性存储结构，
这相当于将图书实体随机存储在一个线性空间内。
宗教与社会政治 宗教与科学 … 破除迷信 … 软件工程 程序语言 验蔽胜事 作系统
图4.2 图书实体的线性表存储
试想采用这种丢弃分类线索并按线性表存储的方式，若要查找某一个具体的图书实体，算法
的时间复杂度是多少?如果我们能有一种存储方式将隶属关系也考虑在内，查找某一图书实体
的算法是否能有更高的效率?
4.1.2 查找
为了更好地理解树的结构和特性，在正式回答上述问题和介绍树的内容之前，我们首先通过
线性表介绍静态查找的概念，并以两个实例详细介绍顺序查找和二分查找的实现过程与算法。
在此基础上再给出非线性结构树的概念，以使读者对线性和非线性结构的本质特征有更好的
理解。
查找(Searching)在人们日常生活中被频繁使用，例如从字典中查找某个单词的读音与注解，
从黄页簿中查找某个单位的地址和电话等。严格的定义为：给定一个记录的集合R,根据某个给
定的关键字K,从集合R中找出关键字与K相同的记录，这个过程称为“查找”。若集合中存在
这样的记录，则称查找是“成功的”,返回该记录的信息或该记录在集合中的位置；若集合中不存
在这样的记录，则称查找为“不成功的”,返回一个空记录或空指针。
查找可分静态和动态两种情况考虑，又分为利用比较和利用映射两种查找思路。所谓静态
查找，是指集合中的记录是固定的，不涉及对记录的插入和删除操作，而仅仅是按关键字查找记
录。例如，一本词典中所含的词汇是固定不变的，当人们想了解某一个词汇时，以此词汇作为关
键字就可以查到其含义。又如C语言编译器工作时就是在静态的关键字表(包括关键词 in clude、typedef,struct、int、double、for、while、return等)中查找的。
静态查找的效率主要用“平均查找长度”这一指标来衡量。设查找集合中第i个记录的概率
万m。 是P(Zn=1),,且需要进行 n,次比较才能找到，则成功查找的平均查找长度定义为
因为在实际应用中，往往查找成功的可能性比不成功的可能性大得多(如在词典中查找词汇),
100 第4章 树
故可以重点考察成功查找的平均查找长度。一个好的查找算法应能使平均查找长度最小化。
静态查找通常是从一个线性表中查找数据元素，线性表可以是基于数组的顺序存储或者是
线性链表存储，已经在3.2.2节及3.2.3节中分别给出了定义。下面讨论2种静态查找方法。
方法1:顺序查找
顺序查找是一种最基本、直接的查找方法。它从线性表的一端开始，向另一端逐个取出数据
元素的关键字，并与要找的关键字K进行比较，以判定是否存在要找的数据元素。
以数组存储为例，设数据元素从下标为1的数组单元到下标为Last的单元存放。为了简化
算法，使得从后向前查找失败时，不必判断表是否检查完毕，可以在查找开始前，作为哨兵将要查
找的关键字K存入下标为0的数组单元。这样，即使原表1~Last单元中没有关键字为K的记
录，算法再多一次查找下标为0的单元，也会找到元素而终止，而此时用返回数组下标值0表明
查找失败。
代码4.1给出了顺序查找算法的实现函数SequentialSearch。
Position SequentialSearch(List Tb1,ElementType K)
1/*在顺序存储的表 Tbl中查找关键字为K的数据元素，使用“哨兵”*/
Position i;
Tbl->Data[0]=K;/*建立哨兵*/
for(i=Tbl->Last;Tbl->Data[i]!=K;i--);
return i;/*查找成功返回数据元素所在单元下标；查找不成功返回0*/
代码4.1 顺序查找
算法复杂度分析：若有n个数据元素(Last为n),查找从数组下标为Last 的最后一个单元开
始到第一个单元逐个进行数据比对。查找结束时，算法返回一个下标值i,关键字的比较次数则
为n-i+1。因此，顺序查找算法的平均查找长度为 ∑p(n-i+1),其中p,是查找第；个数据元
素的概率。若每个数据元素的查找概率相等，即p:=1/n,则等概率情况下的平均查找长度为
p(n-i+1=富(n-i+1)="2 ;查找不成功时，每个关键字比较一次，直到哨兵为
止，共进行了n+1次比较。由此可见，顺序查找算法的时间复杂度为0(n)。
方法2:二分查找
从查找方法1我们知道，顺序查找算法的时间复杂度是线性的。而当线性表中数据元素是
按大小排列存放时，可以设计一种更高效率的新算法——二分查找。二分查找也称为折半查找，
是针对线性表中数据的存放是有序的这一特殊性，而采用的一种有效方法。
假设n个数据元素的关键字满足k?<k?<…<ka,试想若要查找的关键字K小于线性表中的某
4.1 引子 101
一关键字k,,那么接下来是从k,的左边还是右边继续查找?答案是显而易见的，要找的元素只
可能是在k,左边的i-1个元素中，而一定不会是在k,的右边。因此，利用有序这一特性可以缩
小查找的范围，使得接下来的查找总是在上一次查找范围的一个子集中进行。
二分查找是每次在要查找的数据集合中取出中间元素关键字km与K进行比较，根据比较
结果确定是否要进一步查找。当K=k,查找成功；否则，将在k的左半部分或者右半部分继
续下一步查找。以此类推，每步的查找范围都将是上一次的一半，因此，二分查找也常常被称为
折半查找。
[例4.1] 假设有13个数据元素，它们的关键字为51,202,16,321,45,98,100,501,226,39.
368,5,444。若按关键字由小到大顺序存放这13个数，二分查找关键字为444的数据元素过程
如下。
第一步：要查找数据集合的左边界(left)为下标为1的元素，右边界(right)为下标为13的元
mid=edtris=7 素，则此范围内中间元素的下标为 关键字K与mid单元的关键字相比较，结
果为444>100。下一步的查找将在mid 的右边继续进行。此时，左边界重新设置为left=middle+1,
而右边界保持不变。
5 16 39 45 51 98 100 202 226 321 368 444 501
1 2 3 4 5 6 7 8 9 10 11 12 13
古 古
第二步：此时的左边界为left=8,右边界为 right=13,计算此范围内中间单元的下标为mid=10。
K与mid单元的关键字比较，结果为444>321。下一步将继续在mid单元的右边查找。
5 16
1 2
39 45 51 98 100 202 226 321 368 444 501
3 4 5 6 7 8 9 10 11 12 13
古
第三步：此时的左边界为left=11,右边界仍然是13,计算中间单元下标mid=12。K与mid
单元的关键字比较，结果为444=444,表明已在线性表中找到要查找的元素。
5
1
16 39 45 51 98 100 202 226 321 368 444 501
2 3 4 5 6 7 8 9 10 11 12 13
66m古
上述过程中灰色单元表示某一步不必考虑(缩小)的查找范围。经过上述三步(三次比较)
找到了关键字为444的元素。而采用从左到右的顺序查找将需要比较12次。
102 第4章 树
[例4.2] 仍然以上面13个数据元素构成的有序线性表为例，二分查找关键字为43的数据
元素过程如下：
第一步：与例4.1相同，left=1、right=13、mid=7。关键字K与mid单元的关键字相比较，结
果为43<100。
5 16 39 45 51 98 100 202 226 321 368 444 501
1 2 3 4 5 6 7 8 9 10 11 12 13
6 5
第二步：查找将在mid的左边继续进行。此时，右边界重新设置为 right=middle-1=6,而
左边界保持不变。在缩小的范围内，mid=3。关键字K与mid单元的关键字相比较，结果为
43>39。
5 16 39 45 51 98 100 202 226 321 368 444 501
1 2 3 4 5 6 7 8 9 10 11 12 13
古 6
第三步：查找将在第二步的mid的右边继续进行。此时，左边界重新设置为left=middle+1=4,
而右边界保持不变。在缩小的范围内，mid=5。关键字K与mid单元的关键字相比较，结果为
43<51。
5 16 39 45 51 98 100 202 226 321 368 444 501
1 2 3 4 5 6 7 8 9 10 11 12 13
古 古
第四步：查找将在第三步的mid的左边继续进行。此时，右边界重新设置为 right=middle-1=4,
而左边界保持不变。在缩小的范围内，mid=4。此时，查找范围缩小到只有一个单元。关键字K与
mid单元的关键字相比较，结果为43<45。
5 16 39 45 51 98 100 202 226 321 368 444 501
1 2 3 4 5 6 7 8 9 10 11 12 13
6
第五步：查找将在上一步的mid的左边继续进行。右边界重新设置为right=middle-1=3,而
左边界仍为4,保持不变。此时，出现了左右边界错位的情况，右边界已小于左边界，表明二分查
找结束，没有发现所要找的数据元素。
分析上述例题两个关键值查找的过程，可以得到代码4.2所示的二分查找算法。
4.2 树的定义、表示和术语 103
#define Not Found 0/*找不到则返回0*/
Position BinarySearch(Liat Tb1,ElementType R)
1在顺序存储的表Tb1[1..Last]中查找关键字为K的数据元素*/
Position Ioft. right,mid:
left=1; /*初始左边界·
right-Tb1->Last;初始右边界·
whilo(Ieft<=right)
mid=(left+right)/Z:/*计算中间元素坐标
ir(K<Tb1->Data[mid])right=mid-1;/调整右边界·
return NotFound;/*返回查找不成功的标识*/
elae if(K>Tb1->Data[mid])left=mid+1;调整左边界
else return mid;人查找成功，返回数据元素的下标/
代码4.2 二分查找
与顺序查找算法不同，我们不必通过在0单元增加哨兵来判断查找是否成功，而是通过判断
是否还有合理的剩余查找范围。因此，其实可以将表中元素从单元0开始存起，那么当查找失败
时二分查找算法返回的NotFound就应该是一个负数(比如-1)。
算法时间复杂度分析：从算法代码4.2可以看出，当线性表中没有所要查找的元素时，算法
复杂度达到最大。设经过k步，查找范围从n减小到1。因为每步查找范围是上一步的二分之
一，可得到关系n/2?=1,即k=log?n。由此可以得到结论：二分查找算法具有对数的时间复杂度
0(log n)。
至此，我们已知道顺序查找和二分查找都属于静态查找方法，所谓静态是指数据一旦建立起
来就基本不添加新的数据元素，也不删除原有的数据元素。因此用数组存放数据并通过下标访
问数据元素既方便又高效。但当数据集变化频繁，采用链表存储时，这种基于有序性的二分查找
策略还适用吗?在本章后面我们将介绍二叉搜索树，大家还会看到，基于二分查找思路的动态结
构方法。
4.2 树的定义、表示和术语
从上一节静态查找算法我们知道，当数据具有有序性时，基于线性表的二分查找算法时间复
104 第4章 树
杂度可以达到0(log n)。我们要问的是，当数据组成不具有这种特性时，是否能采用其他的非
线性表数据结构，使得算法也具有较好的时间复杂度?接下来本章的重要内容有关树结构及其
应用(二叉搜索树和AVL树)将使读者得到答案。
树是一种十分重要的非线性数据结构，它的形式化定义如下：
[定义4.1]树(Tree)是n(n≥0)个结点构成的有限集合。当n=0时，称为空树；对于任一
棵非空树(n>0),它具备以下性质：
(1)树中有一个称为“树根”(Root)的特殊结点，用r表示。
(2)其余结点可以划分为m个不相交的子集T?,T?,…,Tm。任何子集T?(i∈[1,m])也是
一个树，称为根结点r的“子树”(SubTree)。每个子树的根结点都与r有一条相连接的边，r是这
些子树根结点的“父结点”(Parent)。
由上述树的定义可以看出这是一种递归的定义形式。由于子树是不相交的，那么除了根结
点外，树中每条边将某个结点与其父结点连起来。因此，除了根结点外，每个结点有且仅有一个
父结点。这隐含着一棵N个结点的树有N-1条边。
在以下有关树的内容介绍中，树的结点用圆圈表示，圈内用一个数字或字母等符号代表该结
点的数据信息(比如，可以是关键字),例如图4.3中的字母A、B、C、…是树的结点。而树枝(树
的边)仍然用结点之间的连线表示。图4.3(a)是一个具有13个结点的树的逻辑表示形式，根结
点A有4个子树，假设命名为T、Ta?和T、T?(见图4.3中的(b)、(c)、(d)、(e)子图),4个子
树的根结点分别是B、C、D和E。B结点又有两个子树，依此类推，树中的每个结点都是其子树
的根结点。
A
B C D B O
D E
F O H ① ①K 日 ①①K
① M ① M
(a)树T (b)子树T? (e)子树Ta (d)子树Ts (e)子树T
图4.3 树的表示形式
m(m≥0)棵树的集合称为“森林(Forest)”。对树中每个结点而言，其子树的集合即为森林。
例如，对于图4.3(a)中根结点A,它的4棵子树T、Ta和Ta、T就构成了一个森林。因此，任
何一棵树可以看作为一个二元组 Tree=(Root,Forest),其中Root是根结点，Forest是这个根结点
所有子树构成的森林。
有关树的一些基本术语包括：
(1)结点的度(Degree):一个结点的度是其子树的个数。例如，图4.3(a)中结点D的度为
4.2 树的定义、表示和术语 105
3.结点E的度为0。
(2)树的度：树的所有结点中最大的度数。例如，图4.3(a)的树中结点A有最大的度数4,
所以这棵树的度为4。
(3)叶结点(Leaf):是度为0的结点。叶结点也可称为端结点，图4.3(a)中E、F、H、J、K、L
和M等7个结点是叶结点。
(4)父结点(Parent);具有子树的结点是其子树的根结点的父结点。例如，图4.3(a)中B
是F、G的父结点。
(5)子结点(Child):与父结点相反，对于某一个结点来讲，其子树的根结点是它的子结点。
例如，图4.3(a)中F和G是B的子结点。
(6)兄弟结点(Sibling):具有同一父结点的各结点彼此是兄弟结点。例如，图4.3(a)中B、
C、D、E有共同的父结点A.它们彼此是兄弟结点。
(7)祖先结点(Ancestor):沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。
例如，图4.3(a)中A、B、C是L的祖先。
(8)子孙结点(Descendant):某一结点的子树中的所有结点是这个结点的子孙。例如，图
4.3(a)中F、G、L是B的子孙。
(9)结点的层次(Level):规定根结点在1层，其他任一结点的层数是其父结点的层数加1。
例如，图4.3(a)中结点G在第3层。
(10)树的深度(Depth):树中所有结点中的最大层次是这棵树的深度。例如，图4.3(a)树
T的深度为4。树的高度(Height)跟深度是一样的，只不过是自底向上计数。叶结点的高度规定
为1,其他任一结点的高度层数是其所有子结点的最大高度层数加1。树的高度就是其根结点的
高度。
(11)分支：树中两个相邻结点的连边称为一个分支。
(12)路径和路径长度：从结点n,到n,的路径被定义为一个结点序列n,,n?,…,n,,对于1≤i<k,n
是n..的父结点。一条路径的长度为这条路径所包含的边(分支)的个数。例如，图4.3(a)中结
点序列(A,D,I,M)是结点A到结点M的路径，其长度为3。
根据上述树的定义和逻辑表示形式，很容易判断在图4.4中，只有图(a)是棵树。而由于图
(b)、(e)、(d)都出现了子树相交、构成了回路的情况，或者说它们不满足N个结点的树有N-1
条边的特性，所以它们都不是树。
A) A A A
B
C B
C D B
C D B C D
E F GH E F GA E F GH E F GH
(a)树 (b)非树 (c)非树 (d)非树
图4.4 树与非树
106 第4章 树
4.3 二叉树
4.3.1 二叉树的定义及其逻辑表示
[定义4.2]一个二叉树是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由
根结点和称为其左子树和右子树的两个不相交的二叉树组成。
根据二叉树的定义，一般来讲，一棵二叉树可以看作为由一个根结点Root 和其左右两棵子
树T?和T组成。具体可有5种基本形态，分别是：①空二叉树；②只有根结点的二叉树；③只
有根结点和左子树T的二叉树；④只有根结点和右子树T的二叉树；⑤具有根结点、左子树T?
和右子树Ta的二叉树。图4.5是这5种基本形态二叉树的图示表示形式。
中
TL T TL TR
(a) (b) (c) (d) (e)
图4.5 二叉树的五种基本形态
一般树的定义它们是同一个树，而对于二叉树来讲，它们是不同的
上述二叉树的定义采用了递归定义方法。与树的一般定义不同，除了每个结点至多有两棵
子树外，子结点是有左右顺序之分的。例如，图4.6中的两个树按 A A
两个树，因为第一个二叉树的右子树为空，而第二个二叉树的左子
树为空。 B D
4.3.2 二叉树的性质 图 4.6 两个不同的二叉树
二叉树的深度小于等于结点数N.可以证明平均深度是0(√N)。图4.7所示为两个二叉树
的特例，图4.7(a)是斜二叉树(Skewed Binary Tree)(也称为退化二又树),图4.7(b)是完美二叉
树(Perfect Binary Tree)。斜二叉树结构最差，深度达到最大N,它已退化为线性表。在一棵二叉
树中，如果所有分支结点都存在左子树和右子树，并且所有叶结点都在同一层上，这样的一棵二
叉树称作完美二叉树(也称为满二叉树)。
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编
号，如果编号为i(1≤i≤n)的结点与满二叉树中编号为i的结点在二又树中的位置相同，则这棵
二叉树称为完全二叉树(Complete Binary Tree)。图4.8给出的是一个完全二又树，读者可以对
照图4.8与图4.7(b)看到它们的对应关系。完全二叉树的特点是：叶结点只能出现在最下层和
4.3 二 又 树 107
A
1
A
2 3
B
B C
4 5 6 7
D E F G
8 9 10 11 12/ 13 14 15 D H ① ① K ① M N ◎
(3)斜二叉树 (b)完美二叉树
图4.7 斜二叉树和满二叉树
次下层，且最下层的叶结点集中在树的左部。显然，一棵完美二叉树必定是一棵完全二叉树。
完全二叉树是最理想的树结构，很容易证明有N个 1
结点的完全二叉树的深度为0(log N)。 A
二叉树有很多重要的性质，下面就罗列部分非常
有用的性质。
2 3
B C
(1)用数学归纳法容易证明：一个二叉树第i层
的最大结点数为2',≥1。
4 5 6 7
D E F
8 9 10/
(2)利用等比数列求和公式，容易得到：深度为k
的二叉树有最大结点总数2*-1,k≥1。
H ① ① K
11 12/
①
图4.8 完全二叉树
(3)对任何非空的二叉树T,若n。表示叶结点的
个数、n?是度为2的非叶结点个数，那么两者满足关系n。=n?+1。
这个公式看上去有趣的地方是，二叉树中明明有3类结点，而公式中却只涉及到度数为0和
2的结点数，那么n,到哪里去了?让我们略花时间仔细看一下各类结点之间的关系。
设n,是二叉树中度为1的结点个数、n是总的结点个数，那么可得到公式4.1:
n=n。+n,+n? (公式4.1)
因为除了根结点外，树中每个结点有且仅有一条与其父结点相连的边。结点数n与边数B
满足关系B=n-1。而B=n?+2n?,所以有公式4.2:
n=1+n,+2n? (公式4.2)
公式4.1减公式4.2就得到no=n?+1。
(4)根据完全二叉树的定义和性质1可知：具有n个结点的完全二叉树的深度k为Llog?n]+1。
4.3.3 二叉树的存储结构
在计算机内存中存储二叉树时，除了存储它的每个结点数据外，结点之间的逻辑关系(父子
关系)也要得到体现。
108 第4章 树
1.顺序存储结构
微视频4-1
这种结构是用一组连续的存储单元(比如数组)存储二叉树结点的
数据，结点的父子关系是通过它们相对位置来反映的，而不需要任何附
加的存储单元来存放指针。通常情况下顺序存储结构用于完全二叉树
的存储。 完全二叉树
的顺序存储
方法
具体实现是从树的根结点开始，从上层至下层，每层从左到右，依次
给结点编号并将数据存放到一个数组的对应单元中。图4.9(a)是一个
完全二叉树，图4.9(b)是其顺序存储的结果。完全二叉树的顺序存储除
了高效的存储空间利用率外，结点的父子关系计算也十分简单高效。从
图4.9(a)可知，结点C的父结点是结点B,它的左孩子是结点W,右孩子是结点K。从图4.9
(b)可知，C结点存储单元的下标是4,将其除以2得到它的父结点B的存储单元下标，而将其
乘以2则是它的左孩子W存储单元的下标，当然将其乘2再加1则是它右孩子K的存储单元
下标。
土
A
2 3
B ◎
4 5 6
C S M
7
@ 数据 A B 0 C s M Q W
1 2 3 4 5 6 7 8
K
8/ 9
W K
编号 9
(a)完全二叉树 (b)顺序存储结构
图4.9 完全二又树及其顺序存储
概括起来，在N个结点的完全二叉树中，对于下标为i的结点：
(1)当Li/2]≥1时，Li/2]单元是其父结点；当Li/2J=0时，表明该结点是树的根结点，无父
结点。
(2)当2i≤N时.2i单元是其左孩子；否则无左孩子。
(3)当Zi+1≤N时，2i+1单元是其右孩子；否则无右孩子。
还要特别声明的是，这种下标的简单运算确定父子关系所用的数组起始单元下标是1,而不
是0。
2.二叉树的链表存储
虽然完全二叉树的顺序存储具有存储空间利用率高、计算简单的双重优点，但它并不适合于
一般的二叉树。比如图4.10是一个二叉树及其他的顺序存储结果。
4.3 二 叉 树 109
A
1
A
2 3
B ◎ B O
4 5 6 7
M
M
8 9 10/ 11 12/ 13
C
(a)二叉树 (b)对应(a)的完全二叉树
数据 A B 0 人 入 M 入 入 入 入 入 入
1 2 3 4 5 6 7 8 9 10 11 12
c
编号 13
(C)顺序存储结果
图4.10 一般二叉树的顺序存储
图4.10(a)为给定的二叉树。图4.10(b)给出了从上至下、从左至右的层序存储的对应
结点编号，其中灰色结点是为了满足顺序存储要求而增加的“虚”结点，可以在相应的存储单
元存放一个特殊的数值，以区别于其他“实结点”。图4.10(c)则是最终的存储结果。可以看
到，5个结点的二叉树，顺序存储需要13个存储单元，超过一半的存储空间浪费掉了。更有甚
者，对一个深度为k的右斜二叉树来讲，需要2?-1个存储单元，而实际上该斜二叉树只有k个
结点。
另外，二叉树的顺序存储方式避免不了顺序存储的固有缺点，即不易实现增加、删除操作。
因此，二叉树的顺序存储方式适用于一定的条件，对于不需要修改的完全二叉树，是一种较好的
选择。
实际上，二叉树的最常用表示方法是用链表表示，每个结点由数据和左右指针三个数据成员
组成(如图4.11所示),代码4.3为其结构定义。
typedef struct TNode*Position;
typedef Position BinTree;/二叉树类型·/
struct TNodel/*树结点定义*/
ElementType Data;/*结点数据*/
BinTree Left; /*指向左子树*/
BinTree Right;/*指向右子树/
I;
代码4.3 二叉树的链表结构
110 第4章 树
Left Data Right Data
Left Right
图4.11 二叉树结点结构
其中，Data域表示这个树结点的数值，Left 域代表指向本结点的左子树根结点的指针，Right是其
右子树根结点的指针。例如，图4.12(a)为一棵二叉树，图4.12(b)是其链表表示的实现。
A) A
B C B C
D F G ① AD 入 F A A G A I A
E H A E 入 A H A
(a) (b)
图4.12 树的链表实现
虽然在图4.12(a)中每条连线上没有用箭头指定方向，但各连线仍然是有向的，其方向隐含
从上而下，即连线的上方结点是下方结点的父结点或称为“前驱结点”,下方结点是上方结点的
子结点或称为“后继结点”。
4.3.4 二叉树的操作
首先我们给出二叉树的抽象数据类型定义。
类型名称：二叉树(BinTree)
数据对象集；一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根结点和其左、
右二又子树组成。
操作集：对于所有BT ∈BinTree,重要的操作有：
(1)bool IsEmpty(BinTree BT):若BT为空返回true;否则返回 false;
(2)void Traversal(BinTree BT):二叉树的遍历，即按某一顺序访问二叉树BT中的每个结点
仅一次：
(3)BinTree CreatBinTree():创建一个二又树。
判断二叉树是否为空是比较简单的事。下面我们着重介绍遍历和创建二叉树的操作。
1.二叉树的遍历
树的遍历是指访问树的每个结点，且每个结点仅被访问一次。访问是一个抽象的概念，实际
4.3 二 叉 树 111
上可以是对结点数据的各种处理，比如输出结点信息。二叉树的遍历可按二叉树的构成以及访
问结点的顺序分为四种方式，即先序遍历、中序遍历、后序遍历和层序遍历。
前三种顺序的命名是依据一个结点和其左右子树被访问的先后次序。我们用L、V和R分
别表示遍历左分支(L)、访问结点(V)和遍历右分支(R),那么可以有六种不同的访问顺序，它们
是LVR、LRV、VLR、VRL、RVL和RLV。若再规定对某一结点左子树的遍历总是在右子树之前，
则只要考虑三种次序的遍历，即LVR、LRV和VLR。按V的位置，它们分别代表中序遍历、后序
遍历和先序遍历。这三种遍历的区别在于同一结点在不同时刻访问，在其各自的遍历结果序列
中位置不同。
(1)中序遍历。
它是指对树中任一结点的访问是在遍历完其左子树后进行的，访问此结点后，再对其右子树
遍历。遍历从根结点开始，遇到每个结点时，其遍历过程为：
①中序遍历其左子树；
②访问根结点；
③中序遍历其右子树。
这个过程用递归可以很方便地实现，如代码4.4所示。在此函数中，“访问结点”定义为用
屏幕输出结点的数据。在实际应用中，读者可以根据自己的需要另外定义“访问结点”函数。
void InorderTraversal(BinTree BT)
if(BT)I
InorderTraversal(BT->Left);
/此处假设对BT结点的访问就是打印数据*/
printf("?,BT->Data);/*假设数据为整型*/
TnorderTraversal(BT->Right);
代码4.4 二叉树中序遍历
如果从非递归的角度理解，遍历实际上是从树根结点开始，沿其左孩子域向下移动，直到某
一结点再无左孩子为止，访问这个最左边的结点，接下来再从此结点的右孩子结点开始进行中序
遍历，当右子树遍历完了以后，退回到上一层的未访问结点继续二叉树的遍历，直到树中所有的
结点被访问到为止。
在图4.13的举例中，标注出了二叉树中序遍历算法的执行过程及其输出结果。其中，图
4.13(a)从根结点开始，在每条边旁的灰色箭头表示算法执行过程中沿各结点指针的探索过程，
而各结点旁的带数字的黑底色圆框给出了结点输出的时刻和顺序。图4.13(b)列出了最终的输
出结果。
112 第4章 树
A
B
② D B E F A G H C I 0
D F G ①
0
3E H
(a) (b)
图4.13 二叉树中序遍历过程及其结果举例
(2)先序遍历。
它是指对结点的访问是在其左、右子树遍历之前进行的。遍历是从根结点开始，遇到每个结
点时，其遍历过程为：
①访问根结点；
②先序遍历其左子树；
③先序遍历其右子树。
递归实现由代码4.5给出。
void PreorderTraversal(BinTree BT)
if(BT)
printf("8d",BT->Data);
PreorderTraversal(BT->Left);
PreorderTraversal(BT->Right):
代码4.5 二又树先序遍历
同中序遍历的举例类似，图4.14中，标注出了先序遍历二叉树的具体过程和遍历结果。
A
B 6
A B D F E C G H I
D
④ F (G 9①
E ⑧ (H
(a) (b)
图4.14 二叉树先序遍历过程及其结果举例
4.3 二 叉 树 113
(3)后序遍历。
它是指结点左右子树的遍历先进行，然后才是对此结点的访问。后序遍历则是从根结点开
始，遇到每个结点时，其遍历过程为：
①后序遍历其左子树；
②后续遍历其右子树；
③访问根结点。
递归实现由代码4.6给出。
void PostorderTraversaI(BinTree BT)
1f(BT)
PostorderTraversal(BT->Left);
PoatorderTraversal(BT->Right);
printf(*d",BT->Data):
代码4.6 二叉树后序遍历
在图4.15的举例中，我们标注出了后序遍历二叉树的具体过程和结果。
A
B④ C
D E F B H G I CA
D F G ①
Q
E ⑥ H
(a) (b)
图4.15 二叉树后序遍历过程及其结果举例
(4)二叉树的非递归遍历。
上面给出的二叉树先序、中序和后序三种遍历算法都是递归算法。但是，并非所有程序设计语
言都支持递归；另一方面，递归程序虽然简洁，但程序执行效率不高——从代
码1.10与代码1.9的运行比较就可以看出。因此，就存在如何把一个递归算
法转化为非递归算法的问题。下面，我们再分析、概括一下3种遍历方法的具
体过程，在此基础上将给出解决这个问题的方法。
从二叉树先序、中序和后序遍历的遍历过程图4.13、图4.14和图4.15
所标示出的遍历路径来看，都是从根结点A开始的，且在遍历过程中经过
结点的路线是一样的，只是访问各结点的时机不同而已。在图4.16中，我
微视频4-2
二叉树的遍
历路线
114 第4章 树
们用一围绕此树的连续曲线表示出这一遍历路线，路线从根结点左外侧入口处开始，由根结点右
外侧出口处结束。并在从人口到出口的曲线上用?、☆和△三种符号分别标记出了先序、中序和
后序遍历各结点的时刻。沿着该路线按?标记的结点读得的序列为先序序列，按☆标记读得的
序列为中序序列，按△标记读得的序列为后序序列。
入口 出口
×
A
B △
D ? F
×
E (H)
图4.16 二叉树遍历路线示意图
注意到，这一路线正是从根结点开始沿左子树深入下去，当深入到最左端，无法再深人下去
时，则返回刚才深入时遇到的结点，再逐一进入其右子树，进行如此的深入和返回，直到最后从根
结点的右子树返回到根结点为止。先序遍历是在深入时遇到结点就访问，中序遍历是在从左子
树返回时遇到结点访问，后序遍历是在从右子树返回时遇到结点访问。
在这一过程中，返回结点的顺序与进入结点的顺序相反，即后进入先返回，正好符合堆栈结
构后进先出的特点。因此，可以借助于堆栈来实现这一遍历路线。其过程如下。
在沿左子树深人时，进入一个结点就将其压人堆栈。若是先序遍历，则在入栈之前访问之；
当沿左分支深人不下去时，则返回，即从堆栈中弹出前面压入的结点；若为中序遍历，则此时访问
该结点，然后从该结点的右子树继续深入；若为后序遍历，则将此结点二次入栈，然后从该结点的
右子树继续深入，与前面类同，仍为进入一个结点入栈一个结点，深入不下去再返回，直到第二次
从栈里弹出该结点，才访问之。
因此，按照上述描述过程，使用堆栈可以直接实现相应的非递归算法。先序和中序算法相对
简单些，而后序遍历因为需要两次将一个结点入栈，情况相对复杂些。这里，我们只以中序遍历
为例，介绍二叉树遍历的非递归算法。
在按中序遍历二叉树时，遇到一个结点，就把它压栈，并去遍历它的左子树；当左子树遍历结
束后，从栈顶弹出这个结点并访问它，然后按其右指针再去中序遍历该结点的右子树。代码4.7
列出了实现二叉树的非递归中序遍历的算法。
void InordorTraversal(BinTree BT)
BinTree T;
Stack s=Createstack();人创建空堆栈S,元素类型为BinTree*/
4.3 二 叉 树 115
T=BT;/+从根结点出发
while(T Ⅱ!ISEmpty(S))
while(T)/一直向左并将沿途结点压人堆栈*/
Push(s,T);
T=T->Left;
1
T=Pop(S);/· 结点弹出堆栈·/
printf("8d",T->Data);/*(访问)打印结点*/
T=T->Right;/* 转向右子树*/
代码4.7 二叉树非递归中序遍历算法
(5)层序遍历。
除了先序、中序和后序三种基本的二叉树遍历方法外，有时还用到二叉树的层序遍历。层序
遍历是按树的层次，从第1层的根结点开始向下逐层访问每个结点，对某一层中的结点是按从左
到右的顺序访问。因此，在进行层序遍历时，完成某一层结点的访问后，再按它们的访问次序依
次访问各结点的左右孩子，这样一层一层进行下去，先遇到的结点先访问，这与队列的操作过程
是吻合的。具体的算法实现可以设置一个队列结构，遍历从根结点开始，首先将根结点指针入
队，然后开始执行下面三个操作：
①从队列中取出一个元素；
②访问该元素所指结点；
③若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。
不断执行这三步操作，直到队列为空，再无元素可取，二叉树的层序遍历就完成了。代码
4.8为二叉树层序遍历算法。
void LevelorderTraversal(BinTreeBT)
IQueue Q;
BinTree T;
if(!BT)return;/*若是空树则直接返回*/
Q=CreatQueue();/*创建空队列Q*/
AddQ(Q,BT);
while(!ISEmpty(Q))
T=DeleteQ(Q);
printf("?,T->Data);/* 访问取出队列的结点*/
116 第4章 树
if(T->Left)AddQ(Q,T->Left);
if(T->Right) AddQ(Q,T->Right);
代码4.8 二叉树的层序遍历算法
仍然以图4.16中的二叉树为例，执行层序遍历算法得到的输出序列为(A,B,C,D,F,G,I,
E,H)。
[例4.3]输出二叉树中的所有叶结点。
输出二叉树中的叶子结点与输出二叉树中的结点相比，它是一个有条件的输出问题。唯一
的区别就是执行“访问结点”的时候，先对该结点进行检测，看它是否是叶子结点，也就是看它的
左右子树是否都为空。所以只要在二叉树的遍历算法中增加检测条件就可以了。代码4.9所示
的叶子结点输出算法是在代码4.5的二叉树先序遍历算法基础上修改的。
void PreorderPrintLeaves(BinTree BT)
if(BT)
if(!BT->Left &&!BT->Right)/*如果BT结点是叶子*/
printf("8d",BT->Data);
PreorderPrintLeaves(BT->Left);
PreorderPrintLeaves(BT->Right);
代码4.9 二叉树叶结点输出算法
[例4.4]求二叉树的高度。
我们知道一棵二叉树的高度(Height)是其根结点的高度，而根结点的高度则是其左子树高
度(H)和右子树高度(H?)两者中的最大值加1(如图4.17所示)。因此可采用二叉树遍历的原
理，递归地计算出二叉树的高度。由于要获得根结点的高度，首先要获得其左右子树的高度，所
以需要利用后序遍历。代码4.10就是根据代码4.6改编而来。注意：根据定义，叶结点高度为
1,所以空树的高度为0。
H? 李树 右子树 H
图4.17 二叉树高度示意图
4.3 二 叉 树 117
int GetHeight(BinTree BT)
int HL.HR,MaxH;
if(BT)1
HL=CetHeight(BT->Left);/求左子树的高度*/
HR=GetHeight(BT->Right):/*求右子树的高度*/
MaxH=HLS HR?HL:HR: /*取左右子树较大的高度*/
return(MaxH+1); /*返回树的高度·/
else return 0;/空树高度为0+/
代码 4.10 求二叉树高度算法
[例4.5] 表达式树及其遍历。
为了加深对二叉树遍历的理解，我们先介绍表达式树，再将其作为二叉树的一个具体的应用
看一下不同遍历的实现。
在3.3节我们介绍了利用堆栈进行表达式求值，知道一个表达式是由一系列运算符号和运
算数组成的。为方便起见，我们只考虑二元运算，即一个运算符作用于两个运算数，比如：a+b*c+
(d*e+f)*g,此表达式有加法和乘法两种二元运算符，以及a~g等7个运算数。这种一个运算符
夹在两个运算数中间的表达形式称为中缀表达式。
由于每个运算符完成两个运算数的算术运算，因此用二叉树表示表达式是合适的。图4.18
是这个表达式的二叉树表示形式，树的叶结点是运算数，可以是常数或变量名；树的非叶结点是
运算符。
如果以图4.18的表达式树为实参调用二叉树遍历函数InorderTraversal(代码4.4)、Preorde rTraversal(代码4.5)和PostorderTraversal(代码4.6),将会分别得到不同的遍历序列，输出结果
为：a+b*c+d*e+f*g、++a*bc*+*defg和 abc*+de*f+g*+。
从表达式树的3种遍历可以得到3种不同的访问
结果，基本对应于中缀表达式、前缀表达式和后缀表达
式。注意，由于不同运算存在优先级，表达式树的中序
遍历结果并不一定是表达式所对应的中缀形式(如图
+
+)
a + 8
4.18就是这样的情况)。不过，只要做个简单的处理就
能正确输出中缀表达式(请想想怎么做?提示：加括
号)。实际上，有了表达式树后可以按照后缀遍历直接
计算表达式。
6 C
①
@ e
图4.18 表达式树
118 第4章 树
[例4.6]由两种遍历序列确定二叉树
从前面讨论的二叉树的遍历知道，任意一棵二叉树结点的先序遍历序列和中序遍历序列都
是唯一的。反过来，若已知结点的先序遍历序列和中序遍历序列，能否确定一棵二叉树?这样确
定的二叉树是否是唯一的?
[分析]根据定义，二叉树的先序遍历是先访问根结点，其次，再按先序遍历方式遍历根
结点的左子树，最后，按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一
个结点一定是二叉树的根结点。另一方面，中序遍历是先遍历左子树，然后访问根结点，最后
再遍历右子树。这样，根结点在中序遍历序列中必然将其分割成两个子序列，前一个子序列
是根结点的左子树的中序遍历序列，而后一个子序列是根结点的右子树的中序遍历序列。根
据这两个子序列，在先序序列中找到对应的左子序列和右子序列，如图4.19所示。在先序序
列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。
这样，就确定了二叉树的3个结点。同时，左子树和右子树的根结点又可以分别把左子序列
和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵
二叉树。
根结点 左子树 右子树 左子树 根结点 右子树
(a)先序序列 (b)中序序列
图4.19 先序遍历序列和中序遍历序列的关系
同样的道理，由二叉树的后序遍历序列和中序遍历序列也可唯一地确定一棵二叉树。因为，
依据后序遍历和中序遍历的定义，后序序列的最后一个结点(根结点),就如同先序序列的第一
个结点一样，可将中序序列分成两个子序列，分别为这个结点的左子树的中序遍历序列和右子树
的中序遍历序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列。如此递归下去，当
倒着取尽后序序列中的结点时，便可以得到一棵二又树。
例如，已知一棵二又树的中序遍历结果为cbedahgijf,后序遍历结果为cedbbjigfa,图4.20画
出的就是这两个遍历序列所确定的二叉树。
从后序遍历结果可以知道最后一个访问的结点是a,可推出该二叉树的根结点是a,那么中
序遍历在a之前的结点序列cbed构成a结点的左子树，在其后的结点序列hgijf则构成a的右子
树，可以得到图4.20(a)的结果。
分析a的左子树，子序列cbed后序遍历时，b是最后访问到的结点，可以断定它是a的左子
树的根结点，中序遍历在b之前的结点c构成其左子树，中序遍历在b后的结点序列ed构成了b
的右子树，此时可以得到图4.20(b)的结果。
分析b的右子树，结点 ed在后序遍历序列中d排在e之后，d是此右子树的根结点，在中序
4.3 二叉 树 119
遍历序列中e排在d之前，说明e是d的左子树结点，由此得到图4.20(c)的结果。
此时根结点的左子树已完全画出，用同样的方法分析根结点a的右子树，就可以得出最终的
图4.20(d)所示的结果。
(a
a 6 hgijt
cbed hgijD C ed
(a) (b)
a
a b
b hgijf @
④ C h ①
①
(c) (d)
图4.20 用中序和后序遍历序列构造其二叉树
2.二叉树的创建
由于树是非线性结构，创建一棵二叉树必须首先确定树中结点的输入顺序，常有的方法是先
序创建和层序创建两种。
层序创建所用的结点输入序列是按树的从上至下从左到右的顺序形成的，各层的空结点输
入数值0。在构造二叉树过程中，需要一个队列暂时存储各结点地址，其创建过程如下。
(1)输入第一个数据：
● 若为0,表示是此树为空，将空指针赋给根指针，树构造完毕；
● 若不为0,动态分配一个结点单元，并存入数据，同时将该结点地址放入队列。
(2)若队列不为空，从队列中取出一个结点地址，并建立该结点的左右孩子：
●从输入序列中读入下一数据；
若读入的数据为0,将出队结点的左孩子指针置空；否则，分配一个结点单元，存人所读数
值，并将其置为出队结点的左孩子，同时将此孩子地址入队；
● 接着再从输入序列中读入下一个数据；
若读入的数据为0,将出队结点的右孩子指针置空；否则，分配一个结点，存人所读数值，并
将其置为出队结点的右孩子，同时将此孩子地址入队。
(3)重复第(2)步过程，直到队列为空，再无结点出队，构造过程到此结束。
120 第4章 树
为了说明如何确定图4.12(a)所示二叉树的层序输入序列，可对其进行适当改造，添加空结
点(灰色结点)。图4.21(a)是改造后的结果，4.21(b)则是对应的输入序列。
1
A
2 3
B C
4
D
5
F
6 7
G ①
8
9101 11 12/ 1314 15
E H
16 17 18 19
(a)根据图4.12(a)改造后的二叉树
A, B. c, D,F, G,I,0,-0.E, 0,0,H, 0,0,0.0,0,0
(b)输入序列
图4.21 二叉树的生成
代码4.11列出了层序生成二叉树的算法。
typedef int ElementType;/*假设结点数据是整数*/
#define NoInfo 0 /*用0表示没有结点*/
BinTree CreatBinTree()
ElementType Data;
BinTree BT,T;
Queue Q-CreatQueue();创建空队列·/
/*建立第1个结点，即根结点*/
scanf("?,GData);
if(Data!-NoInfo)|
八 分配根结点单元，并将结点地址入队/
BT=(BinTree)malloc(sizeof(struct TNode));
BT->Data=Data:
BT->Left=BT->Right=NULL;
AddQ(Q,BT);
else return NULL;/*若第1个数据就是0.返回空树*/
4.3二 叉 树 121
while(!ISEmpty(Q))1
T=DeleteQ(Q);/从队列中取出一结点地址*/
scanf(*kd",&Data):/* 读入T的左孩子*/
if(Data ==NoInfo)T->Left=NULL;
elsel/* 分配新结点，作为出队结点左孩子；新结点入队·/
T->Left=(BinTree)malloc(aizeof(struct TNode)):
T->Left->Data=Data:
T-SLeft->Left=T->Left->Right=NULL:
Addo(0. T->Lert);
scanf("8d",&Data); 读人T的右孩子/
if(Data==NoInfo)T->Right=NULL;
else I/*分配新结点，作为出队结点右孩子：新结点人队*/
T->Right=(BinTree)malloc(sizeof(struct TNode));
T->Right->Data=Data;
T->Right->Left=T->Right->Right =NULL;
AddQ(Q,T->Right);
1/*结束while*/
return BT;
代码4.11 二叉树层序生成算法
下面我们以图4.21为例，由图4.22详细给出执行二叉树层序生成算法的具体过程。
输入序列：A.B,C,D,F,G,1,0,0,E,0,0,H,0,0,0,0,0,0 A
A
(a)输入A,作为根，并入队
输入序列：A,B,C.D,F,G,L,0,0,E,0,0,H,0,0,0,0,0,0
A
BC B
A
C
(b)A出队，输入B,作为A的左孩子，并入队：输入C,作为A的右孩子，并入队
122 第4章 树
输入序列：A,B,C.D,E.G,1,0,0,E,0,0,H,0,0,0,0,0,0 A
B
B
C(DF D F
(c)B出队，输入D,作为B的左孩子，并入队；输入F,作为B的右孩子，并入队
输入序列：A.B,C.D.FG1.0,0,E,0,0,H,0,0,0,0,0,0
A
C
B
DF G(① ① F G ①
(d)C出队，输入G,作为C的左孩子，并入队：输入I,作为C的右孩子，并入队
输入序列：A.B,C.D,E,G,1,0.0,E,0,0,H,0,0,0,0,0,0
A
B
D F G(① D F
(e)D出队，输入0,D的左孩子置空：输入0,D的右孩子置空
输入序列：A,B,C,D,E,G,1,0,0,E,0,0,H,0,0,0,0,0,0 A
B
F
O(①E D F G
E
(1)F出队，输入E,作为F的左孩子，并入队；输入0,F的右孩子置空
输入序列：A,B,C,D,E,G,1.0,0,E,0,0.H,0,0,0,0,0,0
A
B
G ① EH D F G
E
(g)G出队，输入0,G的左孩子置空：输入H,作为G的右孩子，并入队
G ①
C
①
①
4.3二 叉 树 123
输入序列：A.B.C.D.F.G,1,0.0.E,0,0.H,0,0.0.0.0.0
A
B C
① EH D F @ ①
E H
(h)出队，输入0,I的左孩子置空，输入0,1的右孩子置空
输入序列：A,B.C,D,EG,J,0,0,E,0,0,H,0,0,0,0,0,0
A
B
E 日 D F G ①
E H
①)E出队，输入0,E的左孩子置空：输入0,E的右孩子置空
输入序列：A,B.C,D,F,G,,0.0.E,0,0,H,0,0,0,0.0,0
A
B
H D F G ①
E H
()H出队，输入0,H的左孩子置空：输入0,H的右孩子置空；队列为空，过程结束
图4.22 层序生成二叉树举例
[例4.7] 表达式树的构造
既然可以用二叉树表示表达式，并且通过二叉树的遍历可以完成表达式的计算，那么如何将
一串字符构成的表达式在内存中以表达式树的形式存放?
下面给出的算法实现后缀表达式的二叉树存储。堆栈同样可以在构造表达式树的过程中扮
演十分重要的角色，每次读入表达式的一个符号，如果读入答号是运算数，将其作为单个结点构
造一棵二叉树，并将指向这棵树的指针压入堆栈；如果读入的符号是运算符，从堆栈中弹出两个
元素，连同读入的符号构成一棵新的二叉树，树的根结点存人所读入的运算符，左子树为从堆栈
中后弹出的元素，右子树为先弹出的元素，接下来把指向这棵新的二叉树的指针压入堆栈。重复
这一过程，直到处理完表达式的最后一个符号为止，最后形成的二叉树就是所要求的结果。
我们以上一节所介绍例子的后缀表达式 abe*+de*f+g*+为输入，构造其相应的表达式
树，并以图4.23详细列出构造过程。图4.23中的堆栈横着摆放，左侧为栈底位置。
124 第4章 树
abc*+de*f+g*+ abc*+de*f+g*+
a) 6 C a
6
(a) (b)
abc*+de"f+g?+ abe*+de*f+g*+
+ @ e +
a O a ④
6 C 6
(d) (e)
abc*+de*f+g*+
+ + +
a ① a
6 C d e b
(g)
abe*+de*f+g?+
+
a + B +)
6
1)
图4.23 表达式树的构造
abe*+de*f+g*+
+
a
b C
(c)
abe*+de*f+g*+
a O ④
b C
(t)
abe*+de*f+g*+
+ ⑧
①
C d e
(h)
abe*+de*f+g*
+
⑧
O ①
@
①
①
4.4 二叉搜索树 125
(1)首先，依次读入三个符号a、b、c都是运算数，构成三棵一个结点的二叉树，并依次将三
棵树的指针压栈，结果如图4.23(a)所示。
(2)当读入运算符*号后，从堆栈中弹出两个元素，与*号构成新的二叉树，并将指向它的
指针压栈，结果如图4.23(b)所示。
(3)当读入+后，从堆栈中弹出两个元素，构成新的二叉树，并将指向它的指针压栈，结果如
图4.23(c)所示。
(4)当读入d、e后，构成二棵单个结点的二叉树，并依次将指向它们的指针压栈，结果如图
4.23(d)所示。
(5)当读入*后，从堆栈中弹出两个元素，与*号构成新的二叉树，并将指向它的指针压栈，
结果如图4.23(e)所示。
(6)当读入符号f后，构成单个结点的二叉树，并将指向它的指针压栈，结果如图4.23(f)
所示。
(7)当读入+后，从堆栈中弹出两个元素，与+号构成新的二叉树，并将指向它的指针压栈，
结果如图4.23(g)所示。
(8)当读入符号g后，构成一个单个结点的二叉树，并将指向它的指针压栈，结果如图4.22
(h)所示。
(9)当读入*后，从堆栈中弹出两个元素，与*号构成新的二叉树，并将指向它的指针压栈，
结果如图4.23(i)所示。
(10)当读入最后一个符号+后，从堆栈中弹出两个元素，与+号构成新的二叉树，并将指向
它的指针压栈。此时完成了表达式的二叉树存储，结果如图4.23(j)所示。
4.4 二叉搜索树
4.4.1 二叉搜索树的定义
二叉搜索树(Binary Search Tree)也叫做二叉排序树或二叉查找树，它是一种对排序和查找
都很有用的特殊二叉树。在下面的介绍中，为了方便起见，规定各键值彼此不同。
[定义4.3]一个二叉搜索树是一棵二叉树，它可以为空。如果不为空，它将满足以下
性质：
(1)非空左子树的所有键值小于其根结点的键值；
(2)非空右子树的所有键值大于其根结点的键值；
(3)左、右子树都是二叉搜索树。
图4.24给出了两棵二叉树。在图4.24(a)中键值为10的结点有一个键值为5的右孩子，
这不满足非空右子树键值要大于根结点的性质，因此，它不是二叉搜索树。而图4.24(b)所示的
126 第4章 树
二叉树是一棵二叉搜索树。由于二叉搜索树具有的左小右大的有序特征，不难看出对它进行中
序遍历，将得到一个从小到大的输出序列。
(18 30
⑩ 20 ? ④
⑦ ⑤ 2 33 50
(a) (b)
图4.24 二叉树与二叉搜索树
4.4.2 二叉搜索树的动态查找
二叉搜索树是施加了一定约束的特殊二叉树，前面介绍的二叉树的表示和操作都可以直接
用于二叉搜索树，比如中序、先序和后序遍历。不同的是，二叉搜索树的查找、插入和删除操作将
与其特性有关，但这些主要是算法实现的不同，而函数原型并没有什么变化。事实上，二叉搜索
树结点的定义与代码4.3给出的普通二叉树完全是一样的，一般用链表存储。
二叉搜索树作为抽象数据结构的定义也与普通二叉树基本相同，只是操作集中多了下列几
个特别的函数：
(1)Position Find(BinTree BST,ElementType X):从二叉搜索树BST中查找元素X,返回其所
在结点的地址；
(2)Position FindMin(BinTree BST):从二叉搜索树BST中查找并返回最小元素所在结点的
地址；
(3)Position FindMax(BinTree BST):从二叉搜索树BST中查找并返回最大元素所在结点的
地址。
下面我们就详细介绍这三种操作的实现。
1.二叉搜索树的查找操作Find
它是指在二叉搜索树中查找关键字为X的结点，返回其所在结点的地址。由于二叉搜索树
的特殊性质，查找可以比较方便地实现。其过程如下。
(1)查找从树的根结点开始，如果树为空，返回NULL.表示未找到关键字为X的结点。
(2)搜索树非空，则根结点关键字和X进行比较，依据比较结果，需要进行不同的处理：
①若根结点键字小于X,满足条件的结点将不会出现在它的左子树，接下来的搜素只需在
此根结点的右子树中进行；
②如果根结点的键字大于X,接下来的搜索将在此根结点的左子树中进行：
③若两者比较结果是相等，搜索完成，返回指向此结点的指针。
显然，在二叉排序树上进行查找，若查找成功，则是从根结点出发走了一条从根到待查结点
4.4 二叉搜索树 127
的路径；若查找不成功，则是从根结点出发走了一条从根到某一叶结点的路径。代码4.12列出
了实现此过程的递归算法。
Position Find(BinTree BST,ElementType x)
if(!BST)return NULL;/* 查找失败*/
if(X>BST->Data)
return Find(BST->Right,x);/·在右子树中递归查找*
else if(X<BST->Data)
return Find(BST->Left,X);/* 在左子树中递归查找*/
else/*X==BST->Data */
return BST:/* 在当前结点查找成功，返回当前结点的地址 */
代码4.12 二叉搜索树的递归查找函数
由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改
为迭代函数——在代码4.13中用while循环替代代码4.12中的Find递归调用即可。
Position Find(BinTree BST,ElementType x)
while(BST)
if(X>BST->Data)
BST=BST->Right;/* 向右子树中移动，继续查找*/
else if(X<BST->Data)
BST=BST->Left;/* 向左子树中移动，继续查找·/
else/*X==BST->Data*/
break;/·在当前结点查找成功，跳出循环*/
return BST;/* 返回找到的结点地址，或是NULL*/
代码4.13 二叉搜索树的迭代查找函数
2.查找最大和最小元素
根据二叉搜索树的性质，最小元素一定是在树的最左分支的端结点上。所谓最左分支的端
结点，是指最左分支上无左孩子的结点。而最大元素一定是在最右分支的端结点上。例如图
4.25中的结点7和结点22分别是最左端点和最右端点。这使得 FindMin和 FindMax较Find函
数更简单，只要从根结点开始，当其不为空时，沿着左分支或右分支逐个判断各结点的指针，
直到遇到空指针为止。从左分支逐层推下来查找到的是最小元素；反之，从右分支找到的是
最大元素。
128 第4章 树
18
⑩ 20
最左端点 ⑦ ?
22 一最右端点
⑨
图4.25 二叉搜索树的最左和最右端结点
代码4.14和4.15分别给出了实现查找最小元素的递归函数FindMin和查找最大元素的非
递归(迭代)函数FindMax。读者可以尝试自己写出这两个函数的迭代和递归版本。
Position FindMin(BinTree BST)
4/*最小元素在最左端点*/
if(!BST)return NULL;/*空的二叉搜索树，返回NULL·/
else if(!BST->Left)return BST;/*找到最左端点并返回*/
else return FindMin(BST->Left);/*沿左分支递归查找*/
代码4.14 查找最小元素的递归函数
Position FindMax(BinTree BST)
1 if(BST)
while(BST->Right)
BST=BST->Right;/*沿右分支一直向下，直到最右端点*/
return BST;
代码4.15 查找最大元素的迭代函数
从上述基于二又搜索树的动态查找我们可以看到，它实现的基本原理与基于线性表的静态
二分查找很相似，都是利用有序性不断地缩小查找空间。而之所以有静态和动态之分主要是为
了适应于不同的应用需求，前者适用于数据一旦建立好，一般不大需要改变，也就是说不需要或
者很少进行删除和插入操作；而后者适用于频繁的数据变化，插入和删除是
其基本的操作。
4.4.3 二叉搜索树的插入
微视频4-3
二又搜素树
的插人
将元素X插人二叉搜索树BST中关键是要找到元素应该插入的位置。
位置的确定可以利用与查找函数 Find类似的方法，如果在树BST中找到
X,说明要插人的元素已存在，可放弃插入操作。如果没找到X,查找终止
4.4 二又搜索树 129
的位置就是X应插人的位置。
例如要在图4.26(a)中插人元素35,先做查找操作。按照上一节介绍的查找算法，查找将终
止在键值为33的叶结点处，将元素35作为此终止结点的右孩子就完成了新元素的插入，图
4.26(b)为插人完成后的结果。
30
30 4
? 4 33 0
3 S
(a) (b)
图4.26 二叉搜索树的插人
代码4.16为实现上述插入算法的函数。
BinTree Insert(BinTree BST,ElementType X)
if(!BST)|/*若原树为空，生成并返回一个结点的二叉搜索树*/
BST=(BinTree)malloc(sizeof(struct TNode));
BST->Data=x;
BST->Left=BST->Right=NULL;
else {/*开始找要插人元素的位置*/
if(X<BST->Data)
BST->Left=Insert(BST->Left,X);*递归插入左子树*/
else if(X>BST->Data)
BST->Right=Insert(BST->Right,x);/*递归插入右子树/
/* else X已经存在，什么都不做·
return BST;
代码4.16 二叉搜索树的插入算法
[例4.8] 以一年十二个月的英文缩写为键值，按从一月到十二月顺序输入它们，即输入序
列为(Jan,Feb,Mar,Apr,May,Jun,July,Aug,Sep,Oct,Nov,Dec),将产生什么样的二叉搜索树?
[分析]图4.27(a)-(m)给出了从一个结点为空的二叉搜索树逐个插入12个结点生成最
终结果树的过程。结点键值的比较是按字符串的字母序进行的。
130 第4章 树
Jan) Jan Jan Jan Jan
(Feb) (Feb) (Mar) (Feb) (Mar) (Feb) (Mar)
Ap APT Ma
(a) (b) (c) (d) (e) (1)
Jan Jm
Feb) Mar) (Mar)
Ap Jun) May Ap Jun) (May) Apr) Jun)
(uly Aug July Sep
(g) (h) 1) ⑥
Jan) Jan Jan
Feb) Mar) (Feb) Mar)
(Apr)
Aug uly
a
(Nov (Noy)
(k) (1) (m)
图4.27 二又搜索树的生成过程
4.4.4 二叉搜索树的删除
二叉搜索树的删除操作比其他操作更为复杂，要删除结点在树中的位置决定了操作所采取
的策略。有三种情况需要考虑。
(1)要删除的是叶结点。这种情况最简单，可以直接删除，然后再修改其父结点的指针，置
空即可。图4.28(a)为删除操作前的情况。图4.28(b)为删除键值为35的叶结点以后的结果，
此时删除结点的父结点33右指针为空。图4.28(b)中结点35和其连边变为虚线表示已删除。
4.4 二叉搜索树 131
30 30)
? 4 ? 4
3 50 3 50
要删除结点一 3 35
(a) (b)
图4.28 二叉搜索树叶结点的删除
(2)如果要删除的结点只有一个孩子结点(该结点不一定是叶结点，可以是子树的根),删
除之前需要改变其父结点的指针，指向要删除结点的孩子结点，图4.29表示了这一过程。图
4.29(a)为删除操作前的情况。图4.29(b)为删除键值为33的结点以后的结果，此时删除结点
的父结点41的左儿子指针指向了删除结点的子结点35。删除的结点和其连边用虚线表示。将
图4.29(b)按二叉树的标准画法重画，得到图4.29(c)的结果。
30 30 30
? 4 ? 4 ? 4
要删除结点— 3 ⑤0 33 35 50
35 35
(a) (b) (c)
图4.29 具有一个子树的结点删除
(3)如果要删除的结点有左、右两棵子树，究竟用哪棵子树的根结点来填充删除结点的位置?
这里有两种不同选择，基本原则是要保持二叉搜索树的有序性。一种选择是取其右子树中的最小
元素；另一个是取其左子树的最大元素。无论哪种选择，被选择的结点都必定最多只有一个孩子
(为什么?请读者思考),于是可以调用情况2的解决方案删除这个被选择的结点。图4.30是具有两
30 30
33
(d)
?
×
41
33
35
4
(a)
1⑤
50
35
33 50 33 ×
35
34 34
(b) (c)
图4.30 具有两个子树的结点删除
15
50
35
34
50
132 第4章 树
个子树的结点删除操作的过程。图4.30(a)是删除前的情况，要删除的是关键值为41的结点，其左
子树中最大值结点是键值为35的结点。图4.30(b)是删除结点41被填充后的结果。接下来是要
继续递归删除关键值35原来所在结点，这时它只有一个子树，可以采用上面介绍的具有一个子树
的结点删除方法，图4.30(c)则是最终的结果。图4.30(d)为按二叉树标准画法重新画出的结果。
代码4.17给出了针对上述三种情况的二叉搜索树删除操作算法。其中，当待删除结点左右都
不空时，采用右子树最小元素的删除替代策略。
BinTree Delete(BinTree BST,ElementType x)
1Position Tmp;
if(!BST)
printf("要删除的元素未找到“);
else l
if(X<BST->Data)
BST->Left=Delete(BST->Left,x);/从左子树递归删除/
else if(X>BST->Data)
BST->Right=Delete(BST->Right,X);/* 从右子树递归删除·/
/* 如果被删除结点有左右两个子结点·/
if(BST->Left BST->Right)
/* 从右子树中找最小的元素填充删除结点*/
Tmp=PindMin(BST->Right);
BST->Data=Tmp->Data;
· 从右子树中删除最小元素*/
BST->Right =Delete(BST->Right.BST->Data):
E
elsel/* 被删除结点有一个或无子结点·/
Tmp-BST;
1f(!BST->Left) 八只有右孩子或无子结点*
BST=BST->Right;
else /x只有左孩子/
BST=BST->Left;
free(Tmp);
return BST;
else |/* BST就是要删除的结点·/
代码4.17 二又搜索树的删除算法
4.5 平衡二叉树 133
4.5 平衡二叉树
对于二叉搜索树进行查找的时间复杂度是由查找过程中的比较次数来衡量的，比较是从根
结点到叶结点的路径进行的，它取决于树的深度。树深在最好的情况下是0(logN),所以，二叉
搜索树在最好情况下的查找复杂度是0(logN)。但这一结论是由“最好情况”——即“完全二叉
树"导出的，事实上，N个结点的二叉树深度取决于其树枝的分布情况。当二叉树退化成为一棵
单枝树的极端情况下，查找的复杂度将是线性的0(N)。
假定二叉搜索树中每个结点的查找概率都是相同的，我们称查找所有结点的比较次数的平
均值为树的“平均查找长度”(Average Search Length,ASL)。图4.31为三棵二叉搜索树，结点的
关键值是一年中的某一月份，三棵树都是采用二叉搜索树的插入操作逐点生成的，只是输入的顺
序不同。其中图4.31(a)是按一月到十二月的自然月份序列输人所生成的，图4.31(b)的输入
序列为(July,Feb,May,Mar,Aug,Jan,Apr,Jun,Oct,Sept,Nov,Dec);而图4.31(c)的输入序列则
是按月份字符串从小到大的顺序排列的。从图4:31中我们知道，图4.31(a)的深度为6;图
4.31(b)的深度为4;图4.31(c)是一棵斜二叉树，深度达到最高的12。
按ASL的定义，可以分别计算出三棵二叉搜索树的平均长度：
ASL(a)=(1+2×2+3×3+4×3+5×2+6×1)/12=3.5
ASL(b)=(1+2×2+3×4+4×5)/12=3.0
ASL(e)=(1+2×1+3×1+4×1+5×1+6×1+7×1+8×1+9×1+10×1+11×1+12×1)/12=6.5
Jan
Apr)
(Feb) (Mar) July)
Apr) Jun Feb) (May) Aug
(Aug) (luly) (Aug) Jan) (Mar) Oct)
Dee Apr) Dec Jun (Nov Sep
No
(a) (b) (c)
图4.31 不同输入顺序生成的三棵二叉搜索树
显然，图4.31(b)是最好的情况，其ASL和 logN成正比，而图4.31(c)是最坏的情形，它已
退化成线性表。上述ASL的计算结果表明，一棵树的ASL值越小，它的结构越好，与完全二叉树
134 第4章 树
越接近，对它的查找时间复杂度也越接近0(logN)。因此，为了保证二叉搜索树查找的对数级时
间效率，应尽可能创建枝繁叶茂的树，而避免树枝过长、过少。
最好的树结构当然是满二叉树，它是从根到叶的各条路径长都相同的，我们称这种树是完全
平衡的。但是，通常情况下二叉搜索树的结点插入顺序并不是事先确定的，动态查找(在查找的
同时要进行插入和删除)总是要改变树的结构，不可能做到完全平衡。所以，需要考虑如何解决
既能保证插入和删除正常进行又能保持二叉搜索树的查找性能不退化、尽可能地接近平衡的问
题。这样就有两个问题需要解决，其一是，确定一个“接近平衡”的标准；其二是，如何在动态查
找过程中进行“平衡化”处理，使之保持平衡。
4.5.1 平衡二叉树的定义
平衡二叉树(Balanced Binary Tree)又称为AVL树，是最早被提出的自平衡二叉搜索树，得
名于它的发明者G.M.Adelson-Velsky和E.M.Landis,他们在1962年发表的论文 An algorithm for
the organization of information 中描述了它。AVL树的插入、删除、查找操作均可在0(logN)时间
内完成。
[定义4.4]AVL树或者是一棵空树，或者是具有下列性质的非空二叉搜索树：
(1)任一结点的左、右子树均为AVL树；
(2)根结点左、右子树高度差的绝对值不超过1。
在图4.31的三棵二叉搜索树中，只有中间的图4.31(b)满足上述性质，是AVL树，而图
4.31(a)和4.31(c)都不是。
[定义4.5]对于二叉树中任一结点T,其平衡因子(Balance Factor,BF)定义为BF(T)=h?-hg,
其中h和hg分别为T的左、右子树的高度。
有了平衡因子的定义，AVL树“任一结点左右子树高度差的绝对值不超过1”这一性质可以
表述为“一棵AVL树中任一结点的平衡因子只能在集合{-1,0,1}中取值”。这就是平衡的量化
标准。
4.5.2 平衡二叉树的调整
当向一棵AVL树中插入新的结点时，该结点的平衡因子很可能不在上述集合范围内，破坏
了树的平衡，这时就需要做“平衡化”处理，即相应的局部“旋转”调整，使得调整后的树达到
平衡。
1.单旋调整
下面仍以月份关键字为例，向一棵初始为空的二叉搜索树中顺次插入 Mar 、May 、Nov.
其结果如图4.32(a)—(e)所示。各结点的平衡因子分别标于结点顶端。每当AVL树中
插人一个新结点时，其插人路径上各结点的平衡因子都需做自底向上重新计算，以判断树
是否平衡。
4.5 平衡二叉树 135
-2 -1 0
(Mar) 0 (Mar) -1 May) 0
(Mar) (Ma) May) 0 0
0 (Mar) (Nov)
(Nov)
(a) (b) () (d)
图4.32 右单旋示例
问题出现在第3个结点Nov的插人之后(见图4.32(c)所示),此时根结点 Mar的平衡因子为-2,
标识出树的不平衡。解决方法是将树做逆时针旋转，如图4.32(d)中箭头所示，以达到平衡状态。
我们以图 4.33为例，概括上述不平衡的调整过程的一般规律。图
4.33(a)为新结点C插入之前的AVL树的构成情况，结点A的平衡因子为
-1,其右孩子结点B的平衡因子为0,结点C将要插入B的右子树B中。
插入结点C后，重新计算相关结点的平衡因子，此时，结点A的平衡因子为
-2,它的右孩子结点B的平衡因子为-1,如图4.33(b)所示。此时，可以看 平衡二叉树 到被插入结点C(产生问题结点)、发现问题的结点A以及它们之间路径上 的RR调整
的结点B三个结点向右排成一线，我们称这种右子树的不平衡状态为RR
………
(向右倾斜)型不平衡。RR不平衡的调整策略是通过逆时针旋转相关结
微视频4-4
点，将B置于A的位置，A置为B的左子结点，C所在子树仍为B的右子树。若B原有左子树，
则将其左子树置为A的右子树。这个调整过程称为“右单旋”。经过右单旋调整后的平衡结构
和结点的平衡因子如图4.33(c)所示。需要强调的是A不一定是根结点，它是距离产生问题结
点最近的且平衡因子大于1或小于-1的结点。
L-1 A
-2 右单旋 0
A B
0 -1 0
B B A
AL A? BR
B? BR B? BR AL B? C
C
(a)原AVL树 (b)插入C以后 (c)调整后的AVL树
图4.33 右单旋示意图
用类似的方法我们可以判断与RR型相对称的LL型不平衡，并用“左单旋”处理产生这种向
左倾斜的不平衡。
136 第4章 树
图4.34列出了向图4.32(d)所示的树中插人 Aug和Apr两个结点的调整过程。Aug结点
插入并没有破坏树的平衡，各结点的平衡因子如图4.34(a)所示。而图4.34(b)为插入结点Apr
后各结点平衡因子的变化情况，虽然May和Mar的平衡因子都超出了AVL树所允许的范围，但
因为平衡因子是自底向上调整的，故Mar是第一个发现问题的结点。旋转调整时只需考虑由
Mar、Aug、Apr三个结点构成的局部子树，顺时针旋转后的结果如图4.34(c)所示。
1 2 1
1
(May 0 2
(May) 0 0
(May) 0
Mar) (Nov) (Mar) (Nov) 0 1 0
Aug)
0
(Nov)
(Aug) Aug) (Apr) 0
Mar)
Apr)
(a) (b) (c)
图4.34 左单旋示例
图4.35列出了一般情况下的左单旋过程。图4.35(a)是插人结点C之前的情形，图
4.35(b)为插人C后引起不平衡的情况，发现不平衡的是结点A,新结点C是插入在A的左孩子
B的左子树中，三个结点向左排成一线，称其为LL(向左倾斜)型不平衡。左旋调整后，结点A变
成结点B的右孩子，B原来的右子树将作为A的左子树，调整后的结果如图4.35(c)所示。
11 L2
A) A
左单旋 L0
0 1
B
◎
B B
0
A
Ap A
B?
B? Bp BL BR C BR AR C
(a)原AVL树 (b)插入C以后 (C)调整后的AVL树
图4.35 左单旋示意图
2.双旋调整
继续向图4.34(c)的树中插入结点 Jan,并自底向上计算平衡因子，得到图4.36(a)所示的
结构。此时根结点May的平衡因子为2,是首先发现问题的结点，产生问题的新结点Jan位于其
左子结点(Aug)的右子树中。与上述单旋调整的LL型和RR型不平衡不同的是，三个相关结点
的倾斜是“先左后右”的排列形式，我们称其为LR型不平衡。解决LR型不平衡问题的办法是做
“左-右双旋”,结果如图4.36(b)所示。
4.5 平衡二叉树 137
2
0
-1 (May) 0 (Mar) 0 -1
Aug) (Nov) 0 1
Aug) 0
May)
0 0
Apr) Mar) 0
(Apr) Jan) (Nov)
Jan
(a) (b)
图4.36 左-右双旋示例
下面以图4.37为例说明调整LR型不平衡的规律。一般情况下，若产生问题的结点D在发
现问题的结点A的左子结点B的右子树(以C为根结点)中，称为LR型不平衡，如图4.37(b)所
示。调整是将C置于A的位置，A及其右子树调整为C的右子树。原C的左子树将作为B的右
子树，而原C的右子树则作为A的左子树，如图4.37(c)所示。
1 12 左-右双旋 10 A A
0
B
-1B
0或1 -1或0
B A
0 +1或-1
C
AR Ag c? CR
B? CL Cr D B? c Cr B? D D Ag
或 ① ① 或
或
(a)原AVL树 (b)将D插入C的左子树或右子树 (c)调整后的AVL树
图4.37 左-右双旋示意图
之所以称为“左-右双旋”,是因为调整过程相当于先对以B为根结点的子树做了一次右单
旋，再对以A为根结点的子树做了一次左单旋，是两次单旋的合成结果。图4.38是与图4.37
左-右双旋等价的两次单旋合成的过程示意图，图4.38(a)为出现LR不平衡时的树结构，图
4.38(b)和图4.38(c)是右单旋和左单旋调整后的结果。实际上，下面将给出的AVL树插入算
法就是采用两次单旋策略实现LR和RL型不平衡调整的。
用完全对称的方式可以用“右-左双旋”来处理RL型不平衡。图4.39列出了向图4.36(b)
中依次插入 Dec、July和Feb三个结点的调整过程。插入前两个结点后并没有破坏AVL树的平
衡(如图4.39(a)和图4.39(b)所示)。但当插入第3个结点Feb之后，在引起和发现不平衡结点
Feb和Aug之间形成了“先右后左”的不平衡，如图4.39(c)所示。图4.39(d)为调整后的结果。
138 第4章 树
12
A
右单旋 A
左单旋 L0
-1 C
0或1 B C
+1或-1 B
1或0 A
C B
Ag cR A c C
B? c Ca c? ① B ① ① Ag
① D B? ① 或
或
(a)LR型不平衡 (b)先右单旋调整后的AVL树 (c)再左单旋调整后的AVL树
图4.38 左-右双旋等价的两次单旋示意图
1 1
(Mar) (Mar) -1 -1 -1 -1
(Aug) (May) Aug) (May) 0 1 0 0 0 0
Apr) Jan) (Nov Apr Jan (Nov)
0 0 0
Dee) Dec) July)
(a)插入Dee (b)插入July
2 1
-2 (Mar) -1 Mar 0 -1
(Aug (May) 0 1 0 Dee) 1
(May)
0 0
Apr) Jan No)
1 0
(Aug) Jan (Nov) 0 0 0
Dee July) 0
(Apr) (Feb) July)
Feb)
(c)插入Feb (d)右-左双旋
图4.39 右-左双旋示例
图4.40列出了一般情况下的“右-左双旋”过程。产生问题的结点D在发现问题的结点A
的右子结点B的左子树(以C为根结点)中，称为RL型不平衡。则调整的结果将是C置于A的
位置，A及其右子树调整为C的左子树，原C的左子树将作为A的右子树，而原C的右子树则作
为B的左子树。
4.5 平衡二叉树 139
1-2 A
右-左双旋 10
L-1 A
1 0或1 C
0
B
B
+1或-1 A
-1或0 B
0
C
AL c? ca
A
c? Ca Bg A ① BR
D c Ca Bg ① 或
或 或
(a)原AVL树 (b)将D插入C的左子树或右子树 (c)调整后的AVL树
图4.40 右-左双旋示意图
上面介绍了AVL树插入过程中可能出现的LL、RR、LR、RL四种不平衡情况及其相应的旋
转调整方法。AVL树的插入操作用非递归算法实现一般比用递归实现快，然而程序可读性却差
很多，很容易写错，故通常都用递归算法来实现插入操作。
AVL树的数据结构中除了一般二叉树的数据成员外，还需附加平衡信息。代码4.18实现
了AVL树的插入操作，在函数描述中，我们假设结点的附加信息为以该结点为根的子树的高度，
定义为整型的Height。当然，也可以用平衡因子BF取代 Height。代码4.18中Max(a,b)函数返
回a和b中较大整数。另外还用到函数GetHeight(T),其功能是获得树T的高度。代码4.10给
出了该函数递归求解的版本，但在这里可简化为直接访问结点结构中的Height 值。
typedef struct AVLNode *Position;
typedef Position AVLTree;/* AVL树类型·/
typedef struct AVLNodel
ElementType Data;/*结点数据·/
AVLTree Left; /*指向左子树*/
AVLTree Right; /*指向右子树·/
int Height; /*树高*/
I;
int Max(int a,int b)
return a>b?a:b;
AVLTree Insert(AVLTree T,ElementType x)
140 第4章 树
1/*将X插入AVL树T中，并且返回调整后的AVL树*/
T=(AVLTree)malloc(sizeof(struct AVLNode));
T->Data=X;
T->Height=1;
T->Left=T->Right=NULL;
E/if(插入空树)结束*/
else if(X<T->Data)
/* 插入T的左子树*/
T->Left=Insert(T->Left,X);
/* 如果需要左旋*/
if(GetHeight(T->Left)-GetHeight(T->Right)==2)
if(X<T->Left->Data)
T=singleLeftRotation(T); /*左单旋*/
else
T=DoubleLeftRightRotation(T);/左-右双旋*/
F/.else if(插入左子树)结束/
else if(X>T->Data)
/* 插人T的右子树 */
T->Right=Insert(T->Right,X);
/* 如果需要右旋*/
if(GetHeight(T->Left)-GetHeight(T->Right)==-2)
if(X>T->Right->Data)
T=singleRightRotation(T);/右单旋
else
T=DoubleRightLeftRotation(T):/*右-左双旋*
1/else if(插人右子树)结束8
/ else X--T->Data,无需插入·
/*别忘了更新树高*/
T->Height=Max(GetHeight(T->Lert),GetHeight(T->Right))+1;
return T;
if(!T)|/*若插入空树，则新建包含一个结点的树*/
代码4.18 AVL树的插入操作
4.6 树的应 用 141
代码4.19和代码4.20分别为左单旋和左-右双旋调整算法。
AVLTree SingleLeftRotation(AVLTree A)
1/*注意：A必须有一个左子结点B*/
/·将A与B做如图4.35所示的左单旋，更新A与B的高度，返回新的根结点B */
AVLTree B=A->Left;
A->Left=B->Right;
B->Right=A;
A->Height=Max(GetHeight(A->Left),Get Height(A->Right))+1:
B->Height=Max(GetHeight(B->Left),A->Height)+1;
return B;
代码4.19 左单旋算法
AVLTree DoubleLeftRightRotation(AVLTree A)
/*注意：A必须有一个左子结点B,且B必须有一个右子结点C*
/*将B与C做右单旋，C被返回/
A->Left=SingleRightRotation(A->Left);
/*将A、B与C做如图4.38所示的两次单旋，返回新的根结点C*
/*将A与C做左单旋，C被返回*/
return singleLeftRotation(A);
代码4.20 左-右双旋算法
4.6 树的应用
4.6.1 堆及其操作
在第3章中，我们介绍过队列，知道它的一个基本特征是“先进先出”或者说是“先来先服
务”,队列中的元素没有哪个是可以有特权的，前面的元素未处理完，后面的只能等待。
但在现实世界中，许多情况需要有特权。比如，有许多客户在一个打印店排队等待打印资
料，某一个客户需要打印数百页的一本书，而排在他后面的客户只需打印两页的一份简历表。我
142 第4章 树
们不妨把前者称为大作业，而后者称为小作业。这时小作业客户对店主和大作业客户提出是否
可以先为他打印两页的简历，也就是说是否允许他“插队”。遇到这种情形，店主和大作业客户
往往能接受小作业客户的请求。此时，违背了队列先来先服务的策略，是一种称为“小作业优
先”的排队策略。本节介绍的“堆”(Heap)正是考虑了适合于特权需求的数据结构，因此，堆也
通常被称作为“优先队列”(Priority Queue)。
1.堆的定义和表示
堆是特殊的队列，从堆中取出元素是依照元素的优先级大小，而不是元素进入队列的先后
顺序。
我们当然可以用简单的线性数组或者链表来实现有N个元素的优先队列：
(1)如果使用数组，插入时可以将新元素放在末尾，时间复杂度只是0(1);但是删除需要找
优先级最高的元素，必须遍历全部元素，并且从数组中删除一个元素还涉及其他元素的位置移动
问题，时间复杂度是O(N)。
(2)如果使用有序数组，可令元素按优先级从低到高排列，这样删除的时候只要删除最后一
个元素即可，复杂度变成0(1);问题是插入就变得很麻烦，因为要保证插人后元素还是有序的，
需要用0(log N)的时间找到合适的插入位置，而且在数组中插入新元素必定需要涉及其他元素
的位置移动问题，最坏情况下，时间复杂度仍然是0(N)。
(3)当使用链表时，新元素可插入在链头处，时间复杂度是0(1);但删除元素必须遍历全部
元素才能找到优先级最高的那个，虽然找到后删除用时是0(1),但总的时间代价仍为O(N)。
(4)若链表中数据要求有序的话，删除元素代价为0(1),而插入变为0(N)。
观察上述4种方法，最坏情况下它们的时间复杂度都会达到0(N)。而我们知道，二叉搜索
树的插入和删除操作代价为0(log N)。那么,是否可以利用树型结构达到这种性能?答案是肯
定的。
堆的最常用结构是用二叉树表示，不特指的话，它是一棵完全二叉树。因为高度为h的
完全二叉树有结点21到2^-1个.且结点排布极其规律，因此，通常不必用指针，而是用数组
来实现堆的存储。图4.41上半部分为堆的完全二叉树的表示，而下半部分方格代表其数组
存储实现。
a)
6 C
d) e ① B
①
a b d f 8 b i
0123 45 6 7 8 9 10 11
图4.41 堆的完全二叉树表示及其数组存储
4.6 树的应 用 143
对照图4.41上下两部分，可以看出，堆中的元素在数组中是按完全二叉树的层序存储的，根
结点存放在数组的起始处，接着是其子结点，一层层下去，直到最后一个结点。还要特别提醒的
是，所用的数组起始单元为1,而不是通常的从0单元开始。这样做的目的是很容易从子结点找
到其父结点，即根据4.3.3节中顺序存储二叉树的性质，对于下标为i的结点，其父结点的下标
为Li/2」。反过来，找结点i的左、右子结点也十分方便，分别为2i和2i+1。
用数组表示完全二叉树是堆的第一个特性，称为堆的结构特性。堆的另一特性是其部分有
序性，即指任一结点元素的数值与其子结点所存储的值是相关的。相关性的不同决定了两种不
同的基本堆：最小堆(MinHeap)和最大堆(MaxHeap)。
在最大堆中，任一结点的值大于或等于其子结点的值。这一性质决定了根结点元素的值在
整个堆中是最大的。
而在最小堆中，任一结点的值小于或等于其子结点的值。那么根结点元素的值是整个堆中
最小的。
需要指出的是，兄弟结点之间并不存在什么约束关系。例如，可能会出现根的左子树各结点
的值都大于右子树所有结点的值的情况。
图4.42为几个堆的实例，为简便起见，堆中元素的键值设为整数。其中图4.42(a)和(b)为
最大堆，而(c)和(d)为两个最小堆。
56 ② ⑤ ⑦
9 40 ⑩
6 30 ? 30
18 ⑨③ 4 1838 33
(a) (b) (c) (d)
图4.42 最大堆和最小堆
很明显，最小堆和最大堆有各自的用途。当需要小键值优先时，可以使用最小堆；反之，当大
键值优先时，则要使用最大堆。我们下面介绍的内容主要以最大堆为例。
2.最大堆的操作
根据上面已介绍的最大堆的构成和基本特性，可以用以下抽象数据类型表示最大堆：
类型名称：最大堆(MaxHeap)
数据对象集：一个有N>0个元素的最大堆H是一棵完全二叉树，每个结点上的元素值不小
于其子结点元素的值。
操作集：对于任意最多有MaxSize个元素的最大堆H∈MaxHeap,元素XeElementType,我们
重点关注下列操作：
(1)MaxHeap CreateHeap(int MaxSize):创建空的最大堆，其最大长度为MaxSize;
(2)bool IsFull(MaxHeap H):判断最大堆H是否已满，若是返回true;否则返回false;
(3)bool Insert(MaxHeap H,ElementType X):将元素X插入最大堆H。若堆已满，返回
144 第4章 树
false;否则将数据元素X插入到堆H并返回true;
(4)bool IsEmpty(MaxHeap H):判断最大堆H是否为空，若是返回 true;否则返回false;
(5)ElementType DeleteMax(MaxHeap H):删除并返回H中最大元素。
下面我们就重点介绍堆的创建、插入和删除，以及另外一个特殊的操作：根据给定的N个元
素建立最大堆。
(1)最大堆的创建
用C语言描述堆结构如下：
typedef struct HNode *Heap;/*堆的类型定义*/
struct HNode
ElementType*Data;/*存储元素的数组*/
int Size; /* 堆中当前元素个数*/
int Capacity; /* 堆的最大容量 */
|;
typedef Heap MaxHeap;/*最大堆*/
typedef Heap MinHeap;/*最小堆*/
注意到在根据用户输入的MaxSize 建立空的最大堆时，数组应该有MaxSize+1个元素，因为
数组起始单元为1,元素是存在第1~MaxSize个单元中的。通常第0个单元是无用的，但是如果
我们事先知道堆中所有元素的取值范围，也可以给第0单元赋一个特殊的值MAXDATA,这个值
比堆中任何一个可能的元素都要大。至于这个MAXDATA的“哨兵”作用，会在介绍插入操作的
时候提到。
代码4.21给出了创建最大堆的实现。事实上这个程序也同样适用于创建最小堆，只是把
MAXDATA换成小于堆中所有元素的MINDATA即可。
#define MAXDATA 1000/*该值应根据具体情况定义为大于堆中所有可能元素的值*
MaxHeap CreateHeap(int MaxSize)
1/创建容量为Maxsize的空的最大堆*/
MaxHeap H=(MaxHeap)ma1lo0(aizeof(struct HNode));
H->Data=(ElemeneType·)malloc((MaxSize+1)*sizeof(ElementType)):
H->Size=0;
H-SCapacity=Maxsize:
H->Data[01=MAXDATA:/+ 定义“哨兵”为大于堆中所有可能元素的值·/
return H;
代码4.21 最大堆的创建
4.6 树的应 用 145
(2)最大堆的插入
最大堆中插人一个新元素以后，新增结点既要保证最大堆仍是完全二叉树，结点之间元素值
的大小也要满足最大堆的性质，因此，一般情况下要移动元素。是否移动、多少元素要移动，取决
于要插入元素以及最大堆中已有元素数值的大小。
图4.43是一个最大堆插入一个新元素的过程。其中，图4.43(a)是最大堆的初始情况。当
要插入新元素时，按完全二叉树的性质，增加结点的位置应该是图4.43(b)中用灰色结点表示的
最后一个结点。
当插入的元素值小于31时，新增结点处就是要插入元素的正确位置。图4.43(c)表示插入
元素(黑色结点)值为20的结果。
当插入元素值大于31,但小于44时，元素31下移到新增结点，在空出的位置处插入新元
素。图4.43(d)表示插入元素值为35的结果。
当插入元素值大于44时，元素31和元素44依次下移一层，在最后空出的根结点位置处插
入新元素。图4.43(e)表示插入元素值为58的结果。
44 4
25 3 25 3
8 ⑩ 18 ⑩
[4425 31 18 10
01 23 45 67
44 25 31 18 10
0 1 2、3 4567
(a) (b)
44 44 58
25 3 25 35 25 4
8 ⑩ 20 8 ⑩ 3 18 ⑩ 3
44 25 31 18 10 20
01 2345 67
|4425 35 18 1031
012 34567
58 25 44 18 10 31
01 234567
(c) (d) (e)
图4.43 最大堆的插入
由图4.43列出的几种可能的插入结果可知，完成一个元素的最大堆插入操作，只要从完全
二叉树的新增结点开始，顺着其父结点到根结点的路径，将路径上各结点依次与新元素值进行比
较，当一结点的值小于新元素的值，就下移这个结点的元素，直到有结点的值大于新元素的值或
根结点也下移为止，空出的结点位置就是新元素插入点。插入过程也可以用一句话简单描述：从
新增的最后一个结点的父结点开始，用要插入的元素向下过滤上层结点。实际上，由于堆元素之
间的部分有序性，最大堆从根结点到任何叶结点的路径都是递降的有序序列。插入过程的调整
146 第4章 树
就是继续保证这个序列的有序性。
代码4.22给出了最大堆的插入操作算法。注意到如果新插入的X比原来堆中所有的元素
都大，那么它将一直向上比较到根结点都不会停止。对于这种情况，我们可以加一个特殊判断，
当i取值为1时，直接跳出 for循环，但是这种程序不够优美。在代码4.21中我们定义了一个
“哨兵”,即如果我们事先知道堆中所有元素的取值范围，可以给H->Data[0]赋一个特殊的值
MAXDATA,这个值比堆中任何一个可能的元素都要大，这样当i为1时，"H->Data[i/2]<X"这
个条件肯定不满足，就可以自然跳出循环了。
boo1 IBFull(MaxHeap H)
return(H->Size==H->Capacity);
bool Insert(MaxHeapH,ElementType x)
/*将元素X插入最大堆H,其中H->Data[0]已经定义为哨兵*/
int i;
if(ISFu11(H))
printf("最大堆已满");
return false;
i=++H->Size;/*i指向插入后堆中的最后一个元素的位置·
for(;H->Data[i/2]<x;i/=2)
H->Data[1]=H->Data[i/2];/ 上滤X·/
H->Data[i]=x;/·将X插入·/
return true;
代码4.22 最大堆的插入操作
(3)最大堆的删除
最大堆的删除实际上是取出根结点的最大值元素，同时删除堆的一个结点。与插人操作类
似，删除操作后，最大堆仍然要是完全二叉树，结点元素值的大小仍然要满足最大堆的性质。因
此，删除的结点应该是数组的最后一个单元。那么,取走根结点的元素后，堆的最后一个结点必
须重新放置。确定最后一个结点的元素放到哪个结点中去是最大堆删除操作的关键所在。
图4.44是一个最大堆删除操作的过程。其中，图4.44(a)是最大堆的初始情况。当取出根
结点的元素58后，要删除的结点应该是图4.44(b)中用灰色表示的最后一个结点。删除结点的
元素31能放到空的根结点处吗?从图4.44(c)看，显然不行，因为其右子结点的值44大于31。
4.6 树的应 用 147
要保持最大堆的性质，只能上移44元素，得到图4.44(d)的中间结果。此时，空出的结点位置为
存放删除结点元素的正确位置，图4.44(e)为最终结果。
58) 58
25 44 ② 44
8 ⑩ 31 18 ⑩
58 |25 44 18 10 31
0 1 234567
25 44 18 10 31
0123 4567
(a) (b)
31- 44 4
25 4 31 31
18 ⑩ 8 ⑩ 8 ⑩
31 ③
25 44 18 10
01234567
44 25 1810
01 234567 01 2 34567
(c) (d) (e)
图4.44 最大堆的删除
从图4.44列出的最大堆删除过程可以看到，将删除结点(数组中最后一个元素单元)的元
素作为假设的根结点，依次与其下层的子结点进行比较，如果小于子结点的元素值，从两个子结
点中选择值大的元素上移一层，直到在某一点上，比较结果是大于两个子结点的值，此时的空结
点就是要放置删除结点元素的正确位置。删除过程也可以用一句话简单描述：从根结点开始，用
最大堆中的最后一个元素向上过滤下层结点。代码4.23为实现最大堆的删除操作的函数。
#define ERROR-1/*错误标识应根据具体情况定义为堆中不可能出现的元素值·/
bool ISEmpty(MaxHeap H)
return(H->Size==0);
ElementType DeleteMax(MaxHeap H)
1/*从最大堆H中取出键值为最大的元素，并删除一个结点
int Parent,Child;
ElementType MaxItem,X;
148 第4章 树
if(ISEmpty(H))
printf("最大堆已为空");
return ERROR;
I
MaxItem=H->Data[1];/。取出根结点存放的最大值*/
/*用最大堆中最后一个元素从根结点开始向上过滤下层结点*/
X=H->Data[H->Size--];/*注意当前堆的规模要减小*/
for(Parent=1;Parent*2<=看->Size; Parent=Child)|
child=Parent·2;
if((Child!=H->Size)&&(H->Data[Child]<H->Data[Child+1]))
Child++;/ Child指向左右子结点的较大者*/
if(X>=H->Data[Child])break;/*找到了合适位置*/
else /*下滤X*/
H->Data[Parent]=H->Data[Child];
H->Data[Parent]=x;
return MaxItem;
代码4.23 最大堆的删除
(4)最大堆的建立
这里所谓的“建立”,是指如何将已经存在的N个元素按最大堆的要求
存放在一个一维数组中。我们当然可以通过最大堆的插人操作，将N个元素
一个个相继插人到一个初始为空的堆中去，其时间代价最大为D(N log N)。
下面我们将介绍一种更简便的方式，在线性时间复杂度下建立最大堆。
微视频4-5
最大推的建
立过程
具体分两步进行，第一步，将N个元素按输入顺序存入二叉树中，这一步只
要求满足完全二又树的结构特性，而不管其有序性。第二步，调整各结点元
素，以满足最大堆的有序特性。
图4.45是实现这种简便方式的一个实例。图4.45(a)是按输入顺序
依次将各元素存人数组完成第一步操作后的各结点分布情况。接着进行第二步操作，从第LN/2」
个结点(这是最后面一个有儿子的结点)开始，对包括此结点以及其他前面的各结点LN/2J-1,
LN/2-2,……逐一进行向下过滤操作，直到根结点过滤完毕，最大堆也就建立起来了(见图
4.45(b)-(h)所示)。
图4.45所示的堆有12个结点，从L12/2]=6的数组单元位置上的结点87开始处理，接着是5
单元、4单元……一直到1单元的根结点79,每个结点与它的子树中子孙结点进行比较过滤。图
4.6 树的 应 用 149
4.45中我们用灰色结点表示每次过滤所涉及的各个结点。对于某一结点的处理，当其两个子结点
中较大键值的元素大于它时，将它与大键值子结点交换位置，完成一个层次的向下过滤，接着在新
的层次上进行再下一层的过滤，直到找到它的正确位置。图4.45中用灰底白字的结点及其连边旁
的箭头表示两层结点交互过滤；而灰底黑字表示两结点间已满足有序性，不需要调整位置。
79 (79
66 43 66 (43
83 30 87 38 83 30 ⑧ 38
55 972 49 ⑨ SS 91 72 49 9
7966|43| 83 3087 38ss9172499
01 2345 6789101112
79664383| 30| 87 38 ss|917249 9
01 234 567 8 9 10 11 12
(a) (b)
79) 79)
66) 43 66) 43
83 30 87 38 30 87 38
55 91 72 ⑨ 91 ⑦2 49 9
791 66| 83| 8738| 9172| 499 43 30 55
0123 6789 10 11 12 45
7966 83| 72| 87385s| 9130| 9 43 49
01234567 8 9 10 11 12
(c) (d)
79) 79
66) 43 66 87
9 2 87 91 4 38
S5 83 30 49 83 30 49 ⑨
91728738ss8330499
012345678 9 10 11 12
79 879172|43 38ss: 30|49 9 66 83
012 3 4 5678 9 10 11 12
(e) (1)
79 91)
91 8
87
83 43 38 9 43 38
30 49 ⑨ 55 66 30 49 ⑨
79918783| 72| 43 38 6630 9 55 49
0123456789 10 11 12
918387 79721 38 66|30| 9 |43| ss| 49
01234 5 6 7 89 10 11 12
(8) (h)
图4.45 最大堆的建立过程
150 第4章 树
代码4.24是实现上述建立最大堆的过程函数。
void PercDown(MaxHeap H,int p)
A/*下滤：将H中以H->Data[p]为根的子堆调整为最大堆*/
int Parent,Child;
ElementType x;
X=H->Data[p];/*取出根结点存放的值·/
for(Parent=p;Parent*2<=7->Size; Parent=Child)|
child=Parent *2;
if((Child !=H->Size)(H->Data[Child]<H->Data[Child+1]))
Child++;/.child指向左右子结点的较大者*/
if(X>=H->Data[Child])break;/*找到了合适位置*/
else/ 下滤X*/
H->Data[Parent]=H->Data[Child];
H->Data[ Parent]=x;
void BuildHeap(MaxHeap H)
|/*调整H->Data[]中的元素，使满足最大堆的有序性
/*这里假设所有H->Size个元素已经存在H->Data[]中·/
inti;
八·从最后一个结点的父结点开始，到根结点1*/
for(i=H->Size/2;i>0:1--)
PercDown(H.i):
代码4.24 建立最大堆
分析上述建立最大堆的实例和算法描述可以看出，从一个无序的完全二叉树进行结点向下
过滤操作是构建最大堆的主要工作。某一结点向下过滤要与其下层的子孙结点比较键值，因此
最大的比较次数是树中各结点高度的和，这个高度和也就决定了算法的复杂度。而关于各结点
高度，我们有如下结论：
一个高度为h的完全二又树最多包含2*-1个结点(完美二叉树),这些结点的高度和为
2^-1-h。
由于一个完全二叉树的结点个数N是在2*-和2?-1之间，因此结点的高度和为D(N),说
4.6 树 的应 用 151
明最大堆建立算法的复杂度与结点个数呈线性关系。
4.6.2 哈夫曼树
1.问题的提出
让我们先看一个简单的例子。
[例4.9]要求编写一个程序将百分制的考试成绩转换成五分制的成绩。
[分析]首先给出一个简单程序的主要部分，它利用了嵌套条件语句将101种可能的分数
转换为不及格(1)、通过(2)、一般(3)、良好(4)和优秀(5)五个等级。
if(score<60)grade=1;
else if(score<70)grade=2:
else if(score<80)grade=3;
else if(score<90)grade=4;
else grade=5;
上述程序段的判定过程可以用图4.46(a)所示的判定树来表示。如果需要转换的学生成绩
很多，用此判定树或者说基于此判定树的程序效率问题就比较突出了。主要原因是学生成绩的
分布在上述五个分数段中是不均匀的。表4.1是一个实际的学生成绩分布情况表。
yes
grade=1
yes score<60 no
grade=1 yes score<70 no
grade=2 yes score<80
grade=3 yes
(a)
yes
grade=4
score<80
yes score<70
no yes
score<60
no
grade=3
grade=2
(b)
图4.46 不同判定树
grade-4
no
score<90 no
no
Score<90
grade=5
no
grade-5
152 第4章 树
表4.1 学生成绩分布情况表
分数段 0~59 60~69 70~79 80~89
0.05 0.15 0.40 0.30
90~100
比例 0.10
如果学生成绩按表4.1的比例分布，采用图4.46(a)判定树，80??上的数据需要进行三次
或三次以上的比较才能求出结果。现假设有10 000个输入数据，按图4.46(a)判定进行转换，需
要31 500次比较运算；而图4.46(b)是考虑了分数分布比例所设计的另一判定逻辑，对同样的
输入数据，则需要进行22 000次比较。
由此可见，同一问题，采用不同的判定逻辑，计算效率是不一样的。可以推断，图4.46(b)的
判定结构对概率大的数据有更少的比较次数，计算效率得到了提高。那么是否能够找到最好的
比较判定逻辑，使运算效率达到最高?这就是“最优树”要解决的问题。
2.哈夫曼树(Huffman Tree)的定义
我们已经知道，从树根到某个结点的路径是从根结点开始沿着某个分支到达该结点的一个
结点序列，路径所含的分支数(结点个数减1)称为此路径的长度。而一棵树的路径长度是指从
树根到其余各结点的路径长度之和。
结点的带权路径长度是指从根结点到该结点之间的路径长度与该结点上所带权值的乘积。
设一棵树有n个叶结点，每个叶结点带有权值W,从根结点到每个叶结点的长度为L,则每个叶
结点的带权路径长度之和就是这棵树的带权路径长度(Weighted Path Length,WPL),它可以被表
示为：
wPL=
[定义4.6] 假设有n个权值{W,W?,…,W,构造有n个叶子的二叉树，每个叶子的权值
是n个权值之一，这样的二叉树可以构造很多个，其中必有一个是带权路径长度最小的，这棵二
叉树就称为最优二叉树或哈夫曼树。
例如，有五个叶结点，它们的权值为{1,2,3,4,51,用此权值序列可以构造出形状不同的多
个二叉树。这些形状不同的二叉树的带权路径长度可能各不相同。图4.47列出了对应此权值
序列的三棵二叉树，为了清楚起见，用方框表示叶结点，并将权值标注到方框中。而其他结点的
键值省略。
这三棵树的带权路径长度分别为：
WPL(a)=1×1+2×3+3×3+4×3+5×3=43
WPL(b)=1×3+2×3+3×2+4×2+5×2=33
WPL(c)=1×1+2×2+3×3+4×4+5×4=50
其中图4.47(b)的带权路径长度较小。实际上，可以证明它是最小的带权路径长度，对应的
树是这个权值序列的哈夫曼树。
4.6 树的 应 用 153
1
1
2
3 4 5 3
5 4 3 2 1 2 5 4
(a) (b) (c)
图4.47 三棵不同带权路径长度的二又树
3.哈夫曼树的构造
我们已经知道由相同权值的一组叶结点所构成的二叉树有不同的形态和不同的带权路径长
度，那么如何找到带权路径长度最小的哈夫曼树呢?由哈夫曼树和带权路径长度的定义可知，一
棵二叉树要使其WPL值最小，必须使权值越大的叶结点越靠近根结点，而权值越小的叶结点越
远离根结点。哈夫曼依据这一特点提出了一种方法，它是一种贪心算法。该算法在初始状态下
将每个字符看成一棵独立的树，每一步执行两棵树的合并，而选择合并对象的原则是“贪心”的，
即每次选择权最小的两棵树进行合并。具体过程描述如下：
(1)由给定的n个权值|W,,W?,…,W|构造n棵只有一个叶结点的二叉树，从而得到一个
二叉树的集合F=|T?.T?,…,T.I;
(2)在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉
树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和；
(3)在集合F中删除(2)中作为左、右子树的两棵二叉树，并将新构造的二叉树加入到集合
F中；
(4)重复(2)(3),当F中只剩下一棵二叉树时，这棵二叉树就是所要建立的哈夫曼树。
图4.48给出了前面提到的叶结点权值集合为W=|1,2,3,4,5|的哈夫曼树的构造过程。首
先，按权值大小构成5棵单个结点的二叉树，如图4.48(a)所示；由权值最小的2棵二叉树构造
新的二叉树，计算其权值为3(用圆结点中的数值表示)产生新的树集合，如图4.48(b)所示；图
4.48(c)为两个权值为3的结点合并后的结果；图4.48(d)是选择最小权值4、5结点合并后的结
果；图4.48(e)是将剩余两个子树合并成，构成最后的哈夫曼树。
尽管按哈夫曼方法构造成了图4.48的结果，但需要指出的是：对于同一组给定权值叶
结点所构造的哈夫曼树，树的形状可能不同。比如，图4.49是另一棵上述给定权值序列的
哈夫曼树。但不论形状如何，这些哈夫曼树的带权路径长度是相同的，并一定都是同一最
小值。
代码4.25为哈夫曼树构造算法。为了便于抽取最小权值的子树，在树的构造过程中使用了
最小堆及其删除、插入操作。这里堆中的元素是一个加了权值的树结点的指针。
154 第4章 树
5 ③ 3 4 5 4 5 6
③ 3
(a) (b) (c)
6 ⑨ ?
③
6 9
③ 12
2
(d) (e)
图4.48 哈夫曼树的生成过程
①⑤
6 9
3 ③ 4 5
1]2
图4.49 结构不同的哈夫曼树
typedef struct HTNode·HuffmanTree;八哈夫曼树类型
struct HTNode|/*哈夫曼树结点定义*/
int Weight; /*结点权值*/
HuffmanTree Left:/*指向左子树*/
HuffmanTree Right:/*指向右子树·
I;
HuffmanTree Huffman(MinHeap H)
1/*这里最小堆的元素类型为HuffmanTree*/
/*.假设H->Size个权值已经存在H->Data[]->Weight里·/
int I,N;
4.6 树的应用 155
HuffmanTree T;
BuildHeap(H);/*将H->Data[]按权值Weight调整为最小堆*/
N=H->Size;
for(i=1;i<N;i++)|╱·做H->Size-1次合并*/
T=(HuffmanTree)malloc(sizeof(struct HTNode));/·建立一个新的根结点*
return DeleteMin(H);/最小堆中最后一个元素即是指向哈夫曼树根结点的指针/
T->Left=DeleteMin(H):/*从最小堆中删除一个结点，作为新T的左子结点*/
T->Right=DeleteMin(H);/*从最小堆中删除一个结点，作为新T的右子结点·/
T->Weight=T->Left->Weight+T->Right->Weight;/*计算新权值·
Insert(H,T);·将新T插入最小堆·
代码4.25 哈夫曼树的构造
Huffman算法的复杂度主要由以下几部分组成：
(1)调整最小堆：0(N);
(2)2(N-1)+1个删除：0(NlogN);
(3)N-1个插人：0(NlogN)。
故整体复杂度为0(NlogN)。
4.哈夫曼编码
给定一段字符串，如何对其中的字符进行编码，使得该字符串的编码存储空间最少?当然从
存储空间取出的编码必须通过对应的解码才能还原出原字符串。
上述问题的最优解决方案是哈夫曼于1952年提出的，按他给出的算法得到的编码就称为
“哈夫曼(Huffman)编码”,是进行文件压缩的有效方法，其压缩比通常在20?90??间。
可见的ASCII字符大约有一百个左右，加上部分不可见字符，可以用log?128=7位来识别它
们，再加上1位校验码，所以一般用8位即一个字节来表示一个字符。但一般文本中每个字符出
现的频率是不同的，且差异较大，通常只是少量不同字符在大量重复出现，用8位来存储每个字
符是比较浪费的。
[例4.10] 假设有一段文本，包含58个字符。经过统计；发现其中只有7个字符是互不相
同的，它们是：a,e,i,s,t,空格(sp),换行(nl)。
若按每字符1字节的方式存储，则该文本需占58×8=464位。而其中既然只有7个字符是
不同的，我们完全可以仅用[log?7]=3位码来识别它们。例如可令：a=000,e=001,i=010,
s=011,t=100,sp=101,nl=110。这时空间被压缩为58×3=174位，效果已经不错了。
要获得更好的压缩效果，即压缩后的总空间最小，就不能再用等长的编码。一个很直观的想
法是，让出现频率高的字符编码短些，出现频率低的字符则编码不妨长些，可能会得到更好的压
156 第4章 树
缩效果。这要求必须知道更多的信息。
设f(c)为字符c出现的频率。假设例4.10中的统计结果为f(a)=10,f(e)=15,f(i)=12,
f(s)=3,f(t)=4,f(sp)=13,f(nl)=1。表4.2列出了一种最优编码，可见存储空间被进一步压
缩到146位。
表4.2 最优编码统计
字符 频率 编码
10 001
15 01
12 10
3 00000
4 0001
13 11
1 00001
58
占位
a 30
e 30
i 24
5 15
t 16
sp 26
nl 5
总和 146
现在就出现了一个新问题，在允许不同字符采用不同长度编码的情况下，如何保证解码能顺
利实现?
例如，有一个字符串"it is a tie",如果按照表4.2中的编码，此字符串就被压缩为
100001111000000110011100011001。当进行文本恢复时，我们从左向右扫描压缩后的编码，并对
照表4.2,发现1不在表中，而10对应i,接着000不在表中，而0001对应t,于是从前6位得到
“it”以此类推，完全可以解码原文，而不出现二义性。
并不是任何一种编码都可以如此顺利地解码，比如若将sp的编码改为00,再从左向右解
码，前4位解码结果将是“isp”,导致错误的原因是出现二义性问题了，即sp的编码00是a的编
码001的前缀。
不产生二义性的关键在于任何一个字符的编码都不能是另一个字符的编码的前缀，因此哈
夫曼编码也称为“前缀编码”。
采用哈夫曼树生成方法可以保证构成正确的文本前缀编码，图4.50为上述文本的最优前缀
编码树。 0
从图4.50中来看，与前面介绍的哈夫曼树有
所不同的是在每个结点的左分支被记为0,右分支 0 1 0 1
被记为1。某一字符的编码可通过组合从根结点到
该字符结点(叶结点)的路径上所标注的0、1得到。
注意前缀编码树的特点是每个字符必是叶结点，且
树中没有度为1的结点。否则就会出现解码二义
性的问题，比如将sp换成a的父结点，此时，sp为
0 1 O ①
0 1 a
1
m
图4.50 最优前缀编码树
0
O
4.6 树的应用 157
非叶结点，那么编码100001中前两位解码为i后，右边剩下的四位0001,既可以一并解码为t,也
可以先解码前两位00为sp,再解码剩下的两位01为e。导致出现“it”和“i sp e”两种解释。
一个字符的编码长度即是该字符结点在其哈夫曼树中的深度d-1。设字符c,为哈夫曼树中
的一个叶结点，若在树中的深度为d,,将它在文本中的出现频率为f,看作结点的权值，则压缩后
文本长度为∑(d,-1)f,,哈夫曼树的生成确保了这个前缀编码树的编码长度为最小。
图4.51列出了调用哈夫曼树生成算法构造图4.50最优编码树的过程。为清楚起见，用方
结点表示原始字符结点，用圆结点表示生成的树结点，内含以该结点为根的树的权值。
a 10 e 15 12
(a)初始状态
nl 1 s 3 a 10
(b)调整为最小堆
t 4 i 12 ④
s 3
e 15
c
t 4
t 4
15 sp
sp13
sp 13|
13
n1 1 s 3
(c)第1次合并
⑧ a 10
t 4 ④
nl 1 3
(d)第2次合并
i12 15 sp13
sp 13
18
8
e 15
a 10
t 4 ④
nl s 3
(e)第3次合并
nl 1
i 12
a10
i12
s
e
1
158
e 15
i
t
12
12
第4章 树
18 5
8 a 10 i 12
4 ④
1 3
(1)第4次合并
25 33
sp 13 e 15 18
8 a
t 4 ④
(8)第5次合并
S8
2 33
sP 13 e 15 8
8 a
t 4 ④
nl 1 s
(h)一棵最优前缀编码树
图4.51 哈夫曼树生成过程演示
sp
10
10
3
13
4.6 树的应 用 159
可以看到，图4.51生成的树与图4.50并不相同，又一次说明哈夫曼编码不是唯一的。
4.6.3 集合及其运算
1.集合的表示
集合是一种常用的数据表示方法。集合运算包括交、并、补、差以及判定一个数据是否是某
一集合中的元素等。
为了有效地对集合执行各种操作，可以用树结构表示集合，树的每个结点代表一个集合元
素。例如，有3个互不相交的整数集合S,=|1.2,4.7|、S?=13.5.8|、S,=10.6,9|,图4.52是这
3个集合的多叉树表示形式，每个结点允许有多个子结点。与我们之前所见到的父子关系指针
不同，这里结点的指针不是从父结点指向子结点，而是由子结点指向父结点。每个根结点与其集
合名称相关联。当然，究竟选择哪个结点作为代表此集合的父结点是无关紧要的。
①
集合名 指针
S,
S?
S?
②④⑦ ③
6 ⑤ ⑧
⑨ ◎
图4.52 集合的多叉树表示形式
采取这样的树结构表示集合好处是有利于判定某个元素所属的集合，也便于集合的归并运
算。从另一方面考虑，当我们执行集合运算的时候，关注的是集合中的元素，并不在乎这个集合
叫什么名字，所以集合名结构(图4.52左边部分)其实是没有必要存在的。一个巧妙的方法是
直接用树的根结点的编号代表一个集合。让我们把所有N个元素从0到N-1编号，当把它们存
储在数组中时，它们的下标范围也是0到N-1的—充分利用这一点，我们就可以简单地用一
个整型数组表示集合，这个数组的第i个元素(下标为i)存储的是编号为i的集合元素的父结点
编号。例如图4.52中，3是8的父结点，那么数组的第8个元素的值就是3。由于根结点没有父结
点，为了区分根结点和非根结点，我们把根结点单元的值定义成负数(例如就定义成-1)。例如6
是图4.52中一棵树的根结点，那么对应的那个集合的名字就是6,在第6个单元里存的值是-3,因
为这棵树有3个结点，对应的集合有3个元素。于是图4.52中的三棵树就如图4.53所示。
在此我们把N个集合元素的类型 ElementType定义为int,即简单地用0到N-1的编号代替
实际元素。于是集合的类型可描述为：
#define MAXN 1000
typedef int ElementType;
/*集合最大元素个数*/
/* 默认元素可以用非负整数表示*/
第4章 树
/*默认用根结点的下标作为集合名称*/ typedef int SetName;
typedef ElementType SetType[ MAXN];/*假设集合元素下标从0开始 */
下标 S
0 6
1
2
3
4
5
6
7
-1
1
-1
1
3
-1
1
3
6
① ③ 6
8
9 ②④⑦⑤ 8⑨ ◎
(a)集合的数组存储 (b)集合S、S?、和S?
图4.53 集合的树结构表示及其存储实现
2.集合运算
(1)查找某个元素所在的集合
查找编号为X的元素所属的集合，可以沿着该元素父结点指针向上查，当发现一个元素的指针
域值为负数时，该元素就是X所属集合的树根结点。代码4.26的函数Find实现了这一查找过程。
SetName Find(SetType s,ElementType X)
I/*默认集合元素全部初始化为-1/
for( ;s[x]>=0;X=s[x]):
return x;
代码4.26 集合元素查找
(2)集合的并运算
集合的并运算是要完成将元素X1和X2所属的两个集合合并的操作。可以先找到两个元
素所在集合树的根结点，如果它们不同根，则将其中一个根结点的父结点域值设置成另一个根结
点的数组下标就行了。例如，要将数值为4和5的两个元素所属的集合归并，通过Find 函数可
以确定它们所属的集合为1和3。我们只要将S[3]的值设置为1就实现了两个集合的并运算。
图4.54为并运算完成后的结果。其中根结点3的值由原来的-1变成了1。为清晰起见，图
4.54(a)中用灰底色标注出了该值的变化。
代码4.27为实现集合并运算的Union 函数。这里默认传人函数的Root1和Root2是两个不同集
合的根结点，所以一般我们在调用Union之前，都应该先确认这一点。换言之，如果我们要将元素X1
160
4.6 树 的应 用 161
和X2所属的两个集合合并，应该先调用Find(X1)和 Find(X2),得到两个集合的根，然后比较一下：如
果两个根不同，则调用Union 执行合并；否则根本没必要合并，因为它们本来就在同一个集合里。
下标 S
0 6
1 -1
2 1
3 1
4 1 ① 6
5 3
6 -1 ②④⑦ ③ ⑨ O
7 I
8 3
9 6 ⑤ 8
(a)集合的数组存储 (b)集合S?US?和S;
图4.54 集合S,和S?的并运算
void Union(SetType s, SetName Root1,SetName Root2)
s[ Root2]=Root1;
1
(/*这里默认 Root1和Root2是不同集合的根结点*/
代码4.27 集合并运算
(3)按秩合并
乍一看代码4.27是如此简单，会有什么问题呢?假设有N个元素，一开始各自独立，然后
我们要执行这样一系列的并运算：
●合并1和0所在的集合：调用Union(S,1,0)的结果，是令S[0]=1,生成根为1、高度为2
的一棵树；
●合并2和0所在的集合：Find(S,0)搜索了2个结点后找到根结点1;调用 Union(S,2,1)
的结果，是令S[1]=2,生成根为2、高度为3的一棵树；
● 合并3和0所在的集合：Find(S,0)搜索了3个结点后找到根结点2;调用Union(S,3,2)
的结果，是令S[2]=3,生成根为3、高度为4的一棵树；
……
以此类推，当我们不断执行“合并i和0”(1≤i≤N)的操作，Find(S,0)的总执行时间就是
0(N2),因为生成的集合树越来越高。最后的结果如图4.55所示。出现这种问题的根本原因，
是我们每次都把一棵比较高的树并到了一棵矮树上。如果我们每次合并前都先比较一下两棵树
的高度，把矮树并到高树上，就不会改变结果树的高度，也就可以避免上述糟糕情况的发生。
162 第4章 树
当然要做到这一点，我们需要快速知道每个集合的树有多高，而这并不是很容易做到。比较容
易获得的是集合的规模，即集合中元素的个数。用规模替换高度，也 N
可以起到比较好的作用——至少在前面的例子里是这样：如果我们
每次都把规模小的树并到大树上，那么1会一直是根结点，树的高 ② 度始终是2,整套操作的时间复杂度就降为0(N)了。这种按规模、
或者按高度进行合并的算法，就统称为按“秩”合并。 ①
在实现这个算法时，为了能够快速获得集合的规模，我们把对 O
应集合的树的总结点数存在根结点单元里。同时为了与普通结点 图4.55 简单并运算的结果
区分开，我们在这个数字前加负号，使之仍然为负数。代码4.28给
出了按秩合并的算法。这里S[Root2]<S[Root1]说明集合2比较大，是因为对两个正整数A和B
而言，-A<-B即意味着A>B。当合并两个集合的时候，新的根结点应该存两个集合规模的和。
void Union(SetType s,SetName Root1,SetName Root2)
1/*这里默认 Root1和Root2是不同集合的根结点*/
/*保证小集合并人大集合·
if(S[Root2]<s[Root1])/* 如果集合2比较大/
S[Root2]+=S[Root1];/* 集合1并入集合2*/
s[Root1]=Root2;
else /* 如果集合1比较大*/
S[Root1]+=s[Root2]; /*集合2并入集合1*/
s[Root2]=Root1;
代码4.28 Union的按秩合并算法
下标 S
在按秩合并的规则下，图4.54中两个集合合并的结果就变成 0 6
了图4.56所示的数组。图中灰底突出了根结点单元的数值变化。 1 -7
(4)路径压缩 2 1
3 1
4 1
5 3
6 -3
7 1
8 3
9 6
图4.56 图4.54中集合S
和S,的按秩并运算
如果一棵集合树很不幸地长高了，而我们又不得不反复调用
Find去查找它最底部的某个元素，怎么做能提高效率呢?
有一种“路径压缩”的方法可以在第一次查找的时候把树变
矮，使得要查找的元素直接变成根结点的孩子，则下次再查找它的
时候就只需要2次比较了，可以大大提高效率。代码4.29给出了
这个算法的递归版本。在这个算法中，我们递归地把X的父结点
的值S[X]设置为对其当前父结点S[X]执行 Find的结果，并且返
回更新后的父结点值；直到X本身是集合的根，被Find返回给上
本 章 小 结 163
一层。这样执行的效果是，每返回一层，Find 就把当前结点的父结点设置成根结点，即把当前元
素直接变成了根结点的孩子，并且一路返回根结点的值。最后从X到根结点的路径上所有的结
点都变成了根结点的孩子，这就是路径的压缩。
Set Name Find(SetType s. ElementType x)
I/*默认集合元素全部初始化为-1·/
1f(s[x]<0)/找到集合的根/
return X;
olse
return s[x]=Find(S. s[x]);/+ 路径压缩·/
代码4.29 Find的路径压缩算法
图4.57给出了一个示例，在对图4.57(a)给出的集合执行 Find(S,3)后，从3到根4的路径
上所有三个结点3、1、2都变成了4的孩子，如图4.57(b)所示。
④ ④
O ② O
②
① ③
⑤ ①
③
⑤
(a)原始集合 (b)调用Find(S,3)后的结果
图4.57 路径压缩算法示例
本 章 小 结
树是一种十分重要且广泛应用的非线性数据结构。本章首先以线性表的静态查找作为引
子，给出了动态查找的概念，为树的内容介绍做了适当铺垫。第2节介绍了树的定义和基本术
语。紧接着，在第3节详细介绍了二叉树的存储形式和操作，给出了二叉树的建立和几种遍历算
法并讲解了几个应用实例。第4节介绍了二叉搜索树及其插人、删除和查找操作。第5节的内
容主要是平衡二叉树及其调整策略和算法。最后，在第6节中给出了树的几个重要应用实例。
二叉树是最基本和最简单的树结构，其遍历是最重要的操作，依据结点被访问的顺序分为先
序、中序、后序和层序等。尽管几种遍历用递归算法实现既直观又简单，但效率比迭代算法低。
二叉搜索树的有序特性使得它成为一种对排序和查找都很有用的特殊二叉树，通过对二叉
搜索树进行中序遍历可以得到从小到大的排好序的序列。依据结点关键字与要查找值的比较结
果，查找范围限定在左或右子树是动态二分查找思想的实现；查找最大或最小元素也更加有效，
164 第4章 树
它们处于树的最右分支端结点和最左分支端结点处。
平衡二叉树的引入是为了使二叉搜索树始终具有良好的结构，有尽量小的高度，以保证各种
操作的对数复杂度。平衡调整算法中引入了平衡因子的概念，以反映树的不平衡情况，确定采用
单旋或双旋调整策略。
在树的应用中介绍了堆、哈夫曼树和哈夫曼编码、集合及其运算。堆分为最大堆和最小堆两
种，它们是考虑了优先级的特殊队列，因此常用于诸如考虑短作业优先调度等排队情况。尽管逻
辑上用完全二叉树表示，实际的物理存储通常采用数组；哈夫曼树又称为最优二叉树，也就是带
权路径长度最小的二叉树，它进一步提高了树中叶结点访问的总体效率。常用的集合运算包括
判断元素所属集合、不同的集合归并等，树结构适合于这种集合的表示和操作，在本书的集合树
的表示中，采用了子结点到父结点的链接方式，不仅使得集合操作更简捷，也说明树的边只是表
示结点之间的关系。
习题
4.1 判断正误。
(1)二叉搜索树的查找和折半查找的时间复杂度相同。
(2)若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个
结点。
(3)哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
4.2 填空题。
(1)设T是非空二叉树，若T的先序遍历和中序遍历序列相同，则T的形态是____。若T的先序遍历和
后序遍历序列相同，则T的形态是___。若T的中序遍历和后序遍历序列相同，则T的形态是__。
(2)以二叉链表作为二叉树的存储结构，在具有n个结点的二叉链表中(n>0),空链域的个数为___。
(3)已知二叉树的前序遍历序列为ABDCEFG,中序遍历序列为DBCAFEG,则后序遍历序列为_____。
(4)利用过滤法将关键字序列(37,66,48,29,31.75)建成的最大堆为___。
(5)在一棵度为3的树中，度为2的结点个数是1,度为0的结点个数是6,则度为3的结点个数是_____。
4.3 设二又树的存储结构如下；
1 2 3 4 5 6 7 8 9
0 0 2 3 7 5 8 0 10
J H F D B A C E G
0 0 0 9 4 0 0 0 0
10
Lchild 1
data
Rchild 0
其中根结点的指针值为6(实际为所在数组位置的下标),Lchild,Rchild分别为结点的左、右孩子指针域，
data 为数据域。
(1)画出二叉树的逻辑结构。
(2)写出该树的前序、中序和后序遍历的序列。
习题 165
(3)试编写一个算法，判别给定的二叉树是否是二叉搜索树。
4.4 对于算术表达式(A+B+C/D)-E+F·G,给出其中序二叉树表示。
4.5 设顺序存储的二叉树中有编号为i和j的两个结点，请设计算法求出它们最近的公共祖先结点的
编号。
4.6 假设一个文本使用的字符集为|a,b,c,d,e,f,gl.字符的哈夫曼编码依次为|0110,10,110,111,00,
0111,010|。
(1)请根据哈夫曼编码画出此哈夫曼树，并在叶结点中标注相应的字符。
(2)若这些字符在文本中出现的频率分别为：|3,35,13,15,20,5,91,求该哈夫曼树的带权路径长度。
4.7 若有8个数据元素10.1,2,3,4,5.6.71,初始每个元素构成一个独立的集合，其数组单元的数值和树
的表示如图4.58所示。通过集合并运算序列Union(S,6.7)、Union(S.5,6)、Union(S,4.5)、Union(S,3,4)、
Union(5,2.3)、Union(5.1,2)和Union(S,0.1)后，集合树和对应的数组S变化如何?试比较采用按秩合并和简
单合并，以及路径压缩与简单合并结合的结果。
下标 S
0 -1
1 -1
2 -1
3 -1
4 -1
5 -1
6 -1
7 -1
(a)集合的数组S (b)8个独立集合
图4.58 题4.7图
第5章
散列查找
5.1 引子
在前面的第4章中，我们已经介绍了查找的几种方法：当查找的数据对象集合中元素数量N
不大的时候可以采用“顺序查找”(时间复杂度为0(N));当N很大的时候可以采用“二分查找”
(时间复杂度为0(log N)),但二分查找的前提是数据元素已经按照关键字排序并且存储在连续
的地址空间中，这就要求不能有频繁的元素变化(经常性的插入和删除)——即要求是“静态查
找”;当N较大并且经常需要插入和删除元素的时候，可以采用“二叉搜索树”结构进行查找(时
间复杂度为0(h),h为二叉搜索树的高度),插入和删除元素操作的时间复杂度也是0(h),这
里h的最好情况是0(log N),最坏情况可以达到0(N)。
虽然0(log N)是相当不错的时间复杂度，但是有时需要附加条件。到底还有没有其他适应
性广而速度又快的查找方法呢?
[例5.1]我们来考虑一下广泛使用的在线聊天软件QQ的登录过程，登录界面如图5.1所
示。首先，大家知道QQ号码现在已经达到10位数字——数十亿的规模的容量，实际用户估计
也达到亿数量级。当然就目前全球数十亿人口来看，一定有许多号码没有主人或者主人已经抛
弃它，也一定有许多人占有多个号码，占有多个号码的原因可能是主人希望以不同的面貌出现在
他人面前以隐藏身份，或者是择机出卖“吉利号码”以赚取经济利益等。
我们现在感兴趣的是，在登录QQ的时候，QQ服务器如何核对你的身份，以确定你就是该号码
的主人?方法似乎也不难，只要匹配一下你的密码即可。但是很少有人会想：在多达十亿量级的有
效QQ号码中如何快速找到你刚刚输入的QQ号码，以 99Z010 便取出相应的密码与你刚刚输入的密码进行核对?
[分析]现在我们来做个简单分析，先看看是否
可以用二分法查找。假定数十亿的号码容量中有十
亿有效用户，用二分查找30次，可以解决N=2°(十
亿)个有效QQ号码的问题。而30次长整数比较对
现在的计算机来说可以瞬间完成。所以从时间方面
来看是没有问题的。
再来看一下空间的情况。假设每个有效QQ号码
有关信息(如密码、个性签名、个人资料、好友等，但不
C
QQ20IO
在线精彩生活更骑彩
帐号： A123456789
密码：…
状态； □记住峦码 □自动登录
设置
Ia
注册新帐号
我回密码
登放
图5.1 QQ登录界面
5.1 引子 167
包括个人相册和邮箱等)需要1 KB存储空间，那么10亿个账号大约只需要1024 GB(1 TB)的
连续存储容量，这也是可以接受的。
但是，二分查找要求“按有效QQ号大小顺序存储有关信息”,这是不是一个合理的要求呢?
我们知道在连续存储空间中，插入和删除一个新QQ号码将需要移动大量数据，而插入一个新
QQ号码(当某人成功申请一个QQ号时)几乎每小时甚至每分钟都会发生很多次。所以这个代
价是不能接受的。
用不了二分查找，我们该怎么办?
[例5.2]我们来琢磨一下查英文字典的过程。比如要查询英文单词“zoo”,如图5.2所示，
相信大家都知道应该直接到字典的后面去找，而不会
从字典中间开始用二分法去找，更不会从头顺序查
找。为什么呢?因为我们“知道”字典的单词排序规
则以及字母“z”在26个字母中位列最后。实际上，我
们已经根据要查找的关键词“zoo”在脑子里经过了
“计算”,得出该关键词所在的大致位置，这样就能更
快地找到它。这个“计算”过程非常类似于本章将要
介绍的散列查找中的"散列函数计算"。
实际上，查字典的过程结合了散列查找(用于初
步定位)、二分查找(一般不是准确二分)和顺序查找
(当很接近关键词的时候)等几种查找方法。
图5.2 查字典
[例5.3] 我们再来看一下网上搜索。大家都习惯于通过百度和谷歌等搜索工具在因特网
上搜索感兴趣的任何信息，如图5.3所示，但是你有没有思考过，搜索引擎是如何如此神速地把
我们需要的有关信息呈现在面前的?
e//-hdom 6×6
收藏决e网快讯库
图百度一下，道 ·目·页·全⑤ IRo-0
拉室设置!登量注
Baidu百度
新区 网页 贴王 知道 MP3 图片 现题 地图
数据结构 算法 百度-下
空回 百科 na0123|更多》
Interet| 保护顿式插用 ·100%
图5.3 Google 搜索界面
168 第5章 散 列 查 找
[分析]与搜索相关的主要数据结构是“倒排索引”。正常的索引结构建立的是“文档到单
词”的映射关系，而倒排索引建立的是“单词到文档”的映射关系，即关键词对应所有拥有这个关
键词的文档编号列表。其实可以这样理解，倒排索引就是描述一个关键词对象集合(Terms)和
一个文档集合(Docs)对应关系的数据结构。通常仅记录关键词在哪些文章中出现还不够，同时
还需要记录关键词在文章中出现次数和出现的位置(行号或段落号),这样做可以方便快速获取
查询记录的数目和列出查询结果。一个倒排索引的示意如表5.1所示。
表5.1 倒排索引表
Docs
Terms 文档， 文档?
……
文档
3:1,12,20 0
……
2:1,22
0 2:11,22
……
4:9,20,32,65 …… …… …… ……
0 0
……
5:3,9,10,32,56
5:1,9,20,22,55 0
……
0
文档。
关键词， 3:9,40,52
关键词? 5:5,9,10,32,35 …… ……
关键词 10:5,6,19,..,44
关键词。 1:7
比如，用户要搜索“关键词。”,查找上面的索引表知道，“文档，”出现5次“关键词。”,分别在
第1、9、20、22和55行，“文档。”仅在第7行出现1次“关键词。”。根据这些线索，就可以将“文
档，”和“文档。”的有关行信息(经过适当删减和排序)显示在用户面前。如果同时需要搜索“关
键词?”和“关键词…”,查找索引表知道，“文档”中“关键词?”和“关键词-1”同时出现的地方
有2处，分别在第9和32行；这两个词在“文档”的第5行同时出现了1次。
如何高效地建立和查找该表格呢?理论上说这个表格包含了所有关键词和文档的索引，它
是非常巨大的，如果不采取适当的技术，几乎是没有办法来具体实现。因为搜索面对的是任何人
和任何事，所以这里的“关键词”包含了任何人想出的任何名词、动词、词组和地名、人名等，数量
可想而知，很容易超过几千万，甚至上亿条。这里的“文档”也可以是所有网站上的在线图书、杂
志、论文、博客、网页等任意文章，也容易突破千万级数量，如何删选它们主要看搜索提供商的能
力。更进一步地.这个表还是动态的，因为网络上时时刻刻都在增加和删除各种各样的文档，所
以这个索引表也需要时刻更新。
对每个关键词来说，一般不会出现在大多数文档中(如果到处出现，搜索这个关键词的意义
不会很大),所以采用链表表示每一行，可以大大减小上面表格的存储量。实际上也是这么
做的。
现在，最重要的问题是如何能够在极短的时间内(比如1秒内)在表5.1中搜索到需要的关
键词?本章要介绍的方法——散列查找法可以很好地解决这样的问题。
散列方法为什么会有很快的查找效率呢?通过分析前面的例子，可以看出散列方法的思想，
也就可以理解其中的奥妙了。
5.2 基本概 念 169
先回到第二个例子——查字典。我们能够很快找到“关键词”的第一步是根据“关键词”的
字母序“估算”出它在字典中的大体位置。而散列方法查找关键字的第一步也是通过“散列函
数”的计算，求出关键字所在的存储位置。区别在于查字典时我们事先“估计”关键词的“大致位
置”,而散列函数“计算”的是关键词的“准确位置”。散列查找法之所以能够通过计算来快速定
位要找的关键词，一个基本的前提是在存放的时候也要通过同样的“计算方法”来定位存储的
位置。
再看第三个例子，表5.1中插人“关键词"时，其存储位置应该由散列函数“计算”来决定，然
后在查找的时候就可以通过同样的“计算方法”求出它的存储位置而迅速找到它。
读者可能有一个疑问：如果有两个(或更多)关键词通过某散列函数计算出相同的存储位
置，那又该怎么办呢?总不能把多个关键词的信息存放在相同的位置吧?我们把这种情况叫做
冲突(Collision)。因此，还需要研究解决冲突的方法。这样我们就提出了散列查找法的两个基
本内容：如何构造散列函数和如何解决冲突。很显然，假如某一次查找没有发生冲突，那么只需
要一次就完成了查找，而不管我们面对的是多大的查找集。现在读者应该可以感觉到这种方法
具有何等强大的诱惑力!
散列查找被广泛地应用于数据库的信息搜索。例如，当你用信用卡刷卡(系统需要在百万
条信用卡号中找到你的信用卡号以及相关的信息)、当你登录一个网站(系统需要在数据库中找
到你的登录名)、当你在其他应用软件中使用查找功能时等。
本章将系统地讨论散列函数的特性要求和构造方法，并介绍解决冲突的分离链接法和开放
地址法，同时进行散列方法性能分析，最后通过单词频度统计的应用实例，给出一个完整程序实
例。本章还讨论了装入因子对查找性能的影响、关键词特点、删除特性、重散列等各项技术特性，
最后总结了各种方法优缺点比较，试图给大家在解决实际问题时提供选择依据。
5.2 基本概念
从抽象的数据类型的角度看，表5.1实际上就是符号表(Symbol Table),它定义为“名字-属
性”对的集合。名字和属性的含义随着应用的不同而不同。例如，我们在查字典时，名字就是一
个单词，而属性就是该单词的解释；在编译程序符号表中，名字就是标识符，而属性则可能是包含
其类型、初值和使用该标识符的行号表。
符号表的抽象数据类型描述为：
类型名称：符号表(SymbolTable)。
数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合。
操作集：对于一个具体的符号表Table ESymbolTable,一个给定名字Name ∈NameType,属性
Attr ∈AttributeType,以及正整数TableSize,符号表的基本操作主要有：
(1)SymbolTable CreateTable(int TableSize):创建空的符号表，其最大长度为TableSize;
170 第5章 散 列查 找
(2)bool IsIn(SymbolTable Table,NameType Name):查找指定名字Name是否在符号表Table
中，若是返回true;否则返回false;
(3)AttributeType Find(SymbolTable Table,NameType Name):获取符号表Table中指定名字
Name 对应的属性；
(4)bool Modify(SymbolTable Table,NameType Name,AttributeType Attr):将Table 中指定名
字Name的属性修改为Attr。成功返回true;找不到Name则返回false;
(5)bool Insert(SymboITable Table,NameType Name,AttributeType Attr):向Table中插入一个
新名字Name及其属性Attr。成功返回 true;若Name 已存在则返回 false;
(6)bool Delete(SymbolTable Table,NameType Name):从Table 中删除一个名字Name及其
属性。成功返回 true;找不到Name则返回 false。
符号表最核心的操作是查找、插入和删除，所以在选择符号表的存储结构时，关键是保证有
效地实现这三种操作。而这三种操作频度最大的应该是查找，频度最小的是删除。插入某“关
键词-属性”(也称记录)的操作往往要先查找这个关键词，看是否在符号表中已经存在，只有不
存在这个关键词的时候才可以插入该记录。从后面的散列方法可以知道，查找确定不存在某关
键词的时候，也同时找到了要插入的存储位置，而具体插入记录的动作只需常量时间0(1),所
以插入操作的时间与查找不成功的所需时间相当。
采用本章的散列技术实现上面的操作，符号表也叫做散列表(Hash Table,即哈希表)。
散列(Hashing)是一种重要的查找方法。它的基本思想是：以数据对象的关键字key为自变
量，通过一个确定的函数关系h,计算出对应的函数值h(key),把这个值解释为数据对象的存储
地址，并按此存放，即“存储位置=h(key)”。
微视频5-1
在查找某数据对象时，由函数h对给定值key 计算出地址，将key与该
地址单元中数据对象关键字进行比较，确定查找是否成功。因此，散列法又
称为“关键字-地址转换法”。散列方法中使用的计算函数称为散列函数
(也称哈希函数),按这个思想构造的表称为散列表，所以它也是一种存储
方法。 散列表与散
列查找 [例5.4]有n=11个数据对象的集合，关键词是正整数，分别为18.
23,11,20,2,7,27,30,42,15,34。如果符号表的大小用TableSize=17(通常
用一个素数),选取散列函数h如下：
h(key)=key mod TableSize (公式5.1)
其中mod是求余运算，相当于C语言中的??算。
用这个散列函数对11个数据对象建立查找表(忽略其属性部分)如表5.2所示：
表5.2 例5.4对应的关键词散列查找表
i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
34 18 2 20 23 7 42 27 11 30 15
16
Table
5.2 基本 概 念 171
这里，我们特意选取关键词，使得没有两个关键词key,和key,的散列值是相同的，即当key,≠key,
时，必有h(key,)≠h(key,),否则就应该用5.4节中将要介绍的方法来调整存储位置。本例中查找和
插入操作都只需要一次比较就可以定位完成，与表的大小TableSize和关键词的数量n都无关。
查找时，对给定关键词key,依然通过公式5.1计算出地址，再将key,与该地址单元中关键词
比较，若相等，则查找成功。
对于n个数据对象的集合，总能找到关键字与存放地址一一对应的函数。例如当关键词为正
整数时，若最大关键词为m,可以分配m个数据对象存放单元，选取散列函数h(key)=key 即可，但
这样可能会造成存储空间的很大浪费，甚至不可能分配这么大的存储空间。比如用身份证号码作为
关键词的时候，18位十进制数字的大小已经超过2百万太字节(TB),这完全是没有办法承受的。
一般情况下，设散列表空间大小为m,填人表中的元素个数是n,则称α=n/m为散列表的装
填因子(Loading Factor)。分离链接法(5.4.2节)的装填因子定义成每个链表的平均长度。例
5.4的装填因子α=11/17≈0.65。实用时，常将散列表大小设计使得α=0.5~0.8为宜。
经过散列函数变换后，可能将不同的关键字映射到同一个散列地址上，这种现象称为冲突
(Collision),映射到同一散列地址上的关键字称为同义词(synonym)。通常关键词的值域(允许
取值的范围)远远大于表空间的地址集，所以说，冲突不可能避免，只能尽可能减少。
[例5.5]将给定的10个C语言中的关键词(保留字或标准函数名)顺次存人一张散列表。
这10个关键词为：acos、define、float、exp、char、atan、ceil、floor、clock、ctime。散列表设计为一个2
维数组Table[26][2]。
根据关键字均为小写英文字符串这一事实，可设计散列函数如下：
h(key)=key[0]-'a' (公式5.2)
将关键字key 按其首字母映射到Table[h(key)][0];若该单元已满，即发生了“冲突”,解决
的办法是将关键字放入 Table[h(key)][1];这种在同一个散列地址定义多个槽(slot)的方法可
以解决一部分冲突。但若此单元亦满，则插入失败——这种情况称为散列表溢出(Overflow)。
对于例中给定的10个关键词，表5.3显示了从acos到floor被插入后的散列表。此时该表
的装填因子α仅为8/52≈15然而clock 和ctime已经因溢出而无法直接插入了。
表5.3 散列表的插入
i Table[i][0]
acos
char
define
exp
float
…
Table[i][1]
0 atan
1
2 ceil
3
4
5 floor … …
25
172 第5章 散 列 查 找
一种解决方法是将产生溢出的关键字插入任何一个空单元，但下次查找时如何能找到它们
又成了一个难题。
通过上面两个例子可以看到，使用散列表时，在没有冲突和溢出的情况下，插入、删除、查找
等操作都可一步完成。散列映射法的关键问题有两个：一是如何设计散列函数，使得发生冲突的
概率尽可能小；二是当冲突或溢出不可避免时，如何处理使得表中没有空单元被浪费，同时插入、
删除、查找等操作都能正确完成。
所以，散列方法需要解决以下两个问题：
(1)构造“好”的散列函数，将在5.3节中介绍；
(2)制定解决冲突的方案，将在5.4节中介绍。
5.3 散列函数的构造方法
一个“好”的散列函数一般应考虑下列两个因素：
(1)计算简单，以便提高转换速度；
(2)关键词对应的地址空间分布均匀，以尽量减少冲突。即对于关键词集合中的任何一个
关键字，经散列函数映射到地址集合中任何一个地址的概率是基本相等的。实际应用中，严格的
均匀分布也是不可能的，只是不要过于“聚集”就行了。
本节把关键词分为数字型关键词和字符串型关键词这两种类型，分别介绍散列函数的构造
方法。
5.3.1 数字关键词的散列函数构造
构造这类散列函数只不过是把原来的数字按某种规律转换成另一个数字。
1.直接定址法
如果我们要统计人口的年龄分布情况(0~120岁),如表5.4所示，那么对年龄这个关键词
可以直接作为地址。此时，h(key)=key。
表5.4 年龄分布表
地址 年龄
0
1
2
…
100…
120及以上
人数
0 1180万
1 1210万
2 1 230万 … …
100 500 … …
120 25
5.3 散列函数的构造方法 173
如果我们要统计的是1990年以后出生的人口的分布情况，如表5.5所示，那么对出生年份
这个关键词可以减去1990作为地址。此时，h(key)=key-1990。
表5.5 90后分布表
地址 出生年份
1990
1991
1992 …
2000
2011
人数
0 1 285万
1 1281万
2 1280万 … …
10 1250万 … …
21 1180万
总之，取关键词的某个线性函数值为散列地址，即
(a、b为常数) h(key)=a×key +b (公式5.3)
这类函数计算简单，分布均匀，不会产生冲突，但要求地址集合与关键词集合大小相同，因
此，对于较大的关键词集合不适用。所以在现实应用中并不常用。
2.除留余数法
现实应用中比较常用的方法是除留余数法。假设散列表长为TableSize(TableSize的选取，
通常由关键词集合的大小n和允许最大装填因子α决定，一般将TableSize取为n/α),选择一个
正整数p≤TableSize,散列函数为：
h(key)=key mod p (公式5.4)
即取关键词除以p的余数作为散列地址。使用除留余数法，选取合适的p很重要，一般选取p为
小于或等于散列表表长TableSize的某个最大素数比较好。用素数求得的余数作为散列地址，比
较均匀分布在整个地址空间上的可能性较大。表5.6给出了一系列TableSize对应的p值。
表5.6 p的取 值
TableSize 8 16 32 64 128 256 512 1024
P 7 13 31 61 127 251 503 1019
大家可能已经注意到，如果p<TableSize,则意味着地址p~TableSize-1是不能通过散列函数
直接映射到的。不过不用担心这些空间被浪费了，事实上，在冲突发生时就可能会用到它们。
3.数字分析法
如果数字关键词的位数比较多，在特定的情况下，有些位数容易相同，而有的位数比较随机。
174 第5章 散 列 查 找
比如11位手机号码，前3位容易相同，中间4位表示用户的归属地，在一定范围内也容易重复，
而最后4位表示用户号，是很随机的。所以一般选择最后4位作为散列地址，这样发生冲突的可
能性较小。因为11数字已经超过长整数，所以可以改成字符串表示。如果用key表示指向某11
位数字字符串的指针，那么,采用C语言的字符串转换成整数的处理函数 atoi,可以将散列函数
表示成：
h(key)=atoi(key+7) (公式5.5)
这里key+7表示指针往后移7个数字，即留下4位数字。如果4位正整数太大，不适合作为地
址，那么还可以结合前面介绍的除留余数法再做一次转换。
另一个例子，如果关键词是18位的身份证号码，各位数字的含义如表5.7所示，其中第18
位是校验码，可以取0~9和x这11个符号。通过分析容易知道，在一定范围内，前6位表示的所
属地编号，容易相同；如果考虑在校生范围的时候，第7~10位表示的出生年份都应该比较接近；
第11位是0的可能性为10/12,是1的可能性为2/12,也不够随机；第13位基本上取0~2,不可
能取4以上的数字；第15位取0的可能性远大于其他数字，因为同一个区(县)下属辖区中同生
日的人数很难达到3位数；第17位的奇偶性用来区分男女性别；一般来说不够随机的位不适合
参与散列计算，否则映射出来的地址可能会产生某种“聚集”效应。
表5.7 身份证号码分析表
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
3 0 1 0 6 1 9 9 0 1 0 0 8 0 4 1
省 市
区(县)
下属辖区
编号
(出生)年份 月份 日期 该辖区中的序号
18
3 9
校验
因此，我们可以针对不同的应用对象，选取尽可能取值较随机的身份证号码的“位”参与散
列计算，从而达到均匀分别的效果。比如，我们选取第6、10、14、16、17、18位参与散列计算，计算
方法可以是：
h1(key)=(key[6]-'0')×10*+(key[10]-'0)×102+(key[14]-'0')×102
+(key[16]-'0')×10+(key[17]-'0')
h(key)=h1(key)×10+10 (当key[18]='x'时)
h(key)=h1(key)×10+key[18]-0'(当key[18]为'0'-'9'时) (公式5.6)
公式5.6计算结果可以达到6位的正整数。如果太大，不适合作为散列地址，那么还可以结
合前面介绍的除留余数法再做一次转换。也可以取前面6个位数中的几位类似地计算散列地
址，主要考虑依据是选取合适的装入因子，从而估计需要多大的地址空间。比如，有5 000个数
据元素的集合，装入因子选为0.5,则地址空间大小应为5 000/0.5=10 000左右，即可以选用上
述6个位数中的某4个位数。
5.3 散列函数的构造方法 175
5.3.2 字符串关键词的散列函数构造
对于字符串类型的关键词，因为字符串的比较比整数的比较要花费更大的代价，所以通过散
列函数计算，把字符串映射到整数后再比较也是散列方法的优势之一。
1.一个简单的散列函数——ASCII码加和法
对字符型关键词key定义散列函数如下：
h(key)=(Zkey[i])mod TableSize (公式5.7)
函数很简单，然而均匀性也较差。例如考虑长度不超过8的字符串关键词集，并把字符限制
在大小写英文字母、下横线和数字(26×2+1+10=63)以内，关键词集包含有63°个不同的关键词。
取TableSize为质数10 007,这个数字相对于关键词总数还是很小的。然而(Zkey[i])最大只能
取到127×8=1016,这就意味着h将全部63?个关键字都映射到[0,1 016]区间内，显然冲突可
能是很严重的。比如关键词“a3"、“b2”和“c1”的散列值都是100,它们是冲突的；关键词“tea”和
"eat"也是冲突的。
2.简单的改进——前3个字符移位法
上面介绍的ASCII码加和法完全不区分每个字符的出现位置，导致严重冲突。现改造如下：
h(key)=(key[0]+key[1]×27+key[2]×272)mod TableSize(公式5.8)
选择27进制是因为英文有26个字母(不分大小写),加1个空格符。函数仅考虑关键字
key的前3个字符。该函数假设key至少有2位字符，此时字符串结束符('\0')也参与计算。
若忽略空格符不计，则前3位所有可能的不同组合有263=17 576种，似乎TableSize=10 007
是不错的选择。可惜不巧的是，英文不是随机的，真正的英文单词中，前3位的不同组合大约不
到3000种，即使没有冲突问题，也是对空间的浪费(装填因子不到30???何况具有相同的前3
个字符的不同关键词一定会发生冲突，比如：string、street、strong、structure等。因此，虽然很容易
计算，但是当散列表太大的时候，这个函数还是不合适的。
3.好的散列函数——移位法
这个散列函数涉及关键词的所有n个字符，并且分布得很好。形式如下：
h(key)=(∑key[n-i-1]×32) mod Tablesize (公式5.9)
该函数用于处理长度为n的字符串型关键字，每位字符占5位(即2?=32),如图5.4所示。
具体实现时并不需要做乘法运算，而是通过一次左移5位来完成，如参考代码5.1所示。这也是
为什么选用32来代替公式5.8中的27的原因。
…
key[0] key[1] key[n-2] key[n-1]
图5.4 关键字位移映射示意
176 第5章 散 列 查 找
int Hash(const char*Key,int Tablesize)
unsigned int H=0; /*散列函数值，初始化为0*/
while(·Key !='o') /*位移映射·
H=(H<<5)+*Key++;
return H8 Tablesize;
代码 5.1 散列函数——位移映射
该函数遇到的主要问题是，当n太大时(例如关键词是一段邮寄地址所组成的字符串),前
面若干位字符可能被左移出界，而起作用的只有最后几位字符。一种解决的办法是不使用整个
字符串，而是从中选择若干位有代表性的字符进行映射，比如字符串长度大于12的时候，仅选取
奇数位置上的字符来实现散列函数。
5.4 处理冲突的方法
在前面的散列函数构造过程中，我们努力使散列地址均匀分布于整个地址空间，但是实
际应用中，冲突只能尽量减少，而不能完全避免。接下来我们讨论在冲突发生时，如何有效地
解决它。常用的处理冲突的方法有两种：开放地址法(Open Addressing)和链地址法(Linear
Probing)。
5.4.1 开放定址法
假如你打算在某小区买套房子住，根据你的生辰八字(关键词),风水先生(散列函数)告诉
你8-801最适合你。正准备下单的时候，开发商却告诉你说该房子已经被其他人买走了(冲突
发生啦),此时你会怎么办呢?其实很简单，只能换一套房子看看呗!这就是解决冲突的开放地
址法。而“换一套房子”的策略也有不同，比如可以看看8-802,或者8-901,或者8-701,或者
9-801等，这种试探紧邻的单元有没有空的策略叫做线性探测法。当然你也可以换一个策略(平
方探测、双散列)决定试探其他房子。
所谓开放定址法，就是一旦产生了冲突，即该地址已经存放了其他数据元素，就去寻找另一
个空的散列地址。在没有装满的散列表中，空的散列地址是否总能找到，这也是我们在选择解决
冲突方法时要考虑的因素之一。
一般来说，发生了第i次冲突，我们试探的下一个地址将增加d。它的基本公式是：
h,(key)=(h(key)+d,)mod TableSize(1≤i<TableSize)(公式5.10)
根据d的选取方式不同，我们可以得到不同的解决冲突方法。上面的地址必须对TableSize
5.4 处理冲突的方法 177
取余，否则可能超出散列表的地址空间。
1.线性探测法
如果公式5.10中的d,就选为i,那么它就是线性探测法。即线性探测法以增量序列1,
2,…,(TableSize-1)循环试探下一个存储地址。做插入操作的时候，要找到一个空位置，或者知
道散列表已满为止；做查找操作的时候，探测一个比较一次关键词，直到找到特定的数据对象，或
者探测到一个空位置表示查找失败为止。
[例5.6] 设关键词序列为[47,7,29,11,9,84,54,20,30|,散列表表长TableSize=13,散列
函数为：h(key)=key mod 11。用线性探测法处理冲突，列出依次插人后的散列表，并估算查找性
能。表5.8列出了相应的地址计算和冲突情况统计。
表5.8 散列函数计算与冲突统计
关键词 47 7 29 11 9 84 54 20
3 7 7 0 9 7 10 9
0 0 1 0 0 3 1 3
30
散列地址 8
冲突次数 6
表5.9给出了用线性探测法依次插入上述序列的散列表过程。
表5.9 线性探测法构建散列表的过程
散列
地址 0 1 2 3 4 5 6 7 8 9 10 11 12 说 明
操作
插入47 47 无冲突
插入7 47 7 无冲突
插入29 47 7 29 d?=1
插入1 11 47 7 29 无冲突
插入9 11 47 7 29 9 无冲突
插入84 11 47 7 29 9 84 d,=3
插入54 11 47 7 29 9 84 54 d?=1
插入20 11 47 7 29 9 84 54 20 d,=3
插入30 11 30 47 7 29 9 84 54 20 d,=6
如表5.9所示，关键词47、7是由散列函数得到的没有冲突的散列地址而直接存入的。第
3个关键词29遇到h(29)=7,散列地址冲突，需寻找下一个空的散列地址：由h?=(h(29)+1)
mod 13=8,散列地址8为空，将29存入。关键词11、9的散列地址没有冲突，直接存入。而
h(84)=7,散列地址又一次冲突，于是进行以下探测：
178 第5章 散 列 查 找
(1)h?=(h(84)+1)mod 13=8仍然冲突；
(2)h?=(h(84)+2)mod 13=9 仍然冲突；
(3)h?=(h(84)+3)mod 13=10 找到空的散列地址，存入。
类似地，关键词54、20分别冲突1次和3次才找到空地址，存入；关键词30经过6次冲突才
找到可以存放的地址1,存人。
0
微视频5-2
散列表查找
性能分析
线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，
也就是说，本应存入第i个散列地址的数据对象变成了第i+1个散列地址
的同义词。因此，可能出现很多元素在相邻的散列地址上“堆积”起来的现
象，会大大降低查找效率。如上例中插入30需要经过很多次冲突才找到空
位置。这种现象叫做一次聚集(Primary Clustering)。为减轻这种一次聚集
效应，可采用平方探测法，或双散列探测法，这些方法随后介绍。
在4.5节中，我们介绍了平均查找长度(ASL)的概念，现在来估计算一
下，在这个散列表中查找数据对象的ASL。我们假设要查找的关键词一定
在散列表中存在，来计算一下平均需要查找多少次，即成功查找的ASL。只要对查找表中的每个
关键词的比较次数加起来，除以关键词的个数，就得到平均每个关键词的查找长度。而每个关键
词的比较次数是其冲突次数加1。就例5.6中的数据而言，根据表5.8有：
成功查找的ASL=(1+1+2+1+1+4+2+4+7)/9=23/9≈2.56
关于线性探测法的查找性能分析将在5.5节中不加证明地给出。线性探测法思想简单，并
且只要散列表中有空地址，这个方法总能够找到它。
2.平方探测法
如果公式5.10中的d,选为±i2,那么它就是平方探测法(Quadratic Probing)。即平方探测法
以增量序列12,-12,22,-22,…,q2,-q2且q≤[TableSize/2J循环试探下一
个存储地址。有证明表示，如果散列表长度TableSize是某个4k+3(k是正
整数)形式的素数时，平方探测法就可以探查到整个散列表空间。这一点
很重要，是我们能够放心使用平方探测法的理论保证。
关键词
散列地址
冲突次数
微视频5-3
平方探测法
的理论保证
[例5.7]设关键词序列为|47.7,29,11,9.84,54.20,301.散列表表
长TableSize=11(即满足4×2+3形式的素数),散列函数为：h(key)=
key mod 11。用平方探测法处理冲突，列出依次插人后的散列表，并估算查
找成功的平均查找长度。表5.10列出了相应的地址计算和冲突情况统计。
表5.10 散列函数计算与冲突统计
47 7 29 11 9 84 54 20
3 7 7 0 9 7 10 9
0 0 1 0 0 2 0 3
30
8
3
5.4 处理冲突的方法 179
表5.11给出了用平方探测法依次插入上述序列的散列表过程。
表5.11 平方探测法构建散列表的过程
散列
地址 0 1 2 3 4 5 6 7 8 9 10
47
47 7
47 7 29
11 47 7 29
11 47 7 29 9
11 47 84 7 29 9
11 47 84 7 29 9 54
11 20 47 84 7 29 9 54
11 30 20 47 84 7 29 9 54
说 明
操作
插人47 无冲突
插人7 无冲突
插人29 d?-1
插入1 无冲突
插入9 无冲突
插入84 d?=-1
插人54 无冲突
插人20 dy=4
插人30 d,=4
类似于例5.6中的计算，根据表5.10有：
成功查找的ASL=(1+1+2+1+1+3+1+4+4)/9=18/9=2
例5.6的装填因子α=9/13≈0.69,而例5.7的装填因子α=9/11≈0.82。从这两个例子中
看到，装填因子较大的例5.7反而比装填因子较小的例5.6有更小的ASL。似乎给我们一定的
暗示，平方探测法在一定程度上减轻了“聚集”效应，从而提高了散列表的查找性能。关于平方
探测法的查找性能分析将在5.5节中不加证明地给出。
虽然平方探测法排除了一次聚集，但是散列到同一地址的那些数据对象将探测相同的备选
单元，这叫做二次聚集(Secondary Clustering)。二次聚集在理论上是个小缺憾，下面的双散列探
测法可以弥补这个缺憾，但也需要一定的代价，用得不好还会带来严重后果。
在开放地址散列表中，不能进行标准的删除操作，因为相应的单元可能已经引起过冲突，数
据对象绕过它存在了别处。例如在例5.6和5.7中，完全删除关键词7将导致再也找不到关键
词29了。为此，开放地址散列表需要“懒惰删除”,即需要增加一个“删除标记”,而并不是真正
删除它。这样可以不影响查找，但增加了额外的存储负担并增加了程序的复杂程度。代码5.2
的类型声明中，EntryType取值Deleted的时候就表示已被删除的意思。
实现开放定址法的类型声明在代码5.2中表示，其中关键词类型 ElementType和数组下标
Index 都在这里定义为整型，实际应用中可以根据情况定义为其他类型。
/*允许开辟的最大散列表长度·/ #define MAXTABLESIZE 100000
/*关键词类型用整型*/ typedef int EIementType;
/*散列地址类型*/ typedef int Index;
/*数据所在位置与散列地址是同一类型*/ typedef Index Position;
180 第5章 散 列查 找
/*散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素·/
typedef enumI Legitimate,Empty,Deleted |EntryType;
typedef struct HashEntry cell;/散列表单元类型*/
struct HashEntryl
ElementType Data;/存放元素·/
EntryType Info;/*单元状态·/
I;
typedef struct Tb1Node*HashTable;/*散列表类型*/
struct TblNode /*散列表结点定义·/
int Tablesize; /*表的最大长度*/
Cell*Cells; /*存放散列单元数据的数组*/
I;
代码5.2 开放定址法的类型声明
代码5.3给出了散列表的初始化函数CreateTable。首先申请散列表需要的空间，再将每个
单元的 info域设置成 Empty,表示为空。注意需要确定一个不小于TableSize的素数，用作真正的
散列表的地址空间大小，这个功能由函数NextPrime 实现。
int NextPrime(int N)
I/*返回大于N且不超过 MAXTABLESIZE的最小素数*/
int i.p=(N)?N+2:N+1;/*从大于N的下一个奇数开始·/
while(p<=MAXTABLESIZE)
for(i=(int)sqrt(p);i>2;i--)
if(!(pOi))break;/*p不是素数*/
if(i==2)break;/*for 正常结束，说明p是索数*/
else p+=2:/*否则试探下一个奇数*
F
return pi
HashTable CreateTable(int TableSize)
HashTable H;
int i;
5.4 处理冲突的方法 184
H=(HashTable)malloc(sizeof(struct TblNode));
/·保证散列表最大长度是素数·/
H->TableSize=NextPrime(TableSize);
/*声明单元数组*/
H->Cells=(Cel1*)malloc(H->Tablesize*sizeof(Cel1));
/*初始化单元状态为“空单元”·/
for(i-0;i<H->TableSize;i++)
H->Cells[i].Info=Empty:
return H:
代码5.3 开放定址法的初始化函数
代码5.4是平方探测法的查找函数Find。首先调用Hash 函数计算地址，以确定关键词所在
的散列表的地址。用while循环控制直到明确查找成功或者找到空位置表示查找失败，遇到冲
突则继续查找。注意：关键词Key的类型 ElementType不一定总是如代码5.2中定义为整型，也可
能在某些应用中被定为字符串。若是字符串类型，则while的判断条件中“H->Cells[NewPos].
Data!=Key"要用C语言strcmp 函数来替换。若找到了关键词，函数直接返回结点的地址，若找
不到则返回一个空单元的位置。
Position Find(HashTable H,ElementType Key)
Position Current Pos,NewPos;
int CNum=0;/*记录冲突次数*/
NewPos=CurrentPos=Hash(Key,H->Tablesfze);/*初始散列位置*/
/*当该位置的单元非空，并且不是要找的元素时，发生冲突*/
while(H->Cells[NewPos].Info!=Empty
H->Cells[NewPos].Data!=Key)
/*字符串类型的关键词需要 strcmp 函数*/
/*统计1次冲突，并判断奇偶次*/
if(++CNum)|/*奇数次冲突·/
/*增量为+[(CNum+1)/2]^2*/
NewPos=CurrentPos+(CNum+1)*(CNum+1)4;
if(NewPos >=H->Tablesize)
NewPos=NewPosH->TableSize;/*调整为合法地址*/
else |/*偶数次冲突·/
182 第5章 散 列 查 找
NewPos=Current Pos-CNum*CNum/4;/增量为-(CNum/2)^2·/
while(NewPos<0)
NewPos+=H->Tablesize;/*调整为合法地址·/
1
return NewPos;
/此时NewPos或者是Key的位置，或者是一个空单元的位置(表示找不到)*/
代码5.4 平方探测法的查找函数
代码5.5是插入函数Insert。先检查Key是否已经存在，该地址的单元状态只要不是合法的
元素(Empty 或者 Deleted),就可以确定在此插入。插入后，把单元状态改成合法数据(Legiti mate)。与查找的情况类似，如果关键词是字符串类型的数据，语句“H->Cells[Pos].Data=Key”
需要用strcpy 函数替换。
bool Insert(HashTable H,ElementType Key)
Position Pos=Find(H,Key);/*先检查Key是否已经存在*/
if(H->Cells[Pos].Info !=Legitimate)|
/*如果这个单元没有被占，说明Key可以插入在此*/
H->Cells[Pos].Info=Legitimate;
H->Cells[ Pos].Data=Key;
/·字符串类型的关键词需要 strcpy 函数*/
return true;
else
printf("键值已存在“):
return false:
代码5.5 平方探测法的插人函数
3.双散列探测法
如果公式5.10中的d,选为i*h?(key),其中h?(key)是另一个散列函数。我们把它叫做双散
列探测法(Double Hashing)。这个公式的意思是，我们的探测增量序列成了h?(key),2h?(key),
3h?(key),……第二个散列函数h?(key)如果选得不好，结果将会是灾难性的。比如，如果用
5.4 处理冲突的方法 183
h?(key)=key mod 11,要把key=22插入到表5.9的最后一行中去，这是没法实现的。原因是
h?(22)=0,所有的探测都是同一个位置。因此，要求对任意的key,h?(key)都不能是0值。
另外，探测增量序列还应该保证所有的散列存储单元都应该能够被探测到。一般形如
h?(key)=p-(key mod p) (公式5.11)
这样的函数会有良好的效果，其中p是小于TableSize的素数。选用一个素数作为TableSize
也同样重要，否则可能探测不到所有的存储单元。
采用双散列探测法会增加每次探测的乘法和除法的计算，但其期望的探测次数比较少，这使
得它在理论上很有吸引力。不过平方探测法不需要计算第二个散列函数，从而在实践中可能更
简单又实用。
4.再散列法
开放地址法的装填因子α(0<=α<=1)会严重影响查找效率，由于表长在一定时间内是定
值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性
就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。实用最大装填因子一般取
0.5<=α<=0.85,超过最大装填因子将导致查找速度严重下降。
当装填因子过大时，解决的方法是加倍扩大散列表，这样α可以减小一半，这个过程叫做再
散列(Rehashing)。
再散列需要新建一个两倍大的散列表，并将原表中的数据重新计算分配到新表中去，这个过
程集中花费较多的时间，因此在交互系统中会使人感觉有“停顿”现象。而在一些实时系统中使
用要充分谨慎，比如在医用的生命保障系统中，设备的短时“停顿”有可能导致严重的后果。此
时可以采用不需要再散列的“分离链接法”。
5.4.2 分离链接法
分离链接法(Separate Chaining)是解决冲突的另一种方法，其做法是将所有关键词为同义词
的数据对象通过结点链接存储在同一个单链表中。
设散列函数得到的散列地址域在区间[0,m-1]上，以每个散列地址作为一个指针，指向一
个链，即分配指针数组如下：
List Heads[m];
建立m个带头结点的空链表，散列地址为i的所有关键词均插入到Heads[i]指向的单链表
中。插入时，新元素插入到表头，这不仅为了方便，而且还因为新近插入的元素最有可能最先被
访问，这样可以加快在单链表中的顺序查找速度。每个分离链的单链表设计成带表头结点，根据
3.2.3节可以知道，带空头结点的单链表实现插人和删除等操作的代码可以更简洁。后面的代
码5.6到代码5.15以及例5.9采用的就是这样的数据结构。
[例5.8]设关键字序列为47,7,29,11,16,92,22,8,3,50,37,89,94,21,散列函数取为：
h(key)=key mod 11。用分离链接法处理冲突，建表如图5.5所示，注意向链表中插入元素均在
表头进行。
184 第5章 散 列查 找
0 22 11
1 89
2
3
A
3 47 A
4 37 92 A
5 16 A
6 94 50 A
7 29 7 入
8 8
9
10
图5.5 分离链接法处理冲突时的散列表
容易看出，该表中有9个结点只需1次查找，5个结点需要2次查找，因此查找成功的平均
查找次数ASL=(9+5*2)/14=1.36。
接下去我们将具体介绍分离链接法的代码实现。有关声明在代码5.6中，在此我们设关键
词类型用字符串，且字符串的长度不超过15。
A
21 A
/*关键词字符串的最大长度*/ #define KEYLENGTH 15
typedef char Element Type[KEYLENGTH+1];/*关键词类型用字符串*/
typedef int Index; /*散列地址类型*/
/*******以下是第3章中单链表的定义******
typedef struct LNode·PtrTOLNode;
Btruct LNode
ElementType Data;
PtrTOLNode Next;
1:
typedef ptrTOLNode Position;
typedef PtrToLNode List;
/********以上是第3章中单链表的定义********/
typedef struct TbINode*HashTable;/*散列表类型*/
struct TblNode//*散列表结点定义·/
5.4 处理冲突的方法 185
int Tablesize;/*表的最大长度*/
;
List Heads;/*指向链表头结点的数组*
代码5.6 分离链接法的结构声明
散列表结构包括一个TableSize记录表的最大长度以及一个结点数组对应的单链表，它们在
初始化时动态分配空间，并设置相应的初值。
代码5.7是散列表的初始化函数CreateTable。首先申请散列表的头结点空间；然后确定一
个不小于TableSize的素数，用作真正的散列表的地址空间大小；最后动态分配散列表的地址列
表数组并初始化空的头结点(如图5.6所示)。
H- TableSize
Heads …
NULL NULL NULL
图5.6 散列表结构
HashTable CreateTable(int Tablesize)
HashTable H;
int i;
H=(HashTable)malloc(sizeof(struct TbINode));
/*以下分配链表头结点数组*/
H->Heads=(List)malloc(H->Tablesize*sizeof(struct LNode));
for(i=0;i<H->Tablesize;i++)|
H->Heads[].Data[0]='0';
H->Heads[i].Next=NULL;
return H;
/*保证散列表最大长度是素数，具体见代码5.3*/
/*初始化表头结点*/
H->Tablesize=NextPrime(Tablesize);
代码5.7 分离链接法的初始化函数
186 第5章 散 列 查 找
代码5.8是查找函数Find。首先调用Hash 函数(代码5.1)计算地址，得到关键词所在的
Heads 中单元的下标Pos;P则指向Heads[Pos]链表中真正的第1个元素。因为关键词是字符
串，所以 while的条件判断中要用strcmp 函数来比较 Data与Key的值。若找到了关键词，函数直
接返回结点的地址，若找不到则返回空地址。
Position Find(HashTable H,ElementType Key)
Position P;
Index Pos;
Pos=Hash(Key,H->Tablesize);/*初始散列位置*/
P=H->Heads[Pos].Next;/*从该链表的第1个结点开始*/
/*当未到表尾，并且 Key未找到时*/
while(P&& strcmp(P->Data,Key))
P=P->Next;
return P;/*此时P或者指向找到的结点，或者为NULL*/
代码5.8 分离链接法的查找函数
代码5.9是插入函数Insert。该函数先调用函数Find,如果找到了关键词则不需要插入，返
回插入不成功的信息；如果找不到关键词才需要插人。插入时，先申请一个新结点NewCell,然后
计算Key的地址 Pos(注意，第2次调用Hash函数)。插入成为单链表Heads[Pos]的第一个
结点。
函数Insert有点不尽如人意的地方是它计算了两次散列函数，在最初的Find 函数里面计算
了一次，而在插入之前又重复计算它。一个简单的改进是Find 函数增加一个参数传递计算后的
散列地址，但这样在程序可读性方面会要付出代价。
bool Insert(HashTable H,ElementType Key)
Position P,NewCe11;
Tndex Pos;
P=Find(H,Key):
if(!P)|/*关键词未找到，可以插入·/
Newcel1=(Position)malloc(sizeof(struct LNode));
strepy(NewCell->Data,Key);
Pos=Hash(Key,H->Tablesize);/*初始散列位置·/
5.4 处理冲突的方法 187
/*将Newcel1插入为H->Heads[Pos]链表的第1个结点·/
Newcel1->Next=H->Heads[Pos].Next;
H->Heads[Pos].Next=NewCell;
return true;
elsef/●关键词已存在·/
printf("键值已存在");
return false;
代码5.9 分离链接法的插人函数
释放CreateTable函数所占用的所有内存空间可以调用代码5.10的函数DestroyTable。
void DestroyTable(HashTable H)
int i;
Position P,Tmp;
/*释放每个链表的结点*/
for(i=0;i<H->Tablesize;i++)
P=H->Heads[i],Next;
while(P)
Tmp=P->Next;
free(P);
P=Tmp;
free(H->Heads);/*释放头结点数组*/
free(H); /*释放散列表结点*/
代码5.10 分离链接法的释放散列表函数
删除关键词的操作可以直接实现，因为链表结点的删除不会影响其他关键词。就这一点来
说分离链接法比开放地址法要好。删除操作的程序实现作为一道练习留给读者。
188 第5章 散 列 查 找
5.5 散列表的性能分析
散列表的查找过程基本上和建表过程相同。一些关键字可通过散列函数转换的地址直接找
到，另一些关键词在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介
绍的两种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键字进行比较的过程。所以，
在上一节中的例5.6和例5.7中，我们已经用平均查找长度(ASL)来度量散列表查找效率。
查找过程中，关键词的比较次数，取决于产生冲突的多少。产生的冲突少，查找效率就高；产
生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影
响产生冲突多少有以下三个因素：
(1)散列函数是否均匀；
(2)处理冲突的方法；
(3)散列表的装填因子α。
分析这三个因素，尽管散列函数的“好坏”直接影响冲突产生的频度，但一般情况下，我们总
认为所选的散列函数是“均匀的”,因此，可不考虑散列函数对平均查找长度的影响。
另外，期望的平均查找次数与操作有关，插入操作和不成功的查找需要探测相同的次数，成
功查找应该比不成功查找花费较少的查找次数。
1.线性探测法的查找性能
可以证明，线性探测法的期望探测次数p满足下列公式：
(对插人和不成功查找而言)
(对成功查找而言)
(公式5.12)
假设α=0.5,那么可以算出，插人操作和不成功查找的期望查找长度是2.5次，成功查找的
期望查找长度是1.5次。例子5.6的α=0.69,这两类期望查找次数分别5.70次和2.11次(例
中实际成功查找的ASL是2.56)。
2.平方探测法和双散列探测法的查找性能
可以证明，平方探测法和双散列探测法的期望测次数p满足下列公式：
成功查找而言)
寸成功查找而言)
(公式5.13)
假设α=0.5,那么可以算出，插入操作和不成功查找的期望查找长度是2次，成功查找的期
望查找长度是2In 2≈1.39次。例子5.7的α=0.82,这两类期望查找次数分别5.56次是和
5.6 应用 实 例 189
2.09次(例中实际成功查找的ASL是2)。
图5.7表示了上面几种探测法的期望探测次数与装填因子α的关系。当装填因子α<0.5
的时候，各种探测法的期望探测次数都不大，也比较接近。随着装填因子的增大，线性探测法的
期望探测次数增加较快，不成功查找和插入操作的期望探测次数明显比成功查找的期望探测次
数要大。合理的最大装入因子α应该不超过0.85。
,U,I 15.0 U.I
12.0
9.0 !s
6.0
3.0 S
0.0
.10.15.20.25.30.35.40.45.50.55.60.65.70.75.80.85.90.95
图5.7 期望探测次数与装填因子α的关系
线性探测法(虚线)、双散列探测法(实线)
U表示不成功查找，I表示插入，S表示成功查找
3.分离链接法的查找性能
为了给出分离链接法的期望查找次数，先定义分离链接法的装填因子。我们把分离链接表
中每个链表的平均长度定义成装填因子α,因此这个α有可能超过1。
不难证明：分离链接表中每个链表的平均长度为α,那么其期望探测次数p为：
(对插入和不成功查找而言)
-
(对成功查找而言) (公式5.14)
假设α=1,可以算出，插人操作和不成功查找的期望查找长度是1.37次，成功查找的期望
查找长度是1.5次。例子5.8的14个元素分布在11个单链表中，所以α=14/11≈1.27,这两类
期望查找次数分别1.55次是和1.63次(例中实际成功查找的ASL是1.36)。
5.6 应用实例
《哈利·波特》(Harry Potter)是英国作家J·K·罗琳的奇幻文学系列小说，被翻译成了近
七十多种语言，在全世界两百多个国家，截至2008年的累计销量已达四亿多册。下面关于
·出自《数据结构与算法—C语言描述》英文版第2版，Mark Allen Weiss著。
190 第5章 散 列 查 找
“Harry Potter”的问题你会不会觉得很奇怪呢：谁能告诉我，在其共七集的小说中，"Harry Potter"
的名字总共出现了多少次?
用本节讨论的程序，你只要输入小说的文本文件，就可以知道答案。该程序不仅可以回答上
面的问题，它实际上可以统计所有单词的出现次数。
[例5.9]给定一个英文文本文件，统计文件中所有单词出现的频率，并输出词频最大的前
10??单词及其词频。假设单词字符定义为大小写字母、数字和下划线，其他字符均认为是单词
分隔符。
解决这个问题的最基本的工作、也是大量的工作是不断对新读入的单词在已有单词表中查
找，如果已经存在，则增加该单词的词频，如果不存在，则插入该单词并记词频为1。
关键问题是，如何设计该单词表的数据结构才可以进行快速地查找和插入呢?散列表结构
正好符合快速查找的要求。
需要注意的是，在这个问题中我们将要统计每个单词的词频，所以代码5.6中的链表结点类
型LNode必须增加计数器 Count,用于存储该单词的出现次数。空头结点中的Count 被利用来存
储该单链表中的结点数，并且在代码5.7的CreateTable 函数中应被初始化为0。更改后的结点
声明如下：
struct LNode
ElementType Data;
int Count;
PtrToLNode Next;
1;
下面给出解决该问题的完整程序。
主控函数(代码5.11)先将散列表的大小估计为100——这不是素数，不过散列表初始化时
会调用代码5.7求出比较接近的素数，用作真正的散列表大小。这个估计大小可以根据应用问
题的规模更改。如果你有《哈利·波特》的电子版文本文件，做词频统计的散列表的大小取
5 000左右比较合适。
在创建了散列表之后，进入 while循环，每次调用CetAWord 函数从文件中读一个单词。这
里要求根据返回的单词的长度，过滤太短的没有多大意义的单词。如果需要的话，还可以增加条
件，过滤掉全数字的单词等。然后统计文件中的单词数量，并调用 InsertAndCount 函数实现把该
单词插入到散列表结构中，并计算它的词频。重复以上过程直至输入文件结束。
函数InsertAndCount是对代码5.9给出的Insert 函数的一个改编，主要的修改有三点；一是
将NewCell 插入为H->Heads[Pos]链表的第1个结点时，要将NewCell的Count 初始化为1,即
这是新单词第一次出现；二是插入后Heads[Pos]头结点的Count要加1,表示这个链表中增加了
一个新单词；三是如果一开始 Find 函数找到了关键词，不需要打印错误信息，而是应该把找到的
这个P指向的结点的Count加1,即执行“P->Count++”,表示这个单词又出现了一次。完整代码
在代码5.12中给出。
5.6 应用 实 例 191
此时，已经完成把文件中的所有单词与词频信息存入散列表中。据此，调用Show 函数显示
词频前10??单词。
销毁散列表函数 DestroyTable将释放由初始化函数申请的全部内存空间。“有借有还，再借
不难"。尽管程序运行结束后，操作系统会回收应用程序的内存空间，但还是强烈建议不要忘记
这个步骤。良好的程序设计习惯将使你受益匪浅。
int main()
PILE+fp;
HashTable H:/*需改编代码5.6.结点增加计数器Count·/
ElementType word:
int Tablesize=100;/·散列表的估计大小，可以根据应用更改·/
int length,wordcount=0;
char document[30]-"HarryPotter.txt";要被统计词频的文件名*/
H=CreateTable(Tablesize);/*用代码5.7建立散列表*/
if((fp=fopen(document,"r"))==NULL)
printf("无法打开文件! \n");
while(!feof(fp))
length=GetAWord(fp,word);/*读取一个单词·/
if(length>3)|/*只考虑长度大于3个字符的单词*/
wordcount++;
InsertAndCount(H,word);/*改编代码5.9,统计 word出现次数*/
fclose(fp);
printf("该文档共出现 d 个有效单词",wordcount);
Show(H,10.0/100);/*显示词频前108的所有单词*/
DestroyTable(H);/*用代码5.10销毁散列表*/
return 0;
代码5.11 主函数
void InsertAndCount(HashTable H,ElementType Key)
Position P,NewCell;
192 第5章 散 列查 找
Index Pos;
P=Find(H,Key);
if(!P)/*关键词未找到，可以插人*/
Newcell=(Position)malloc(sizeof(struct LNode));
strcpy(NewCel1->Data,Key);
Newcell->Count=1;/*新单词第一次出现*人
Pos=Hash(Key,H->Tablesize);/*初始散列位置·/
/*将Newcell插入为H->Heads[ Pos]链表的第1个结点·/
NewCel1->Next=H->Heads[Pos].Next;
H->Heads[ Pos].Next=NewCell;
H->Heads[Pos].count++;/*链表中增加了一个新单词*/
else(/*关键词已存在·/
P->Count++;
代码5.12 插入单词并统计词频
代码5.13的IsWordChar 函数判断一个字符是否为合法的单词字符。本例中单词的合法字
符为大小写字母、数字和下划线。
bool IsWordChar(char c)
if(c>='a'&c<='z' c>='A'&反c<='z' I1e>='o'ce=19' 11e==')
return true:
else
return false;
代码5.13 判断合法的单词字符
代码5.14的GetAWord 函数从给定文件中读取一个单词，返回该单词的长度，超出
KEYLENGTH(本例中定义为15)的长度将截去。
#define MAXWORDLEN 80/*所有单词最大长度*/
int GetAWord(FILE*fp. ElementType word)
5.6 应用 实 例 193
char tempword[ MAXWORDLEN+1],c;
int len=0;/单词长度·/
c=fgetc(fp);
while(!feof(fp))
if(ISWordChar(c))/*如果是合法的单词字符*/
tempword[len++]=c;
c=fgete(fp);
/*跳过单词前的非法字符，或以非法字符结束一个单词*
if(len &!IsWordchar(c))
break;/s一个单词结束/
tempword[len]='o';/设定字符串结束符*/
if(len>KEYLENGTH)/·太长的单词被截断*
tempword[KEYLENGTH]='0';
len=KEYLENGTH;
strcpy(word, tempword);
return len;
代码5.14 读取一个单词
最后介绍代码5.15。Show 函数显示词频前一定百分比的单词。另外，附带的一些统计功能
都可以在这个函数里面加入。比如有多少不同单词的数量(有别于文件中单词数，不计重复单
词)、最大词频的单词是哪些单词、冲突次数(单链表的长度)大小的分布情况(作为练习，读者自
己修改实现)等。
Show 函数的大概流程如下：首先用第一个for循环扫描整个散列表，统计不同的单词数量和
最大词频maxf;其次，根据最大词频maxf申请一个数组 difwords用于存储词频从1到maxf的单
词数量；然后，根据每个词频的单词数数组才能划定最频繁出现的前给定百分比(Percent)的单
词应该有多大的词频i;最后一个for 循环按词频从大到小输出单词；当然，不要忘记释放数组
diffwords占用的内存空间。
void Show(HashTable H,double percent)
int diffwordcount=0;/不同的单词数量·/
/每个词频对应的不同单词数量·/
int maxf=0; /最大的词频*/
/*最大冲突次数，初始化为0*/
int*diffwords;
int maxCo1lision=0;
194 第5章 散 列 查 找
int mincollision=100;/*最小冲突次数，初始化为100·/
Position L;
int i,j,k,lowerbound,count=0;
for(i=0;i<H->Tablesize;i++)
/*求不同的单词数量·/
diffwordcount+=H->Heads[i].Count;/*头结点 Count 统计链表长度·/
/*统计最大和最小冲突次数*
if(maxcollision<H->Heads[i].Count)
maxCollision=H->Heads[i].Count;
if(mincollision>H->Heads[i].Count)
minCollision=H->Heads[i].Count;
/*求最大的词频*/
L=H->Heads[i].Next;/*从每个链表的表头开始·/
while(L)I/*遍历链表*/
if(maxf<L->Count)maxf=L->Count;
L=L->Next;
|/*结束for循环*/
printf("共有8d个不同的单词，词频最大是td;\n",diffwordcount,maxf);
/*求每个词频等级拥有的不同单词数量·/
diffwords=(int·)malloc((maxf+1)·sizeof(int));
for(1=0:i<H->Tablesize;i++)
L=H->Heads[1].Next;
while(L)|/*遍历链表·/
diffwords[L->Count]++;/*该词频增加一个单词*/
L=L->Next;
printf("最大冲突次数是d,最小冲突次数是 td.n",maxcollision,mincollision);
/*根据最大的词频，分配一个整数数组·/
/*统计词频从1到maxf的单词数量*/
for(i-0;i<=maxf;i++)
diffwords[1]=0;
本 章 小结 195
/*求特定的词频，使得大于等于该词频的单词总和超过给定的比例·/
lowerbound=(int)(diffwordcount*percent);
for(i=maxf;i>=1& count<lowerbound;i--)
count+=diffwords[1];
*按词频从大到小输出单词*/
for(j=maxf;j>=i;j--)|/*对每个词频*/
for(k=0:k<H->TableSize;k++)|/*遍历整个散列表·/
L=H->Heads[k].Next;
while(L)1
if(j--L->Count)/发现一个单词的词频与当前词频相等*/
/*输出该单词及词频*/
printf("-15s:d\n",L->Data,L->Count);
L=L->Next;
free(diffwords);
代码5.15 显示词频超过给定的比例的所有单词
代码5.15值得讨论的是，最后一个for循环按词频从大到小输出单词，其效率是成问题的，
如果输入的文件很大而输出的百分比也不小的话，将花费较多的时间。读者可以用第7章排序
中介绍的方法，尝试改写这部分代码，使其对大数量输出时提高效率。当然，如果输出单词不需
要按照词频从大到小的顺序，那么可以省去最外层的 for 循环，并把语句“if(j==L->Count)”改
成"if(i<=L->Count)"即可成为高效的程序。
本 章 小 结
顺序查找、二分查找和树形查找等方法，由于数据对象的存储位置与其关键字之间不存在确
定的关系，因此，查找时，需要进行一系列对关键字的查找比较，即“查找算法”是建立在比较的
基础上的，查找效率由比较一次能够缩小多少查找范围来决定。而本章介绍的散列方法是依据
关键字直接计算得到其对应数据对象的位置，即要求关键字与数据元素间存在一定对应关系，通
过这个关系，能很快地由关键字得到对应的数据对象位置，这就是散列方法的思想核心。关键词
是字符串的时候，由于字符串比较过程较之于整型的地址比较需要花费更多的时间，所以散列方
法相对于其他查找方法有更好的查找效率。
196 第5章 散 列查 找
在合适的散列函数和装入因子下，散列法的查找效率是常数0(1),它几乎与查找空间的大
小n无关。这一点是非常诱人的。
另一方面，常数的查找时间复杂度不是无条件的。总的来说，它是以较小的装入因子α为
前提。因此，散列方法是一个以空间换时间的成功范例。
散列方法的两个基本内容是散列函数的构造与冲突的解决策略。
构造散列函数的原则是“计算简单”和“分布均匀”。对整数型的关键词，采用除留余数法是
比较好的方法，通常取除数为素数。对字符串关键词采用移位法是好的选择。
解决冲突的策略我们介绍了开放地址法和分离链接法。开放地址法的散列表是一个数组，
散列函数求得的地址对应数组下标。开放地址法相对于分离链接法而言有较高的存储密度和存
取效率。开放地址法的冲突解决方法又分成线性探测法、平方探测法和双散列法。使用这些方
法的两个要点是：避免或减少“聚集”现象；保证可以循环探测到每个地址。第一点主要考虑采
用“好”的散列函数和合适的探测法；第二点主要采用特定形式素数(4k+3)的散列表大小和特定
的双散列函数。
当装填因子过大时，我们可以通过再散列将数据重新分配到一张两倍大的散列表中去。不
过这个过程需要一次性花费较多的时间，对于一些实时性要求非常高的系统而言，宁可可以采用
不需要再散列的分离链接法。
分离链接法是把冲突的关键词链接成一个单链表，而所有的单链表的头结点构成的数组与
散列表地址对应。链表指针的存储和操作会付出一些空间和时间效率的代价。选择“不好”的
散列函数和太小的表头数组会导致有的单链表太长，而在单链表中的查找完全是顺序的，所以长
的单链表将严重影响效率。
分离链接法的装入因子α定义为这些单链表的平均长度。太小的装入因子α可能导致较
多的空间浪费，较大的装入因子α又将付出更多的时间代价。选择(2≤α≤5)或将是比较好的
折中。
另外，开放地址法中删除数据对象需要做临时的“懒惰删除”,等待有插入时或者进行再散
列时再行处理。这样散列表中会有部分“垃圾”影响空间和时间效率。而分离链接法中删除数
据对象不需要特别处理，从而也不会存在这样的“垃圾”,所以需要做频繁插入和删除操作的散
列表可以首先考虑使用分离链接法。
散列方法的存储是随机的，它不便于顺序查找，比如例5.9中按词频大小次序输出单词，或
者按照单词的字母序输出单词都是比较麻烦的事情；它也不适合于范围查找，比如查找车价在
20万元到30万元的所有车型；同样它也不适合查找最大值、最小值等。
习 题
5.1 判断正误。
(1)在散列表中，所谓同义词就是被不同散列函数映射到同一地址的两个元素。
习题 197
(2)将10个元素散列到100 000个单元的哈希表中，一定不会产生冲突。
(3)若用平方探测法解决冲突，则插入新元素时，若散列表容量为质数，插入就一定可以成功。
5.2 填空题。
(1)假定有K个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，要进行的探测次数至
少为____。
(2)从一个具有N个结点的单链表中查找其值等于X的结点时，在查找成功的情况下，需平均比较
个结点。
5.3 用公式5.9计算一下你姓名的散列值是多少。假定你姓名的关键词是各个汉字的首拼音字母构成的
字符串，比如“张三"的关键词是“ZS”。
5.4 在例5.7中，如果最后还要插入关键词18,它应该插入到散列表的哪个位置?
5.5 设有一组关键宇|29,01,13,15,56,20,87,27,69,9,10,74|,散列函数为：H(key)=key ,采用线性
探测方法解决冲突。试在0到18的散列地址空间中对该关键字序列构造散列表，并计算成功查找的平均查找
长度。
5.6 设有一组关键字[29,01,13,15,56,20,87,27,69,9,10,741,散列函数为：h(key)=key ,采用平方
探测方法解决冲突。试在0到18的散列地址空间中对该关键字序列构造散列表。
5.7 设有一组关键字|92,81,58,21,57,45,161,38,117},散列函数为：h(key)=key ,采用下列双散列
探测方法解决第1次冲突：h(key)=(h(key)+i* h2(key))mod 13,其中h2(key)=(key mod 11)+1。试在0到
12的散列地址空间中对该关键字序列构造散列表。
5.8 已知线性表的关键字集合|21,11,13,25,48,6,39,83,30,96,108,散列函数h(key)=key 1,采用
分离链接法处理冲突，试给出散列表的结构，并计算该表的成功查找的平均查找长度。
5.9 将关键字序列17,8,30,11,18,9,14|散列存储到散列列表中，散列表的存储空间是一个下标从0开始
的一个一维数组。处理冲突采用线性探测法，散列函数为：h(key)=(key×3)mod TableSize,要求装入因子
为0.7。
5.10 试实现线性探测法的查找函数Find。
5.11 试实现分离链接法的删除操作函数Delete。
5.12 试修改代码5.15中的Show 函数，使得程序能输出文件中有多少个不同的单词。
5.13 利用5.6节介绍的方法和程序代码，调试实现一个完整的程序。该程序能够对一个英文文本文件
(最好达到数万单词),统计文件中所有不同单词的个数，以及词频最大的前10??单词。
第6章
图
6.1 引子
网络在我们的生活中随处可见，计算机网络、交通网络、电话网络、超文本链接，甚至人际关
系网络都将人们的日常生活高效地联接起来。不论是网络中的电缆、无线电通信线路，还是交通
中的道路，都能以多种方式连接事物。本章我们将看到并解决在各种网络图中许多有趣的问题。
假设某个山区县为了加快发展农村建设；决定实施公路村村通项目。该项目包括必要时对
已有公路的升级改造。但是资金是有限的，钱必须用在刀刃上。县长提出的要求是，如何能够用
最小的资金投入完成公路村村通项目。
我们来考虑相对小一点的范围，比如一个镇，如图6.1所示，共有十个村：卜家村(B)、陈家
村(C)、丁家村(D)、冯家村(F)、何家村(H)、李家村(L)、魏家村(W)、徐家村(X)、杨家村
田田田 m
魏
用同
田田
画 田
田回
0
le
圈
图6.1 一个山区乡镇的公路规划示意图
6.2 图的基本概念 199
(Y)、张家村(Z)。图6.1中村与村之间的道路是一个较长远的规划目标。有的邻村之间暂时
没有规划道路的原因可能是自然地理不适合建设道路。
由于资金的原因暂时不能建设所有的道路，但是公路村村通项目要求用最小的投入实现每
个村都能够有公路通达。那么应该选择建设哪些道路可以使这个投资最小呢?
你暂时回答不上来是很正常的。这一章要介绍一种非常有意思的数据结构——图，图的应
用非常广泛，我们日常生活中的许多问题都可以归结为图的问题。学完这一章，你就知道该如何
去解决公路村村通问题了。
当然，要准确描述这个问题，还需要给出每条规划公路的造价预算。图6.2就是给出了造价
预算的示意图，比如魏家村(W)到徐家村(X)的公路造价预算为8(万元)。这个问题将在6.5
节中详细讨论。
⑦ 5 8 ×
8 5
5
w) 7
B) 4 5
4
5/ 4 H
L 6 6
D
4 3
2 C
F 7
图6.2 公路规划及造价预算示意图
6.2 图的基本概念
图状结构是一种比树形结构更复杂的非线性结构。在树形结构中，结点间具有分支层次关系，
每一层上的结点只能和上一层中的至多一个结点相关，但可能和下一层的多个结点相关。树的关
系也叫做一对多关系。而在图状结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可
以是任意的。比如“朋友”关系是一种多对多的关系，因为我认识的朋友，他们之间可能也相互是朋
友。图的结构是任意两个数据对象之间都可能存在某种特定关系的数据结构。
为了以后陈述上的方便与准确，需要对图中涉及的许多术语给出明确的定义或约定。不过
这些术语不是随意取名的，只要你用心体会，它们其实还是比较有规律的。
6.2.1 图的定义和术语
1.图的定义
图(Graph)是由两个集合构成，一个是非空但有限的顶点集合V,另一个是描述顶点之间关
系——边的集合E(可以是)。因此，图可以表示为G=(V,E)。每条边是一顶点对(v,w)且v,
200 第6章 图
w∈V。通常用|V|表示顶点的数量，用|E|表示边的数量。
[例6.1]图6.2给出了一个图的示例，在该图中：
集合V=|B,C,D,F,H,L,W,X,Y,Z|,|V|=10;
集合E={(Z,B),(Z,W),(B,W),(B,L),(B,D),(D,L),(W,X),(W,L),(L,H),
(L,F),(X,H),(X,Y),(H,Y),(H,F),(H,C),(F,C),(Y,C)|,|E|=17。
关于图的定义，与以前的线性表和树比较，还有几点需要明确：
(1)在线性表中，一般叫数据对象为元素；在树中，将数据对象称为结点；而在图中，我们把
数据对象称作顶点(Vertex)。
(2)线性表中可以没有数据对象，此时叫空表；没有数据对象的树称为空树；而在图中，我们
至少要求有一个顶点，但边集可以是空。
2.图的相关术语
图的术语比树的术语要多得多，而且许多概念对于初学者来说难以一下子理解。如果阅读
本节太觉乏味，你可以初步了解一下后先进大后面小节的学习，在以后发现对某个术语不甚理解
的时候再回到本节来仔细琢磨就行了。
(1)无向图(Undirected Graphs):如图6.2、图6.3(a)所示的图叫无向图。无向图中顶点之
间的边(Edge)没有方向，即边(v,w)等同于(w,v)。用圆括号“()”表示无向边。边的起点w和
终点v次序并不重要。
[例6.2]对图6.3(a)来说，G?=(V?,E),其顶点集合V?=10,1,2,3|,边的集合E,=
I(0,1),(0,2),(0,3),(2,3)。
(2)有向图(Directed Graphs):如图6.3(b)所示的图叫“有向图”。有向图中顶点之间的所
有边都有方向，即边<v,w>不同于<w,D>。用尖括号“<>”表示有向边。有向边也称弧(Are)。弧
的“起点(弧头)"和“终点(弧尾)”的次序不能随意颠倒。在不会混淆的场合，有向边和无向边
都简称为“边”。
[例6.3]对图6.3(b)来说，G?=(V?,E?),其顶点集合V?={0,1,2,3,4|,边的集合E?=
|<1,0>,<2,0>,<0,2>,<2,1>,<4,2>,<1,3>,<3,4>]。
O ① 0 ①
② ③
② ③ ④
(a)无向图G? (b)有向图C?
图6.3 两种基本图
(3)简单图(Simple Graph):如果图中出现重边(即边的集合E中有相同的重复元素)或者
自回路边(即边的起点和终点是同一个顶点),就叫做非简单图，如图6.4所示。它们都不在要
讨论的范围，我们考虑的都是“简单图”。
6.2 图的基本概念 201
O ① O ①
② ③ ②
(a)重边图 (b)自回路图
图6.4 两种非简单图
(4)邻接点(Adjacent Vertices):如果(v,w)是无向图中任意一条边，那么称v和w互为邻接
点；如果<v,w>是有向图中任意一条边，那么称起点v“邻接到”(Adjacent to)终点w,也称终点w
“邻接自”(Adjacent from)起点v。比如，考察图6.3中的有向图G?,顶点2邻接到顶点1,或者说
顶点1邻接自顶点2。
(5)路径(Path)、简单路径(Simple Path)、回路(Cycle,也叫做“环”)、无环图(Acyclic
Graph):图中的一条路径是一顶点序列n?,D?,…,D,序列中任何相邻的两顶点都能在图中找到
对应的边，即(n,D+)∈E(I≤i<N)。一条路径的长度是这条路径所包含的边数。比如，考察图
6.3中的无向图G?,顶点序列1,0,2,3是从顶点1到顶点3的一条路径，该路径长度是3。
一条简单路径是指除了路径的首尾顶点外，其余顶点都是不同的。
有向图中的一条回路是指v?=v的一条路径。路径长度为1的回路是一个自回路(属于非
简单图)。简单路径形成的回路称为简单回路(Simple Cycle)。
如果在一个有向图中不存在回路，那么这个有向图称为无环图。比如，考察图6.3中的有向
图G?,它有3个简单回路：[0,21、10,2,1,0和/2,1,3,4,2|;回路|3,4,2,1,0,2,1,3|不是简单
回路。
对于无向图，由于顶点是无序的，环路的长度要大于等于3。比如路径u,v,u不会是一条环
路，因为(u,v)和(v,u)是同一条边，它是重边图，不属于讨论之列。
(6)无向完全图(Undirected Complete Graph):在一个无向图中，如果任意两顶点都有一条边相连
接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，共有n(n-1)/2条边。
(7)有向完全图(Directed Complete Graph):在一个有向图中，如果任意两顶点之间都由方
向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，共
有n(n-1)条弧。
(8)顶点的度(Degree)、入度(In-degree)、出度(Out-degree):顶点v的度是指依附于该顶点的边
数。在有向图中，顶点的度还要分为人度与出度。顶点v的人度是指以顶点v为终点的弧的数目；顶
点v的出度是指以顶点o为起点的弧的数目。有Degree(o)=In-degree(n)+ Out-degree(v)。
[例6.4]在图6.3(a)中的G?有：Degree(0)=3;Degree(1)=1;Degree(2)=2;Degree(3)=2。
在图6.3(b)中的G?有：
In-degree(0)=2;0ut-degree(0)=1;Degree(0)=3;
In-degree(1)=1;Out-degree(1)=2;Degree(1)=3;
In-degree(2)=2;0ut-degree(2)=2;Degree(2)=4;
202 第6章 图
In-degree(3)=1;Out-degree(3)=1;Degree(3)=2;
In-degree(4)=1;Out-degree(4)=1;Degree(4)=2。
可以证明，对于具有n个顶点、e条边的图(不论是有向图还是无向图),每个顶点v,的度
Degree(v,)与顶点的个数n以及边的数目e满足关系：
e=(Degree(v,))/2=Aln-degree(u)=Out-degre(e) (公式6.1)
(9)稠密图(Dense Graph)、稀疏图(Sparse Graph):若一个图的边数接近完全图的边数，称这
样的图为稠密图；相对地，称边数很少的图为稀疏图。通常，设图G=(V,E),如果边的数量为|E|,
顶点的数量为|V|,一个图的稠密度(Density)定义为平均顶点度2|E|/|V|,显然，对于完全图
来说，平均顶点度应该是|V|-1。由2|E|/|V|=|VI-1,可知，|E|=(|V|-1)|V[/2。
类似地，我们把稠密图定量定义成“平均顶点度与顶点数量|V|成正比的图”,由2|E|/|V|=
k|V|(0<k<1),可知，|E|=k|V|2(0<k<1/2)。对一个具体的图来说，当然这里的k不能
太小，比如取k>1/8。有的教材也用是否满足-|E|>.|V| log?|V|,作为稠密图和稀疏图的分
界条件。
(10)权(Weight)、网图(Network):根据需要边可以附带一个数值信息，通常称这个信息为
权或代价(Cost)。在实际应用中，权值可以有某种含义。比如，在一个反映城市交通线路的图
中，边上的权值可以表示该条线路的长度、造价或者等级；对于一个电子线路图，边上的权值可以
表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示边
代表的工作所需要的时间等。边上带权的图称为网图。如图6.2所示的公路规划及造价预算示
意图，就是一个无向网图。如果边是有方向的带权图，则就是一个有向网图。在不会引起混淆的
时候，为了简便起见，网图也简称为图。
(1I)子图(Subgraph):对于图G=(V,E)和G'=(V',E'),若满足V'是V的子集，并且E'是E
的子集，则称图G'是G的一个子图。
[例6.5]图6.5示出了G?和G?的三个子图G、G"和G"(i=1,2)。
O ① ◎ O ① O ①
② ③ ② ③ ② ③
(a)无向图G? (b)Gi (c)Gi (d)Gi
O ① ①
③ O ① ② ③ ④ ③ ④ ② ④
(e)有向图C? fC? (g)Gz (h)G2
图6.5 子图示例
6.2 图的基本概念 203
(12)连通图(Connected Graph)、连通分量(Connected Component):在无向图中，如果从一个
顶点v,到另一个顶点p;(i≠j)有路径，则称顶点v,和v,是连通的(Connected)。如果图中任意两顶
点都是连通的，则称该图是连通图。无向图的极大连通子图称为连通分量。连通分量的概念包
含以下4个要点：
●子图：连通分量应该是原图的子图；
● 连通：连通分量本身应该是连通的；
● 极大顶点数：连通子图含有极大顶点数，即再加入其他顶点将会导致子图不连通；
● 极大边数：具有极大顶点数的连通子图包含依附于这些顶点的所有边。
因此，连通的无向图只有一个连通分量，这个连通分量就是本图。比如，图6.3中的无向图
C?的连通分量就是C?本身。不连通的无向图有多于一个的连通分量。
[例6.6] 如图6.6,其中无向非连通图C?有两个连通分量，如图6.6(b)、6.6(c)所示，而图
6.6(d)虽然也是6.6(a)的子图，并且是连通的，但是6.6(d)没有达到极大的顶点数，所以6.6
(d)不是G?连通分量。
A B A B A
B(E FD
E
C
F
C D C
(a)无向图G? (b) (c) (d)
图6.6 无向图及连通分量
(13)强连通图(Strongly Connected Graph)、强连通分量(Strongly Connected Component):对
于有向图来说，若图中任意一对顶点v,和v,(i≠j)均既有从v,到v,的路径，也有从v,到v的路径，
则称该有向图是强连通图。有向图的极大强连通子图称为强连通分量。
强连通分量的概念与连通分量类似，也包含4个要点。图6.3中有向图G?是强连通图(任
意两个顶点都存在来回双向路径，请读者自行验证),所以G?本图就是一个强连通分量。不是强
连通的有向图有多于一个的强连通分量。
[例6.7]如图6.7,其中有向非强连通图G?有两个连通分量，如图6.7(b)、6.7(c)所示，而
图6.7(d)既不是6.7(a)的子图，也不是强连通的，所以6.7d)不是G的强连通分量。
A D A A
B
① B B
(a)有向图G4 (b) (c) (d)
图6.7 有向图G?的两个强连通分量
204 第6章 图
(14)生成树(Spanning Tree):所谓连通图G的生成树，是G的包含其全部n个顶点的一个
极小连通子图。它必定包含且仅包含G的n-1条边。图6.8中连通图G?有4个顶点，任何包含
这全部4个顶点的有3条边的连通子图都是G?的生成树。显然，生成树有可能不唯一。
O ① O ① O ① O ①
② ③ ② ③ ② ③ ② ③
(a)G? 6G (c)G?" (d)G?"
图6.8 G,及其生成树
有n个顶点的图，如果边的数量小于n-1,那么它必定是不连通的，所以 n-1是连通图所需
的“极小”的边的数量。而多于n-1条边的图必将产生回路，它就不是树了，因为树中是没有回
路的。由此可见，图G是一棵树，当且仅当G满足下面4个条件之一：
·G有n-1条边，且没有环；
·G有n-1条边，且是连通的；
● G中的每一对顶点有且只有一条路径相连；
·G是连通的，但删除任何一条边就会使它不连通。
对有向图来说，生成树应该是一棵有向树。如果一个有向图恰有一个顶点的入度为0,其余
的顶点入度为1,则它就是一棵有向树(Directed Tree)。对有向树的理解并不难，入度为0的顶
点就是树的根，其余顶点入度为1表示非根结点只有一个父结点。
(15)生成森林(Spanning Forest):在非连通图中，由于每个连通分量都是一个极小连通子
图，即一棵生成树可以对应一个连通分量。对应各个连通分量的各棵生成树就组成了一个图的
生成森林。对无向图而言，一个图的生成森林中树的数量就等于它的连通分量数。
对有向图来说，一个强连通分量当然可以得到对应的生成树(不唯一);但是，非强连通图也
可能只需用一棵生成树(有向树)与之对应。
[例6.8]如图6.9所示，图6.9(a)有2个强连通分量，而6.9(b)、6.9(c)或者6.9(d)
中的任意一棵树都是6.9(a)的生成树。所以生成森林中树的数量可能会少于强连通分
量数。
A D A D A D A ①
B B C B B
(a)有向图G? (b)顶点A为根 (c)顶点B为根 (d)顶点C为根
图6.9 非强连通有向图G.的生成树
6.3 图的存储结构 205
6.2.2 图的抽象数据类型
对图的构成及其特性了解以后，现在可以给出图的抽象数据类型，其描述为：
类型名称：图(Graph)。
数据对象集：一非空的顶点集合Vertex和一个边集合 Edge,每条边用对应的一对顶点
表示。
操作集：对于任意的图G∈Graph,顶点VeVertex,边EeEdge,以及任一访问顶点的函数
Visit(),我们主要关心下列操作：
(1)Graph CreateGraph(int VertexNum):构造一个有VertexNum个顶点但没有边的图；
(2)void InsertEdge(Graph G.Edge E):在G中增加新边E;
(3)void DeleteEdge(Graph G,Edge E):从G中删除边E;
(4)bool IsEmpty(Graph G):如果图G为空，返回 true,否则返回false;
(5)void DFS(Graph G,Vertex V,(*Visit)(Vertex)):在图G中，从顶点V出发进行深度优
先遍历；
(6)void BFS(Graph G,Vertex V,(·Visit)(Vertex)):在图G中，从顶点V出发进行广度优
先遍历。
与图相关的操作还有很多，这里我们只列出最常见的几个，在后面一一讨论。
6.3 图的存储结构
图是一种结构复杂的数据结构，主要表现在逻辑上任意顶点之间都可以存在特定关系。而
这些顶点位置和边的次序可以有某种随意性。比如图6.10中的4个图表示的是同一个逻辑
问题。
在顶点和边的数量不多的时候，比如教材上给出的所有示意图，画在纸上我们可以一目了然
图的结构和边上的信息。但是当顶点和边的数量达到几十、几百、几千的时候，我们就很难看清
楚这些关系了，更何况计算机没有我们的“慧眼”。那么如何把图的所有信息完整地存储在计算
机中，并可以方便地存取和修改呢?
从图的定义可知，一个图的信息包括两部分，即图中顶点的信息以及描述顶点之间的关
系——边或者弧的信息。因此无论采用什么方法建立图的存储结构，都要完整、准确地反映这两
方面的信息。
下面介绍几种常用的图的存储结构。
206 第6章 图
G H)
B C
F
A D
C D H G
E
B A E F
(a) (b)
B
A D G H
E F A
H G
E
B D
E
(c) (d)
图6.10 4个等价的图
6.3.1 邻接矩阵
所谓邻接矩阵(Adjacency Matrix)的存储结构，就是用矩阵表示图中各顶点之间的邻接关系
和权值。假设图Graph=(V,E)有n个确定的顶点，即V=|to,D?.…,v.1,则表示Graph 中各顶
点相邻关系为一个n×n的矩阵G,矩阵的元素为：
cu-{。(,)或>不是EGmsp)中的边
若Graph是网图，则邻接矩阵可定义为：
若(v,)或<D,,B>是E(Graph)中的边
C[i们={0或若(v,v,)或<0;>不是E(Craph)中的边
其中，w,表示边(v,D)或<v?,D,>上的权值。在有权值的图中，因为0可能被误认为是权值，所以
有时用○表示没有边。∞表示一个计算机允许的、大于所有边上权值的数。
[例6.9]图6.11左边所示的无向图的邻接矩阵列于在右边。从图6.11可以看出，无向图
对应的邻接矩阵必定是对称矩阵(回忆一下，对称矩阵在《线性代数》中是怎么定义的?
G[i][i]=G[j][i])。C[0][1]=1表示(vo,v,)是图的一条边；而G[0][2]=0表示图中不存在
(vo,v?)这条边。主对角线上的元素必定为0,因为不存在自回路顶点。。顶点的度就是对应行
(或对应列)中1的元素个数。
6.3 图的存储结构 207
o
O o0
2
00 v?的度为2
G:1 1011
②
v2
v?
主对角线
图6.11 一个无向图的邻接矩阵表示
[例6.10]图6.12左边所示的无向网图的邻接矩阵表示法列在右边。从图6.12可以看
出，有向图对应的邻接矩阵可以是不对称的(一定是不对称的吗?否!)。主对角线上的元素也
必定为∞(或0)。G[3][1]=5表示<3,1>是图的一条边(弧);而G[3][2]=0表示图中不存
在<3.2>这条边(弧)。顶点3的出度=2就是对应第3行中非的元素个数是2。
0 2
O
9 6
0 6 3 o
① 3
4 ② G:
1
2
9
5
7
3 可
③
8
ni 8 出度(3)=2
④ 4 \ 6
6 入度(1)=1 主对角线
图6.12 一个有向网图的邻接矩阵表示
从图的邻接矩阵存储方法容易看出这种表示具有以下特点。
(1)无向图的邻接矩阵一定是一个对称矩阵。因此，在具体存放邻接
矩阵时只需存放上(或下)三角矩阵的元素即可。所需存储元素的个数是
|V|×(|V|-1)/2。
(2)对于无向图，邻接矩阵的第i行(或第i列)非0元素(或非0元 无向图邻接 素)的个数正好是第i个顶点的度Degree(v?)。 矩阵的存储
微视频6-1
(3)对于有向图，邻接矩阵的第i行(或第i列)非0元素(或非元素) 技巧
的个数正好是第i个顶点的出度Out-degree(v,)(或入度In-degree(v,))。
(4)用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否
有边相连，只需考察邻接矩阵对应的元素即可；确定一个顶点的所有邻接点，也只需邻接矩阵对
应的一行(或一列);但是，要确定图中有多少条边，则必须按行(或按列)对每个元素进行检测，
所花费的时间代价是θ(|V|2)。这是用邻接矩阵来存储图的局限性。
下面介绍图的邻接矩阵存储的C语言描述。
在用邻接矩阵存储图时，除了用一个二维数组存储表示顶点间相邻关系的邻接矩阵外，还需
用一个一维数组来存储顶点信息，另外还有图的顶点数和边数。故可将其形式描述如下：
如代码6.1所示，最大顶点数MaxVertexNum暂设为100,可以根据需要更改。顶点数据类
208 第6章 图
微视频6-2
型DataType设为字符型，这也是为了简单起见，事实上关于顶点的信息可
以很多，一般应使用一个struct类型来描述。边的权值类型WeightType一
般为整型，但必须注意区分合法权值和无边的表示值(0或或负数，根据
应用选择特别的约定)。顶点类型Vertex 被定义为整型，意即用顶点的下
标代表顶点(所以当我们提到顶点i的时候，就指的是v,)。 邻接矩阵表 MGraph是邻接矩阵存储的图类型，它是指向图结点的指针。我们把这 示法的结构
两个类型都定义成指针，是为了传递函数参数的方便。图结点不仅包含图 和类型声明
的顶点数Nv和边数Ne,还有一个二维数组G存储邻接矩阵，一个一维数组
Data存储顶点数据，它们的大小都采用MaxVertexNum固定值。采用固定
大小的数组可能会导致比较大的空间浪费，实际上，最好根据问题的大小(顶点数Nv)动态分配
它们的大小。这件事情作为练习留给读者去尝试完成。
/* 最大顶点数设为100/ fdefine MaxVertexNum 100
/*设为双字节无符号整数的最大值65535*/
/ 图结点的定义·
typedef struct GNode*PtrTOGNode;
int Nv;顶点数·/
WeightType G[MaxvertexNum][ MaxvertexNum];/* 邻接矩阵*/
/* 注意：若顶点无数据，此时 Data[]可以不用出现·
I:
typedef ptrToGNode MGraph;以邻接矩阵存储的图类型+
#define INFINITY 65535
/* 用顶点下标表示顶点，为整型*/
struct GNodel
int Ne;/ 边数*/
DataType Data[MaxVertexNum];/* 存顶点的数据·/
typedef int Vertex;
/* 边的权值设为整型*/ typedef int WeightType;
/ 顶点存储的数据类型设为字符型/ typedefchar DataType;
代码6.1 邻接矩阵表示法的结构和类型声明
有了图的结构与类型定义，代码6.2通过先创建一个包含全部顶点但没有边的图，再逐条插
入边，从而创建了一个无向网图的数据对象。其中Edge是边的类型，边结构中包含两个端点V1
和V2,还有边的权重Weight。Edge是指向这个结构的指针。
该程序所需的时间复杂性和空间复杂性都是0(Nv2)。
/* 边的定义 */
typedef struct ENode·PtrTOENode;
struct ENodel
6.3 图的存储结构
/*有向边<V1,V2>* Vertex V1,V2;
WeightType Weight;/·权重·/
I;
typedef PtrTOENode Edge;
MGraph CreateGraph(int VertexNum)
1/初始化一个有VertexNum个顶点但没有边的图
VertexV,W;
MGraph Graph:
Graph=(MGraph)malloc(sizeof(struet CNode));人建立图*/
Graph->Nv=VertexNum;
Graph->Ne=0;
/* 初始化邻接矩阵*/
/* 注意：这里默认顶点编号从0开始，到(Graph->NV-1)*/
for(V=0; V<Graph->NV;V++)
for(W=0;W<Graph->NV;W++)
Graph->G[v][W]=INFINITY;
return Graph;
void InsertEdge(MGraph Graph,Edge E)
/* 插人边<V1,V2>*/
Graph->G[E->V1][E->V2]=E->Weight;
/若是无向图，还要插入边<V2,V1>*/
Graph->G[E->V2][E->V1]=E->Weight;
MGraph BuildGraph()
MGraph Graph;
Edge E;
Vertex V;
int Nv,i;
scanf("d",NV);/* 读入顶点个数·/
209
微视频6-3
邻接矩阵表
示法：图的初
始化
微视频6-4
邻接矩阵表
示 法：图的
创建
210 第6章 图
Graph=CreateGraph(Nv);/* 初始化有Nv个顶点但没有边的图*∠
scanf("td",6(Graph->Ne));/* 读入边数·/
if(Graph->Ne !=0)|/* 如果有边*/
E=(Edge)malloc(sizeof(struct ENode));/* 建立边结点*/
/* 读入边，格式为"起点 终点 权重",插入邻接矩阵·
for(i=0;i<Graph->Ne;i++)|
scanf("?d td",E->V1,&E->V2,&E->Weight);
/* 注意：如果权重不是整型，Weight的读入格式要改*/
InsertEdge(Graph,E);
/如果顶点有数据的话，读入数据*/
for(V=0;V<Graph->Nv; V++)
scanf("c",&(Graph->Data[V]));
return Graph;
代码6.2 邻接矩阵表示——无向网图的初始化程序
邻接矩阵是一种表示各类图的简洁的数据结构。但是我们发现，不论图中的边的数量多或
少，我们都花费了◎(Nv2)(即O(|VI2))的存储空间，这对于稠密图来说是一种高效的方法。
但是如果我们面对的是一个稀疏图，则邻接矩阵中大多数项为0(或四),形成了所谓的稀疏矩
阵，就会浪费许多空间。同时，有些操作也会经常访问邻接矩阵中0(或)代表的无效元素，这
也会浪费许多时间。
为了解决这些浪费问题，我们考虑另外一种存储结构。回忆我们在线性表时曾说过，顺序存
储结构需要事先分配连续内存，这就可能造成空间浪费的问题，于是引出了链式存储的思路，同
样，这里也可以对边或弧采用链式存储来减少空间浪费的问题。这就是下面一小节要讨论的邻
接表存储结构。
6.3.2 邻接表
邻接表(Adjacency Lists)是图的一种顺序存储与链式存储结合的存储方法。邻接表表示法
类似于树的孩子链表表示法。就是对于图G中的每个顶点v,,将所有邻接于v?的顶点v,链成一
个单链表，这个单链表就称为顶点v,的邻接表，再将所有点的邻接表表头放到一个数组中，就构
成了图的邻接表。在邻接表表示中有两种结点结构，如图6.13所示。
6.3 图的存储结构 211
一种是顶点表的结点结构，它由顶点数据域(Data)和指向第一条邻接边的指针域
(FirstEdge)构成，另一种是边表(即邻接表)结点，它由邻接点域(AdjV)和指向下一条邻接边的
指针域(Next)构成。对于网图的边表需再增设一个存储边上信息(如权值等)的域(Weight),网
图的边表结构如图6.14所示。图6.15给出无向图6.11 对应的邻接表表示。
顶点域 边表头指针 邻接点城 指针城
Data FirstEdge AdjV Next 邻接点域 边上信息 指针域
(a)顶点表 (b)边表
图6.13 邻接表表示的结点结构
AdjV Weight Next
图6.14 网图的边表结构
序号 Data FirstEdge
0
1
0
1 3 A
1 0 2 3 A
微视频6-5
2 2 1 入 邻接表表示
3
法的结构和 3 0 1 类型声明
图6.15 图6.11的邻接表表示
邻接表表示的图结构和类型声明由代码6.3给出。图的初始化过程由代码6.4给出。
/*最大顶点数设为100*/ #define MaxVertexNum 100
/ 边的定义*/
typedef struct ENode+PtrTOENode;
Vertex V1,V2; /·有向边<V1,V2>/
WeightType Weight;/权重*/
I:
typedef PtrTOENode Edge;
/邻接点的定义*/
typedef struct AdjVNode·PtrTOAdjVNode;
struet AdjVNodel
Vertex AdjV; /· 邻接点下标*/
/·用顶点下标表示顶点，为整型*/ typedef int Vertex;
struct ENodel
/* 边的权值设为整型·/ typedef int WeightType;
/顶点存储的数据类型设为字符型* typedef char DataType;
212 第6章 图
WeightType Weight;/* 边权重·/
PtrToAdjVNode Next;/* 指向下一个邻接点的指针*/
1;
/*顶点表头结点的定义 */
typedef struct Vnodel
PtrTOAdjVNode FirstEdge;/*边表头指针·/
DataType Data; / 存顶点的数据*/
/* 注意：很多情况下，顶点无数据，此时 Data可以不用出现*/
IAdjList[ MaxVertexNum]; / AdjList是邻接表类型·/
/* 图结点的定义*/
typedef struct GNode *PtrTOGNode;
struct GNodel
int Nv;/· 顶点数*/
int Ne;/* 边数
AdjList G;/ 邻接表*/
1;
typedef PtrTOGNode LGraph;/·以邻接表方式存储的图类型/
代码6.3 邻接表表示法的结构和类型声明
LGraph CreateGraph(int VertexNum)
1/* 初始化一个有VertexNum个顶点但没有边的图*/
Vertex V;
LGraph Graph;
Graph=(LGraph)malloc(sizeof(struct GNode));八建立图·/
Graph->NV=VertexNum;
Graph->Ne=0;
初始化邻接表头指针*/
/*注意：这里默认顶点编号从0开始，到(Graph->Nv-1)*
for(V=0:V<Graph->NV;V++)
Graph->G[v].FirstEdge=NULL;
return Graph;
void InsertEdge(LGraph Graph,Edge E)
6.3 图的存储结构 213
PtrTOAdjVNode NewNode;
/*插入边<V1,V2>*/
NewNode=(PtrTOAdjVNode)malloc(sizeof(struct AdjVNode));
NewNode->Next=Graph->G[E->V1].FirstEdge;
八 若是无向图，还要插入边<V2,VI>*/
/ 为V1建立新的邻接点*/
NewNode=(PtrTOAdjVNode)malloc(sizeof(struct AdjVNode)):
NewNode->AdjV=E->V1;
NewNode->Weight=E->Weight;
·将V1插入V2的表头/
NewNode->Next=Graph->G[E->V2].FirstEdge;
Graph->G[E->V2].FirstEdge=NewNode;
LGraph BuildGraph()
LGraph Graph;
Edge E;
Vertex V;
int Nv,i;
scanf("8d",&Nv);/* 读人顶点个数·/
scanf("Bd",(Graph->Ne));/* 读入边数*/
if(Graph->Ne !=0)/ 如果有边*/
E=(Edge)malloc(sizeof(struct ENode));/* 建立边结点*/
scanf("d d d",&E->V1,&E->V2,6E->Weight);
/* 为V2建立新的邻接点*/
NewNode->AdjV=E->V2;
Graph->G[E->V1].FirstEdge=NewNode;
Graph=CreateGraph(Nv);/*初始化有Nv个顶点但没有边的图*/
/* 读入边，格式为“起点 终点 权重”,插人邻接矩阵*/
/ 注意：如果权重不是整型，Weight的读入格式要改*/
NewNode->Weight=E->Weight;
for(i=0;i<Graph->Ne;i++)
InsertEdge(Graph,E);
/* 将V2插入V1的表头*/
214 第6章 图
/· 如果顶点有数据的话，读入数据*/
for(V=0;V<Graph->Nv;V++)
scanf("Bc",&(Graph->G[V].Data));
return Graph;
代码6.4 邻接表表示——无向图的初始化程序
若无向图中有|V|个顶点和|E|条边，则它的邻接表需|V|个头结
点和2|E|个表边结点。显然，在边稀疏(|E|<< |V|(|V|-1)/2)的
情况下，用邻接表表示图比邻接矩阵节省存储空间，当和边相关的信息较多
时更是如此。
微视频6-6 在无向图的邻接表中，顶点v,的度恰为第i个链表中的结点数；而在
邻接表表示 有向图中，第i个链表中的结点个数只是顶点v?的出度，但是求入度就很 法：图的创建
不方便，必须遍历整个邻接表，在所有链表中其邻接点域的值为i的结点
的个数是顶点v,的入度。有时，为了便于确定顶点的入度或以顶点v,为头的弧，可以建立一个
有向图的逆邻接表，即对每个顶点v,建立一个链接以v,为头的弧的链表。
[例6.11] 例如图6.16给出了(a)中有向图G?的邻接表(b)和逆邻接表(c)。
A D
0 A 3 1A 0 A 2 A
1 B 2 △ 1 B 0 入
2 C 0 A
B
2 C 1 A
3 D 入 3 D 0 A
(2)有向图G. (b)邻接表 (c)逆邻按表
图6.16 有向图C,及其邻接表和逆邻接表
在建立邻接表或逆邻接表时，若输人的顶点信息为顶点的编号，则建立邻接表的复杂度为
0(|V|+|E|),否则，需要通过查找才能得到顶点在图中位置，时间复杂度为0(|v·|El)。
在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个顶点n?
和p,之间是否有边或弧相连，则需搜索第i个或第j个链表，因此，不及邻接矩阵方便。
6.4 图的遍 历 215
6.4 图的遍历
6.4.1 迷宫探索
在3.5.2节中，我们讨论了一个简单的迷宫问题。这里我们将讨论另外一个更灵活的版本，
这里的迷宫不一定是由方格子组成，虽然我们仍然假设它的通道都是直的，而通道所有交叉点
(包括通道的端点)上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有
的灯并回到起点?比如，你将以什么样的策略，走遍图6.17所示迷宫的所有通道的交叉点(顶点
0~7)?
0 2 0 ②
6 ⑥ ① 7 ① ⑦
3 ③
5 4 ⑤ ④
(a) (b)
图6.17 一个点灯迷宫及其对应的图
虽然，在一些特殊的简单的迷宫中，采用诸如“保持右手靠墙”的简单策略就可以解决问题，
如图6.18(a)所示的迷宫，但是如果在有些迷宫(如图6.18(b)所示)中，这种策略将可能永远达
不到目的，因为你可能在其中的一个环中无休止地绕圈。
(a) (b)
图 6.18 探索迷宫
当我们到达的通道端点如果已经亮着灯，表明曾经来到过这里，这在规则上是允许的。同样
曾经走过的通道还是可以重复走。
216 第6章 图
为了设计一个策略来解决这个问题，并且在叙述上更加直观，我们暂时用术语“迷宫”而不
是“图",“通道”而不是“边”,“交叉点”而不是“顶点”。
自古以来，我们就知道探索迷宫而不迷路的技巧，就是用一个线球的线跟在我们身后，这根
线除了可以保证我们总能找到出口，还可以记住最先是从哪个通道来到这个交叉点的，以便在探
索了该交叉点的所有通道以后，沿着这根线退回原先过来的通道。我们始终心怀一个目标，就是
探索迷宫的每个交叉点(点亮所有灯),但除非万不得已，我们并不想走回头路。为了达到这些
目标，就需要用一些方法来标记到过的地方。以下的描述更接近为计算机实现建模。
假设每个交叉点都有灯，开始时所有灯都是关着的，另外，每个通道的两端都有门，开始时也
是关着的，并约定我们需要打开门才能观察通道的另一端是否亮着灯。进一步假设这些门都有
玻璃窗户，通道的另一端并不需要开着门，我们也能从这一端看见另一端的灯是否亮着。我们的
目标是打开所有的灯和所有的门。
基于这些假设，以下的迷宫探索策略就变得容易理解，这个策略被称为Tremaux 探索，至少
从19世纪以来就为人们所知了，算法描述如下：
(1)如果在当前的交叉点还有关着的门，则打开其中的任何一扇门(并使该门一直开着，记
住我们已经探索过该通道),并转向第2步；否则转向第3步。
(2)如果你看到通道另一端的交叉点已经亮着灯，则尝试当前交叉点的另一扇门(转向第1
步);否则，沿着该通道走到另一端，边走边放线绳，开灯，再转向第1步。
(3)如果当前交叉点的所有门是打开的，则检查是否回到了起点，如果是，则结束算法；否
则，利用线绳返回到首次带你到该交叉点通道上，边走边收线绳，退回到交叉点，再转向第1步。
[例6.12]图6.19描述了遍历一个简单迷宫的过程。这些图只是显示了很多可能的探索中
的一种，因为我们可以随意地按照任意顺序打开一个交叉点上的多个关着的门。放绳的方法是一
种高效的方法。从该例子还可以得知，对于我们考虑选取的每个通道，会出现4种可能的情况：
(1)通道是暗的，所以选择该通道；
(2)该通道曾经进去过(其中有我们的线绳),因此利用它退出(同时卷起线绳):
(3)通道另一端的门是关着的(但交叉点的灯是亮着的),因而跳过(不选择)该通道；
(4)通道另一端的门是开着的(并且交叉点的灯是亮着的),因此跳过该通道。
从交叉点0出发，图6.17所示的迷宫的Tremaux 探索(遍历)过程如图6.19所示。先点亮
入口交叉点0的灯，它有三个通道可以选择，因为这三个通道门都不曾打开，为了简单起见，我们
总是选择到达交叉点编号小的先打开，因为通道是暗的，所以选择通往交叉点2的通道(情况
1),到达2并点亮灯；下一步没有其他选择，打开通往交叉点6的通道，到达6并点灯；同样道理，
接着到达交叉点4并点灯；我们的线绳也到达交叉点4。
交叉点4可以到达的并且通道没有开门的交叉点(邻接点)有3、5和7(6是刚刚放线绳过
来的通道，不考虑，除非在回退的时候),选择最小编号3。因为通道是暗的，所以选择通往交叉
点3的通道(情况1),到达3并点亮灯；下一步没有其他选择，打开通往交叉点5的通道，到达5
并点灯；我们的线绳也到达交叉点5。
6.4 图的 遍 历 217
0 2 0 2 0 2 O 2
6 6 6
3 ③
M
① 7
3
51 ④ 5 4 5 4
0 2 0 2 0 2 0 2
6 6 6 6
7 ① 7
3 3
5 ④ 5 4 5 4
0 2 0 2 0 2 ◎ 2
6 6 6 6
17 ① 7
3 ③ 3
5 ④ 5 4 5 4
0 -2 0 2 0 2 0 2
6 6 6 6
① 7 ① 7
③ ③ 3 3
5 ④ 5 4 5 4
0 2 0 2 0 2 0 2
6 6 6 6
1 7 7
3 3 3× 3
5 ④ 5 4 5 4 5 4
图6.19 Tremaux探索迷宫示例
交叉点5可以到达的并且通道没有开门的邻接点有0和4(3是刚刚放线绳过来的通道，不
考虑，除非在回退的时候),先打开通往小编号0的通道门，发现交叉点0的灯是亮着的，因而跳
过该通道(情况3);再打开通往交叉点4的通道门，发现交叉点4的灯是亮着的，因而跳过该通
218 第6章 图
道(情况3)。此时已经无路可走，只好沿着通往3通道退回到3(情况2);同样再退回到4(情况
2)。线绳也退回卷起。
回到交叉点4,还有通往交叉点5和7的通道门没有打开，先打开通往5的通道门，发现通道
另一端的门是开的并且交叉点5的灯是亮着的，因而跳过该通道(情况4)。再打开通往交叉点7
的通道门，因为通道是暗的，所以选择通往交叉点7的通道(情况1),到达7并点亮灯；再打开通
往交叉点0的通道门，发现交叉点0的灯是亮着的，因而跳过该通道(情况3);接着打开通往交
叉点1的通道门，发现通道是暗的，所以选择通往交叉点1的通道(情况1),到达1并点灯，线绳
也到达交叉点1。
从交叉点1退回到交叉点7,并收回线绳。此时站在交叉点7上，发现已经没有未打开的通
道门，根据算法，此时要判断7是否就是起点，不是的话沿着线绳退回到交叉点4(情况2)。同
样，沿着线绳，依次退回到交叉点6、2直到交叉点0。
交叉点0还有通往5和7的两个通道的门没有打开，先打开通往5的通道门，发现通道另一
端的门是开的并且交叉点5的灯是亮着的，因而跳过该通道(情况4);再打开通往7的通道门，
发现通道另一端的门也是开的并且交叉点7的灯是亮着的，因而跳过该通道(情况4)。于是，发
现已经没有未打开的通道门，根据算法，此时要判断0是否就是起点，果真如此，算法结束。
综上所述，交叉点点灯的次序为0-2-6-4-3-5-7-1,这就是所谓的图的顶点的“遍历次
序”。
如果这个迷宫探索的例子改用图的术语，实际上就是图6.17(b)从顶点0出发的“深度优先
遍历”。迷宫就是图，通道就是边，交叉点就是顶点。交叉点通往相邻交叉点的通道的门的打开
与否用来记录该边是否已经考虑过。交叉点的灯点亮了表示该顶点已经访问过了，从而不需要
再次访问。线绳的作用是在没有新的通道可以探索的时候，可以顺利退回到上次过来的交叉点，
而不至于迷路。在深度优先搜索的非递归算法中，通常用一个堆栈来记录一路走来的交叉点，因
为回退的次序是按“后来先退”,刚好符合栈的操作特点。不过，深度优先搜索的算法用递归显
得更简单。
“图的遍历”是指从图中的任一顶点出发，对图中的所有顶点访问一次且只访问一次的次序
序列。对应迷宫探索的问题就是点亮一次各个交叉点的灯，输出点灯次序序列。图的遍历是图
的一种基本操作，图的许多其他操作都是建立在遍历操作的基础之上。
6.4.2 深度优先搜索
深度优先搜索(Depth First Search,DFS)类似于树的先序遍历，是树的先序遍历的推广。上
一小节的迷宫探索就是对迷宫图的深度优先遍历。
假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点v?出发，访问
此顶点，然后依次从v。的未被访问的邻接点出发递归地进行同样的深度优先搜索，直至图中所有
和v。有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问(非连通图),则另选图中一
个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
6.4 图的 遍历 219
[例6.13]以图6.20(a)的无向图G?为例，进行图的深度优先搜索。假设从顶点E出发进
行搜索(建议读者从其他顶点出发，自行练习),在访问了顶点E之后，选择E的邻接点进行递
归，此时E的未曾访问过的邻接点有A、F和H,理论上说，选哪个邻接点都是可以的，但实际应
用中，算法是在一个确定的数据结构上运行，所以会按照某种存储次序选取邻接点。在这里，为
了方便起见，当有多种选择的时候，采用字母序的策略选择下一个邻接点。遍历顺序如图
6.20(b)所示。
④ ⑥ ⑧ 0
D H @ C D H O
D A E F B A E F
③ ② 0 ⑥
(a) (b)
图6.20 一个无向图G,及其一种深度优先遍历顺序
选择A为下一个邻接点，则从A出发进行递归搜索。依次类推，接着从B、C、D出发进行
搜索。在访问了D之后，由于D的邻接点(A和C)都已被访问，则搜索回退(递归调用返回)到
C。由于同样的理由，搜索继续回到B,A直至E。此时由于E有没有访问过的邻接点F和H,按
照字母序先选F,访问了F以后依次访问G、H;再从G、F退回到E。此时E已经没有未经访问的
邻接点，并且递归搜索回到了起点，这样我们就完成了一个连通分量的深度优先搜索。访问的顺
序是E→A→B→C→D→F→G→H。
显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标
志数组 Visited[ ],它是全局变量，其Nv个分量初值都是false。一旦某个顶点被访问，则其相应
的分量置为 true。这相当于Tremaux 探索迷宫时点亮交叉点的灯。
实现上述深度优先遍历(DFS)递归算法的伪码描述如代码6.5所示。
/*Visited[]为全局变量，已经初始化为false*/
void DFS(Graph G, Vertex V, void(*Visit)(Vertex))
/从第V个顶点出发递归地深度优先遍历图G*/
Visit(V);/* 访问第V个顶点·/
Visited[V]=true;
for(V的每个邻接点W)
if(!Visited[W])
/对V的尚未访问的邻接顶点W递归调用DFS*/
DFS(G,w. Visit);
代码6.5 深度优先遍历的递归算法——伪码描述
220 第6章 图
其中Visit(V)是访问顶点V的函数调用，它可以根据不同的应用改变。算法DFS是对抽象
数据结构“图”的一个连通分量进行遍历的操作，与选择的存储图的具体数据结构无关。
更具体地，如果选择邻接表作为图的数据结构，则代码6.6用打印顶点编号作为访问函数
Visit(V)的任务，实现了对一个连通分量的DFS遍历。
void visit(Vertex V)
printf(·正在访问顶点名d\n,V);
/* Visited[]为全局变量，已经初始化为false*/
void DFS(LGraph Graph, Vertex V, void(*Visit)(Vertex))
/*以V为出发点对邻接表存储的图Graph进行 DFS搜索*/
PtrTOAdjVNode W;
Visit(V):/* 访问第V个顶点/
Visited[v]=true;/* 标记V已访问*/
for(W=Graph->G[V].FirstEdge; W;W=W->Next)/*对V的每个邻接点W->AdjV·/
if(!Visited[W->Adjv])/* 若W->AdjV未被访问*/
DFS(Graph,W->Adjv, Visit); 则递归访问之·/
代码6.6 邻接表存储图的深度优先遍历
如果要列出图中所有连通分量，则可以用一个for 循环遍历图中所有顶点，对每个顶点V,如
果其 Visited[V]是false(即还没有被打印过),就从它开始进行一次 DFS遍历，从而打印出包含
V的连通分量中的所有顶点。
在遍历时，对图中每个顶点至多调用一次DFS 函数，因为一旦某个顶点被标志成已被访问，
就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。其
耗费的时间则取决于所采用的存储结构。当用邻接矩阵作为图的存储结构时，查找所有顶点的
邻接点所需时间为0(|VI2)。而当以邻接表作图的存储结构时，找邻接点所需时间为0(|E|)。
由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为0(|V|+|E|)。
6.4.3 广度优先搜索
广度优先搜索(Breadth First Search,BFS)类似于树的按层次遍历的过程。本章最后的应用
实例，即验证六度空间理论问题，就是广度优先遍历的一个富有成效的应用。
假设从图中某顶点v。出发，在访问了v?之后依次访问v。的各个未曾访问过的邻接点，然后分
6.4 图的 遍 历 221
别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问
的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚
有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶
点都被访问到为止。换句话说，广度优先搜索遍历图的过程中以v。为起始点，由近至远，依次访
问和v。有路径相通且路径长度为1,2,……的顶点。
为了能够使得这种访问次序得以实现，需要一个队列把访问过的顶点依次保存下来，以便下
次依次访问它们的邻接点。利用队列先进先出的特性，可以保持访问的次序。队列为空的时候
表明一个连通分量遍历完成。
[例6.14]对图6.20(a)所示无向图G?进行广度优先搜索遍历，假设从顶点E出发进行搜索
(建议读者从其他顶点出发，自行练习),在访问了顶点E之后，接着访问E的未曾访问过的所有邻
接点，此时E的未曾访问过的邻接点有A、F和H,理论上说，选哪个邻接点先访问都是可以的，与深
度优先搜索同样的原因，有多种选择的时候，采用字母序的策略选择邻接点的访问次序：A、F和H。
在访问了距离E路径长度是1的A、F和H以后，接下去要访问的是距离E路径长度是2的A
的邻接点、F的邻接点和H的邻接点，次序仍然是A的所有邻接点(未曾访问过的)、F的所有邻接
点(未曾访问过的)、最后才是H的所有邻接点(未曾访问过的)。如此等。得到的顶点访问序列为
E→A→F→H→B→D→G→C(对应距离E的路径长度为1、1、1、2、2、2、3),如图6.21所示。
8 ⑥ ④ ⑦
C D H G
B A E F
⑤ ② 0 ③
图6.21 无向图G,对应的一种广度优先遍历顺序
与深度优先搜索类似，在遍历的过程中也需要二个访问标志数组Visited [],它是全局变量，
其Nv个初值都是false。一旦某个顶点被访问，则其相应的分量置为true。
采用队列的实现过程如下：假如首先访问顶点E,然后E进队列。接下来对非空队列进行如
下循环：
(1)删除队列头元素E,E的未曾访问过的邻接点A、F和H相继被访问并进队列；
(2)删除队列头元素A,A的未曾访问过的邻接点B和D相继被访问并进队列；
(3)删除队列头元素F,F的未曾访问过的邻接点G被访问并进队列；
(4)删除队列头元素H,H没有未曾访问过的邻接点；
(5)删除队列头元素B,B的未曾访问过的邻接点C被访问并进队列；
(6)删除队列头元素D,D没有未曾访问过的邻接点；
(7)删除队列头元素G,G没有未曾访问过的邻接点；
(8)删除队列头元素C,C没有未曾访问过的邻接点。
222 第6章 图
此时队列为空，循环结束，表明一个连通分量访问结束。由于本例的图是连通图，所有顶点
都被访问，由此完成了图的遍历。
实现上述广度优先遍历(BFS)的算法如代码6.7所示。
bool ISEdge(MGraph Graph,VertexV, Vertex W)
return Graph->G[v][W]<INFINITY?true:false;
/* Visited[]为全局变量，已经初始化为false*/
void BFS(MGraph Graph, Vertex S,void(*Visit)(Vertex))
/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索*/
Queue Q;
Vertex V,W;
Q=CreateQueue(Maxsize);/* 创建空队列，MaxSize为外部定义的常数*/
/* 访问顶点S:此处可根据具体访问需要改写*/
Visit(S);
Visited[S]=true;/* 标记S已访问*/
AddQ(Q,S);/*S入队列*/
while(!ISEmpty(Q))
V=DeleteQ(Q);/* 弹出V*/
for(W=0;W<Graph->NV;W++)/* 对图中的每个顶点W*/
/* 若W是V的邻接点并且未访问过*/
if(!Visited[W]&& ISEdge(Graph,V, W))
/* 访问顶点W*
Visit(W);
Vioited[W]=true;/标记W已访问*/
AddQ(Q,W);/W人队列*
/* while结束*/
代码6.7 邻接矩阵存储图的广度优先遍历
函数IsEdge(Graph,V,W)检查<V,W>是否图Graph 中的一条边，即W是否V的邻接点。
此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。代码6.7中
的实现是针对有权图的，其中不存在的边被初始化为INFINITY。
6.5 最小生成树 223
若选择邻接表作为图的数据结构，则对代码6.7的改造会与代码6.6相似，该工作留给读者
作为练习。
分析上述算法，每个顶点至多进一次队列。遍历图的过程实质是通过边或弧找邻接点的过程，因
此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问
的顺序不同。当用邻接矩阵表示图的存储结构时，所需时间为0(|V|2),而当以邻接表作图的存储
结构时，找邻接点所需时间为0(|E|),广度优先搜索遍历图的时间复杂度为0(|V|+|E|)。
综上所述，由于图结构的复杂性，所以图的遍历操作也较树的遍历复杂，主要表现在以下四
个方面。
(1)在图结构中，没有一个“自然”的首结点，图中任意一个顶点都可作为第一个被访问的
结点，所以遍历的序列通常还要指出从哪个顶点出发。
(2)在非连通图中，从一个顶点出发，只能够访问它所在的连通分量上的所有顶点，因此，还
需考虑如何选取下一个出发点以访问图中其余的连通分量。
(3)在图结构中，如果有回路存在，那么一个顶点被访问之后，有可能沿回路又回到该顶点。
因此需要标记已经被访问的顶点，比如点亮交叉点的灯或者用Visited 数组。
(4)在图结构中，一个顶点可以和其他多个顶点相连，当这样的顶点访问过后，存在如何选
取下一个要访问的顶点的问题。比如通道的门是否打开表示是否已经尝试该通道，或者对应具
体的存储结构控制下一个尝试的邻接点。
图的遍历可以有许多应用，比如求连通分量、欧拉回路、生成树、DAG的判定、DAG的根、桥
边、关节点等的计算都可以通过遍历来进行。具体内容参见相关习题。
6.5 最小生成树
图的生成树和生成森林的概念在6.2.1节中已经作了介绍，本节将介绍如何从图中导出生
成树(或生成森林),并且介绍很有用的最小生成树的概念与生成算法。并解决6.1节引出的公
路村村通问题。
6.5.1 生成树的构建与最小生成树的概念
由生成树的定义可知，无向连通图的生成树不是唯一的。连通图的一次遍历所经过的边的
集合及图中所有顶点的集合就构成了该图的一棵生成树，对连通图的不同遍历，就可能得到不同
的生成树。
例6.13对图6.20(a)所示的无向图的深度优先的一种访问的顺序是：E→A→B→C→D→F
→G→H,根据遍历时的递归过程，这相当于得到了图6.22(a)所示的生成树。例6.15对图6.24
的广度优先的一种访问的顺序是：E→A→F→H→B→D→G→C,根据遍历算法引入队列的父子
关系(孩子由其父顶点引入队列),这相当于得到了图6.22(b)所示的生成树。
224 第6章 图
E) E)
② A ⑥ F
② A ③ F ④H
③ B ⑦ G ⑥
⑤ B D
⑦ G
◎ ⑧ H
⑧ C
⑤ D
(a) (b)
图6.22 无向图G?的一棵深度优先生成树与一棵广度优先生成树
如果例6.12和例6.13不采用“有多个未访问邻接点可选时以字母序策略”,那么图6.23是
无向图G?的另一棵深度优先生成树与另一棵广度优先生成树。
但是图6.24的(a)、(b)两图都不可能是G,的深度优先生成树与广度优先生成树。图6.24(a)
中D到B是没有边的，不可能出现在生成树中，所以它根本就不是G?的生成树。图6.24(b)中D
到C是G?的边，所以它是-G?的生成树，但是根据广度优先遍历顺序，B在D前的话，B的邻接点就
应该在D的邻接点之前，换句话说，C应该作为B的邻接点被访问，所以应该是B的孩子。
E) O
E
②H ⑤ A
②! H ③ F ④A
③ G ⑥ D
⑤G ⑥ B D⑦
④1 F
0
8 B
(a) (b)
图6.23 无向图G,的另一棵深度优先生成树与另一棵广度优先生成树
E 0
E
eH ⑤ A
②E ③( F ◎A
G③ ⑥ D
◎F ⑦
区
B
G⑤( ⑥ B D⑦
⑧
×
C
8 C
(a) (b)
图6.24 无向图G,错误的深度优先生成树与错误的广度优先生成树
6.5 最小生成树 225
显然，对于有n个顶点的无向连通图，无论其生成树的形态如何，只要是树，就都有且仅有
n-1条边。
如果无向连通图是一个网图，那么,它的所有生成树中必有一棵边的权值总和最小的生成
树，我们称这棵生成树为最小生成树(Minimum Spanning Tree,MST)。当然，对任意一个带权的
连通网图来说，最小生成树也未必是唯一的。
对一个网图来讲，边上权值总和最小的连通子图是不是一定是一棵树呢?我们一般假定权
值非负，连通图上如果存在回路，那么删去回路上的任意一条边仍然是连通图，但权值和可以减
少。因此，权值总和最小的连通图一定是没有环的，它也就是一棵生成树。
回忆6.1节的图6.1和图6.2表示的公路村村通问题，目标是要选择建设哪几条公路，既能
够连通所有村子，又能够使投资最少。就是要找到一个连通子图，边上权值总和最小，也即要找
对应网图的最小生成树。
图6.25和图6.26都是图6.2的生成树，前者的权值和为56,后者的权值和只有38。所以
我们选择图6.26的方案解决公路村村通问题，要比选择图6.25的方案节省18(万元)的投入。
但是，我们还有两个疑问；图6.26是不是就是唯一的最佳答案?我们又该如何找到一个最佳答
案呢?通过观察可以知道，即便图6.26就是最佳答案，它也不是唯一的，因为用边(H,C)代替
(Y,C)得到的也是权值和为38的生成树，见图6.27(j)。至于第二个问题，就是本节要介绍的
重点。
② ②
8 8 X 5 X
5 W
B
7 W
5
× B 4
4
5
5/ 4 H)
D ① 6
6/ H
D
4 ①
6/
3/
F
7 C 2
F
图6.25 权值和为56的一棵生成树 图6.26 权值和为38的一棵生成树
下面介绍两种常用的构造最小生成树的方法——普利姆(Prim)算法和克鲁斯卡尔
(Kruskal)算法。
6.5.2 构造最小生成树的Prim算法
我们先从实例的最小生成树构造过程入手，介绍(不是证明)构造过程的正确性，然后再用
严格的符号表达方式描述，最后给出Prim算法的代码。
对n个顶点的连通图来说，其最小生成树可以由图中的n-1条边(当然还包括相关的顶点)
构成，我们要做的就是如何从图中的边里面选择适当边的方法。从任何一个顶点出发，构建过程
从初始只有这个顶点的“当前树”开始，不断加入边和相关顶点到当前树中，使得当前树不断“生
226 第6章 图
长",最终成为最小生成树。
[例6.15]用Prim算法构造网图6.2的最小生成树的生长过程如图6.27所示。各图的
“粗线边”构成了当前树，“虚线边”表示当前树的所有邻接点与当前树的最短边。我们用T=
|E;V|来表示一棵树T,其中E是T的边集合，V是T的结点集合。
对图6.27(a):从顶点Z开始，当前树T?=||;|ZI1,从所有与当前树有关顶点Z相连的
边(图6.27(a)中用虚线表示，一端在当前树，另一端不在当前树)中，选择权重最小的边
(Z,W,5)加入到当前树T?,当前树成了T?=1(Z,W,5)|;|Z,WI1,同时修改“虚线边”,如图
6.27(b)所示。
②
8/
5
B) 4
5/
D
4
②
8
5
B
5/ 4
D
4
⑦
8/
5
B
5/ 4
D
4
5 8
W) 7
4
4 H
L) 3/
2
F
7
(a)
5
8
w) 4
7/
4 H
L
3.
2 7
F
(c)
5 8
W
4
7/
4 H
① 3/
2) F
7
(e)
X
5
6
X
5
.6
5
×
6/
5
6/
C
X
5
5
Y
6 6/
8/
5
B)
5/ 4
D
4
②
8
5. B
5/ 4
D
4
②
8
5
B)
5/ 4
D
4
5 8
W 7
4
4 H
L
3
2
F
7
(b)
5 8
W
4
7/
4 H
L 3
2
F
7
(d)
5 8
W
4
7
4 H
D 3
2 7
X
5
6
X
5
6
5
Y
6
C
X
5
5. ×
6 6/
C
5
6/
F
f
6.5 最小生成树 227
② ②
8/ 5 8 x 8/ 5 8 x)
5 w 5
B
7/ 5 w
5
4
5/ 4
5
B 4
7
4 H
D
4 ①
6 6
5/ 4
5
4 H
4
3) D
D
6
6/
3y
2 7 C 2) 7 C
F F
(g) (h)
②
8/ 5 ② 8 ×
5 w) 5
8/ 5 8 ×
B
7
5 w) 5
7/ 4
5/ 4
5
B 4
4
5
4 H
D
4 ① 6 6/ 5/ 4 H)
3) D
4
L
6 6/
2 7 C
3/
2) 7
F F
(i) ①
图6.27 Prim算法构造最小生成树的过程
修改“虚线边”的规则是：对新加入的顶点W,考察其所有的邻接点{B,H,X|,这些邻接点到
当前树的距离是否会因为W的加入而变的更近。邻接点B到当前树的距离原来是8,现在成了
5,所以把边(B,W,5)改成虚线边的同时，边(B,Z,8)改成实线边。
为什么边(Z,W,5)必定是最小生成树中的边呢?其正确性可以这样理解：假如除Z以外的
全部顶点已经找到了一棵最小生成树，那么把Z加入该树的最小代价是用边(Z,W,5)。
对图6.27(b),考虑当前树T?,从所有T?的邻接点与T?相连的最短边(图6.27(b)中用虚线
表示)中，选择权重最小的边(W,H,4)加入到当前树T?,当前树成了T?=l(Z,W,5),(W,H,4)|;
|Z,W,H|1,同时修改“虚线边”,如图6.27(c)所示。“(W,H,4)必定是最小生成树中的边”的
正确性同样可以与前面类似地理解。
完全类似地考虑图6.27(c)和图6.27(d),不过图6.27(d)中加入边(H,F,3)以后，增加虚线
边(F,L,2),同时边(L,H,4)改成了实线，因为该边的两端都在当前树中了，如图6.27(e)所示。
对图6.27(e),考虑当前树T?=日(Z,W,5),(W,H,4),(H,F,3),(F,L,2);|Z,W,H,F,L,从
所有T?邻接点与T,相连的最短边(图6.27(e)中用虚线表示)中，选择权重最小的边(L,B,4)
(关于这种选择的解释见后)加入到当前树T?,当前树成了T?=|(Z,W,5),(W,H,4),
(H,F,3),(F,L,2),(L,B,4)|;|Z,W,H,F,L,BIl,同时修改“虚线边”,如图6.27(f)所示。
上面考虑权重最小的边有两条：(L,B,4)和(L,D,4),选择哪一条加入到当前树T?中，应该
都是可以的，本质上得到的都是最小生成树。不同选择可能会导致两种情况，一种是这几条边都
228 第6章 图
是最小生成树的边，这次不选，以后的步骤中也会选到——(L,B,4)和(L,D,4)就是属于这种情
况，先选哪条不会影响最终结果；另一种是选了其中的一条边，其余的边可能在以后的步骤中就
不会再选到，这也是导致最小生成树不唯一的原因。
最后，图6.27(j)粗线边就构成了Prim算法得到的最小生成树。
由此可见，Prim算法构建最小生成树的过程就是当前树的生长过程。n个顶点的网图只要
通过 n-1步的生长就可以完成。图6.27中用“虚线边”表示当前树的所有邻接点与当前树的最
短边(每个邻接点只有一条),这是Prim算法的关键。下面是Prim算法的形式化描述。
假设G=(V,E)为一网图，其中为网图中所有顶点的集合，E为网图中所有带权边的集合。
设置两个新的集合V,和E,,其中集合V,用于存放G的最小生成树中的顶点，集合E,存放G的最
小生成树中的边(即当前树T=|E,;V,l)。令集合V,的初值为V,=lv?F(假设构造最小生成树
时，从顶点v。出发),集合E的初值为O。Prim算法的思想是，从所有u∈V,,v∈V-V,的边(算法
中只需考虑虚线边)中，选取具有最小权值的边(u,0),将顶点v加入集合V,中，将边(u,v)加入
集合E,中，如此不断重复，直到V,=V时，最小生成树构造完毕，这时集合E,中包含了最小生成
树的所有边。
Prim算法可用下述过程描述，其中用W表示顶点u与顶点》边上的权值。
V,={v?l,E,=|0|;
while(V,≠V)
(n,v)=min|W|u∈V,,v∈V-V,I;
E,=E,+|(u,0)|;
V,=V,+{};
结束。
为实现Prim算法，顶点用0~|V|-1编号，顶点之间没有边用权值表示，并设置两个辅助
一维数组 parent和dist。其中数组 parent用来保存当前树的顶点生长过程中，每个顶点的父顶
点，parent[0]=-1表示 v。为根。dist[j]用来保存顶点v,到V,顶点的边的最小权值(即图6.27中
的虚线边的权值),即存储各顶点与当前树的“距离”——如果v,属于当前树，则dist[j]=0;如果
v,不属于当前树且不是当前树所有顶点的邻接点，则用 dist[j]=0表示。
在程序中我们用顶点编号代表顶点，假设初始状态时，V,=|0}(v。为出发的顶点),这时有
dist[0]=0,它表示顶点v?已加人集合V,中；数组 dist的其他各分量的值是顶点v。到其余各顶点
所构成的直接边的权值，可以从图的存储结构中直接复制。
然后从 dist 中不断选取权值最小的边(w,0)(w∈V,,veV-V,,数据存储在 dist[0]中),每选
取一条边，就将dist[v]置为0(当前树生长至v)。由于顶点v从集合V-V,进入集合V后，这两
个集合的内容发生了变化，就需对每个weV-V,更新数组 parent 和 dist 的内容：若收录o使得
dist[w]变小，则将dist[w]更新为(v,w)的权值，并且将v设置为w的父顶点。
用邻接矩阵存储图的Prim算法的实现如代码6.8所示，其中求当前树和非当前树顶点之间
6.5 最小生成树 229
的最小距离的算法由代码6.9给出。由于最后产生的最小生成树肯定是个稀疏图(只有Nv-1
条边),所以我们用邻接表存储它。
#define ERROR-1/*错误标记，表示生成树不存在*/
int Prim(MGraph Graph,LGraph MST)
1/+将最小生成树保存为邻接表存储的图MST,返回最小权重和·/
WeightType dist[MaxVertexNum],Totalweight;
Vertex parent[MaxVertexNum],V, W;
int VCount;
Edge E;
/* 初始化。默认初始点下标是0*/
for(V=0;V<Graph->Nv;V++)
/* 这里假设若V到W没有直接的边，则Graph->G[V][W]定义为INFINITY*/
dist[V]=Graph->G[0][V];
parent[v]=0;/* 暂且定义所有顶点的父结点都是初始点0*/
TotalWeight=0;/* 初始化权重和*/
Vcount=0; /* 初始化收录的顶点数*/
/ 创建包含所有顶点但没有边的图。注意用邻接表版本*人
MST=CreateGraph(Graph->Nv);
E=(Edge)malloc(sizeof(struct ENode));/* 建立空的边结点*/
/*将初始点0收录进MST*/
dist[0]=0;
VCount ++;
parent[0]=-1;/* 当前树根是0*/
while(1)!
V=FindMinDist(Graph,dist);
/* V=未被收录顶点中dist 最小者*/
if(V==ERROR)/* 若这样的V不存在*/
break;/* 算法结束*/
/·将V及相应的边<parent[v],V>收录进MST*/
E->V1=parent[v];
E->V2=V;
230 第6章 图
E->Weight=dist[V];
InsertEdge(MST,E);
TotalWeight*=dist[V];
dist[V]=0;
VCount++;
for(W=0;W<Graph->Nv; W++)/* 对图中的每个顶点W*/
if(dist[W]!=0& Graph->G[V][W]<INFINITY)|
/*若W是V的邻接点并且未被收录*/
if(Graph->G[v][W]<dist[W])
/* 若收录V使得 dist[W]变小*/
dist[W]=Graph->G[v][W];/* 更新dist[W]*/
parent[W]=V;/* 更新树*/
1/* while结束*/
if(VCount <Graph->Nv)/MST中收的顶点不到|v|个*/
TotalWeight=ERROR;
return TotalWeight;/* 算法执行完毕，返回最小权重和或错误标记*
代码6.8 邻接矩阵存储图的Prim算法
Vertex FindMinDist(MGraph Graph, WeightType dist[])
/*返回未被收录顶点中dist最小者*/
Vertex Minv,V;
WeightType MinDiat=INFINITY;
for(V=0;V<Graph->NV;V++)I
if(dist[v]!=0&&dist[v]<MinDist)I
/若V未被收录，且diat[V]更小*/
MinDist=dist[V]:/* 更新最小距离*/
Minv=V;/* 更新对应顶点*/
1
if(MinDist<INFINITY)/*若找到最小 dist*/
return Minv;/* 返回对应的顶点下标·/
else return ERROR;/若这样的顶点不存在，返回-1作为标记*/
代码6.9 FindMinDist 函数
6.5 最小生成树 231
表6.1给出了用上述算法构造网图(例6.14)的最小生成树的过程中数组parent、dist 的变
化情况，读者可进一步加深对Prim算法的理解。
表6.1 例6.14中用Prim算法构造最小生成树过程中各参数的变化示意
va(Z) v,(B) v?(W) v,(X) v?(D) v?(L) w。(H) v,(Y) v.(F)
dist 0 8 5 0
parent -1 0 0 0 0 0 0 0 0
dist 0 5 0 8 4
parent -1 2 0 2 0 0 2 0 0
dist 0 5 0 7 4 0 5 3
parent -1 2 0 6 0 6 2 6 6
dist 0 5 0 7 2 0 5 0
parent -1 2 0 3 0 8 2 6 6
dist 0 4 0 7 4 0 0 5 0
parent -1 5 0 3 5 8 2 6 6
dist 0 0 0 7 4 0 0 5 0
parent -1 5 0 3 5 8 2 6 6
dist 0 0 0 7 0 0 0 5 0
parent -1 5 0 3 5 8 2 6 6
dist 0 0 0 5 0 0 0 0 0
parent -1 5 0 7 5 8 2 6 6
dist 0 0 0 0 0 0 0 0 0
parent -1 5 0 7 5 8 2 6 6
dist 0 0 0 0 0 0 0 0 0
parent -1 5 0 7 5 8 2 6 6
v,(C)
初始 0
选v? 0
6
选v. 6
6
选n, 6
6
选v? 6
6
选， 6
6
选 6
6
选v, 6
6
选v, 6
0
选 6
在这个以邻接矩阵为存储结构的Prim算法中，第一个初始化辅助数组的for 循环的执行次
数为|VI-1;CreateGraph用0(IV|)建立起一个空的邻接表表示的MST;接下来的while 循环
最多执行|V|-1次，但是其中又要执行 FindMinDist 和一个for 循环，执行次数为2(|V|-1)2,
所以Prim算法的时间复杂度为0(|VI2)。这对稠密图来说是比较好的方法，也因此我们用邻
接矩阵表示Graph。
对于稀疏图来说，这个时间界未必是理想的。一个改进是：改用邻接表作为存储结构并更换
代码6.9,求V-V,中到V,最小距离的点的FindMinDist 函数改用第4章介绍的最小堆结构。另一
232 第6章 图
个做法是采用随后介绍的Kruskal算法，它们的时间复杂度都可以改进为0(|E|log|V|)。
6.5.3 构造最小生成树的Kruskal算法
Kruskal算法是一种按照网图中边的权值递增的顺序构造最小生成树的方法。其基本思想
是：设无向连通网图为G=(V,E),令G的最小生成树为T,其初态(不是树，可以看成生成森林)
为T=|日空边集};VI,即开始时，T由图G中的全部|V|个顶点构成，顶点之间没有一条边，这
样T中各顶点各自构成仅有一个顶点的连通分量。然后，按边的权值由小到大的顺序，按照贪
心原则考察G的边集E中的各条边。
所谓贪心原则就是既然我们要找“最小”生成树，那么每次就选取权值最小的边作为T的候
选边。然而同时我们要求最后生成的是一棵“树”,树中不可以有回路，所以我们必须确认候选
边不在现有的T集合中构成回路。要检查这一点，就要注意到一个事实：如果两个顶点属于同
一个连通分量，那么在它们之间加一条边就必定构成回路。所以，若候选边的两个顶点属于T
的两个不同的连通分量，则此边是可以作为最小生成树的边加入到T中的(同时也就把两个连
通分量连接为一个连通分量);否则舍去此边，以免构成回路。如此下去，当T中收集到|V|-1
条边时——也即T中连通分量个数为1时，T便成为G的一棵最小生成树。
可见，与Prim算法从根结点长出一棵树的过程不同，Kruskal方法是把初始仅包含|V|个孤
立顶点的森林逐步合成一棵生成树的过程。
[例6.16]用Kruskal算法构造网图6.2的最小生成树的过程如图6.28所示。图的全部顶
点以及由“粗线边”连成的树构成了“当前森林”。最终，当前森林成为最小生成树。由于顶点集
合V始终不变，我们以T的边集变化来记录树的生成过程，即记T=|E|。
图6.28(a):当前森林是由全部顶点但没有边构成的|V|棵树T?=|01,从所有的边(图中
用虚线表示)中，选择权重最小的边(L,F,2)合并两棵树，把虚线边(L,F,2)改成“粗线边”,当前
森林成了|V|-1棵树的森林T?=|(L,F,2),如图6.28(b)所示。
权重最小的边，如果该边的两个端点不在当前森林的同一棵树中，那么它必定是最终最小生
成树中的边。其正确性比较显然，因为我们是在用最小的代价连通两棵树。
图6.28(b):考虑当前森林T?=1(L,F,2),从所有的边(图6.28(b)中用虚线表示)中，选
择权重最小的边(H,F,3)合并两棵树，把虚线边(H,F,3)改成"粗线边",当前森林成了|V|-2
棵树的森林T?=1(L,F,2),(H,F,3)|,如图6.28(c)所示。
图6.28(c):考虑当前森林T?,从所有的边(图中用虚线表示)中，选择权重最小的边，最小
权重是4的边共有4条：(H,W,4)、(H,L,4)、(L,B,4)和(L,D,4)。其中边(H,L,4)的两端已
经是同一棵树，加入它将导致回路，所以不能选。而其他3条边都不会出现上述情况，因而都是
可选的，比如我们先选边(L,B,4),合并两棵树，把虚线边(L,B,4)改成“粗线边”,当前森林成了
|V|-3棵树的森林T?=I(L,F,2),(H,F,3),(L,B,4),如图6.28(d)所示。
当出现有多条权重最小的边(不会导致回路的边)可选时，选择哪一条来合并两棵树，应该
都是可以的，本质上得到的都是最小生成树。不同选择可能会导致两种情况，一种是这几条边都
是最小生成树的边，这次不选，以后的步骤中也会选到，先选哪条不会影响最终结果，这里的3条
6.5 最小生成树
② ②
8
5 8 X
5 w) 5
8
5 8
B) 4
7/ 5 w
4
5 Y B) 4
7/
5j 4 H
4
D ① 6 6/ s/ 4
4 H
4
3/ D
① 3
2) 7 2 7
F (F)
(a) (b) ② ②
8) 5 8 X
5 w) 5
8/ 5 8
B) 7/ 5 w) 7
4
4
5
B 4
5 4
4
H 5/ 4
D
D
6 6
4 H
3/ D
4
L
6
3
2 7 C 2 7
F F
(c) (d)
② ②
8
5 8 X
5 W
5
8/ 5 8 X
B) 4
7/ 5 W)
s
4
5 Y B 4
7
4
5
4 H
4
D
D
6 6/ sj 4 H) 4 6
3/ D 3
2 7 C 2) 7
F F
(e) (1)
② ⑦
8/ 5 8 X
5 W
5
8/ 5 8
B) 4
7/ 5. W)
4
5
B 4
7/
5i 4 H
D
4
L
6 6/ s/ 4
4 H)
3/ D
4 ① 3)
2 7 C 2) 7
F F
(g) (h) Z ②
8/ 5 8 X 8/ 5 8
5 w
B) 4
7/ 5 5 w
5/ 4
5
B) 4
7/
4 H
D
D
6 6/ 5/ 4
4 H
3/ D
4
L 3
2) 7 C 2 7
F F
(1) 0
图6.28 Kruskal 算法构造最小生成树的过程
233
X
5
6
6
5
Y
6/
C
X
5
5 Y
6/
5
Y
6/
C
X
5
5 Y
6/
C
5
Y
4
X
5
6 6/
C
234 第6章 图
边(H,W,4)、(L,B,4)和(L,D,4)就是属于这种情况；另一种是选了其中的一条边，其余的边可
能在以后的步骤中就不会再选到，比如后面的图6.28(j),用(H,C,6)代替(Y,C,6)也是最小生
成树，这也是导致最小生成树不唯一的原因。但是，在我们选定了一种存储结构并实现了具体算
法以后，事实上已经确定了将会选择哪一条最小边，即便它们有相同的最小权值。
完全类似地考虑图6.28(d)到图6.28(i)。最后，图6.28(j)粗线边就是Kruskal算法得到
的最小生成树。
综上所述，实现Kruskal算法的核心工作有三点：
(1)选择一条权重最小的边。因为权值是不变的，所以所有边可以事先按照权值升序排列，这
项工作如果采用第7章效率较高的方法，时间复杂性是0(|E|log|E|)。如果不把所有的边事先
排序，也可以采用第4章介绍的优先队列(最小堆)数据结构。建初始堆的时间复杂性是0(|E|),删
除堆顶元素后重组一个堆的时间是0(log|E|),所以总的时间复杂性还是0(|E|log|E|)。
(2)判定一条边的两端是否属于同一棵树。这项工作可以用第4章中并查集的运算Find
的返回值是否相同来检验。需要一个辅助的数组parents[]记录每个顶点的父顶点。
(3)合并两棵树。这项工作可以用第4章中并查集的合并运算Union来实现。
代码6.10给出了Kruskal算法的伪代码。在第8章的8.2.2节将给出一个具体应用问题的
详细实现代码。
int Kruskal(LGraph Graph,LGraph MST)
1/*将最小生成树保存为邻接表存储的图MST,返回最小权重和*/
while(MST中收集的边不到Graph->Nv-1条原图的边集E非空)
从E中选择最小代价边(V. W);/* 引入最小堆完成*/
从E中删除此边(V,W);
if((V,W)的选取不在MST中构成回路)/*此判断由并查集的Find完成/
else
彻底丢弃(V.W):
/* 结束while*
if(MST 中收集的边不到Graph->Nv-1条)
return ERROR;
else
return最小权重和；
MST=包含所有顶点但没有边的图；
将(V,W)加入MST;/*此步由并查集的Union完成*/
代码6.10 Kruskal算法的伪代码
在上面的Kruskal算法中，时间复杂性主要体现在while循环中，其循环次数最多为|E|次
数；其内部调用的最小堆操作的复杂度为每次0(log|E|);回路判断及边的收集由并查集中带路
径压缩的Find 函数和按秩合并的Union 函数完成，最快需要O(log|V|);所以总体时间复杂度为
6.6 最 短路 径 235
0(|E|log|V|)。可见当图比较稀疏(例如|E|=0(|V|))时，用Kruskal算法的效率会比用
Prim算法好，也因此我们在代码6.10中将Graph的类型写为LGraph,即用邻接表表示的图。
6.6 最短路径
我们经常会面临路径选择的决策问题。如果你去过上海世博会，相信你一定还记得曾经精
心计划过到上海以后如何前往世博会的交通线路。不论你是上海本地游客，还是乘飞机、火车或
是汽车到达上海的外地游客，通常都会最后选择地铁交通。地铁网络有许多条线路交错布置，不
同线路换乘站作为图的顶点，如图6.29所示。我们要在其中选择一条前往世博会的路径。
高定西站
白银路站
高定新城站 事、直城站 美重年等站
研之常能的悟站
虹桥国际机场
管指困站 龙柏新村站 龙重有站
洒冬站
1站
事 中事路站 七重站
经站
江大学城站
江新域站
酷陆日 作贾前
参虹路站 的淫毒护
机通文通115线
满带种站
雷站
武威磊站
蛋山关路站
上大路站
场中硒站
良满交道7号线 大场镇站
行知路站
。祁连山盛站 事子国站 上海西站站
真如站
城重盗等 大华三路站
新村路站
枫桥路对 中重害
镇坪路站鼓
金沙江路站 自福站
长寿路
所德路贴
中山公国站
顾安西路站〇
水藏落靠 言肆嘴站 宋配路站 上意运 宜山路站
星中路站 合川路站 重河泽开发区站 柱林路站
情江乐园处 蓬花路站
外环路站
事庄站〇
交通天学的
上海南站站 意西于 潜溪路站
龙潜路站
石龙路站
上路南站
轨道交通5号线 中路站
重起路站
等露排 T轴路
水产路站 新江湾城站 地滨路站
张华澡站股离东路贴
股发路站 三门路站
长辽路站 江考体商场站 服高与路站 繁寻真且口 五角场站 江考满站
大帕站 国权路站
费峰清站 问济大学站
东宝兴路站 品等看山舞 曲阳路站□四平路站 酒端落。 藏某腾光。 电新村站
上海火车站
汉中路站
满平路站
黄置情说 室山籍站
曲单路站
静安寺站 南京民路站人民广场站
天油路站 旧北腾站 表伦青箭 章暗站
常熟路站 大世界站 陕西南路站 黄皱率路
词
新天地达 衡山路站 名西门站
嘉浜路站
律家汇站 车安灌站 置年路的 事零指 小南门贴
阳家浜路站
B
上海体育场站
船厂路站 。内年相明酷 国
低满 临沂新村洁 同
轨道交通8号线成山路站 东明路站
思站 高青路站 壹高情肆站
液兆新村站 华夏西路站
芦慢路站 着风 上责卷
图6.29 城市地铁交通图
家道略晰
宝安公路站
共富新村站
呼兰路站
通河新村站
共滩路站
彭满断村站
能指
汉水晒站
上海马戏城站
上海火车站站 延长路站
中正糖站 中深 西藏正路站 口及雄坏的
江苏路结
上者电丹信着
市光路站
江路站 外高情
用股路站
黄兴公四站 外高析
中路站
醋家事站 奔的站 航通交通6号
世大道P 民生路站。 北样浮腾。 德平路。 a山病站。 金预路比 繁覆法曲 电路 扬离中路站
：站参着 盒村路站
中路站
世纪公四站
上海料技馆站
上海儿童医学中心站 张工壹科站 金相路站
磁洋
轨道交通4号线
大连路站
杨树浦路站
浦东大道站
意深体育中心站。
花木睛时口
龙阳路站
箭器害指; 若接路话
236 第6章 图
每个人的想法不同，选择的方案不尽相同。有的人选择换乘次数最少的线路(不计时间和
路程),有的人选择能最快时间内到达的线路(要选择地铁发车时间间隔小的线路，而路程也不
能太远),有的人选择花钱最省的线路(假如票价与距离成正比，就是选择最短距离)。实际上，
以上各种选择考虑问题的差异，仅仅是对网图边上的权值的含义的理解不同而已。选择最快时
间的，权值理解为时间；选择花钱最省的，权值理解为价格；而选择换乘次数最少的，可以理解为
任意两个换乘站之间的距离都是1。它们都属于本节要介绍的“最短路径问题”。
最短路径问题是图的又一个比较典型的应用问题。一般来说，对于一个无向网图(也可以
是有向网图),边上的权值可以理解为距离(自然约定为非负)。那么,这个问题就可归结为：在
网图中，求两个不同顶点的所有路径中，边的权值之和最短的那一条路径。这条路径就是两点之
间的最短路径(Shortest Path),并称路径上的第一个顶点为源点(Source),最后一个顶点为终点
(Destination)。在非网图中，最短路径是指两点之间经历的边数最少的路径。
边上权值有负数的情况要复杂一些，此时必须限定网图中任意回路上的权值和为正值，否则
最短路径长度可能是-∞。即便有这个限定，用来寻找最短路径的算法时间复杂度也更大。
下面讨论两种最常见的最短路径问题。
6.6.1 单源最短路径
从一个源点到其他各顶点的最短路径问题称为“单源最短路径问题”。本小节先来讨论这
类问题，下一小节再讨论任意两个顶点之间的最短路径问题。
单源最短路径问题可描述为：给定带权有向图G=(V,E)和源点t。∈V,求从v?到G中其余
各顶点的最短路径。在下面的讨论中均假设源点为v。
观察图6.30,你能够很快找出从源点v。到终点v,的最短路径吗?如果不能，暂时也没有关
系，让我们一同来研究计算机如何解决这个问题；如果你能找出v。到v,的最短路径，那也是仅仅
表示你的智商还不错，仍然得好好学习，毕竞现实的许多问题要比这个图复杂得多。我们要找到
一种对任意复杂的网图都可以找到两个顶点之间最短路径的方法。
8
5 (v2 5
2
4
2
9 以
2/ 4 (vs) 4
5
W
6
3
3 8
2
U
7
图6.30 一个无向网图
下面就介绍解决这一问题的经典算法，即由迪杰斯特拉(Dijkstra)提出的一个按路径长度递
增的次序产生最短路径的算法。
我们先通过对网图6.30的计算过程陈述，来介绍 Dijkstra算法的思想，然后再比较形式化地
6.6 最短路 径 237
描述该算法，最后给出程序。
[例6.17]用Dijkstra方法求网图6.30中(注意：权值均是正的)v。到所有其余顶点的最短
路径。
这是一个按距离递增的顺序逐步找出v?到各个顶点的最短距离(路径)的过程，实际上整个
过程完全类似于Prim算法求最小生成树。我们用两个数组 dist和path分别存储v。到其余顶点
的“当前最短距离”和相应的最短路径邻接于哪个顶点。两个数组分别类似于Prim算法的 dist
和 parent。|V|个顶点要经过|V|步完成，如表6.2所示，计算从左至右推进。
初始时(第0步),数组 dist的内容就是该图邻接矩阵表示时v?对应的行向量：v到?和v,的
距离分别是2和5(dist[1]=2,dist[3]=5),其余都是四；数组P的内容就是记录到v?和v?的路
径父顶点是v。(path[1]=path[3]=0)。在数组 dist中选择到v?距离最小的顶点v?,可以断定，顶
点v,已经找到了到v。的最终的最短距离，因为不可能通过绕行别的顶点使 v。到v,的距离会变得
更小(由权值均是正数容易推得)。
因此，v,作为已经求得最短路径的顶点，通过绕行D?,。到其余顶点的当前最短距离可以更
新：考虑v?的邻接点v?和v?(不需考虑已经求得最短距离的邻接点v。),dist[2]由原来的的变成
了7;dist[3]由原来的5变成了4;到v?和v?的路径父顶点是v?(path[2]=path[3]=1)。如表
6.2的(第1步)。表中 dist[1]表格项用深色底纹，表示 v,已经求得最短路径，dist[1]不参与下
一步最短距离的选择。在后面的算法中，我们用一个数组 collected[v]=true 表示顶点v已经求
得最短路径。
因此，下一步在dist 中选择到v。距离最小的顶点是v?(最小距离是4),表示到v?已经找到了
最短路径。接下去，v。到其余顶点的当前最短距离可以用一样的思想方法更新：考虑v,的邻接点
v?和v?(不需考虑已经求得最短距离的邻接点v。和v?),dist[5]由原来的变成了8;dist[6]由原
来的○变成了6;到v?和v?的路径父顶点是v?(path[5]=path[6]=3)。如表6.2的第2步。
表6.2 例6.16的最短距离数组 dist 和记录最短路径的结点序列数组 path的变化过程
=>从v。到各终点的dist值D和最短路径父顶点path 值P的变化过程=>
过程 初始
(第0步)
选B? 选v,
(第1步)(第2步)
选o
(第3步)
选p?
(第4步)
选v? 选v
(第5步)
选
(第7步)
选v,
(第6步) (第8步)
D P D P D P D P D P D P D P D P D P D
2 0 2 0 2 0 2 0 2 0 2 0 2 0 2 0 2 0 2
7 1 7 1 7 1 7 1 7 1 7 1 7 1 7 1 7
5 0 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4
0 0 0 15 2 10 5 10 5 10 5 10 5 10
8 3 8 3 8 3 8 3 8 3 8 3 8 3 8
6 3 6 3 6 3 6 3 6 3 6 3 6 3 6
选v。
终点 (第9步)
P
0
? 1
1
5
s 3
3
238 第6章 图
续表
=>从。到各终点的dist 值D和最短路径父顶点path值P的变化过程=>
过程「 初始
(第0步)
选v,
(第1步)
选v,
(第2步)
选v。
(第3步)
选v?
(第4步)
选v,
(第5步)
选
(第6步)
选v
(第7步)
选v,
(第8步)
D P D P D P D P D P D P D P D P D P D
00 17 5 15 4 15 4 15 4 15
13 6 13 6 13 6 13 6 13 6 13 6 13
21 8 19 7 19
更新v?,更新v?,更新vs更新v,更新v.,更 新更新v,,更新v,,更新 vg,
?,。是，,,是：,,是v?是父顶v?是父顶v?,vs是B,是父顶。是父顶 ,是父顶 是最短距
父顶点，父顶点， 父顶点， 点， 点， 父顶点， 点， 点， 点，
最小值1 最小值3最小值5最小值66最小值7|最小值9最小值12 最小值14 最小值18|径父顶点
选
终点 (第9步)
P
? 4
6
7
结束。D
说明 离，v是路
用同样的方法一直做到第9步。dist[1]~dist[9]表示从v?到v?~v,的最短距离，比如dist
[9]=19的意思就是v。到v,的最短距离是19。可以通过搜索数组 path 得到最短路径，比如，v到
v,的最短路径可以这样得到：path[9]=7、path[7]=4、path[4]=5、path[5]=3、path[3]=1、
path[1]=0,顺序倒过来就是：0??D?、U?、U?、U?、U,、0,。
上述例子使我们熟悉了算法的大概过程，现在我们比较容易理解 Dijkstra算法的更一般化
的描述：假设有向图G=|V,E(无向图可以看成所有边都是双向边的有向图),设置两个顶点的
集合S和T(T=V-S),集合S中存放已找到最短路径的顶点，集合T存放当前还未找到最短路径
的顶点。初始状态时，集合S中只包含源点v?,然后不断从集合T中选取到顶点v?路径长度最短
的顶点a加人到集合S中。集合S每加入一个新的顶点u(表6.2中用深色底纹表示的D值),
都要修改顶点v。到集合T中剩余顶点的最短路径长度值，集合T中各顶点新的最短路径长度值
为原来的最短路径长度值与顶点u的最短路径长度值加上u到该顶点的路径长度值中的较小
值。此过程不断重复，直到集合T的顶点全部加入到S中为止。
Dijkstra算法的正确性可以用反证法加以证明。假设下一条最短路径的终点为v,那么,该路
径必然或者是弧(v?),或者是中间只经过集合S中的顶点而到达顶点v的路径。因为假若此
路径上除v之外还有一个或一个以上的顶点不在集合S中，那么必然存在另外的终点不在S中
而路径长度比此路径还短的路径，这与我们按路径长度递增的顺序产生最短路径的前提相矛盾，
所以此假设不成立。
下面介绍Dijkstra算法的实现。
首先，用dist[v]表示当前所找到的从始点s到终点b的最短路径的长度。它的初态为：若从
s到》有弧，则dist[v]为弧上的权值；否则置 dist[0]为的。然后，从dist 数组中选取路径长度最
小的dist[v],满足：
6.6 最 短 路 径 239
dist[v]=min| dist[w]|w∈V-|s}|
的路径就是从s出发到v的长度最短的一条最短路径。此路径为(s,v)。
那么,下一条长度次短的最短路是哪一条呢?假设该次短路径的终点是w,则可想而知，这
条路径或者是(s,w),或者是(s,v,w)。它的长度或者是从s到w的弧上的权值，或者是dist[v]
和从v到w的弧上的权值之和。
依据前面介绍的算法思想，在一般情况下，下一条长度次短的最短路径的长度必是：
dist[n]=min|dist[w]|w∈V-S}
其中，dist[w]或者是弧(s,w)上的权值，或者是dist[v](veS)和弧(v,w)上的权值之和。
根据以上分析，可以得到如下描述的算法：
(1)假设用带权的邻接矩阵C来表示带权有向图，G[v][w]表示弧(v,w>上的权值。若《v,w)
不存在，则置G[0][w]为(INFINITY)。S为已找到从s出发的最短路径的终点的集合，它的初
始状态为0。那么,从s出发到图上其余各顶点(终点)v可能达到最短路径长度的初值为：
dist[v]=G[s][v] veV
path[v]=-1(表示v尚无父顶点)
(2)选择v,使得
dist[v]=min{dist[w]|w∈V-S|
则》就是当前求得的一条从s出发的最短路径的终点。令S=SU|,即 collected[n]=true。
(3)修改从s出发到集合V-S上任一顶点w可达的最短路径长度 dist[w]如下：
dist[w]=min|dist[w],dist[n]+G[v][w]l
同时更新w的父顶点：path[w]=v。
重复操作(2)、(3)共|V|-1次。由此求得从s到图上其余各顶点的最短路径是依路径长
度递增的序列。
代码6.11为用C语言描述的Dijkstra算法。
Vertex FindMinDist(MGraph Graph,int dist[]:int collected[ ])
1/*返回未被收录顶点中dist最小者*/
Vertex Minv,V;
int MinDist=INFINITY;
for(V=0;V<Graph->Nv;V++)
if(collected[v]==false & dist[V]<MinDist)
/*若V未被收录，且dist[V]更小*/
MinDist=dist[v];/* 更新最小距离*/
MinV=V;/·更新对应顶点·/
if(MinDist<INFINITY)/*若找到最小dist·/
return MinV;/*返回对应的顶点下标*/
240 第6章 图
else return ERROR;/*若这样的顶点不存在，返回错误标记*/
boo1 Dijkstra(MGraph Graph,int dist[],int path[ ],Vertex S)
int collected[ MaxVertexNum];
Vertex V,W;
/*初始化：此处默认邻接矩阵中不存在的边用INFINITY 表示·/
for(V=0;V<Graph->Nv;V++)
dist[v]=Graph->G[s][v];
path[V]=-1;
collected[v]=false;
/*先将起点收入集合·/
dist[s]=0;
collected[s]=true;
while(1)I
/* V=未被收录顶点中dist最小者*/
V=FindMinDist(Graph,dist,collected);
if(V==ERROR)/* 若这样的V不存在·/
break; /* 算法结束·/
collected[v]=true;/收录V*/
for(W=0;W<Graph->Nv; W++)/ 对图中的每个顶点W*/
/* 若W是V的邻接点并且未被收录*/
if(collected[W]==false && Graph->G[v][w]<INFINITY)
if(Graph->G[v][w]<0)/*若有负边·/
return false;不能正确解决，返回错误标记*/
/· 若收录V使得 diat[W]变小*/
if(dist[V]+Graph->G[v][W]<dist[W])
dist[W]=dist[v]+Graph->G[v][w]; 更新dist[W]*
path[W]=V;更新S到W的路径*/
1/* while结束*/
return true;/算法执行完毕，返回正确标记*/
代码6.11 Dijkstra算法
6.6 最 短 路 径 241
下面分析一下这个算法的时间复杂度。第一个for 循环的时间复杂度是O(|V|),随后
while循环共进行|V|-1次，每次执行的时间是0(|V|)。所以总的时间复杂度是0(IV|2)。
如果用带权的邻接表作为有向图的存储结构，则虽然修改 dist的时间可以减少，但由于在
dist 中选择最小分量的时间不变，所以总的时间仍为0(|V|2),对稠密图来说这是很好的
结果。
但对于稀疏图来说，这个时间界未必是理想的。一个改进是：改用邻接表作为存储结构并改
用第4章介绍的优先队列(最小堆)的DeleteMin操作。查找最小值的时间是0(log|V1),它的
时间界可以改进为0(|E|log|V|)。
如果只希望找到从源点到某一个特定的终点的最短路径，从上面我们求最短路径的原理来
看，这个问题和求源点到其他所有顶点的最短路径一样复杂，其时间复杂度也是0(IVl2),稀
疏图可以改进为0(|E|log|VI)。
6.6.2 每一对顶点之间的最短路径
要求每一对顶点之间的最短距离，可以每次以一个顶点为源点，重复执行 Dijkstra算法|V|次。
这样，便可求得每一对顶点的最短路径。总的执行时间为0(|VI3)。
这里要介绍由弗洛伊德(Floyd)提出的另一个算法。这个算法的时间复杂度也是0(|V|3),
但形式上非常简洁、优雅，而且对于比较稠密的图，实际运行效率更快。
为了能很快理解 Floyd算法的精妙所在，先从一个简单的例子开始。
[例6.18]图6.31给出了一个简单的有向网及其邻接矩阵G。用Floyd算法求该有向网中
每对顶点之间的最短路径长度及其最短路径。
o
3 4
11 6
2
图6.31 一个有向网图及其邻接矩阵G
显然，最后得到的每对顶点之间的最短路径长度及其最短路径都应该分别是一个二维矩阵，
分别用二维数组D和二维数组 path 表示。D[i][j]表示从v,到v,的最短路径长度，path[i][j]表
示从v,到v,的最短路径上v,的父顶点号。
这两个数组都是从初始数组演变到最终数组的。数组D的初始值就是邻接矩阵G,为了方
便记录演变过程，把初始数组D写成D'-,通过依次考察3个顶点对应的行列，如图6.32,D-
演变成D'2),就是最终的各顶点之间的最短路径长度矩阵。
考察v。:0行0列以外的非对角线元素，D[1][2]=2,垂直和水平方向往0列0行投影的两
个元素之和D[1][0]+D[0][2]=6+11=17,因为17>2,所以D[1][2]=2保持不变。而另一个
元素D[2][1]=0,水平和垂直方向往0列0行投影的两个元素之和D[2][0]+D[0][1]=3+4=7,因
242 第6章 图
为7<∞,所以D[2][1]要替换成7。这个替换的含义是：原来从v?到v?的距离是∞,现在替换成
v?到v。再到v?,这样的距离是3+4=7,变成更小。D-1演变成 D。
考察v?:1行1列以外的非对角线元素，D[2][0]=3,水平和垂直方向往1列1行投影的两
个元素之和D[2][1]+D[1][0]=7+6=13,因为13>3,所以D[2][0]=3保持不变。而另一个
元素D[0][2]=11,水平和垂直方向往1列1行投影的两个元素之和D[0][1]+D[1][2]=4+
2=6,因为6<11,所以D[0][2]要替换成6。这个替换的含义是：原来从v。到v?的距离是11,现
在替换成v。到v,再到v?,这样的距离是4+2=6,变成更小。D演变成D"。
考察v?:2行2列以外的非对角线元素，D[0][1]=4,水平和垂直方向往2列2行投影的两
个元素之和D[0][2]+D[2][1]=6+7=13,因为13>4,所以D[0][1]=4保持不变。而另一个
元素D[1][0]=6,水平和垂直方向往2列2行投影的两个元素之和 D[1][2]+D[2][0]=2+
3=5,因为5<6,所以D[1][0]要替换成5。这个替换的含义是：原来从v?到v。的距离是6,现在
替换成v?到v?再到v?,这样的距离是2+3=5,变成更小。D1演变成D2。
Vov? V?
V% 0 4 且
V 6 0
D
v? 0
v?演变：0行0列以外的元素，水平和垂直方向
往0列0行投影的两个元素之和是否比原值小?
V V? v?
V 0 4
V 6 0 2
2 ③ 0
v?演变：1行1列以外的元素，水平和垂直方向
往1列1行投影的两个元素之和是否比原值小?
V? V1 v?
0 ④ 6
Y1 6 0 2
v? 3 7 0
D?演变：2行2列以外的元素，水平和垂直方向
往2列2行投影的两个元素之和是否比原值小?
图6.32 Floyd算法把邻接矩阵演变成目标矩阵的过程
6.6 最 短路 径 243
最后，D2给出的是每对顶点之间的最短距离。
下面考察最短路径矩阵path。与D的演变过程对应，初始路径矩阵记为path,然后经过
3次(依次对应3个顶点)演变成path2。初始 path(-如图6.33所示，path[i][j]=k的含义是：
从v,到v,的最短路径中，v,的前驱结点(父顶点)为v?,即初始假设直接的边就是最短路径(如果
不存在直接的边，D[i][j]=∞,最终也不会混淆)。图6.33给出了最短路径矩阵path(图6.33
中简写为P)的演变过程。其路径上的父顶点的修改完全取决于D矩阵中元素的修改。
一维一-淮
图6.33 Floyd算法把初始路径矩阵演变成最短路径矩阵的过程
下面考察一般情况下的Floyd算法。同样，我们从图的带权邻接矩阵出发，其基本思想
如下。
假设求从顶点e,到v,的最短路径。如果从v,到v,有弧，则从v,到v,存在一条长度为G[i][j]
的路径，该路径不一定是最短路径，尚需进行|V|次试探。首先考虑路径<v.,o,D,>是否存在(即
判别弧<v,,v?>和<v?,D>是否存在)。如果存在，则比较<v?,D>和<v,vo,D>的路径长度取长度较
短者为从v,到v,的“中间顶点的序号不大于0的最短路径”。
假如在路径上再增加一个顶点v?,也就是说，如果<D;;…,v?>和<v?,…,0,>分别是当前找到
的“中间顶点的序号不大于0的最短路径”,那么<v,…,D?,…,v,>就有可能是从 v,到v,的“中间
顶点的序号不大于1的最短路径”。将它和已经得到的从v,到v,“中间顶点序号不大于0的最短
路径”相比较，从中选出“中间顶点的序号不大于1的最短路径”之后，再考察下一个顶点v?,依
次类推。
在一般情况下，若<v,…,v>和<v,…,0,>分别是从v,到v和从v,到v,的“中间顶点的序号不
大于k-1的最短路径”,则将<v,,…,v?,…,v,>和已经得到的从v,到v,且中间顶点序号不大于k-1
的最短路径相比较，其长度较短者便是从v,到v,的“中间顶点的序号不大于k的最短路径”。这
样，在经过|V|次比较后，最后求得的必是从v,到v,的最短路径。
按此方法，可以同时求得各对顶点间的最短路径。
现定义一个|V|阶方阵序列。
D'-1,D°,D1,…,D"),DM-1)
其中：
D'-[i][j]=G[i][j];
D"[i][j]=min|D?1[i][j],D“[i][k]+D-[k][j]l,0≤k≤|V|-1。
从上述计算公式可见，D''[i][j]是从v,到v,的中间顶点的序号不大于0的最短路径的长
度；D*[i][j]是从v,到v,的中间顶点的序号不大于k的最短路径的长度；D-[i][j]就是从
244 第6章 图
v,到v,的最短路径的长度。
由此得到求任意两顶点间的最短路径的代码6.12。显然，算法的时间复杂度是0(|VI3)。
boo1 Floyd(MGraph Graph, WeightType D[][MaxvertexNum],Vertex path[ ][MaxVertex-1
Vertexi,j,k;
/*初始化·/
for(i=0;i<Graph->NV;i++)
for(j=0;j<Graph->NV;j++)
D[1][j]=Graph->G[i][j];
path[i][j]=-1;
for(k=0;k<Graph->Nv;k++)
for(i=0;i<Graph->Nv;i++)
for(j=0;j<Graph->Nv;j++)
if(D[i][k]+D[k][j]<D[i][i])
D[i][j]=D[i][k]+D[k][j];
if(i==j D[i][j]<0)/*若发现负值圈*/
return false;/ 不能正确解决，返回错误标记*/
path[1][j]=k;
return true;/*算法执行完毕，返回正确标记·/
Num])
代码6.12 Floyd 算法
注意：当图中存在负值圈(即存在顶点v,有D[i][i]<0)时，Floyd 算法是无法得到正确结果
的，这时程序要返回错误标记。
6.7 拓扑排序
在现实生活中，某些事物可以用有向无环图(Directed Acyclic Graph,DAG)表述。这种有向
无环图通常也称作“流程图”,比如，施工流程图、生产流程图，图中每个顶点可以代表一个具体
的工序，每条有向边则反映了两个工序的前后次序。
我们所要讲的拓扑排序是指用有向无环图中各顶点构成有序序列。设图中一顶点v,到另一
顶点v,存在一条路径，那么v,在此图的拓扑排序序列中位于v,之后。
6.7 拓 扑排 序 245
如果不是无环图，拓扑排序将不存在，因为如果有环路的话，那么对于环路上的两个顶点D
和w,既可以认为v在w之前，也可以认为w是在v之前，它们之间的先后顺序是不确定的。
图6.34为某大学计算机专业学生必修的课程以及这些课程之间的先后顺序关系。其中顶
点为课程编号，两顶点间的有向边表示它们之间的预修关系。比如，课程C?到C,以及C?到C,分
别有两条有向边，表明学习C,之前，必须已经完成C和C?的学习，以具备一定的基础。表6.3
列出了课程名称及其各课程要求具备的先修基础。
G
G
G
@
C
图6.34 课程设置
表6.3 课 程 列 表
课程编号 课程名称
程序设计基础
离散数学
数据结构
高等数学1
高等数学2
线性代数
汇编语言
数据库
操作系统
计算机组成原理
编译原理
计算机网络
先修课程
C? 无
C? 无
C, C.,C?
C. 无
C? C.
C. C?
C, C,,C?
C, C?
C。 C,
C? C,
C C??
C口 C,
按拓扑排序的定义，下列两种顶点序列都是图6.34的拓扑排序：
C,,C?,C?,C?,C,,C?,C,,C?,C,,C10,C,C12
C.,C,C?,C?,C?,C?,C,,Cg,C。,C1,C12,C??
当然图6.34的拓扑排序并不只是上述两种，还可以列出其他许多有效序列。
可以采用一种十分简单的思想实现拓扑排序，只要先找到任何一个人度为0的顶点，然后输
246 第6章 图
出该顶点，并从图中删除该顶点以及与其相连的所有边。对改变后的图重复这一过程，直到所有
顶点输出为止。可以这样实施的依据是基于下面的结论：一个顶点数|0|>1的有向图，如果每
个顶点的入度都大于0,那么它必定存在回路。
代码6.13给出了拓扑排序算法的伪代码。用数组 Indegree存储各顶点的人度，当Indegree[V]
为0时，表示顶点v可作为拓扑序列的输出点；TopOrder顺序存储排序后的顶点下标(所以在拓
扑排序完成后直接顺序打印 TopOrder 就得到了拓扑有序序列的输出)。
bool TopSort(Graph Graph,Vertex Toporder[])
1/*对Graph进行拓扑排序，Toporder[]顺序存储排序后的顶点下标*/
/*遍历图，得到各顶点的入度Indegree[ ];*/
for(cnt=0;cnt<Graph->Nv; cnt++)
V=未输出的入度为0的顶点；
if(这样的V不存在)「
printf(·图中有回路");
break;
十
Toporder[cnt]=V;/*将V存为结果序列的下一个元素*/
/* 将V及其出边从图中删除*/
for(V的每个邻接点W)
Indegree[W]--;
if(cnt !=Graph->Nv)
return false;/* 说明图中有回路，返回不成功标志*
else
return true;
代码6.13 拓扑排序算法的伪代码
在TopSort中，比较耗时的是找到下一个“未输出的入度为0的顶点”,如果要检查整个Inde gree 数组，所需时间是0(|vl),且循环结构决定了这一步要进行|0|次，因此，本算法的时间代
价为0(|vl2)。
而实际上，每次图的改变往往只会涉及少数顶点的入度发生变化，没有必要每次都查看整个
Indegree 数组。为了提高算法的时效，可以改进上述算法，将入度为0的顶点单独存放，每当删
除一个顶点而改变其他顶点的入度时，检测到入度为0的顶点，就存放到这个专门开辟的存储区
域，而这个区域可以用各种不同的结构实现。
例如，我们可以用一个队列实现这个特定存储。开始时将所有入度为0的顶点插入队列；当
队列不为空时，取出一个顶点v并输出；然后将与v相邻的顶点入度减1。当产生新的入度为0
6.7 拓 扑 排序 247
的顶点时，将其插入队列。重复这一过程直到队列为空时算法终止。所要寻找的拓扑排序为各
顶点从队列取出的顺序。改进后的算法如代码6.14所示，这里我们用邻接表表示图。
bool TopSort(LGraph Graph, Vertex Toporder[])
|/*对Graph 进行拓扑排序，Toporder[]顺序存储排序后的顶点下标*/
int Indegree[MaxVertexNum],cnt;
Vertex V:
PtrTOAdjVNode W;
Queue QCreateQueue(Graph->Nv);
/* 初始化 Indegree[]*
for(V=0;V<Graph->Nv;V++)
Indegree[V]=0;
/* 遍历图，得到Indegree[]·/
for(V=0;V<Graph->Nv;V++)
for(W=Graph->G[V].FirstEdge;W;W=W->Next)
Indegree[W->Adjv]++;/* 对有向边<V, W->AdjV>累计终点的入度*
/ 将所有入度为0的顶点入列·/
for(V=0; V<Graph->Nv;V++)
/* 下面进入拓扑排序*/
cnt=0;
while(!ISEmpty(Q))
V=DeleteQ(Q);/* 弹出一个人度为0的顶点*/
Toporder[cnt++]=V;/* 将之存为结果序列的下一个元素*/
for(W=Graph->G[V].FirstEdge;W; W=W->Next)
if(--Indegree[W->Adjv]==0)/*若删除V使得W->AdjV入度为0*/
AddQ(Q,W->AdjV);/*则该顶点人列*/
/* while结束·/
if(cnt!=Graph->Nv)
return false;/*说明图中有回路，返回不成功标志*/
return true;
if(Indegree[v]==0)
/ 对V的每个邻接点W->AdjV*/
else
AddQ(Q,V);
代码6.14 改进后的拓扑排序算法
248 第6章 图
图6.35(a)~(i)详细列出了有向图6.35(a)的拓扑排序过程。
表6.4概括了上述过程，表的上方“顶点入度变化”包含8列数据，对应于图6.35(b)~(i)。
表的底端两行列出了顶点出入队列的情况，与图6.35中每图下面队列的形象表示是一致的。从
顶点出队列的结果可以得到图6.35(a)的一种拓扑排序为(v?,Da,0?,vs,v?,6,V,,vs)。
) V
② ② ②
S S
(a)顶点1、4入队 (b)顶点1出队，顶点2入队 (c)顶点4出队，顶点5入队
V8 v)
以
哆
4② O 哆 2
(d)顶点2出队 (e)顶点5出队，顶点3、6入队 (1)顶点3出队
O②哆 O 2s O
(g)顶点6出队，顶点7入队 (h)顶点7出队，顶点8入队 1)顶点8出队
图6.35 有向无环图的拓扑排序过程
6.8 关键路径计算 249
表6.4 拓扑排序过程列表
顶点入度变化(1:初始→8:结束) 顶点 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0
3 2 2 1 0 0 0 0
D 0 0 0 0 0 0 0 0
1 1 0 0 0 0 0 0
1 1 1 1 0 0 0 0
, 2 2 2 2 2 1 0 0
2 2 2 2 2 1 1 0
入队列 v, s % P
出队列 B? ? s , V
如果图的表示采用邻接表，改进后的算法所付出的时间代价为0(|E|+|V|)。拓扑排序
算法可以用来检测一个有向图是否是DAG。
6.8 关键路径计算
通过6.7节介绍的拓扑排序，我们知道，现实生活中，许多任务可以分解为一系列活动，各个
活动之间是相互关联的，关系可以是串行的，也可以是并行的。合理地调度和安排各活动，保证
在计划时间内完成任务是十分重要的。
本节所要讲的关键路径分析，适合于规划工程项目，解决类似“工程完成的最早时间是什么
时候?”“一个工程中哪些活动可以适当延迟，可以延迟多长时间，而不影响整个工期?”等问题。
仿照拓扑排序给出的网络表示，一个工程可以用无环有向图表示。图中的顶点代表活动，并
记录完成它的时间。图中的边表示活动的先后关系，有向边<v,w>意味着活动v必须在活动w
开始之前完成。这种顶点表示活动或任务的图也称为AOV(Activity On Vertex)图。图6.34是
一个AOV图，图6.36也是一个AOV图。
[例6.19]图6.36中结点内大写字母A~H表示活动，字母右下角括起来的数字表示完成
此活动所需的时间。分析图中活动时间可知道，完成路径A、C、F、H上的各活动需要11个时间
单位，这几个活动中任意一个的延迟都会延长整个工期，实际上这是一条“关键路径”。但活动
B可以延迟3个时间单位，并不会影响整个工程的完成进度，相对于关键路径，包含活动B的路
径是非关键路径。
250 第6章 图
C) Fa)
Am) H) 完成
开始、 Da) Ga)
Ba)
E
k
图6.36?表示一个工程活动关系的AOV图
为了便于分析关键路径，我们将活动为顶点的AOV图转换为活动为边的AOE(Activity On
Edge)图，有向边表示任务或活动，边上的权表示该活动持续的时间。在AOE图中顶点表示事
件，每个事件对应一个活动及其与之相关的其他活动的完成。图6.37是对应于图6.36的AOE
图，顶点1和顶点10分别表示工程的开始和完成事件。
如果一个活动是在几个活动完成后才能开始的话，需要增加虚构的边和结点，来表示活动之
间的这种依赖关系。例如，从图6.36中我们知道，活动D是在活动A和B都完成后才能进行。
A和B两个活动的完成在图6.37中表示为结点2和3两个事件，在这两个事件之间引入虚构结
点6'(灰色表示)和两条0标识(该活动所需时间为0)的虚构活动边，使得活动D是在A、B完成
后才能开始。同样还有活动F、G、H,它们也是依赖多个先前的活动，因此，引人虚构结点7'、8'、
10'和相应的虚构边。
2
C/4 ④ 0 F/3
A/3 0 ⑦ 0
0
① D/2 H/I
6
0 ⑩
B/2 0
0
G/2 8 0
0
③ E/I ⑨
⑤ K/4
图6.37 对应于图6.36的AOE图
可以用以下方法简化图6.37:对出度为1的顶点，如果其出边的权重是0的话，可以删去该
顶点及其出边，该顶点的入边直接指向后面的顶点。比如，顶点4、7、8和9就可以删去而不会影
响整个图的意义。调整顶点序号如图6.38所示。
为了能够确定工程的最早完成时间，只需在开始事件到完成事件间寻找最长有向路径，它的
长度就是答案。路径长度是指这条路径上所有活动时间的总和。
可以通过求解树中每个结点(事件)的最早完成时间，来计算整个工程的最早完成时间。若
Earliest[i]表示结点i的最早完成时间，C.表示<v,w>边的权重，则有：
Earliest[1]=0
Earlies[w]=max(Earliest[V]+c,)
6.8 关键路径计算 251
按照AOE图中各事件的先后次序，从起始事件开始，依次用上式求出各事件结点的最早完
成时间，直到最后推算到结束事件为止，也就得到了整个工程的最早完成时间。图6.38中各顶
点的上方标出了我们所举例子的各事件最早完成时间，在结束事件上方标出的11个时间单位是
整个工程的最早完成时间。
3
② C/4 7
0
A/3 0
3
① 4
D/2 5 0 ⑦ F/3
6
B/2 2
0
0 5
10
G/2
③ E/I 3 0
8
9
H/1 11
⑩
⑤ K/4
图6.38 各顶点事件最早完成时间
同样，还可以求解每一事件i在不影响整个工程完成情况下的允许最晚完成时间Latest[i]。
计算是从结束事件开始，设结束顶点为事件n,按事件拓扑的相反次序逐个顶点推算，直到工程
的初始顶点为止。结束顶点的最晚完成事件等于它的最早完成时间，其他顶点按下式计算：
Latest[n]=Earliest[n]
Latest[v]=min(Latest[w]-c,)
图6.39标识出了上面例子中各事件的最晚开始时间，具体数值是标注在各顶点的下方。
A/3
②
3
C/4
0
0 ⑦ F/3
① ④
D/2 6
7
0
B/2 0
0
5 7
③ E/1 0
8
G/2 9
H/I ⑩
8
5 ⑤
K/4 10 11
6
图6.39 各顶点事件最晚完成时间
各顶点的最早和最晚完成时间被求出以后，能够很容易地确定在不影响工程进度的前提下，
每一活动最多能耽误的时间长短。这个时间是否为0决定了该活动是否为关键路径。求<v,w>
边上的允许耽误的最大时间Delay.采用的计算公式为：
Delay.=Latest[w]-Earlieat[v]-C
图6.40标识出了各活动的允许耽误时间，其数值添加在图中各边活动所需时间的后面，并
用斜杠“/”分割开来。而Earliest[i]和Latest[i]仍然标注在顶点的上方和下方。
显然，最多能耽误的时间为0(即不允许有时间耽误)的活动都是关键活动(Critical Activity),
由关键活动构成的从头至尾的路径就是关键路径(Critical Path)。本例中A、C、F、H是关键活
动，而其他活动的允许耽误时间都大于0,所以不是关键活动。
252 第6章 图
3
② C/4/0 Z
A/3/0
0
30
3
① ④
D/2/2 5
0 ⑦ F/3/0
6
0 B23 0
5
7
5
10 11
③ E/1/3
7
3
G/2/3
0
8
9
H/1/0 ⑩
5
8 K/4/3 10 11
5
6
图6.40 活动的可延迟时间
6.9 应用实例
6.9.1 六度空间理论
六度空间理论又称作六度分隔(Six Degrees of Separation)理论。这个理论可以通俗地阐述
为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个中间人你就
能够认识任何一个陌生人。”该理论产生于20世纪60年代，由美国心理学家米尔格伦 Stanley
Milgram(1933—1984)提出。六度分隔现象又称为小世界现象(small world phenomenon)。
有这么一个故事，几年前一家德国报纸接受了一项挑战，要帮法兰克福的一位土耳其烤肉店
老板，找到他和他最喜欢的影星马龙·白兰度的关联。结果经过几个月，报社的员工发现，这两
个人只经过不超过六个人的私交，就建立了人脉关系。原来烤肉店老板是伊拉克移民，有个朋友
住在加州，刚好这个朋友的同事，是电影《这个男人有点色》的制作人的女儿在女生联谊会的结
拜姐妹的男朋友，而马龙·白兰度主演了这部片子。
用无向图的路径来描述上述的“关联关系”如图6.41所示。S表示烧烤店老板，D表示影星
马龙·白兰度，中间间隔了5个人。
⑤ O
朋友 同事 男友干姐妹 父女 同事 ①
图6.41 关联关系的路径
“六度空间”理论的应用价值越来越受到人们的关注。无论是人际网络，还是万维网的架
构，还是通过超文本链接的网络、经济活动中的商业联系网络、生态系统中的食物链，甚至人类脑
神经元以及细胞内的分子交互作用网络，有着完全相似的组织结构。通过网络使“六度分隔”理
论对人与人之间都可以构成弱纽带，当然理想的状态是人人都置身在连接的世界中，这个目标在
6.9 应用 实 例 253
不断接近。社会中普遍存在“弱纽带”,通过弱纽带人与人之间的距离变得非常“相近”,这在社
会关系中发挥着非常强大的作用。经常运用六度分隔理论的领域有：直销网络、电子游戏社区、
SNS网站和BLOG网站等。
但是，在过去的数十年的时间里，米尔格伦的理论从来没有得到过严谨的证明，虽然屡屡应
验，虽然很多社会学家一直都对其兴趣浓厚，但它只是一种假说。现在，美国两所不同大学的社
会学家们正在分别对此进行研究，它们都不约而同地使用了网络时代的新型通信手段——
Email——来对“小世界现象”进行验证。
2001年，哥伦比亚大学社会学系的登肯·瓦兹主持了一项最新的对“六度分隔”理论的验证
工程。166个不同国家的六万多名志愿者参加了该研究。瓦兹随机选定18名目标(比如一名美
国的教授、一名澳大利亚警察和一名挪威兽医等),要求志愿者选择其中的一名作为自己的目
标，并发送电子邮件给自己认为最有可能发送邮件给目标的亲友。到目前为止，瓦兹在世界
顶级的科学学术期刊《科学》杂志上发表最新论文表明邮件要达到目标，平均也只要经历5~7
个人。
“六度分隔”假说的出现使得人们对于自身的人际关系网络的威力有了新的认识。但为什
么偏偏是“六度分隔”而不是“七度”、“八度”或者“千百度”呢?这可能要从人际关系网络的小
世界性质的另外一个特征“150定律”来寻找解释。其数学解释(但并不是证明)如下：若每个人
平均认识150人，其六度就是150?=11 390 625 000 000人。这个数字远超过人类历史上所有各
代的人数总和。
“150定律”可以简单描述为“人类可以与大约150人左右建立比较合适的人际关系”。从
《纽约客》杂志的专栏作家马可姆·格兰德威尔在他的著作《引爆流行》中考证了一个名为“郝特
兄弟会”的欧洲农民组织，这个组织有个约定俗成的规定：一个聚居点的人员规模超过150个人
时，就要将该聚居点变成两个，这两个点再进行“150-分离-150”的循环。格兰德威尔说：“把人
群控制在150人以下似乎是管理人群的一个最佳和最有效的方式”。古往今来，许多团体建制
都无意识地采用了这条规律。例如：在14世纪以后瑞典陆军编有旅，每旅辖3个营，每营辖4个
连，每连编150人。人们不免要问为什么偏偏是150人这个数字呢?人类学家特蕾茜·H·约
菲研究发现人类所能处理的社会信息与人类的大脑的视觉和社会认知能力的发达程度有关。由
罗宾·邓巴领导的研究小组1993年报道了动物种群的规模与其大脑新皮层相对于整个大脑
比例相关，在现代人，这个规模是147人左右。进而，邓巴在2002年通过西方人比较熟悉圣
诞卡片交换行为的调查发现这个人数在153左右。类似的大量研究都表明“150定律”的科
学性。
6.9.2 六度分隔理论的验证
显然，社会学家主持的验证研究，都不约而同地使用了网络时代的新型通信手段——Email。
然而，这样的研究具有太大的局限性和困难。其一，使用Email保持社会关系的人群有较大的局
限性。其二，我们很难记录和跟踪所有Email的走向，这是一个信息量太过巨大的工程，即便只
254 第6章 图
涉及数万名志愿者，也需要一个非常长的周期才能完成。其三，志愿者很可能会遗漏一些与之相
识的人，而这些人或许刚好就是快速通往目标人的中间人。其四，整个过程有赖于志愿者的意
愿，部分或许是重要的中间人，可能没有兴趣为这个验证转发Email。
现代人用电话和短信保持联络的远远大于用Email保持联络。截至2011年初，我国三大运
营商的手机和固话用户数大约在11亿(中国移动的用户数量已经接近6亿，联通和电信各超过
2.5亿),除去部分重复使用者，应该有10亿用户左右。基本上覆盖了全部成年人口。由于电话
和短信的通信都有一个运行服务商，从而人脉关系的数据已经集中在服务商那儿，不需要再进行
跟踪。因此采用现成的电话和短信通信信息，很容易建立两个人是否为“认识”的关系。比如，
假定任意两个人在一年内，电话或短信相互收发两次以上定义为两人“认识”,这可以排除绝大
部分的广告电话和广告短信。
实际操作中，由于竞争和保密的原因，运营商对用户的通信数据不会公开。因此，我们只能
理论上介绍并分析验证“六度空间理论”的思想方法。
“六度空间理论”可以形式化描述成以下图论中的最短距离问题：首先，用一个无向图G来
表示N个人的人际关系网络。假定有N(N=10亿)个人，用图G的一个顶点表示一个人，那么
该图有N=10°个顶点。两个人“认识”与否，用代表这两个人的顶点之间是否有一条边来表
示，如果平均每个人“认识”其他150个人，则该图大约有150×N/2=75×10°条边，并假定边上
的权值都是1。“六度空间理论”可以陈述为：在人际关系网络图G中，任意两个顶点之间都
有一条最短距离不超过6的路径。在实际验证过程中，可以改用一定的百分比(比如99???
陈述：在人际关系网络图C中，任意一个顶点到其余99??上的顶点都有一条最短距离不超
过6的路径。
要求每一对顶点之间的最短距离，理论上采用6.6.2节的Floyd算法，就可以完全解决问
题。但是由于这个算法的空间复杂度是0(N2),时间复杂度是0(N3),这对于N=10°规模的问
题来说，这个复杂性太大，没有实施的可能。
另一种思路是，随机抽样部分人进行验证。每次以某个顶点为源点，执行6.6.1节的Dijkstra
算法，可以计算一个人到其余所有人之间的最短距离。因为这个图是稀疏图，可以用邻接表作为
存储结构并用第4章介绍的优先队列进行 DeleteMin 操作。它的时间界大约可以改进为
0(|E|log|V|)~75×102×log 10°~75×103×30~2250 C。对于现代每秒万亿次运算速度的计
算机来说，在几秒钟可以验证一个顶点，每天可以验证近万人。从存储的角度看，采用邻接表存
储该图，如果每个顶点平均有150个左右的邻接点，大体上会有数百个吉(G)的存储量。因此在有
太(T)数量级存储的超大型计算机上可以实现。为了解决存储的问题，还
可以考虑把这个邻接表存储在外存的数据库上(需要付出增加时间的代
价),内存中只存储当前的最短路径长度和当前路径(表6.2中的D向量和
P向量),它们分别需要数吉(G)的存储量。 微视频6-7
六度空间 求得一个人到其余所有人的最短距离以后，就很容易计算出最短距离
不超过6的顶点所占比例。
6.9 应 用 实 例 255
还有一种更好的思路是，不用Dijkstra算法。首先，我们把人际关系网络图G看成是一个不
带权的图。然后，“六度空间理论”也可以陈述为：在人际关系网络图G中，任意两个顶点之间都
有一条路径长度不超过6的路径。可以采用6.4.3节广度优先搜索(BFS)的方法，对任意一个
起点，通过对图G的“6层”遍历，就可以统计出所有路径长度不超过6的顶点数。从而得知这些
顶点在所有顶点数中的所占比例。代码6.15是算法的实现。该算法的时间复杂度是0(|E|+
|V|)≈75×10°≈100 G,对于现代每秒万亿次运算速度的计算机来说，每秒钟可以验证数个顶
点，每天可以验证数万人。空间复杂度与Dijkstra算法相当，需存储 Visited 向量和当前队列向
量，它们分别需要数个吉(G)的存储量。
#define SIX6
int visited[MaxVertexNum];
void InitializeVisited(int Nv)
Vertex V;
for(V=0;V<Nv;V++)
Visited[V]=false;
一
int SDS_BFS(LGraph Graph,Vertex S)
1/*以S为出发点对Graph进行6层BFS搜索*
Queue Q;
VertexV, Last,Tail;
PtrTOAdjVNode W;
int Count,Level;
Q=CreateQueue(MaxSize);/创建空队列，MaxSize为外部定义的常数*/
Count=1;
Level=0;
/统计人数从1开始*人
Last=S;
AddQ(Q,s);
/* 该层只有s一个顶点，是该层被访问的最后一个顶点·/
while(!ISEmpty(Q))
V=DeleteQ(Q);/* 弹出V*/
for(W=Graph->G[v].FirstEdge;W;W=W->Next)|/*对V的每个邻接点W->AdjV*/
if(!Visited[W->Adjv])I/*若W->AdjV未被访问/
Visited[s]=true;/*标记S已访问·/
/*起始点定义为第0层*/
/*S入队列*/
256 第6章 图
Visited[W->Adjv]=true;/* 标记W->AdjV已访问/
Count++; /·统计人数*/
Tail=W->AdjV; /*当前层尾*/
AddQ(Q.W->AdjV);/* W->AdjV入队列*/
if(V==Last)I/·如果上一层的最后一个顶点弹出了·/
Level++;/* 层数递增/
Last=Tail;/* 更新当前层尾为该层被访问的最后一个顶点*/
if(Level==SIX)break;/*6层遍历结束，退出搜索·/
/* while结束*/
DestroyQueue(Q);
return Count;/*返回统计数据·/
void Six_Degrees_of_Separation(LGraph Graph)
/*用邻接表存储图，对每个顶点检验六度空间理论*
Vertex V;
int count;
for(V=0;V<Graph->Nv;V++)I/ 对图中的每个顶点V*/
InitializeVisited(Graph->Nv);
count=SDS_BFS(Graph,V);
printf(·顶点者d的六度覆盖比例=8.2f?n",v,100.0*(double)count(double)
Graph->Nv);
代码6.15 统计路径长度不超过6的顶点数比例
算法SDS_BFS没有给出路径上的这六个中间人是谁，需要这些信息的话，也不难修改算法
得到它们。
现在回到原始问题，“六度空间”理论中所指的“每个人”应该是指全球的70亿人口，上述的
讨论从原理上可以应用于全球每个人。但是，出于比较现实的可获得原始数据的原因，我们把范
围暂时限定在国内，或者相对容易实现的某一个“电话运营商”用户的范围内。有兴趣的研究学
者不妨寻求与运营商合作来验证一下。
本 章小 结 257
本 章 小 结
相对于线性表和树，图这种数据结构具有更强的描述现实问题的能力。正如线性表是树的
特例一样，线性表和树都可以看成图的特例，因而利用图数据结构能解决更为广泛和复杂的问
题。相应地，在计算机中表达一个图及其相关的操作也要复杂得多。
存储一个图的常用方法主要有两种，即邻接矩阵和邻接表。前者属于顺序存储，需要θ(|VI2)
的存储空间；后者属于顺序存储和链式存储的结合，需要θ(IVI+|E|)的存储空间。对于稠
密图来说，两者差别不大，由于前者的结构简单，所以是首选；对于稀疏图来说，后者比较省空间，
当|V|比较大的时候，节省的空间就相当可观，对于超级巨大的|V|来说(比如6.9节的应用实
例),前者可能就无能为力，你非选择后者不可了。
不同的存储结构也会影响算法的时间复杂性。一般来说，稀疏图采用邻接表存储可以大大
提高从顶点寻找邻接边的处理效率，从而提高算法的时间性能；稠密图可以首先考虑较为简单的
邻接矩阵存储结构。
6.4.1节迷宫探索的思路很好地表达了深度优先搜索(DFS)的过程，其实现的核心技巧是
利用一个辅助的堆栈。实现广度优先遍历(BFS)的核心技巧是利用一个辅助的队列。应用中，
选择 DFS还是BFS进行遍历，主要看遍历的目的是什么。如果仅仅为了访问每个顶点，选用哪
个方法都可以。但是如果图的顶点和边的数量庞大，遍历的目的也只是寻找某合适的顶点，那么
选择哪种遍历方式就有讲究了。如果估计目标顶点离开起始顶点不会太远，那么选择广度优先
遍历是比较合适的，因为它是一种由近及远的搜索策略，有较大的可能性快速找到目标；如果估
计目标顶点与起始顶点没有太大的关系，那么选择深度优先遍历是比较合适的，深度优先是通过
邻接点尽快接近较远目标的搜索策略。举个未必十分准确却也类似的例子，在野外寻找失踪人
员，搜索方法也可以有两种。假如失踪时间不长，可以采用类似于广度优先策略的“地毯式”搜
索，因为我们估计失踪人员短时间内不会离开很远，快速搜索成功的可能性也比较大；假如失踪
时间已经很长久，最好的策略是沿着失踪人员留下的“足迹线索”不断跟踪搜索，这类似于深度
优先策略，而费时盲目的“地毯式”搜索显然无助于快速找到失踪者。
6.5节的最小生成树不仅解决了本章一开始提出的公路村村通问题，其现实应用非常广泛，
一般的最小连通成本问题都可以通过最小生成树算法求得最优解。普利姆(Prim)算法和克鲁
斯卡尔(Kruskal)算法分别从顶点出发和从边出发，最后“扩展”成一棵代价最小生成树，算法思
想都是采用“贪婪”的方法，从时间效率上来说，前者适合稠密图，后者适合稀疏图。
6.6节讨论最短路径问题。主要讨论了两个问题，即边上正权值图的“单源最短路径问题”
和“任意两个顶点的最短路径问题”。前者采用迪杰斯特拉(Dijkstra)算法，算法思想是“贪婪”
方法，时间和空间效率都比较高；后者采用弗洛伊德(Floyd)算法，算法思想是“动态规划”方法。
最短路径问题算法的应用也很广泛，现代人们常用的汽车导航系统就是一个直接的应用。
6.7节的拓扑排序是解决一个“项目流程规划图”的合理性问题，即判断其是否属于有向无
258 第6章 图
环图(DAG),若是则给出一种可行的顺序。而6.8节的关键路径问题是在此基础上，进一步找
出哪些活动是影响项目工期的关键活动。不过，如果仅仅是拓扑排序问题的话，DAG可以描述
成不带权的AOV(顶点表示活动)就可以了，而如果要进一步解决项目工期问题，那么,“项目流
程规划图”就应该描述成一个带权的AOE(边表示活动)才比较方便。
在涉及全图的问题中，算法的时间代价0C|E|+|V|)通常是最优了，因为考察每个顶点和
边一次就需要这个时间复杂性。如果是稠密图，则0(|VI2)的时间代价算法也是最优的了。
另外一个问题，应用非常广。理论上是哈密尔顿回路(Hamilton Cycle)问题，它的提法可以
简单陈述为“是否存在仅仅经过各个顶点一次的回路”。但是它的一些变形的提法可能更具现
实应用背景：“寻找至少经过各个顶点一次的最短回路”。我们把它叫做巡回售货员问题(Trave ling Salesman Problem,TSP),也叫货郎担问题。它不是最短路径问题，也不属于最小生成树问
题。令人遗憾的是，至今没有找到解决TSP的多项式时间界的方法。事实上，到目前为止的研
究表明，这类问题很可能需要指数时间界的算法才能解决，但这个结论仍然只是一个猜测。同属
于哈密尔顿回路的变形问题还有：最佳旅游线路问题、最佳灾情巡视路线选择问题、印刷电路板
最优穿孔问题等。
同样非常著名、并且也有相同难度的问题还有：装箱问题、背包问题、图的着色、团问题等，读
者如果有兴趣，建议查阅有关文献或网站资料。
欧拉回路(Euler Cycle)问题看起来似乎与哈密尔顿回路问题有点相似，它的提法简单陈述
为“是否存在仅仅经过各条边一次的回路”,所以也叫图的“一笔画”问题。它的一个著名应用就
是“哥尼斯堡七桥问题”。然而令人惊奇的是，判断是否存在欧拉回路和寻找一条欧拉回路的时
间界只需要0(|E|+|V|)!理论的结果非常简单：存在欧拉回路的充分必要条件是所有顶点
的度均为偶数。找到一条欧拉回路的算法同样不复杂：采用一次深度优先搜索可以得到一个回
路，在原图中删去这个回路后再次进行深度优先搜索，拼接得到的各个回路就可以得到覆盖所有
边的欧拉回路。具体算法读者可以查阅有关资料。
习 题
6.1 判断正误。
(1)用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。
(2)用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。
(3)无向连通图所有顶点的度之和为偶数。
(4)在任一有向图中，所有顶点的入度之和等于所有顶点的出度之和。
(5)如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。
(6)如果从有向图G的每一点均能通过深度优先搜索遍历到所有其他顶点，那么该图一定不存在拓扑序列。
(7)如果e是有权无向图G唯一的一条最短边，那么边e一定会在该图的最小生成树上。
6.2 填空题。
(1)在用邻接表表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度为_。
习题 259
(2)如果G是一个有28条边的非连通无向图，那么该图顶点个数最少为_____。
(3)在一个有权无向图中，如果顶点b到顶点a的最短路径长度是10,顶点c与顶点b之间存在一条长度
为3的边。那么c与a的最短路径长度____。
6.3 设无向图为G=(V,E),其中V=|v?,v?,西，I,E=|(?B?),(p?,n.),(?.n,),(v?,v,),(v,v,)|。请
回答下列问题：
(1)画出该图。
(2)分别写出每个顶点的度。
(3)画出相应的邻接矩阵。
6.4 已知有向图如图6.42所示，请给出该图的
(1)每个顶点的入度和出度。
(2)邻接矩阵。
(3)邻接表。
(4)逆邻接表。
(5)各个强连通分量。
6.5 已知一个无向图的顶点集为{V.V?.….V,I,其邻接矩阵如下所示：
v,
V
(1)画出该图的图形。
(2)给出从V。出发的深度优先遍历序和广度优先遍历序。
6.6 设有图的数据逻辑结构 B=(K,R),其中：顶点K=+k,,k?,…,kI,有向边集R=|<k,,k,>,<k,,kg>,
<k?,k?>,<k?,k>,<k?,k?>,<k,,k>,<k,,k>,<kg,k,>,<k,,k?>,<ka,k>,<k,,k>|。
(1)请在图6.43中完成，画出这个逻辑结构的图示。
① ⑤
A
6
② ④
③
图6.42 题6.4图 图6.43 题6.6图
260 第6章 图
(2)对该DAG图，分别举出四个拓扑序列的例子(开始结点和结束结点不完
全相同)。 a 4
(3)给出从顶点k,出发深度优先搜索遍历该图的顶点序列(有多种遍历方式
时，顶点标号小者优先)。
3/ 9
e) 3
b 7
6 ①
6.7 根据图6.44所示的无向带权图回答下列问题： 8
5
d 2
(1)写出它的邻接矩阵。 5
4
5
8
(2)画出图6.44的最小生成树。 c 5
h 6
(3)给出从顶点a出发深度优先搜索遍历该图的顶点序列(多个顶点可以选
择时按字母序)。 图6.44 题6.7图
6.8 给定一个图的邻接矩阵如下：
v V? V, V V V V, V V。 V1
V? 0 1 1 1 0 0 0 0 0 0
V? 0 0 0 1 1 0 0 0 0 0
V? 0 0 0 1 0 1 0 0 0 0
V 0 0 0 0 0 1 1 0 1 0
v, 0 0 0 0 0 0 1 0 0 0
v 0 0 0 0 0 0 0 1 1 0
V, 0 0 0 0 0 0 0 0 1 0
V 0 0 0 0 0 0 0 0 0 1
V, 0 0 0 0 0 0 0 0 0 1
V 0 0 0 0 0 0 0 0 0 0
(1)在图6.45中画出该图的边：
(2)从V,出发的深度优先遍历序列(DFS,有多种选择时小标号优先)。
(3)从V,出发的宽度优先遍历序列(BFS,有多种选择时小标号优先)。
6.9 试利用Dijkstra算法求图6.46中从顶点A到其他顶点的最短距离及对应的路径，写出计算过程中各
步状态。
4
(B 6
E
9
15 8
A
2
C G
12 4
10
D
5
F
3
图6.45 题6.8图 图6.46 题6.9图
习题 261
6.10 给出如图6.47所示的具有7个结点的网G。请；
(1)画出该网的邻接矩阵。
(2)采用Prim算法，从4号结点开始，给出该网的最小生成树(画出Prim算法的执行过程及最小生成树的
生成示意图)。
0
1 3
① 6
5
3
②
4 6 4
2 5
③ 2 ④
7 1
⑤
图6.47 题6.10图
6.11 试利用 Floyed算法，求如图6.48所示有向图的各对顶点之间的最短路径，并写出在执行算法过程
中，所得的最短路径长度矩阵序列和最短路径矩阵序列。
6.12 给定如图6.49所示的有向图，请问其不同的拓扑排序序列有几种，请给出按字母序从小到大的拓扑
序列。
6
A
2 D
(a)
8
6 ④
3 4 3
B 2
C e ①
图6.48 题6.11图 图6.49 题6.12图
6.13 一个工程项目由下列A~L共12个活动构成，各活动的持续时间和前驱活动如表6.5所示。
表6.5 题6.13表
活动 持续时间 前驱活动 活动 持续时间
15
17
10
8
15
33
G
无无A H
I
J
C,D K
B L
10
40
20
25
30
20
B
前驱活动
A
B
C
D
E
G
E
I
E F
F H,J,K
262 第6章 图
(1)画出表示该工程项目的AOE网络图。
(2)列出图中各顶点(状态)的最早发生时间和最迟发生时间。
(3)计算完成该项目的所需时间；指出哪些是关键活动。
6.14 参考代码6.1和代码6.2,把它们修改成根据问题的大小(顶点数n)动态分配一维 Data数组和二维
G矩阵的大小。
6.15 参考例6.12,以图6.20(a)的无向图G,为例，进行图的深度优先搜索。假设从顶点C出发进行搜索。
6.16 参考例6.13,以图6.20(a)所示无向图G,,进行广度优先搜索遍历，假设从顶点C出发进行搜索。
6.17 若选择邻接表作为图的数据结构，请改造代码6.7。
第7章
排 序
7.1 引子
前面我们已经学习过线性表、树、图等数据结构，数据结构和算法是密不可分的，特定的算法
需要特定的数据结构才能发挥出应有的效率。本章我们来谈谈最常见的一类算法：排序。
在计算机中，所谓排序就是将一组无序的记录序列调整为有序的记录序列，是计算机处理问
题时经常会遇到的一项工作。一个排序算法是指一种能将一串记录序列按照某种特定的方式进
行调整的一种方法。
请大家试想下，如何让计算机将7,6,3,4,2,5,1这组序列排成从小到大的序列?就算完全
没有排序算法的概念，相信读者也能找到办法来解决这个问题。有些读者可能已经学过一些简
单的排序方法，比如冒泡排序、直接插入排序等，这些简单排序方法都可以很好地解决类似前面
这种数据量比较小的排序问题。那么现在换个问题，如果要对Google的搜索关键词进行排序，
选出10大热门关键词，请问该如何实现?对于这类数据量很大的问题，排序算法的效率就非常
关键。
接下来让我们通过例子来了解与排序密切相关的一个问题，从中可以看到，相同的问题，由
于采用的算法思路不同，最终问题求解的效率差别会很大。
[例7.1]有1亿个随机给出的浮点数，请找出其中最大的1万个。假设每个浮点数占4个
字节。
[分析]解决该问题的办法有很多，下面列举3种。这里我们重点分析问题的求解思路，并
关注它们的时间复杂度。读者通过本章的学习可以编写出具体的程序。
方法1:
每个浮点数占4个字节，1亿个浮点数需要400 MB。最直接的方法是：每次通过一轮循环
比较，选择其中最大的数据，这样进行1万次选择，就可以得到最大的1万个数。这种思路就是
选择排序的基本思想。由于从N个数的序列中选择一个最大的数需要经过N-1次的比较，故此
方法总比较次数为N-1+(N-2)+…+(N-10 000)次。当N为1亿时，比较次数大约为1万亿
次。这样的时间复杂度和排序效率都是不能忍受的，可见，一些简单的排序算法在海量数据面前
是不适用的。
方法2:
对于如此规模的排序，一种比较好的方法是采用“分而治之”的策略。比如，以1百万为一
264 第7章 排序
个块，分为100块，分别对这100块数据进行排序。由于只需要得到最大的1万个数，故每块排
完后可以只要前1万个数，再从这100块共100万个数中取最大的1万个就可以了。后面我们
会讲到的快速排序和归并排序都是这种“分而治之”算法设计思想的体现。如果数据是完全没
有规律的话，快速排序的平均复杂度是0(NlogN)。当N为100万时，0(NogN)是2000万，所
以求解100块百万数据的排序问题以及随后对100万数据的再排序，时间复杂性大约是20亿，
与前一种方法比较已经有很大的改进。
方法3:
还有一种更为精巧的方法：先读出1百万个数，可以利用快速排序等高效算法进行排序，找
出最大的1万个数。然后维护好这1万个数，对剩下的近I亿个数进行过滤：每次读入剩下的一
个数，如果该数小于等于这1万个数的最小值，则继续读下一个数；否则，用该数替代1万个数里
的最小值。这里的关键问题是如何维护好这1万个数，使之能随时知道这1万个数的最小值并
方便删除它，以及加入新的数。从前面4.6节可以知道，堆结构就可以很好地完成这个任务。因
此，基于堆结构也有一种好的排序算法，那就是堆排序。如果最早选取的这1百万个数据够理想
的话，其中最大1万个数里面的最小数应该接近最终所求的1万个最大数里面的最小数，故可以排
除掉剩下近1亿个数中的大部分数。假设有90??右的数被排除了，那么也就只有1千万个左右
的数入堆，堆的操作效率是0(logN)。由于堆里只有1万个数，每次堆操作复杂性是log10 000,约
等于14,所以这个方法的效率大致是：2000万(百万数排序)+1亿(顺序过滤)+14*1千万，共约
2.6亿，比第2种方法在计算效率上又提高了不少。
另外，这种方法也不用把所有数都一次性放到内存里来处理，因此在大数据量情况下可以节
省内存空间。这种思想就是本章最后要提到的外部排序的思路。
由上例可以看出，不同的方法，其效率可以相差很多，而效率其实是跟数据的特点直接或间
接相关的。本章的任务就是向大家介绍几种经典的排序算法，同时分析它们各自的优缺点。需
要特别指出的是：没有一种排序算法在任何情况下都是最优的，我们必须学会根据实际情况选择
最优的算法来解决问题。
这里还有个常用的概念要解释下。排序算法的“稳定性”是指：在一组待排序记录中，如果
存在任意两个相等的记录R和S,且在待排序记录中R在S前，如果在排序后R依然在S前，即
它们的前后位置在排序前后不发生改变，则称该排序算法为稳定的。
为了叙述方便，本章随后讨论的排序问题都约定为从小到大的排序。
7.2 选择排序
7.2.1 简单选择排序
简单选择排序(Simple Selection Sort)是一种直观的排序算法，其思想是在未排序的序列中
7.2 选择 排 序 265
选出最小的元素和序列的首位元素交换，接下来在剩下的未排序序列中再选出最小元素与序列
的第二位元素交换，依次类推，最后形成从小到大的已排序序列。
代码7.1给出了这个算法的C语言实现。
void Swap(ElementType*a,ElementType·b)
ElementType t=*a;*a=b; b=t;
void simpleSelectionsort(ElementType A[],int N)
|/*简单选择排序·/
int i,j,min;
for(i=0;i<N-1;i++)|/*寻找最小元素*/
min=i;
for(j=i+1; j<N;j++)
if(A[j]<A[min])
mín=j;/* min记录最小元素位置*/
/* 将第i个元素与最小元素交换*/
Swap(&A[i],&A[min]);
代码7.1 简单选择排序的C语言实现
可以看出，简单选择排序无论在什么情况下，都需要比较N*(N-1)/2次，故其时间复杂度
为0(N2)。事实上，在将第i个元素与最小元素交换之前，我们可以判断一下，如果min==i,则
不用交换，那么简单选择排序移动元素的次数在最好的情况下是0次(待排序的元素序列已经
是有序),在最坏的情况下为3(N-1)次(除了最后一个元素外，每个元素都要经过3步交换
位置)。
7.2.2 堆排序
堆排序(Heap Sort)是由1991年计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯
特·弗洛伊德(Robert W.Floyd)和威廉姆斯(J.Williams)在1964年共同提出的。
堆排序是指利用堆这种数据结构所设计的一种排序算法。在第4章中我们已经介绍了堆，
是一种特殊的二叉树，每个子结点的值总是小于(或者大于)它的父结点，相应地分为最大堆和
最小堆。由于堆是一个完全二叉树，一般情况下堆排序都是用数组的方式来实现。
堆排序的核心思想是：利用最大堆(或者最小堆)输出堆顶元素，即最大值(或最小值),将剩
266 第7章 排 序
余元素重新生成最大堆(或者最小堆),继续输出堆顶元素，重复此过程，直到全部元素都已输
出，得到的输出元素序列即为有序序列。
实现堆排序方法一种简单的做法是额外开辟一个辅助的数组空间，将堆顶元素逐一放
入辅助数组里，最后再把辅助数组的内容复制回原始的数组。这种方法的额外空间复杂度
是0(N)。下面我们讨论一种更聪明的方法，只用0(1)的额外空间即可。
如图7.1所示，首先将一个无序的序列生成一个最大堆，如图7.1(a)所示。接下来我们
不需要将堆顶元素输出，只要将它与堆的最后一个元素对换位置即可，如图7.1(b)所示。这
时我们确知最后一个元素99一定是递增序列的最后一个元素，而且已经在正确的位置上。
现在问题变成了如何将剩余的元素重新生成一个最大堆——也很简单，只要依次自上而下进
行过滤，使其符合最大堆的性质。图7.1(c)是调整后形成的新的最大堆。要注意的是，99
已经被排除在最大堆之外，即在调整的时候，堆中元素的个数应该减1。结束第1轮调整
后，再次将当前堆中的最后一个元素22与堆顶元素换位，如图7.1(d)所示，再继续调整成
新的最大堆……如此循环，直到堆中只剩1~个元素，即可停止，得到一个从小到大排列的有
序序列。
99 3
(66 45 66 45
33 37 ⑩ 22 33 37 ⑩ 22
?
(a)原始最大堆 (b)将13与99换位
(66
37 45 37 45
33 3 ⑩ 22 33 ? ⑩ 66
99
(c)调整后形成新的最大堆 (d)将22与66换位，继续调整
图7.1 最大堆的调整
这个方法的时间复杂度与前一种方法相同，仍然是O(MlogN),但是不需要额外的辅助数
组，所以额外空间复杂度是0(1)。
代码7.2给出了堆排序的实现。注意到第4章的最大堆代码不能直接调用，因为这里的
数据是从第0个单元开始存放的，所以代码需要做相应的改动。这时对于第i个单元的结点，
7.2 选 择 排 序 267
其左孩子的编号不再是2i,而是2i+1,右孩子编号是2i+2;其父结点的编号是L(i-1)/2」。又
注意到无论是建立堆还是删除堆顶元素，其核心部分都是“下滤”,所以我们把这个核心函数
抽取出来，用PercDown(A,i,N)来实现对A[ ]中的前N个元素从第i个元素开始向下迁移调
整的过程。
void PercDown(ElementType A[],int p,int N)
1/*改编代码4.24的PercDown(MaxHeap H,int p)
/*将N个元素的数组中以A[p]为根的子堆调整为最大堆
int Parent,Child;
ElementType x:
x=A[p];*取出根结点存放的值*/
for(Parent=p;(Parent*2+1)<N;Parent =Child)1
Child=Parent·2+1;
if((Child!=N-1)&(A[Child]<A[Child+1]))
Child++;/* Child指向左右子结点的较大者*/
if(X>=A[Child])break;/*找到了合适位置*/
else /* 下滤X*/
A[ Parent]=A[Child}:
A[Parent]=x;
void HeapSort(ElementType A[ ],int N)
1/· 堆排序·/
int i;
for(i=N/2-1;i>=0;i--)/*建立最大堆*/
PercDown(A,i,N);
for(i=N-1;i>0;i--)
/ 删除最大堆顶*/
Swap(&A[0],&A[i]);/* 见代码7.1·/
PercDown(A,0,i);
代码7.2 堆排序
268 第7章 排序
7.3 插入排序
7.3.1 简单插入排序
简单插入排序的核心思想是：将待排序的一组序列分为已排好序的和未排序的两个部分；初
始状态时，已排序序列仅包含第一个元素，未排序序列中的元素为除去第一个以外N-1个元素；
此后将未排序序列中的元素逐一插入到已排序的序列中。如此往复，经过N-1次插人后，未排
序序列中元素个数为0,则排序完成。
具体到第k-1次插入，对应待插入元素应为第k个元素，也就是未排序序列中的第一个元
素，插入的基本过程是：将它和第k-1个元素(也就是已排序序列的最后一个元素)进行比较，若
大于第k-1个记录，则该次循环结束；否则，将两个元素交换，再比较该数和第k-2个元素之间
的大小，依此往复，直到该数比它当前位置的前一个元素大，或该数已交换到了第1个位置，则第
k-1次循环结束。
下面我们来看一个例子。表7.1显示了对|44,12,59,36,62,43,94,7,35,52,85|进行简单插入
排序的前3次循环的情况。在第2次循环结束后，已排序序列中有3个记录。第3次循环第1步，
将未排序序列中的第一个记录36和已排序组中的最后一个记录59进行比较，因满足36<59,因此
交换这两个记录；第2步，36仍然小于一个记录44,则继续交换；直到大于前一个记录12,则停止交
换，第3次循环结束。已排序序列中新增记录36,未排序序列中删除该记录，记录数量减1。
表7.1 简单插入排序示例
排序前 44 12 59 36 62 43 94 7 35 52
已排序序列 未排序序列
59 44 12
12 44
12 3644
36 62 43 94 7 35 52
3659 62 43 94 7 35 52
59 62 43 94 7 35 52
已排序序列 未排序序列
59 44 12 36 62 43 94 7 35 52
85
经过2次循环
第2次循环结束后 85
第3次循环第1步 85
第3次循环第2步 85
第3次循环结束 85
经过10次这样的循环，未排序序列的所有记录逐个插入到已排序序列中，则排序结束。简
单插入排序的算法实现由代码7.3给出。注意到在程序实现时，不需要每次做3步赋值实现交
换，而是将未排序序列中的第一个元素先取出来，依次与已排序序列中元素比较，将需要交换的
元素右移，最后把未排序序列中的第一个元素放进合适的位置即可。
7.3 插入 排 序 269
void InsertionSort(ElementType A[],int N)
1/插入排序*/
int P,1;
ElementType Tmp;
for(P=1;P<N;P++)
Tmp=A[D];/取出未排序序列中的第一个元素·/
for(i=P:i>0A[i-1]>Tmp;i--)
A[1]=A[1-1]:/*依次与已排序序列中元素比较并右移*/
A[1]=TmD;/*放进合适的位置 */
代码7.3 插入排序
由该算法代码可以看出，空间复杂度上，简单插入排序仅需要常数个额外空间；时间复杂度
上，函数中有2个嵌套的循环，每个循环进行0(N)次比较和交换，因此整个简单插入排序的平
均时间复杂度为0(N2)。在最坏的情况下，对应每一个P,要进行P-1次比较和交换，总共要花
费0(N2)次操作；在最好的情况下，也就是对已经排好序的序列进行排序，第二个循环在第一个
(A[i-1]>Tmp)比较时就跳出，因此总共花费O(N)次操作。
此外，简单插入排序是稳定的排序，我们发现，数值相同的两个记录不会发生相对位置上的
改变。
7.3.2 希尔排序
简单插入排序效率不高的一个重要原因是每次只交换相邻的两个元素，这样只能消去一对
错位的元素。希尔排序对插入排序进行改进，试图通过每次交换相隔一定距离的元素，达到排序
效率上的提升。
希尔排序的基本原理是，将待排序的一组元素按一定间隔分为若干个序列，分别进行插入排
序。开始时设置的“间隔”较大，在每轮排序中将间隔逐步减小，直到“间隔”为1,也就是最后一
步是进行简单插入排序。
希尔排序将“间隔”定义为一组增量序列，用来分割待排序列，即将位置之差等于当前增量
的元素归属于同一个子序列，并分别进行插入排序；排好后再选取下一个增量，划分子序列再次
排序，直到最后一个增量(一般为1)。
[例7.2] 对于待排序列|44,12,59,36,62,43,94,7,35,52,85|,我们可设定增量序列为
15,3,11。
第一个增量为5,因此{44,43,851、{12,94|、59,71、36,351、|62,521分别隶属于同一个
子序列，子序列内部进行插入排序；然后选取第二个增量3,因此{43,35,94,621、12,52,59,
270 第7章 排序
851、17,44,36|分别隶属于同一个子序列；最后一个增量为1,这一次排序相当于简单插入排序，
但是经过前两次排序，序列已经基本有序，因此此次排序时间效率就提高了很多。希尔排序过程
如表7.2所示。
表7.2 希尔排序示例
排序前 12 59 36 94 62 43 7 35 52
43 12 7 35 52 44 94 59 36 62
35 12 7 43 52 36 62 59 44 94
7 12 35 36 43 44 52 59 62 85
85
第一个增量排序后 85
第二个增量排序后 85
第三个增量排序后 94
代码7.4给出了用Sedgewick 增量序列进行希尔排序的实现。
void shel1sort(ElementType A[],intN)。
1/*希尔排序-用Sedgewick增量序列·/
int si,D,P,i:
ElementType Tmp;
/*这里只列出一小部分增量*/
int Sedgewick[]=1929,505,209,109,41,19,5,1,0;
for(Si=0;Sedgewick[si]>=N; Si++)
;/*初始的增量Sedgewick[Si]不能超过待排序列长度·/
for(D=Sedgewick[si];D>0;D=Sedgewick[++si])
for(P=D;P<N;P++)|/*插入排序*/
Tmp=A[P];
for(i=P;i>=D&A[1-D]>Tmp;i-=D)
A[1]=A[1-D]:
A[i]=Tmp;
代码7.4 希尔排序
由该算法代码可以看出，空间复杂度上，和简单插入排序一样，希尔排序只需要0(1)的额
外空间；时间复杂度上，每一次针对某增量进行插入排序，而随着增量逐渐变小，整体序列逐渐有
序起来，每次插入排序的比较和交换次数变少。
希尔排序算法的整体时间复杂度和增量序列的选取有关，目前并没有统一的最优增量序列。
当使用增量序列{LN/2J,LN/22],…,1|进行希尔排序时，最差情况下时间复杂度为0(N2);而当
7.4 交 换 排序 271
使用增量序列|z?-1,…,7,3,1时，最差情况下时间复杂度为O(N32),其平均时间复杂度尚无
定论，猜想结果为0(N3)。除此以外，还有不少其他的增量序列选取方法，在各自特定的排序
对象中有较好的时间复杂度的表现。代码7.4中用到的Sedgewick 增量序列中的每一项或者是
9×4-9×2'+1的形式、或者是4-3×2'+1的形式，关于它的复杂度分析目前也是尚无定论，只
有猜想其平均时间复杂度为0(N2),最差情况下时间复杂度为0(N)。经验表明，希尔排序
对规模以万计的待排序列会体现出比较好的效率。
此外，和简单插入排序不同的是，希尔排序不是稳定的排序，选取不同增量进行排序时，可能
导致数值相同的两个元素发生相对位置上的改变。
7.4 交换排序
7.4.1 冒泡排序
冒泡排序是最简单的交换排序。对元素个数为N的待排序序列进行排序时，共进行N-1
次循环。在第k次循环中，对从第1到第N-k个元素从前往后进行比较，每次比较相邻的两
个元素，若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变。这样一次循
环下来，就把第k大的元素移动到第N-k个位置上，称为第k趟的冒泡。整个过程一共进
行N-1趟冒泡，直到第1个和第2个元素比较完成，最终剩余最小的元素，留在第1个位置
上，排序结束。
我们来看例7.2中对给定初始序列的冒泡排序过程，会有十分直观的理解：第1趟冒泡后，
最大的记录94被移动到了第N个位置上，它将不参与接下来的冒泡；第2趟冒泡后，剩余N-1
个记录中最大的记录85被移动到了第N-1个位置上；经过N-1趟冒泡后，剩余的最小记录7留
在第1个位置上，排序结束，如表7.3所示。
表7.3 冒泡排序示例
排序前 44 12 59 36 62 43 94 7 35 52
12 44 36 59 43 62 7 35 52 85
12 36 44 43 59 7 35 52 62 85
12 7 35 36 43 44 52 59 62 85
7 12 35 36 43 44 52 59 62 85
7 12 35 36 43 44 52 59 62 85
85
第1趟冒泡后 94
第2趟冒泡后 94 …
第N-3趟冒泡后 94
第N-2趟冒泡后 94
第N-1趟冒泡后 94
272 第7章 排 序
代码7.5给出了冒泡排序的算法实现。注意到这里增加了一个flag标记，检查一趟扫描有
没有元素需要交换。如果没有任何元素交换，说明序列已经全部有序，不需要继续执行下一趟扫
描，可直接结束。在序列基本有序的情况下，增加一个flag虽然在每次交换时增加了一次赋值操
作，但可以避免大量冗余的扫描，总体上还是合算的。
void BubbleSort(ElementType A[],int N)
I/*冒泡排序/
int P,i;
bool flag;
for(P=N-1;P>=0;P--)F
flag=false;/* 标记该次循环中是否发生交换，若无，则说明整个序列有序*/
for(i=0;i<P;i++)|/*一趟冒泡/
/每次循环找出一个最大元素，被交换到最右端·/
if(A[1]>A[i+1])
Swap(&A[i],6A[i+1]);
flag=true;/* 标识发生了交换·/
if(flag==false)break;/*若全程无交换，则跳出循环/
代码7.5 冒泡排序
显而易见，冒泡排序最坏的情况下(序列是逆序排列的),在每一次比较都要进行一次交换，
时间复杂度为0(N2);最好的情况下，序列已经是排好序的，这时由于应用了flag标记只要进行
0(N)次比较就可以从循环中跳出来，完成排序；程序的平均时间复杂度为0(N2)。空间复杂度
方面，冒泡排序只需要常数个额外空间用于保存中间变量。此外，冒泡排序是稳定的，因为元素
关键字相等的两个记录在比较时并不会发生交换，即相对位置不会发生变化。
7.4.2 快速排序
快速排序也是交换排序的一种，但和冒泡排序不同的是，冒泡排序只比较相邻两个记录
的顺序，而快速排序的原理是：将未排序元素根据一个作为基准的“主元”(Pivot)分为两个子
序列，其中一个子序列的记录均大于主元，而另一个子序列均小于主元，然后递归地对这两个
子序列用类似的方法进行排序，如图7.2所示。这种思路我们在第2章最后讨论集合中位
数的时候已经见到过了。本质上，快速排序使用分治法，将问题的规模减小，然后再分别进
行处理。
7.4 交 换排 序 273
44,12,59, 12,
36,43,
59.
36,62,43,94, 7,35
62,94, 52,85 7.35,52,
85
递归解决
图7.2 快速排序示意
子序列的划分方法也与我们在第2章讨论过的方法类似，从原序列中选择一个主元，将比主
元大的元素从右向左放置，而比主元小的元素从左向右放置。
表7.4给出了对例7.2序列进行一趟主元调整的过程。具体步骤为：
(1)选择一个主元，并与最后一个元素交换。
(2)设置两个指针 Low 和 High,初值分别指向第一和倒数第二个元素。
(3)Low从左向右扫描，其位置左侧为已遍历或交换过的比主元小的元素；High 从右往
左扫描，其位置右侧为已遍历或交换过的比主元大的元素。首先从Low指向的位置向右扫
描，若遇到比主元大的元素，则停止；然后从 High 指向的位置向左搜索，若遇到比主元小的元
素，则停止。
(4)若Low和 High 没有错位(即Low<High),则High 和Low指向的元素互换位置。
(5)重复3、4直至High 和Low 错位，将基准与A[Low]对换位置。这就完成了一次划分，以
主元为边界分别划分成大于和小于主元的两个子序列。
(6)递归地对两个子序列用同样方法进行快排。
主元的选取有多种方法。表7.4中用最简单的办法，即选择第一个记录44为第一趟快速
排序的主元，经过4次交换后，44移动到了A[5]位置，左边都是比主元小的记录，右边是比主
元大的记录，此时原序列划分为两个子序列。下一趟快速排序分别对两个子序列进行快排，
依次递归下去直至当前子序列只有一个元素时结束递归，这样就达到了分而治之的算法
目的。
表7.4 快速排序示例
一趟快速排序：
85 12 59 36 62 43 94 7 35 52
Low High
35 12 59 36 62 43 94 7 85 52
Low High
35 12 7 36 62 43 94 59 85 52
Low High
基准
44
排序前
44
第1次交换
44 第2次交换
274 第7章 排 序
续表
一趟快速排序：
35 12 7 36 43 62 94 59 85 52
Low High
35 12 7 36 43 62 94 59 85 52
High Low
35 12 7 36 43 44 94 59 85 52
High Low
基准
44
第3次交换
44
第4次扫描发现错位
交换A[Low]和最后 62
一个主元，一趟结束
快速排序的时间复杂度分析略显复杂。最好的情况下，每一次划分都将原序列分成两个基
本等长的子序列，随着递归层次的加深子序列的数量翻倍，但在每一递归层次上比较总次数都是
0(N)次，而递归层次(深度)是log?N,由此可见，快速排序的最好时间复杂度应为0(Nlog?N)。
更复杂一些的证明显示，快速排序的平均时间复杂度也是0(Nlog?N)。相对于其他的内部排序，
快速排序的平均时间效率是最高的。但在最坏的情况下，例如每次划分都近似于1和N-1,快速
排序的执行时间复杂度就接近于冒泡排序，可能导致-0(N2)的时间效率。
为了避免最坏结果，在确定主元时需要有一定技巧。一种比较好的方
法是，将A[low]、A[high]、A[(low+high)/2]三者关键字的中值作为主元，
这样有可能避免在基本有序的序列中进行快速排序时时间复杂度出现最坏
情况的问题。
微视频7-1
快速排序选
主元
另外一个问题是，由于快速排序一般是用递归实现的，如果待排序列的
规模比较小，递归的副作用就会凸显出来，效果甚至还不如简单的插入排
序。所以更专业一些的处理，是在递归过程中检查当前子问题的规模，当其
小于某个阈值时就不继续递归，而是直接调用插入排序解决问题。
代码7.6给出了快速排序算法的实现。其中Median3函数的作用是确定主元，将最左边、最
右边、中间的三个元素的中位数作为主元，并且把三个元素调整成“最左元≤主元≤最右元”的
状态。此时由于最右元肯定不小于主元，所以在后面的集合划分中我们根本无须再考虑它，于
是我们不是把主元与最后一个元素交换，而是把它换到倒数第二个元素的位置上，并且返回
主元的值。
QSort完成关键的排序功能。我们当然可以直接把QSort 函数给用户使用，但是必须告诉用户
以QSort(A,0,N-1)的方式调用，而这与其他几个排序函数的接口不一致。为了用户界面的一致
性，我们给QSort加了一个外包装，这样用户就可以通过与其他排序函数一致的接口“某Sort(A,
N)”来调用快速排序函数了。这个外包装不是必须的，但却是专业程序员应该有的编程风格。
7.4 交 换 排 序 275
ElementType Median3(ElementType A[ ],int Left,int Right)
int Center=(Left+Right)/2;
Swap(&A[Left],&A[Center]);
if(A[Left]>A[Right])
Swap(&A[Left],&A[Right]);
Swap(A[Center],A[Right]);
/*此时A[Left]<=A[Center]<=A[Right]*/
Swap(&A[Center].&A[Right-1]);/·将基准Pivot 藏到右边·/
八·只需要考虑A[Left+1]…A[Right-2]*/
return A[Right-1];/* 返回基准Pivot*/
void Qsort(ElementType A[ ],int Left,int Right)
1/*核心递归函数·/
int Pivot,cutoff,Low,High;
if(Cutoff<=Right-Left)|/*如果序列元素充分多，进人快排·/
Pivot =Median3(A,Left,Right);/ 选基准·/
Low=Left;High=Right-1;
while(1)/*将序列中比基准小的移到基准左边，大的移到右边*/
while(A[++Low]<Pivot);
while(A[--High]>Pivot);
if(Low<High)Swap(&A[Low],&A[High]);
else break;
Swap(&A[Low],A[Right-1]);/* 将基准换到正确的位置·/
Qsort(A, Left,Low-1);/*递归解决左边*/
Qsort(A,Low+1,Right);/*递归解决右边·/
else InsertionSort(A+Left,Right-Left+1);/*元素太少，用简单排序·/
void QuickSort(ElementType A[],int N)
/*统一接口/
Qsort(A,0,N-1);
if(A[Left]>A[Center])
if(A[Center]>A[Right])
代码7.6 快速排序
276 第7章 排 序
空间复杂度上，由于快速排序需要进行至少 log?N层的递归，因此需要至少0(log?N)深度
的栈空间。若每次划分的子组大小不够平均，则栈空间的深度更大，在最坏的情况下将导致
接近O(N)的栈空间深度。
此外，快速排序是不稳定的。因为在和主元进行比较时，可能导致一个元素交换到和它等值
的另一个元素位置以前，导致两者的位置发生相对变换，因此快速排序是不稳定的。
7.5 归并排序
归并排序是建立在归并操作基础上的一种排序方法。归并操作，是指将两个已排序的子序
列合并成一个有序序列的过程。
归并排序的基本原理是：将大小为N的序列看成N个长度为1的子序列，接下来将相邻子
序列两两进行归并操作，形成N/2(+1)个长度为2(或1)的有序子序列；然后再继续进行相邻子
序列两两归并操作，如此一直循环，直到剩下1个长度为N的序列，则该序列为原序列完成排序
后的结果，如图7.3所示。
…
图7.3 归并排序示意
归并排序的核心在于归并操作的实现。归并操作的过程如下：首先申请额外的空间用于放
置两个子序列归并后的结果，接着设置两个指针分别指向两个已排序子序列的第一个位置，然后
比较两个指针指向的元素，将较小的元素放置到已申请的额外空间内，并将当前位置向后移动一
格，重复以上过程，直到某一个子序列的指针指向该序列的结尾。这时候将另一个指针所指向序
列的剩余元素全部放置到额外空间内，归并操作结束。
表7.5仍然使用例7.2的序列，应用2路归并排序。一开始将所有记录看成单独的N个有
序子序列；每一趟归并操作，将相邻的两个已排序子序列两两进行归并，形成一个规模扩大一倍
的已排序子序列，直到最后归并成一个完整序列。
…
7.5 归 并排序 277
表7.5 归并排序示例
排序前 44 12 59 36 62 43 94 7 35 52
44 12 59 36 62 43 7 94 52 35
12 36 44 59 7 43 62 94 35 52
7 12 36 43 44 59 62 94 35 52
85
第1趟归并操作结束 85
第2趟归并操作结束 85
第3趟归并操作结束 85
第4趟归并操作结束 7 12 35 36 43 44 52 59 62 85 94
从特定角度看，归并排序也可以用分治法的思想去自下而上地理解，就是将原序列划分成两
个等长子序列，再递归地排序这两个子序列，最后再调用归并操作合并成一个完整的有序序列。
归并排序的递归实现由代码7.7给出。其中Merge是对两个有序序列的归并操作，MSort 是核心
的归并排序递归函数，而MergeSort是使用了统一用户接口的排序函数。
注意到，我们只在Merge 函数中才用到那个额外的数组TmpA来存储归并后的序列，但却在
MergeSort 中开辟了这个额外空间，并且一直将其地址作为参数在MSort的递归调用中反复传送。
为什么要这样做?为什么不直接在Merge 函数内部开辟一个数组，并且在使用结束后释放?如
果真的这样做了，那么程序需要多少额外的空间呢?
/+L=左边起始位置，R=右边起始位置，RightEnd=右边终点位置·/
void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)
I/*将有序的A[L]-A[R-1]和A[R]-A[RightEnd]归并成一个有序序列·
int LeftEnd, NumElements,Tmp;
int i;
LeftEnd=R-1;/*左边终点位置*/
Tmp=L; /* 有序序列的起始位置·/
NumElements=Right End-L+1;
while(L<=Left End &反 R<=RightEnd)|
if(A[L]<=A[R])
TmpA[Tmp++]=A[L++];/* 将左边元素复制到TmpA*/
else
TmpA[Tmp++]=A[R++];/·将右边元素复制到TmpA*/
while(L<=LeftEnd)
TmpA[Tmp++]=A[L++];/*直接复制左边剩下的·/
while(R<=RightEnd)
278 第7章 排序
TmpA[ Tmp++]=A[R++];/*直接复制右边剩下的·/
for(i=0;i<NumElements;i++,RightEnd--)
A[RightEnd]=TmpA[RightEnd];/*将有序的TmpA[]复制回A[ ]*/
void Msort(ElementType A[],ElementType TmpA[ ],int L,int RightEnd)
1/*核心递归排序函数*/
int Center;
if(L<Right End)
Center=(L+RightEnd)/2;
Msort(A;TmpA,L,Center); /*递归解决左边·/
Msort(A,TmpA,Center+1,RigheEnd);/*递归解决右边*/
Merge(A,TmpA,L,Center+1,RightEnd);/合并两段有序序列*/
void MergeSort(ElementType A[],int N)
I/*归并排序*/
ElementType·TmpA;
TmpA=(ElementType*)malloc(N*sizeof(ElementType));
if(TmpA!=NULL)
Msort(A,TmpA,0,N-1);
free(TmpA);
else printf("空间不足“);
代码7.7 归并排序
由非递归的算法描述可以看到，每一趟归并操作(图7.3中的一行)需要进行0(N)次比较，
而一共将进行0(log?N)趟归并操作，因此整个归并排序的时间复杂度为0(Nlog?N),哪怕在最
坏情况下时间复杂度也是一样。递归的时间复杂度分析略复杂，不过结果也是0(Nlog?N)。
空间复杂度上，由于归并操作过程中需要额外的空间用于保存已排序的子序列，因此，如果
实现方法正确的话，整个归并排序的空间复杂度为0(N)。若使用递归方法进行实现并在Merge
函数内部申请空间，如果不及时释放，则可以证明将耗费0(Mlog?N)的额外空间；若每次都执行
7.6 基 数 排 序 279
申请和释放，则除了耗费0(N)的额外空间以外，还增加0(N)次 malloc和 free操作。这就是为
什么我们不嫌麻烦地在Merge 之外(MergeSort 中)申请了额外空间，并且一
直将这个数组的地址通过指针方式传递给递归函数的原因。此外，相对于
快速排序和堆排序，归并排序虽然耗费更多的额外空间，但整体的排序过程
是稳定的，关键字值相同的两个元素在排序过程中并不会发生相对位置上
微视频7-2 的变化。 归并排序的 归并排序虽然看上去稳定而且时间复杂度不高，但是在实际应用中，开
辟大块的额外空间并且将两个数组的元素来回复制却是很耗时的，所以归
并排序一般不用于内部排序。但它是进行外部排序(详见7.7节)的非常
有用的工具。
额外空问耗
费
…
7.6 基数排序
基数排序(Radix Sort)可以看成是桶排序(Bucket Sort)的推广，所以让我们先看一下桶排序
的思想。
7.6.1 桶排序
如果已知N个关键字的取值范围是在0到M-1之间，而M比N小得多，则桶排序算法将为
关键字的每个可能取值建立一个“桶”,即建立M个桶；在扫描N个关键字时，将每个关键字放
入相应的桶中，然后按桶的顺序收集一遍就自然有序了。所以桶排序效率比一般的排序算法
高——当然需要的额外条件是已知关键字的范围，并且关键字在此范围内是可列的，个数还不能
超过内存空间所能承受的限度。
[例7.3]已知某门公共选修课有1500学生选修，其成绩为分布于[0,100]之间的整数。
现需要将学生名单按其成绩从低到高顺序打印出来。
[分析]若将学生名单按成绩排序再打印，则至少需要O(NlogN)的时间，这里N=1500。
而用桶排序的方法，可为每一个分数建立一个“桶”,共建101个桶——具体实现时可定义一个
链表指针数组 Bucket[101]。顺序扫描学生名单，若当前这个学生的成绩是i分，则将他的记录
插入 Bucket[i]所指的链表头部，这一操作只需2步。整个扫描的过程用去0(N)的时间。然后
顺序扫描每个Bucket[i],将链表中的学生名单逐一打印，该过程用0(N+M)的时间，其中
M=101是桶的个数。可见桶排序只需要0(N+M)的时间就可以完成名单的顺序打印，特
别当M=0(N)时，这个时间复杂度是线性的。
7.6.2 基数排序
基数排序是桶排序的一种推广，它所考虑的待排记录包含不止一个关键字。例如对一副牌
280 第7章 排序
的整理，可将每张牌看作一个记录，包含两个关键字：花色、面值。一副理顺的牌是按如下顺序排
放的：
2,…,4A ◆2,…,◆A v2,…,A …2,…,A
可见一个有序列是先按花色划分为四大块，每一块中又再按面值大小排序。这时“花色”就
是一张牌的“最主位关键字”,而“面值”是“最次位关键字”。
对于一般有K个关键字的情况，基数排序通常有两种方法：主位优先法(Most Significant Dig it Sort,简称MSD)和次位优先法(Least Significant Digit Sort,简称LSD)。
仍以整理扑克牌为例，顾名思义，所谓主位优先法，是先为最主位关键字(花色)建立桶，将
牌按花色分别装进4个桶里；然后对每个桶中的牌，再按其次位关键字(面值)进行排序，最后将
4个桶中的牌收集，顺序叠放在一起。
而次位优先法，是先为最次位关键字建立桶，即按面值建立13个桶，将牌按面值分别放于
13个桶中；然后将所有桶中的牌收集，顺序叠放在一起；再为主位关键字花色建立4个桶，顺序
将每张牌放入对应的花色桶中，则4个花色桶中的牌必是有序的，最后只要将它们收集，顺序叠
放即可。
从上述例子可见，两种方法具有不同的特点。主位优先法基本上是分治法的思路，将序列分
割成子列后，分别排序再合并结果。而次位优先法是将“排序”过程分解成了“分配”和“收集”
这两个相对简单的步骤，并不需要分割子列排序，故一般情况下次位优先法的效率更高一些。
7.6.3 单关键字的基数分解
从上面可以看到，基数排序主要是对有多关键字的对象进行排序。其实可以将单个整型关
键字按某种基数分解为多关键字，再进行排序。这也是“基数排序”名称的由来。例如826可以
根据基数10分解为8、2、6这三个关键字，其中8是最主位关键字，6是最次位关键字；还可以根
据基数16分解为3、3、A这3个关键字，其中第一个3是最主位关键字，A是最次位关键字。
典型问题是给定N个记录，每个记录的关键字为一整数，其取值范围在0到M之间。若M
比N大很多(例如M=N*),这时桶排序需要M个桶，会造成巨大的空间浪费；而以R为基数对
关键字进行分解后则只需要R个桶就可以了。让我们通过一个具体的例子来理解什么是基数
分解。
[例7.4]给定范围在0到999之间的10个关键字{64,8,216,512,27,729,0,1,343,125|,
现用基数排序算法进行递增排序。
我们可以将每个关键字看成一个3位的10进制整数(不足位的在左边补0),从而将每个十
进制整数关键字分解成3个关键字，其个位数为最次位关键字，百位数为最主位关键字。这就是
以10为基数的分解。
对给定的10个记录用次位优先法进行基数排序，首选对最次位(个位)关键字建立10个
桶，将记录按其个位数字的大小放入相应的桶中，如图7.4(a)所示。此时10个数字恰好均匀分
布于10个桶中，当然一般情况下不是总有这么好的运气。每个“桶”实际上是一个链表，一趟排
7.6 基 数 排 序 281
序后，将桶中记录重新收集成为一个新的记录链|0,1,512,343,64,125,216,27,8,7291。
接下去按下一个次位关键字(十位)排序，所得结果如图7.4(b)所示。注意到此时桶中记
录的分布不再均匀。向桶中插入的新记录需排在链表尾部。将桶中记录收集形成新的记录链
00,01,08,512,216,125,27,729,343,64。
最后按最主位(百位)关键字排序，结果如图7.4(c)所示，再收集所得的记录链就是最终有
序的[000,001,008,027,064,125,216,343,512,729|。
0: 1: 2: 3: 4: 5: 6: 7: 8: 9:
0 512 343 64 125 216 27 8 729
(a)基数排序第一趟——按个位数字排序结果
0: 1 2: 729 3: 4: 5: 6: 7: 8:
216 27
0 512 125 343 64
(b)基数排序第二趟——按十位数字排序结果
64
27
0: 8 1: 2: 3: 4: s: 6: 7: 8: 1
0 125 216 343 512 729
(c)基数排序第三趟——按百位数字排序结果
图7.4 基数排序次位优先法演示
代码7.8给出了按次位优先法进行基数排序的算法实现。这里假设元素最多有MaxDigit个
关键字，基数全是同样的Radix。我们用桶B承载分配的记录，再用链List 进行收集。函数
GetDigit 的作用是返回整型关键字X的第D位数字，次位优先从D=1开始。
/·假设元素最多有MaxDigit个关键字，基数全是同样的Radix*/
#define MaxDigit 4
#define Radix10
/·桶元素结点*/
282 第7章 排 序
typedef struct Node *PtrToNode;
struct Nodel
int key;
PtrTONodenext;
I;
/*桶头结点*/
struct HeadNodel
PtrTONode head, tail;
I;
typedef struct HeadNode Bucket[Radix];
int GetDigit(int x,int D)
I/*默认次位D=1,主位 D<=MaxDigit·
int d,i;
for(i=1;i<=D;i++)
d=X号 Radix;
X/=Radix;
return d;
void LSDRadixSort(ElementType A[ ],int N)
|/*基数排序-次位优先*/
int D,D1,i:
Bucket B;
PtrTONode tmp,p,List=NULL;
for(i=0:i<Radix;i++)/*初始化每个桶为空链表*/
B[1],head=B[1].tail=NULL;
for(i=0;i<N;i++)|/*将原始序列逆序存入初始链表Liat·
tmp=(PtrToNode)malloc(sizeof(struct Node));
tmp->key=A[i];
tmp->next=List;
List=tmp;
F
7.6 基数 排 序
/*下面开始排序*/
for(D=1;D<=MaxDigit;D++)|/*对数据的每一位循环处理·/
/*下面是分配的过程*/
p=List;
while(p)|
Di=GetDigit(p->key,D);/·获得当前元素的当前位数字·/
/*从List 中摘除/
tmp=p;p=p->next;
/*插人 B[Di]号桶尾*/
tmp->next=NULL:
if(B[Di].head==NULL)
B[Di].head=B[Di].tail=tmp;
elsel
B[Di].tail->next=tmp;
B[Di].tail=tmp;
/*下面是收集的过程*/
List=NULL;
for(Di=Radix-1; Di>=0;Di-)|/*将每个桶的元素顺序收集入List*/
if(B[Di].head)|/*如果桶不为空 */
/*整桶插入List 表头 */
B[Di].tail->next=List;
List=B[Di].head;
B[Di].head=B[Di].tail=NULL;/*清空桶*/
—
/*将List 倒入A[]并释放空间*/
for(i=0;i<N;i++)
tmp=List;
List=List->next;
A[i]=tmp->key;
free(tmp);
283
代码7.8 次位优先的基数排序算法
284 第7章 排 序
对N个关键字用R个桶进行基数排序时，其时间复杂度为0(D(N+R)),其中D为分配收
集的趟数，也就是关键字按基数分解后的位数。当记录的个数N与桶的个数基本是同一数量级
时，基数排序可以达到线性复杂度。但注意到由于链表指针操作的引入，这个0(N)的常数项可
能会超过logN,从而实际效果也未必比前面讲过的几种算法要好很多。
另一方面，基数排序用链表实现的好处是不需要将记录进行物理移动，对于大型记录的排序
是有利的，代价是需要0(N)额外空间存放指针。
总之，基数排序的效率与基数的选择密切相关，而基数的选择需要综合考虑待排记录的规模
和关键字的取值范围。
7.7 外部排序
外部排序是指大文件排序，即待排序的数据记录以文件的形式存储在外存储器上。由于文
件中的记录很多、信息容量庞大，所以整个文件所占据的存储单元往往会超过了计算机的内存容
量，因此，无法将整个文件调入内存中进行排序。于是，在排序过程中需进行多次的内外存之间
的交换。在实际应用中，由于使用的外设不一致，通常可以分为磁盘文件排序和磁带文件排序两
大类。
外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含N个记
录的文件分成若干长度为L(<N)的子文件，依次读入内存，利用内部排序算法进行排序。然后，
将排序后的文件写入外存，通常将这些文件称为归并段(Run)或“顺串”;对这些归并段进行逐步
归并，最终得到整个有序文件。可见外部排序的基本方法是归并排序法，例7.5给出了一个简单
的外部排序解决过程。
[例7.5]给定磁盘上有6大块记录需要排序，而计算机内存最多只能对3个记录块进行内
排序，则外部排序的过程如图7.5所示。
有序 有序
输入块
输出块
(b)归并策略
磁盘
有序 有序
内存
(a)分段内排序的结果
磁盘
内存
周转盘
图7.5 外部排序示意
7.8 排序的比较和应用 285
首先将连续的3大块记录读人内存，用任何一种内部排序算法完成排序，再写回磁盘。经过
2次3大块记录的内部排序，得到图7.5(a)的结果。然后另用一个可容纳6大块记录的周转盘，
辅助最后的归并。方法是将内存分成3块，其中2块用于输入，1块用于输出，指定一个输入块
只负责读取一个归并段中的记录，如图7.5(b)所示。归并步骤为：
(1)当任一输入块为空时，归并暂停，将相应归并段中的一块信息写入内存；
(2)将内存中2个输入块中的记录逐一归并入输出块；
(3)当输出块写满时，归并暂停，将输出块中的记录写入周转盘。
如此可将2个归并段在周转盘上归并成一个有序的归并段。
例7.5的解决方法是最简单的归并法，事实上外部排序的效率还可以进一步提高。要提高
外排的效率，关键要解决以下4个问题：
(1)如何减少归并轮数；
(2)如何有效安排内存中的输入、输出块，使得机器的并行处理能力被最大限度地利用；
(3)如何有效生成归并段；
(4)如何将归并段进行有效归并。
针对这四大问题，人们设计了多种解决方案，例如采用多路归并取代简单的二路归并，就可
以减少归并轮数；例如在内存中划分出2个输出块，而不是只用一个，就可以设计算法使得归并
排序不会因为磁盘的写操作而暂停，达到归并和写周转盘同时并行的效果；例如通过一种“败者
树”的数据结构，可以一次生成2倍于内存容量的归并段；例如利用哈夫曼树的贪心策略选择归
并次序，可以耗费最少的磁盘读写时间等。有兴趣的读者可以自行了解更详细的解决过程，本书
就不再赘述。
7.8 排序的比较和应用
7.8.1 排序算法的比较
本章前7节介绍了8种不同的内部排序方法，它们在时间复杂度、空间复杂度和稳定性上各
有优劣。不存在绝对意义上最佳的排序方法，8种排序方法分别适用于不同的条件下。我们首
先从时间复杂度、空间复杂度和是否稳定上比较这几种排序方法。
基数排序是时间复杂度最低的排序方法，借助0(N+R)(R为每个关键字不同取值的个数)
的辅助空间和严格限制的元素数据类型，基数排序仅仅需要0(D(N+R))的时间复杂度。基数
排序适用于处理数量大、关键字取值范围有限的序列，例如扑克牌排序等。同时，基数排序也是
稳定的排序方法。
除了基数排序以外的其余7种排序方法都是建立在比较和交换操作上的，决定其性能的
286 第7章 排 序
是比较、交换(主要是比较)的次数和是否需要额外空间用于保存临时值。显而易见的是，对
任意两个元素进行关键字的比较就可以确定两者的相对位置，而对一个序列的全部N个元素
进行两两比较则可以确认所有元素之间的相互位置关系，从而对所有的元素完成排序。这种
情况下，总的比较次数为N(N-1)/2,因此，如果对全部元素进行两两比较的话，其时间效率
下限是0(N2)。
具有0(N2)时间复杂度的，是简单选择排序、直接插入排序和冒泡排序这3种排序。
元素规模N较小或基本有序时，它们是较好的排序方法。同时，由于相邻的两个元素总是
进行比较，因此在比较两个关键字相等的元素时可以确定两者的相对位置，从而保证排序
后它们不会发生相对位置的变化，因此理论上，这些时间复杂度为0(N2)的排序都是稳
定的，然而简单选择排序在进行最小元素和第一个位置交换时，却改变了被交换元素和
其他元素的相对位置，因此简单选择排序是不稳定的，而直接插入排序和冒泡排序是稳
定的。
希尔排序是最早从0(N2)时间复杂度中提升的排序方法之一，它使用一个增量序列进行
多次的规模逐渐变大的排序。在规模较小的排序时使用直接插入排序将序列基本有序化，这
样一来，在规模较大的排序时就避免了过多的比较和交换，从而将时间复杂度减少到0(N?),
其中d的取值同增量序列和排序对象的具体情况有关，在最差的情况下接近2,即时间复杂度
接近直接插入排序。由于希尔排序无法保证总是将相邻的两个元素进行比较，可能出现一个
元素在排序过程中“跳跃”到和它等值且初始位置在前的另一个元素之前，因此，希尔排序是
不稳定的。
时间效率表现较好的是快速排序、堆排序和归并排序三种排序，它们都使用分而治之
的方法，将原序列分成两个部分，在排序过程中，这两个部分之间只进行复杂度为0(N)的
划分或归并操作，其他的比较或交换操作集中在两个部分各自内部，因此大大减少了比较
或交换的次数。例如，堆排序在堆顶元素输出以后需要寻找下一个堆顶元素，在寻找的过
程中不断地将问题规模减小，直到跳出循环；快速排序在寻找基准后，序列划分为两个部
分，两个部分内部各自进行比较交换，两个部分之间并没有进行比较；同样的，归并排序始
终将规模减半再进行排序，在规模为N时再进行复杂度为0(N)的归并操作。此三种排序
均实现了0(Nlog?N)的时间复杂度。但具体到实际的平均时间效率上，快速排序无疑是最
佳的排序方法。
然而，在最坏情况下，快速排序的时间效率却不如堆排序和归并排序，可能导致0(N2)的最
差结果。此外，快速排序需要0(log?N)深度的栈空间，归并排序也需要0(N)的额外空间，堆排
序在空间复杂度上表现出色，仅需要常数个额外空间。
在稳定性上，归并排序是稳定的，而堆排序和快速排序却是不稳定的。
因此，每一种排序都有其自身优点，适用于不同的情况。应该根据具体的条件，选择相应的
排序方法，甚至将2种以上的排序方法结合使用。表7.6给出了各种排序算法时空效率及稳定
性的比较。
7.8 排序的比较和应用 287
表7.6 排序算法效率比较
排序方法 平均时间复杂度 最坏情况下时间复杂度 额外空间复杂度
0(N2) 0(N2) 0(1)
0(N2) 0(N2) 0(1)
0(N2) 0(N2) 0(1)
0(N) 0(N2) 0(1)
0(Mlog?N) 0(Nlog;N) 0(1)
0(Nlog?N) 0(N2) 0(log?N)
0(Mlog?N) 0(Mlog?N) 0(N)
0(D(N+R)) 0(D(N+R)) 0(N+R)
稳定性
简单选择排序 不稳定
直接插入排序 稳定
冒泡排序 稳定
希尔排序 不稳定
堆排序 不稳定
快速排序 不稳定
归并排序 稳定
基数排序 稳定
7.8.2 排序算法应用案例
1.Google十大热门关键词的排序
在iGoogle里面，有一个叫“Google飙升热搜”的应用，提供Google热门关键词在一段时间
内的排行榜。由于是商业机构的应用，原算法我们不得而知，但是我们可以分析下该应用的
算法原理。
Google数据库中的关键词记录大概是天文数字(数据库中大约存有30亿网页),对于这种
数量级的排序，首先应该想到的是分块处理。若要得到1天内的关键字排行榜，我们只要得到每
1个小时内的十大关键词排行榜；同理只要知道每1分钟内的关键词排行榜，便可知道每1个小
时内的排行榜。Google每分钟全球搜索次数大约在千万级，因此每分钟的关键词数量应该在十
万级左右，问题就转化为对这10万个左右的关键词排序。
初次排序可以采用快速排序，以后每分钟对其进行更新即可。在更新的过程中，可以选择采
用冒泡排序，因为此时的数据已经相对有序，快速排序的性能会因此而急剧恶化。特别是我们只
需要知道前十名的关键词，进行十趟冒泡排序便可得到结果。同理可得1周内、1个月内的关键
词排序。
2.富豪排行榜
所谓富豪排行榜，即指对一个地区内的富豪财富总量进行排序，最后得到前若干名的榜单。
其本质与上文是一致的，都是海量数据排序，其核心思想依旧是分治。
现假设要得到2011年中国十大富豪排行榜。一种方法是采用分治，该问题可以转化为得到
各个省份的十大富豪排行榜，一直分割到某一地区的十大富豪排行榜，将一个海量数据的排序问
题分块为普通的排序问题，最后将每块的排序结果进行归并，并可得到最终的十大富豪排行榜。
当然，这里还可以做一些优化，比如可以对资产超过5000万的人进行排序，5 000万以下的人不
288 第7章 排序
需要进行排序，这样便可剔除掉许多数据。
而在某一个小区域内统计公民财富前十名时，我们不需要对全体公民财富进行完全的排序。
注意到堆排序是可以得到部分有序序列的，我们只要把全体公民财富做成一个最大堆，经过10
次删顶操作就可以得到前十名了。
本 章 小 结
排序是计算机常用的一种重要操作，本章介绍了几种基本的排序算法，让各位读者对排序有
基本了解。排序算法的效率与初始待排序列的特性有关，不存在绝对意义上最佳的排序方法。
随着计算机技术的迅猛发展，排序算法依旧在不断改进，比如冒泡排序在1956年就已被研
究，大部分人都认为这是一个已经解决的问题，然而很多有用的算法依旧不断地被提出，比如
2004年图书馆排序(Library Sort,又名Gapped Insertion Sort)的发表。随着新的应用的不断涌现，
特别是当前互联网行业的快速发展，为排序算法的发展提供了十分有利的土壤。
总之，本章介绍的内容对各位读者来讲只是个开始，有兴趣的读者可以进一步的阅读相
关文献。
习 题
7.1 判断正误。
(1)对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。
(2)采用递归方式对顺序表进行快速排序，每次划分后，先处理较短的分区可以减少递归次数。
7.2 填空题。
(1)对于10个数的简单选择排序，最坏情况下需要交换元素的次数为___。
(2)在快速排序的一趟划分过程中，当遇到与基准主元相等的元素时，如果左右指针都会停止移动，那么当
所有元素都相等时，算法的时间复杂度是____。
(3)给定初始待排序列[15,9.7,8,20,-1.41。如果希尔排序第一趟结束后得到序列为|15,-1,4,8,20,9,
71,则该趟增量为____。
(4)有组记录的排序码为[46,79,56,38,40,841,则利用堆排序的方法建立的初始堆为
7.3 判断简单选择排序是否稳定，并举例说明。提出任何改进方案，使选择排序稳定；提出空间复杂度为
0(1)的改进方案，使选择排序稳定。
7.4 判断快速排序是否稳定，并举例说明。提出至少一种改进方案，使快速排序稳定。
7.5 给定数组|48,27,96,48,25,6,90,17,84,62,49,72,17],请分别用简单选择排序、直接插入排序和
冒泡排序分别进行排序，写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是
否稳定。
7.6 给定数组|48,27,96,48,25,6,90,17,84,62,49,72,171,请分别用堆排序、快速排序和归并排序分别
进行排序，写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是否稳定。
习题 289
7.7 给定数组148,27,96,48,25,6,90,17,84,62,49,72,171,请用3种不同的增量序列分别进行希尔排序，
写出排序过程中每一步操作后的结果，分析各自比较和交换的次数，以及排序结果是否稳定。
7.8 对堆排序的改进：堆排序在元素出堆过程中，每选出一个堆顶元素，就要从堆底交换一个元素至堆顶
(假设最小堆),而实际上，排在堆底的往往是较大的元素，因此即使被交换到了堆顶，仍然要经过数次交换调整
至最小堆。提出一种改进方案，使得调整过程中内存写的次数尽量少。
7.9 请用非递归的方法实现归并排序。
7.10 堆排序、归并排序、快速排序在最坏情况下的时问复杂度是多少，请举例证明。
7.11 如何在0(n)时间内，对0到n2-1个整数进行排序。
7.12 请实现基数排序的MSD算法，分析与ISD的优缺点。
7.13 除了基数排序外，在线性排序算法中，还有什么常用的算法，请举一两种算法，并分析其时间复杂度
和空间复杂度，最后和基数排序比较，分析优缺点和适用情况。
7.14 现想对新浪微博每天信息转发情况进行一个排序，得到被转发最多的前十条信息，而微博上每日信
息量在亿的数量级，属于海量数据问题，请给出一个解决方案。
7.15 某名企的面试题有一道是这样的：从1000个数字中找出最大的10个数字，最快的算法是_______。
A.归并排序 B.快速排序 C.堆排序 D.选择排序
答案是C。但是这个答案真的对吗?
第8章
综合应用案例分析
本章将给出两个生活中的实际案例，提出层层加难的问题以及相应的解决方案，从而帮助读
者体会本书中介绍的数据结构与算法在解决实际问题中的应用。
8.1 银行排队问题
银行排队已经成为一个日益令人头痛的问题，甚至受到不少媒体的关注。图8.1展示了
某银行营业大厅一角排队的人群。为了解决这个问题，不同银行采取了不同的解决方法。下
面就让我们利用学过的数据结构与算法，编程模拟这些解决方案，从而比较分析不同方法产
生的效果。
图8.1 银行排队景象
对于下面将要讨论的各种排队策略，我们的输入都是顾客总人数N,以及这N位顾客的到达
时间T和事务处理时间P,并且假设输入数据已经按到达时间先后排好了顺序。另外我们还定
义每位顾客事务被处理的最长时间为MaxProc分钟，银行最多可开设MaxWindow个营业窗口。
要求输出所有顾客的平均等待时间。
8.1.1 单队列多窗口服务
[策略描述]假设银行有K个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄
8.1 银行排队问题 291
线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。图8.2给出了这种排
队策略的示意。
银行窗口 银行窗口
…
顾客 顾客
银行窗口
顾客
黄 线
顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客
顾客
顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客 顾客
顾客
顾客 顾客 顾客 顾客 顾客 顾客
图8.2 单队列多窗口服务
[实现方法]这种策略比较简单，我们只需要用一个队列模拟即可。队列的基本接口定义
与第3章中的定义一致，代码8.1列出了程序必需的部分类型定义和操作。
typedef struct People ElementType;
struct Peoplel/·顾客类型·/
int T;/*顾客到达时间*/
int P;/* 顾客事务被处理的时间*/
I;
typedef int Position;
struet QNodel/*队列结点*/
ElementType *Data;*顾客数组*/
Position Front,Rear;/*队列的头、尾指针*/
int MaxSize; /*队列最大容量*
I;
typedef struct QNode*Queue;
/以下函数的实现见代码3.17*/
Queue CreateQueue(int MaxSize);
bool ISFu11(Queue Q);
bool Addo(Queue Q,ElementType X);
bool ISEmpty(Queue Q);
ElementType DeleteQ(Queue Q);
代码8.1 单队列多窗口服务模拟队列定义
292 第8章 综合应用案例分析
代码8.2给出了主函数。注意到核心处理函数为QueueingAtBank,它接受传入的参数包括
顾客队列和人数，返回顾客平均等待时间。
int main()
int N;/*顾客总数*/
Queue Q;/*顾客队列*/
int i;
ElementType X;
scanf("d",&N);/*读入顾客人数*/
Q=CreateQueue(N);/*建立空的顾客队列·/
for(i=0;i<N;i++)|/顾客依次人列*/
scanf("8dtd",&X.T,&X.P);
AddQ(Q,x);
/*打印出N位顾客平均等待时间*/
printf("Average waiting time=.If minute(s).n",QueueingAt Bank(Q,N));
DestroyQueue(Q);
return 0;
代码8.2 单队列多窗口服务模拟主函数
核心函数QueueingAtBank 由代码8.3给出，其处理过程非常直观，描述如下。
(1)我们用一个数组Window记录当前每个营业窗口需要处理事务的时间长度，通过调用
函数FindNextWindow得到下一个空闲窗口的位置WinAvail 以及在相邻两次窗口空闲之间所等
待的时间WaitTime,然后更新当前时间CurrentTime为上一次的当前时间累加上等待时间；
(2)下一位顾客Next 出队列。这时有两种情况：
①顾客早已经到达银行，等在队列里。则该顾客的等待时间就是当前时间与其到达时间的
差，累加到等待总时间TotalTime上。
②窗口空闲，但是下一位顾客还没有到，则刷新所有窗口至下一位顾客到达时的状态，并更
新当前时间。
(3)顾客Next到WinAvail 窗口接受服务。
以上3步对每一位顾客重复，直到队列为空。最后用等待总时间TotalTime除以总人数N,
8.1 银行排队问题 293
得到每位顾客的平均等待时间并返回。
double QueueingAtBank(Queue Q,int N)
/*根据顾客队列Q和人数N,返回顾客平均等待时间*/
struct People Next;/8下一位顾客·/
int K; /*营业窗口个数·/
int TotalTime; /*全体顾客等待总时间/
int CurrentTime; /*当前时间，开门营业时为0*/
int window[Maxwindow]:/*营业窗口需要处理事务的时间长度*人
int WaitTime: /*相邻两次窗口空闲之间所等待的时间*/
int winAvail; /*空闲窗口的位置*/
int i,j;
scanf("d",&K):/*读人营业窗口个数*/
if(N<K)return 0;/*如果窗口比人多，则无须等待*/
/*--------初始化--------*/
TotalTime=0;
while(!ISEmpty(Q))/*当队列非空时，持续处理·/
/*--第1步：处理掉当前最短的事务，得到下一个空闲窗口--*/
/*-------------第2步：下一位顾客出列-------------*/
Next=DeleteQ(Q);
if(CurrentTime >=Next.T)/* 如果顾客已经到达等待·/
TotalTime+=(CurrentTime-Next.T);/· 累计等待时间*/
else|/* 如果顾客还没到*/
WaitTime=Next.T-CurrentTime;/* 空闲窗口等待顾客的时间*/
Window[3]-=WaitTime;
if(Window[j]<0)Window[j]=0;
for(i=0;i<K;i++)
winAvail=FindNextWindow(Window,K,&waitTime);
for(j=0;j<K;j++)1/* 刷新所有窗口至顾客到达的状态*/
window[1]=0;
CurrentTime+=WaitTime;
294 第8章 综合应用案例分析
currentTime=Next.T;/* 更新当前时间为顾客到达时间/
/*---第3步：顾客Next到WinAvail窗口接受服务---*/
window[WinAvail]=Next.P;
/*返回每位顾客的平均等待时间*
return((double)TotalTime(double)N);
代码8.3 单队列多窗口服务模拟核心处理函数
函数FindNextWindow的作用，是把当前窗口事务中耗时最短的一个处理掉，得到这个空闲
窗口的位置WinAvail,并且这个最短事务的耗时就是从上一次有空闲窗口到产生下一次空闲窗
口之间所等待的时间WaitTime。代码8.4给出了这个函数。
int FindNextwindow(int W[],int K,int *WaitTime)
1/给定K个窗口W[]的状态，返回下一个空闲窗口的位置*/
/以及在相邻两次窗口空闲之间所等待的时间WaitTime*/
int WinAvail;/下一个空闲窗口的位置·/
int MinW=MaxProc+1;/*最短事务处理时间，初始化为超过最大值*/
int i:
for(i=0;i<K;i++)/*扫描每个窗口，找到最短事务*/
if(W[i]<MinW)
MinW=W[i];WinAvail=i:
WaitTime=MinW:/*最短事务处理时间就是两次空窗间的等待时问
for(i=0:i<K;i++)/*刷新所有窗口的事务处理状态*/
W[1]-=MinW;
return WinAvail;/*返回下一个空闲窗口的位置·/
代码8.4 单队列多窗口服务模拟FindNextWindow 函数
注意到我们可以用一个最小堆来更快速地找到最短事务，使得这个步骤的复杂度从O(K)
降到O(logK)。但是另一方面，由于这个最短事务被处理掉以后，每个窗口的状态都需要随之更
新，所以时间复杂度无论如何都会是Ω(K)。从渐进意义上看，没有必要维护一个堆结构，用最
8.1 银行排队问题 295
简单的一维数组即可。但建议有兴趣的读者自己尝试用最小堆实现，并与代码8.4的版本做比
较，看效率究竟相差多少?
[复杂度分析]程序主要部分由代码8.2~8.4给出，其中代码8.2中主函数复杂度由建立
队列和核心处理两个函数决定。
代码8.2中建立队列的过程包含了一个for 循环，将N个顾客人列，所以时间复杂度显然是
O(N)。
代码8.3的初始化窗口部分用了O(K);之后的while循环对N个顾客进行了处理，每一次
处理需要调用代码8.4中复杂度为θ(K)的函数，并且有可能需要用θ(K)时间处理顾客未到达
的情况，所以while循环的总体时间复杂度是θ(NK)。
综上所述，程序的时间复杂度是0(N)+O(K)+O(NK)=0(NK)。
程序需要存储N个顾客和K个窗口的信息，所以空间复杂度是O(N+K)。
[测试数据]测试数据至少应包含4种类型：
(1)窗口数比顾客数多，这时平均等待时间必定是0;
(2)顾客人数多，且到达时间密集，每次空窗口都有顾客等待；
(3)顾客人数多，但到达时间稀疏，出现有若干个空窗口但需要等待下一位顾客的
情况；
(4)随机混合数据。
由于篇幅所限，在此仅列出少量测试数据以及答案(如表8.1所示),供读者参考。输入数
据格式为：第1行给出N;后面N行给出N位顾客的到达时间T和事务处理时间P;最后一行给
出该银行的营业窗口个数K。
表8.1 单队列多窗口服务模拟部分测试数据
2
1 20
215
3
6
020
015
030
02
160
310
3
5
03
04
12
45
55
3
Average waiting time=
0.0 minute(s).
Average waiting time=
8.0minute(s).
Average waiting time=
0.0minute(s)。
9
020
115
160
210
输人 105
103
3018
3125
312
3
输出 Average waiting time=
6.2 minute(s).
296 第8章 综合应用案例分析
8.1.2 单队列多窗口+VIP服务
[策略描述]有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大
限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服
务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。
同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口。
[实现方法]我们仍然可以用一个队列模拟排队的情况。不同的是，这个问题中有一个隐
形的VIP子队列——每当VIP窗口空闲时，我们不是简单地令下一位顾客出列，而是必须查找
队列中排在最前面的VIP客户。如果我们只是简单地顺序检查队列中的顾客，那么最坏情况是
队列中根本没有VIP客户，而我们必须问过每一位才能确定没有，所以这种查找的方法需要的
时间复杂度是0(N)。更糟糕的情况是，如果银行只开一个VIP窗口，那么这个窗口就要处理全
部N位顾客，总时间复杂度就会是0(N2)。
显然存在更好的解决方案。我们可以将标准的队列结构稍做修改，增加一个VIP子队列的
定义。这个子队列并不重复存储客户信息，只存储该客户在队列中的位置。当VIP窗口空闲
时，我们首先检查VIP子队列，如果非空，则令队首的VIP客户出列，同时将之从全体顾客队列
中删除；如果为空，则令下一位普通顾客出列。
理解了这个过程后，我们只需要对队列的结构和操作做内部修改，而无须改变对外接口。
代码8.5给出了程序必须的部分类型定义和操作，这里只对增加的部分内容做了注释。注
意到顾客信息增加了一个VIP标志，为1时表示是VIP客户，为0时是普通顾客，为-1时标志该
顾客已经被删除。
typedef struct People ElementType;
struct Peoplel
int T;
int P;
int VIP:/ VIP标志：1=VIP;0-普通；-1-删除
I;
typedef int Position;
struct QNodel/+队列结点/
ElementType *Data:/*顾客数组*/
Position Front,Rear;/*队列的头、尾指针·/
int Maxsize; /队列最大容量*/
/-下面是VIP子列的相应元素--*/
Position VIPFront,VIPRear;
int *VIPCustomer;
int VIPSize;/*队列中VIP的数量·/
8.1 银行排队问题 297
/*----------------------*/
I:
typedef struct QueueRecord*Queue;
bool VIPIsFull(Queue Q); /*判断VIP队列是否为满*/
boo1 AddVIP(Queue Q,Position P);/*对VIP客户的人列操作·/
bool VIPISEmpty(Queue Q): /*判断VIP队列是否为空 */
ElementType DeleteVIP(Queue Q);/* 对VIP客户的出列操作 */
Queue CreateQueue(int MaxSize);
bool Addo(Queue Q,ElementType X);
bool IsFu11(Queue Q);
bool ISEmpty(oueue Q):
ElementType DeleteQ(Queue Q);
代码8.5 单队列多窗口+VIP服务模拟队列定义
在代码8.2的基础上，"顾客依次入列"部分需要增加建立VIP子列的内容，即当读入
的顾客是VIP时(输人在T和P的后面增加了一项VIP的值),需要将此顾客在队列中的位
置Q->rear存到VIP子列中。具体代码留给读者作为练习。
代码8.6给出了新的QueueingAtBank 函数，并用粗体标出了与代码8.3不同的部分。最主
要的区别是当VIP窗口空闲时，用IsVipHere 检查当前时刻有没有VIP在等待，如果有，则调用
DeleteVIP函数令VIP客户出列，否则做普通顾客处理。注意，当空闲窗口不是VIP窗口时，下一
位顾客无论是否VIP都当作普通顾客处理。
double QueueingAt Bank(Queue Q,int N)
/*根据顾客队列Q和人数N,返回顾客平均等待时间*/
struct People Next;
int K; /*营业窗口个数*/
int TotalTime; /*全体顾客等待总时间*/
int CurrentTime; /*当前时间，开门营业时为0*
int window[MaxWindow];/*营业窗口需要处理事务的时间长度*/
int WaitTime; /*相邻两次窗口空闲之间所等待的时间/
int WinAvail; /*空闲窗口的位置*/
int i,i;
int VIPWindow;/VIP窗口编号/
scanf(“d d*,&K,&VIPWindow);/* 读入营业窗口个数和VIP窗口编号*/
298 第8章 综合应用案例分析
if(N<K)return 0;/·如果窗口比人多，则无须等待*/
/*-------初始化--------*/
for(i=0;i<K;i++)
Window[1]=0;
TotalTime=0;
/*--------------------
while(!ISEmpty(Q))|
/--第1步：处理掉当前最短的事务，得到下一个空闲窗口--*/
WinAvail=FindNextwindow(Window,K,&WaitTime);
CurrentTime+=WaitTime;
/*------------第2步：下一位顾客出列-------------/
if((WinAvail==VIPWindow)&&(IsVipHere(Q,currentTime)))
Next=DeleteVIP(Q);/* 如果VIP窗口空且有VIP在队伍中等·/
else
Next=DeleteQ(Q);
if(Next.T==EmptyQ)break;/* 如果收到队列已空的信号，退出循环·/
if(CurrentTime>=Next.T)/* 如果顾客已经到达等待·/
TotalTime+=(CurrentTime-Next.T);/* 累计等待时间·/
else|/* 如果顾客还没到*/
WaitTime=Next.T-CurrentTime;/空闲窗口等待顾客的时间*/
for(j=0;j<K;j++)|/*刷新所有窗口至顾客到达的状态*/
Window[j]-=WaitTime;
if(Window[i]<0) Window[i]=0:
currentTime=Next.T;/·更新当前时间为顾客到达时间·/
1
/---第3步：顾客 Next到WinAvail窗口接受服务---*/
Window[WinAvail]=Next.P;
return((double)TotalTime/(double)N);
代码8.6 单队列多窗口+VIP服务模拟核心处理函数部分代码
8.1 银行排队问题 299
注意，如果我们用数组实现队列，则从普通顾客队列中真正删除VIP客户，将可能涉及大量
数组元素的位移，使得删除操作的时间复杂度从0(1)升到0(N);同时VIP子列中其他元素的
位置值也需要调整，这是不可接受的。为了避免这种情况，我们可以改用链表实现队列，但是同
时又要面对指针操作的危险性和效率的降低。一般情况下，我们假设银行不会有太多的VIP客
户(否则VIP就失去了意义),这时可以采用懒惰删除(Lazy Deletion),即用一标记表示该顾客已
经被删除，而并不实际将该元素删去。
于是在令顾客出列时，我们必须检查标记，直到找到一位存在的顾客出列。而这时候有可能
出现全部队列中的顾客都已经被删除的情况，所以出列函数中还必须准备一个空队列信号用以
返回。在这里我们用到达时间T为负数来标志队列已经为空。
代码8.7给出了DeleteVIP函数的懒惰删除实现方法；代码8.8给出了相应的DeleteQ函数
的实现。
bool VIPIsEmpty(Queue Q)
return(Q->VIPSize==0);
ElementType DeleteVIP(Queue Q)
/*令VIP子列队首的客户出列·/
ElementType X;
Position P;
if(!VIPISEmpty(Q))|/*如果存在VIP客户*/
/* 获得队首客户在顾客队列中的位置*/
P=Q->VIPCustomer[Q->VIPFront];
/*将该位置从VIP子列中删除*/
Q->VIPFront++;
Q->VIPSize--;
Q->Data[P].VIP=-1;/* 懒惰删除顾客队列中的VIP*/
X.T=Q->Data[P].T;
X.P=Q->Data[P].P;
else /*如果没有VIP客户，则做普通出列*/
X=DeleteQ(Q);
return X;
代码8.7 单队列多窗口+VIP服务模拟 DeleteVIP函数
300 第8章 综合应用案例分析
#define EmptyQ-1/*队列空的信号·/
ElementType DeleteQ(Queue Q)
/*令Q队首的顾客出列·/
ElementType X;
/*将位于队列前端的被懒惰删除的顾客真正删除*/
while(Q->Data[Q->Front].VIP==-1)
Q->Front++;
if(ISEmpty(Q))/·如果清除后发现队列已空，返回空信号·/
x.T=EmptyQ;
return X;
if(Q->Data[Q->Front].VIP==1)
X=DeleteVIP(Q);/* 令队首的VIP-客户出列*/
elsel /*普通顾客出列*/
X.T=Q->Data[Q->Front].T;
X.P=Q->Data[Q->Front].P;
/·删除队首的顾客·/
Q->Front++;
return X;
代码8.8 单队列多窗口+VIP服务模拟 DeleteQ 函数
[复杂度分析]本节程序与8.1.1节的程序的复杂度分析十分相似，当然前提是各个功能
函数均正确实现。
函数IsVipHere只需要常数时间即可判断当前时刻是否有VIP在等待。根据代码8.7和
8.8的实现方法，DeleteQ和DeleteVIP都可以在常数时间内完成。虽然在DeleteQ中出现了一个
while 循环，但这个循环在QueueingAtBank 中执行的总次数不超过VIP的个数，即0(N)。所以
时间复杂度不变，仍然是0(NK)。
程序需要的存储空间为VIP客户的子列增加了0(N)个单元，从渐进意义上讲，空间复杂度
也不变，仍然是O(N+K)。
[测试数据]测试数据至少应包含6种类型：
(1)重复上一节的测试，令全体顾客为普通顾客，结果应不变；
(2)重复上一节的测试，令全体顾客为VIP,结果应不变；
(3)VIP窗口空闲时，有VIP顾客在普通顾客后面等待的情况；
(4)VIP窗口空闲时，有普通顾客等待，但下一位VIP还未到达的情况；
8.2 畅通工程问题 301
(5)最后一位顾客是VIP且在VIP窗口接受服务的情况——这时队列中会残留一个被懒
惰删除的元素；
(6)随机混合数据。
由于篇幅所限，在此仅列出第3~6类少量测试数据以及答案(如表8.2所示),供读者参考。
输入数据格式为：第1行给出N;后面N行给出N位顾客的到达时间T、事务处理时间P以及是
否VIP的标志；最后一行给出该银行的营业窗口个数K、VIP窗口的编号。
表8.2 单队列多窗口+VIP服务模拟部分测试数据
5
0200
0151
0300
1050
12101
30
6
0100
1
1300
1050
12101
1220
30
5
0100
1
1300
1050
12101
30
151 151
Average waiting time =
2.6 minute(s).
Average waiting time=
1.2 minute(s)。
Average waiting time=
0.6 minute(s).
7
0200
1601
1501
输入 2100
3151
10121
1050
30
Average waiting time= 输出 18.3minute(s)。
8.2 畅通工程问题
某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工
程”的目标：使整个地区任何两个城镇间都可以实现快速交通(但不一定有直接的快速道路相
连，只要互相间接通过快速路可达即可)。由于实现畅通目标时要考虑的侧重点不同，使得相应
的解决方法也不相同。
解决各种问题的共同点是：我们总可以把各城镇看成图中的结点，连接两城镇的快速路看成
边，于是畅通工程问题就转化为各种版本的图论问题。
8.2.1 建设道路数量问题
[问题描述]现有城镇道路的统计数据表中列出了每条快速路直接连通的城镇，问最少还
需要建设多少条快速路就可以达到畅通目标?
输入数据包括城镇数目N和快速路数目M;随后的M行对应M条快速路，每行给出一对正
整数，分别是该条快速路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。要求
302 第8章 综合应用案例分析
输出需要建设的快速路的条数。
[实现方法]我们把已经连通的一片城镇区域看成图的一个连通集，这个问题就等价于问
目前给定的图中有多少个独立的连通集，而连通K个集合，最少需要K-1条边。
数图的连通集个数有多种方法。最直接的方法，是根据输人数据建立一个图的结构，然后用
深度优先搜索遍历整个图，从而得到连通集的个数。我们可以用邻接矩阵，也可以用邻接表来实
现图结构。代码8.9给出了邻接表实现下连通集个数的计算函数。其中图的基本定义与第6章
相同；函数InitializeVisited是将标志数组Visited初始化为0;DFS则是标准的深度优先搜索函数，
将访问过的结点的标志设为1;cnt是一个整型变量，作为连通集的计数器。而主函数需要输出
的快速路的条数是cnt-1。
int CountconnectedComponents(LGraph Graph)
1/*计算图Graph 中连通集的个数*/
VertexV;
int cnt=0;
/*将全局变量Visited[]初始化为 false*/
InitializeVisited(Graph->Nv);
/*每一次DFS对应一个连通集*/
for(V=0;V<Graph->Nv;V++)
if(!Visited[V])
DFS(Graph,V);
cnt++;
return cnt;
代码8.9 连通集个数计算函数
还有另外一种更简单的方法，即利用并查集，将有边相连的结点都并入同一集合，最后数一
下有多少个集合即可。代码8.10给出了并查集的实现，其中并查集的标准函数Union和Find与
第4章中定义相同。
typedef Vertex ElementType;
void Initialization(SetType s,int N)
1/*集合初始化*/
int i;
for(i=0;i<N;i++)
8.2 畅通工程问题 303
s[i]=-1:
1
void InputConnection(SetType s,int M)
/*读入M条边，并将有边相连的结点并人同一集合·/
Vertex U,V;/*记录输人的结点
Vertex Root1,Root2;/* 记录输入结点所在的集合的根结点·/
int i:
for(i=0;i<M;i++)
scanf("8d8d",&U,&V);
Root1=Find(S,U);
Root2=Find(S,V);
if(Root1!=Root2)
Union(s. Root1. Root2);
int CountconnectedComponents(SetType s,intN)
/*计算集合S中连通集的个数·/
int i,cnt=0;
for(i=0;i<N;i++)
if(s[i]<0)
cnt++;
return cnt;
int main()
SetType S;
int N,M;
scanf("8d d",&N,&M);
Initialization(s,N);
InputConnection(S,M);
304 第8章 综合应用案例分析
printf("需要建设道路8d条\n",CountConnectedComponents(S,N)-1);
return 0;
代码8.10 利用并查集统计连通集个数
[复杂度分析]无论是用图的邻接表深度优先搜索，还是用并查集，两种方法的时间复杂度
都是0(N+M)。
在图的邻接表实现中，我们需要0(N+M)的时间建立邻接表，再用0(N+M)的时间遍历图
中的每个结点和每条边。在并查集实现中，我们用0(N)时间初始化集合，用0(M)时间合并每
条边对应的一对结点，最后用0(N)时间扫描每个结点以统计集合根结点的个数。所以总的时
间也是0(N+M)。虽然从渐进的意义上看，两种算法效率基本相同，但由于图的邻接表涉及大
量指针操作，且每条边需要存两遍，所以实际运行效果会比并查集实现慢很多。
在空间利用上，并查集也占有明显优势，因为我们只需要0(N)的整型数组来存放集合，而
图的邻接表需要存储O(N+M)个结点。
[测试数据]测试数据至少应包含以下3种类型：
(1)完全连通图，不需要新建道路；
(2)完全没有边的图，需要N-1条道路；
(3)随机产生的大数据量测试。
8.2.2 最低成本建设问题
[问题描述】现有城镇道路的统计数据表中列出了有可能建设成快速路的若干条道路的成
本，求畅通工程需要的最低成本。
输入数据包括城镇数目N和候选道路数目M;随后的M行对应M条道路，每行给出3个正
整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城
镇从1到N编号。要求输出畅通工程需要的最低成本。如果输入数据不足以保证畅通，则输出
“需要建设更多道路”。
[实现方法]我们把道路建设成本看成图中对应边的权重。要保证图中N个结点的连通，
我们至少需要构建N-1条边，使得结点连接成一棵树；而要求成本最低，就意味着N-1条边的
总权重最小。这个问题就等价于求给定带权图的最小生成树问题。
求最小生成树的算法伪码已经在第6章给出，在此我们选择 Kruskal算法。代码8.11给出
了核心Kruskal算法的实现。
int Kruskal(LGraph Graph,LGraph MST)
|/*将最小生成树保存为邻接表存储的图MST,返回最小权重和*/
WeightType TotalWeight;
8.2 畅通工程问题 305
int ECount, NextEdge;
InitializeVSet(VSet.Graph->Nv):/*初始化顶点并查集*/
MST=CreateCraph(Graph->Nv);
TotalWeight=0;/*初始化权重和*/
ECount=0:
NextEdge=Graph->Ne;/+原始边集的规模
while(ECount<Graph->Nv-1) /*当收集的边不足以构成树时*/
NextEdge=GetEdge(ESet,NextEdge);/+ 从边集中得到最小边的位置
if(NextEdge<0)/ 边集已空*/
break;
/*如果该边的加入不构成回路，即两端结点不属于同一连通集·/
if(Checkcycle(VSet,ESet[NextEdge].V1,ESet[NextEdge].V2)==true)
/*将该边插入MST/
InsertEdge(MST,ESet+NextEdge);
Totalweight+=ESet[NextEdge].Weight;/* 累计权重*/
ECount++;/* 生成树中边数加1·/
if(ECount<Graph->Nv-1)
TotalWeight=-1;/设置错误标记，表示生成树不存在·/
return Totalweight;
SetType Vset;/*顶点数组*/
ESet=(Edge)malloc(sizeof(struct ENode)*Graph->Ne):
/*初始化收录的边数*/
Edge ESet;/*边数组·/
InitfalizeESet(Graph,ESet);/* 初始化边的最小堆*/
/·创建包含所有顶点但没有边的图。注意用邻接表版本·
代码8.11 Kruskal算法函数
代码8.11中，结点集合的初始化留给读者练习。我们知道Kruskal算法的关键在于两个函
数的实现，即GetEdge——用最快速度找出权重最小的边以及CheckCycle——判断该边的加入是
否会构成回路。
找出权重最小的边，可以通过先按边的权重排序，再顺序取出的方法，这种方法取出边比较
方便，只要0(1)的时间，但排序一般需要的时间复杂度是0(MlogM)。如果图中边比较密集，例
306 第8章 综合应用案例分析
如完全图中有M=0(N2),则这一步就需要M=0(N2logN)。即使最后结果需要的N-1条边都排
在最前面，也不能降低时间复杂度，因为我们需要事先对M条边进行完全的排序。
另一种方法是维护一个关于边权重的最小堆。我们有0(M)时间复杂度的算法建立这个最
小堆，每次从堆中取出最小元的方法与堆排序类似。这样做的好处是不需要对全部M条边进行
排序。在最好情况下，如果结果需要的N-1条边都排在最前面，我们只需要O(NlogM)的时间就
可以得到结果。在最坏情况下，这种方法与排序的方法持平。所以我们选择用最小堆实现Get Edge函数。代码8.12给出了实现，其中PercDown函数与第7章代码7.2中给出的函数相似。
void PercDown(Edge ESet,int p,int N)
/*改编代码4.24的PercDown(MaxHeapH,int p)
/*将N个元素的边数组中以 ESet[p]为根的子堆调整为关于Weight的最小堆·/
int Parent,Child;
struct ENode x;
X=ESet[p];/*取出根结点存放的值·/
for(Parent=p;(Parent*2+1)<N; Parent=Child)
child=Parent*2+1;
if((Child !=N-1)&
(ESet[child].Weight>ESet[child+1].Weight))
Child++;/* Child指向左右子结点的较小者*/
if(X.Weight<=ESet[Child].Weight)break;/·找到了合适位置*/
else /下滤X·/
ESet[Parent]=ESet[Child];
ESet[Parent]=x;
void InitializeESet(LGraph Graph,Edge ESet)
/*将图的边存人数组 ESet,并且初始化为最小堆·/
VertexV:
PtrTOAdjVNode W;
int ECount;
/*将图的边存入数组ESet*/
ECount=0;
for(V=0;V<Graph->Nv;V++)
for(W=Graph->G[V].FirstEdge;W;W=W->Next)
if(V<W->AdjV)|/* 避免重复录入无向图的边，只收V1<V2的边*/
8.2 畅通工程问题 307
ESet[ ECount].V1=V;
八初始化为最小堆/
for(ECount =Graph->Ne/2:ECount>=0;ECount--)
PercDown(ESet. ECount,Graph->Ne);
int GeLEdge(Edge ESet,int CurrentSize)
给定当前堆的大小Currentsize,将当前最小边位置弹出并调整堆/
/*将最小边与当前堆的最后一个位置的边交换*/
Swap(&ESet[0],&ESet[CurrentSize-1]);
/*将剩下的边继续调整成最小堆*/
PercDown(ESet,0,Currentsize-1);
return Currentsize-1;╱*返回最小边所在位置*/
ESet[ ECount].V2=W->AdjV;
ESet[ECount++].Weight=W->Weight;
代码8.12 快速得到最小边的函数
如第6章中已经介绍过的，对每一条待收入的边，我们用并查集来判断该边的加入是否会构
成回路。代码8.13给出了CheckCycle 函数的实现。
bool CheckCycle(SetType VSet,Vertex V1,Vertex V2)
/*检查连接V1和V2的边是否在现有的最小生成树子集中构成回路·
Root1=Find(VSet,V1);/*得到V1所属的连通集名称/
Root2=Find(VSet,V2);/*得到V2所属的连通集名称/
if(Rootl==Root2)/*若V1和V2 已经连通，则该边不能要*/
return false;
elsel/*否则该边可以被收集，同时将V1和V2并入同一连通集·/
Union(VSet,Root1,Root2);
return true;
Vertex Root1,Root2;
代码8.13 检查回路的函数
308 第8章 综合应用案例分析
[复杂度分析]程序的总体复杂度是由代码8.11给出的核心函数Kruskal决定的。
首先我们需要0(N+M)的时间初始化结点和边的集合。收集边的while循环最坏情况下需
要遍历全部M条边。在循环内部，取得最小边的GetEdge 函数的时间复杂度为0(logM),而检
查回路的函数CheckCycle的时间复杂度不会超过0(logN)。于是总体时间复杂度在最坏情况下
是0(N+M+M(logM+logN))=0(MlogN)。如果图中边比较稀疏，即M=0(N),或者while循环
只用0(N)次即可完成最小生成树的构造，则算法复杂度可降低为0(MlogN)。所以说Kruskal
算法在边比较稀疏的情况下有比较好的效率。
由于结点集合、边的集合均用一维数组实现，所以空间复杂度是0(N+M)。
[测试数据]测试数据至少应包含以下3种类型：
(1)给出的边数不足N-1,需要建设更多道路；
(2)给出的边数不少于N-1,但图不连通，需要建设更多道路；
(3)随机产生的大数据量测试。
由于篇幅所限，在此仅列出少量测试数据以及答案(如表8.3所示),供读者参考。输入数
据格式为：第1行给出城镇数目N和候选道路数目M;随后的M行对应M条道路，每行给出3个
正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。
表8.3 最低成本建设畅通工程问题部分测试数据
31
232
54
121
232
313
454
Must construct more roads. Must construct more roads.
615
125 133
147
154
162
234
输入 246
252
266
346
351
361
4510
468
563
输出 Minimum Cost=12
习题 309
本 章 小 结
本章通过对银行排队问题的不同解决方案的模拟，展示了队列的灵活应用方法；通过对城镇
畅通工程的不同要求进行分析和解决，展示了图论在实际生活中的应用。
希望读者能通过本书的学习提高实践能力，使数据结构与算法成为用计算机解决实际问题
的有效工具。
习题
8.1 试修改8.1.1节中单队列多窗口服务的模拟程序，使得不仅能计算顾客平均等待时间，还能输出最长
等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。
8.2 试在代码8.2的基础上，使得在建立顾客队列的同时，建立VIP子列。
8.3 试实现8.1.2节中的IsVipHere 函数，检查当前时刻(即CurrentTime)在队列Q中有没有VIP在等待。
如果有，则返回1;否则返回0。
·8.4 银行排队的另一种解决方案是“多队列多窗口服务”,即在黄线到每个窗口之间允许排M位顾客，形
成K条队列。如果K个窗口前的队列全排满了，其他顾客只好在黄线后的多队列入口处排成一列。在多队列人
口处的顾客总会选择K条队列中最短的一条加入。试编写程序模拟这种策略，并计算顾客的平均等待时间。
*8.5 排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行排队的问题中，如果已知第
i位顾客与排在后面的第j位顾客是好朋友，并且愿意替朋友办理事务的话，那么第1位顾客的事务处理时间就
是自己的事务加朋友的事务所耗时间的总和。在这种情况下，后面顾客的等待时间就可能被影响。试编写程序
模拟这种现象，并计算顾客的平均等待时间。
8.6 试实现8.2.2节中初始化函数InitializeVSet,初始化结点并查集 VSet,即将N个结点看成N个只有单
独元素的独立的集合。
8.7 试给出解决8.2.2节问题的完整代码，使能至少通过表8.3中的测试。
·8.8 畅通工程问题的另一个版本是，在得到现有每条快速路直接连通的城镇，并测算出其他有可能建设成
快速路的若干条道路的成本后，求畅通工程需要的最低成本。试编写程序解决这个问题。
附录
PTA 使用说明
本书正文中部分以及习题中的程序设计题目可以在PAT(Programming Ability Test,计算机
程序设计能力考试)的配套练习平台PTA(Programming Teaching Assistant)上进行练习。
1.PAT与PTA
(1)什么是PAT
PAT旨在通过统一组织的在线考试及自动评测方法客观地评判考生的算法设计与程序设
计实现能力，科学地评价计算机程序设计人才，为企业选拔人才提供参考标准。目前PAT已成
为IT界的标准化能力测试，得到包括Google、Microsoft、雅虎、网易、百度、腾讯等在内的百余家大
中小型各级企业的认可和支持，他们纷纷开辟了求职绿色通道，主动为PAT成绩符合其要求的
考生安排面试，免除计算机程序设计方面的笔试环节。同时，PAT(甲级)一年内的成绩可作为浙
江大学计算机学院硕士研究生招生考试上机复试成绩。
PAT在每年的春季(2、3月间)、秋季(8、9月间)和冬季(11、12月间)组织3场统一考试。考试
为3小时、闭卷、上机编程测试，总分为100分。考试分为3个不同的难度级别：顶级(Top Level)、
甲级(Advanced Level)、乙级(Basic Level)。顶级考试3题，题目描述语言为英文；甲级考试4题，题
目描述语言为英文；乙级考试5题，题目描述语言为中文。要求考生按照严格的输入输出要求提交
程序，程序须经过若干测试用例的测试，每个测试用例分配一定得数。每题的得分为通过的测试用
例得分之和，整场考试得分为各题得分之和，提交错误不扣分。
PAT不设合格标准，凡参加考试且获得非零分者皆有成绩，可获得统一颁发的证书。证书
中包含“考试分数/满分”和“排名/考生总数”两个指标。PAT提供官方证书查验功能，在官网相
应位置输人证书编号即可查验真伪。
PAT官网网址：http://www.patest.cn。
(2)什么是PTA
PTA是PAT的配套练习平台，支持更丰富的题目类型，其编程类题目具有与PAT相同的判
题系统环境，配有方便的辅助教学工具，并由全国高校程序设计与算法类课程群的教师们共同建
设内容丰富的题库。本书的题目集就部署在PTA上(见附录图1),读者进入题目集后，单击右
侧"我是读者"并输入验证码，即可进行练习(见附录图2)。
PTA官网网址：http://pta.patest.cn。
2.PTA 工作机制
PTA系统中，提交的程序代码由服务器自动判断正确与否，判断的方法如下。
附录 PTA使用说明 311
程序设计类实验辅助教学平台
首页 题目集列表
题目集 新建肥日来
题库
标题 开放状态
用户组 浙大版(露结构(第2版)》题目集 一直可用
中国大学M00C-、问钦铬-数据结构起步能力自测
理 一直可用
浙大蚯C语言程序进计(第3)》题目果 一直可用
渐大版《O语言程序设计实益与习题指导(第3版)》
超目架 一直可用
附录图1 从PTA首页进入系统后，可查看“浙大版《数据结构(第2版)》题目集”
姓日仅供看，话举山-我是读长班，输入该若验证码，即可答躁。
函数题 摇程题 紫是读
编号 标题 知识点 分 通 提
数 过 交 通过率
习题24 谨墙的数序临的插入
习题25 两个有序稀表序列的井
链表·绩性结构·数据15000
娅表一统性绪构→数惩15000
附录图2 读者单击右侧“我是读者”并输人验证码，即可进行练习
(1)服务器收到提交的源代码后，将源代码保存、编译、运行。
(2)运行的时候会先判断程序的返回是否为0,如果不是0,表明程序内部出错了。
(3)运行的时候用预先设计的数据作为程序的输入，然后将程序的输出与预先设定的输出
做逐个字符的比较。
(4)如果每个字符都相同，表示程序正确，否则表示程序错误。
(5)每一题的测试数据会有多组，每通过一组将获得相应得分。
PTA的服务器采用64位的Linux操作系统，C语言编译器采用gce,版本是4.7.2。gec 使用
的编译参数中含有：-fno-tree-ch-02-Wall-std=c99。
如果没有特别说明，程序应该从标准输入(stdin,传统意义上的“键盘”)读入，并输出到标准
312 附录 PTA使用说明
输出(stdout,传统意义上的“屏幕”)。也就是说，用scanf做输入，用printf做输出就可以了；不要
使用文件做输入输出。
在服务器上的测试数据有多组，但提交的程序只要处理一组输入数据的情况，不需要考虑多
组数据循环读入的问题。
3.PTA可能的反馈信息
程序在每一次提交后，都会即时得到由PTA的评分系统给出的得分以及反馈信息，可能的
反馈信息见附录表1。
附录表1 PTA可能的反馈信息
结 果 说 明
提交成功 对于判断、选择、填空题，系统已经接收到您的提交
稍后显示 对于判断、选择、填空题，在题目集关闭之前，不显示判题结果
对于判断、选择、填空题，该提交已经被您的当前提交所覆盖，系统将只评判题目集
关闭前对该题目的最后一次提交
评测系统还没有评测到这个提交，请稍候
评测系统正在评测，稍候会有结果
您提交的代码无法完成编译，单击“编译错误”可以看到编译器输出的错误信息
恭喜!您通过了这道题
您的代码只通过了部分测试点，继续努力!
您的程序输出的格式不符合要求(比如空格和换行与要求不一致)
您的程序未能对评测系统的数据返回正确的结果
您的程序未能在规定时间内运行结束
您的程序使用了超过限制的内存
您的程序运行时发生了错误
您的程序结束时返回值非0,如果使用C或C++语言要保证int main函数最终return 0
您的程序发生段错误，可能是数组越界、堆栈溢出(比如，递归调用层数太多)等情
况引起
您的程序运行时发生浮点错误，比如遇到了除以0的情况
您的程序输出了过多内容，一般可能是无限循环输出导致的结果
评测系统发生内部错误，无法评测。工作人员会努力排查此种错误
已被覆盖
等待评测
正在评测
编译错误
答案正确
部分正确
格式错误
答案错误
运行超时
内存超限
异常退出
非零返回
段错误
浮点错误
输出超限
内部错误
附录 PTA使用说明 313
4.程序常见问题
(1)main的问题
错误的例子：
void main()
printf("hellon");
函数main()的返回类型必须是int,在main()里一定要有语句
return 0;
用来返回0。
很多教材基于Windows的C编译器，还在使用语句void main(),这是无法接受的。main()
的返回值是有意义的，如果返回的不是0,就表示程序运行过程中错误了，那么服务器上的判题
程序也会给出错误的结论。
另外，某些IDE需要在main()的最后加上一句：
system("pause");
或
getch();
来形成暂停。在上传程序时一定要把这个语句删除，不然会产生超时错误。
(2)多余的输出问题
错误的例子：
int main()
int a,b;
printf("请输入两个整数：");
scanf("d ?,&a,&b); …
printf("???名d的最大公约数是d\n",a,b,c);
return 0;
程序的输出不要添加任何提示性信息，必须严格采用题目规定的输出格式。
读者可以运行自己的程序，采用题目提供的输入样例，如果得到的输出和输出样例完全相
同，一个字符也不多，一个字符也不少，那么这样的格式就是对的。
314 附录 PTA使用说明
(3)汉字问题
程序中不要出现任何汉字，即使在注释中也不能出现。服务器上使用的文字编码未必和读
者的计算机相同，读者认为无害的汉字会被编译器认为是奇怪的东西。
(4)输出格式问题
仔细阅读题目中对于输出格式的要求。因为服务器是严格地按照预设的输出格式来比对程
序输出的。需要注意的输出格式问题包括：
●行末要求不带空格(或带空格)
●输出要求分行(或不分行)
● 有空格没空格要看仔细
●输出中的标点符号要看清楚，尤其是绝对不能用中文全角的标点符号，另外单引号(')
和一撇(')要分清楚
● 当输出浮点数时，因为浮点数会涉及输出的精度问题，题目中通常会对输出格式做明确
要求。一定要严格遵守
· 当输出浮点数时，有可能出现输出-0.0的情况，需要在程序中编写代码判断，保证不出
现-0.0
(5)不能用的库函数
某些库函数因为存在安全隐患是不能用的，目前主要指库函数 itoa和gets。
(6)过时的写法问题
某些教材上提供的过时写法也会在编译时产生错误，例如：
int f()
int a;
