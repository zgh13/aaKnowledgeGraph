目 录
第1章 快速浏览 …………………………1
1.1 开始…………………………………………1
1.2 变量…………………………………………2
1.3 代码中的注释………………………………4
1.4 具名常量……………………………………5
1.5 Unicode字符……………………………6
1.6 控制流……………………………………6
1.7 类和对象………………………………8
1.7.1 创建对象……………………………9
1.7.2 静态字段(类字段)………………10
1.7.3 垃圾回收器 ………………………10
1.8 方法和参数 ……………………………10
1.8.1 调用方法……………………………11
1.8.2 this 引用……………………………11
1.8.3 静态方法(类方法)………………12
1.9 数组 ……………………………………12
1.10 字符串对象……………………14
111 扩展一个类………………………………16
1.11.1 调用超类的方法……………………17
1.11.2 object类 ………………………18
1.11.3 类型强制转换………………………18
1.12 接口……………………………………18
1.13 泛型类型………………………………20
1.14 异常……………………………………22
1.15 注解……………………………………23
1.16 包……………………………24
1.17 Java平台………………………………25
1.18 其他主题概述…………………………26
第2章 类与对象………………………27
2.1 一个简单的类 ……………………………27
2.1.1 类成员 ………………………………28
2.1.2 类修饰符 …………………………28
2.2 字段…………………………………28
2.2.1 字段的初始化 ……………………29
2.2.2 静态字段 …………………………29
2.2.3 fina]字段………………………30
2.3 访问控制………………………………31
2.4 创建对象………………………………32
2.5 构造与初始化…………………………32
2.5.1 构造器 ………………………………33
2.5.2 初始化块…………………………35
2.5.3 静态初始化 …………………………36
2.6 方法……………………………………37
2.6.1 静态方法…………………………37
2.6.2 方法调用 ……………………………38
2.6.3 引元数量可变的方法 ……………39
2.6.4 方法异常与返回…………………40
2.6.5 参数值 ……………………………41
2.6.6 使用方法来控制访问 ………………43
2.7 this……………………………………………………………………45
2.8 重载方法………………………………45
2.9 导入静态成员名 …………………………47
2.10 main方法…………………………48
2.11 本地方法………………………………49
第3章 类的扩展………………………50
3.1 扩展类 …………………………………50
3.2 扩展类的构造器…………………………53
3.3 继承与重定义成员 ………………………56
3.3.1 覆盖……………………………56
3.3.2 隐藏字段…………………………57
3.3.3 访问继承的成员 ……………………57
3.3.4 可访问性与覆盖 …………………59
3.3.5 隐藏静态成员 ……59
3.3.6 super 关键字 ………………………59
3.4 类型兼容与转换 ………………………60
3.4.1 兼容性……………………………60
2 目 录
3.4.2 显式的类型强制转换 ………………61
3.4.3 类型检测……………………………61
3.5 protected的真正含义…………………62
3.6 将方法与类标记为 final ………………64
3.7 抽象类与抽象方法 ……………………65
3.8 Object类 …………………………66
3.9 克隆对象 ………………………………68
3.9.1 克隆的策略 …………………………68
3.9.2 正确克隆 ……………………………69
3.9.3 浅克隆与深克隆 ……………………71
3.10 扩展类：如何扩展以及何时扩展………72
3.11 设计一个可扩展的类…………………73
3.12 单重继承与多重继承…………………77
第4章 接口………………………………79
4.1 一个简单的接口示例 ……………………79
4.2 接口声明 …………………………………81
4.2.1 接口常量 ……………………………81
4.2.2 接口方法 …………………………82
4.2.3 接口修饰符 …………………………82
4.3 扩展接口 …………………………………83
4.3.1 继承和隐藏常量 ……………………83
4.3.2 继承、覆盖和重载方法………………84
4.4 使用接口 …………………………………85
4.4.1 实现接口 ………………………86
4.4.2 使用实现…………………………87
4.5 标记接口 ………………………………88
4.6 何时使用接口 ……………………………88
第5章 嵌套类和接口 …………………90
5.1 静态嵌套类型 ……………………………90
5.1.1 静态嵌套类 …………………………90
5.1.2 嵌套接口 ……………………………92
5.2 内部类 …………………………………92
5.2.1 访问包围对象 ………………………93
5.2.2 扩展内部类 …………………………94
5.2.3 继承、作用字段和隐藏……………95
5.3 局部内部类 ……………………………96
5.4 匿名内部类 ………………………………98
5.5 继承嵌套类型 …………………………99
5.6 接口中的嵌套…………………………100
5.7 嵌套类型的实现………………………101
第6章 枚举类型 ………………………102
6.1 一个简单的枚举类型的例子…………102
6.2 枚举声明…………………………103
6.3 枚举常量的声明………………………104
6.3.1 构造…………………………104
6.3.2 常量相关的行为……………………105
6.4 java.1ang.Enum ………………………………………107
6.5 是否应该使用枚举……………………108
第7章 语言符号、值和变量……………109
7.1 词法元素………………………………109
7.1.1 字符集……………………………109
7.1.2 注释……………………………110
7.1.3 语言符号………………………111
7.1.4 标识符…………………………111
7.1.5 关键字……………………………112
7.2 类型和字面常量……………………112
7.2.1 引用型字面常量…………………113
7.2.2 布尔型字面常量………………113
7.2.3 字符型字面常量…………………113
7.2.4 整型字面常量……………………113
7.2.5 浮点型字面常量…………………113
7.2.6 字符串型字面常量………………114
7.2.7 类字面常量………………………114
7.3 变量………………………………115
7.3.1 字段和局部变量的声明……………115
7.3.2 参数变量……………………116
7.3.3 final变量……………………116
7.4 数组变量………………………………117
7.4.1 数组修饰符………………………118
7.4.2 数组的数组………………………118
7.4.3 数组初始化………………………118
7.4.4 数组和类型…………………………119
7.5 名字的意义…………………………120
第8章 包装器类 ………………………123
8.1 通用字段和方法………………………124
8.1.1 构造………………………124
8.1.2 常量…124
8.1.3 公共方法…………………………125
8.2 Void类 ……………………………126
8.3 Boolean类 ………………………126
8.4 Number类 ……………………………126
8.4.1 整型包装器…………………………126
8.4.2 浮点型包装器类……………………128
8.5 character类 ………………………129
8.6 装箱转换…………………………………133
第9章 运算符和表达式…………………135
9.1 算术运算…………………………………135
9.1.1 整数运算…………………………135
9.1.2 浮点运算…………………………136
9.1.3 严格浮点运算和非严格浮点运算……137
9.2 通用运算符………………………………137
9.2.1 递增运算符和递减运算符………137
9.2.2 关系运算符和判等运算符………138
9.2.3 逻辑运算符………………………139
9.2.4 instanceof …………………………………140
9.2.5 位操作运算符……………………140
9.2.6 条件运算符?:……………………141
9.2.7 赋值运算符…………………………142
9.2.8 字符串连接运算符…………………143
9.2.9 new ……………………………………………………………144
9.3 表达式…………………………………144
9.3.1 计算顺序…………………………144
9.3.2 表达式类型………………………145
9.4 类型转换…………………………………145
9.4.1 隐式类型转换………………………145
9.4.2 显式类型强制转换………………147
9.4.3 字符串转换………………………148
9.5 运算符优先级和结合性…………………148
9.6 成员访问………………………………150
第10章 控制流…………………………154
10.1 语句和块 …………………………154
10.2 if-else …………………………………………………………155
10.3 Switch……………………………………………………………156
10.4 while和do-while ………………158
10.5 for ……………………………………………………………………159
10.5.1 基本的for语句 ………………159
10.5.2 增强的for语句 ………………161
10.6 标号 …………………………………162
10.7 break ………………………………………………………………162
10.8 continue …………………………………………………164
目 录 3
10.9 return……………………………………………………165
10.10 什么?没有 goto? ………………165
第11章 泛型类型 ……………………167
11.1 泛型类型声明 …………………………169
11.1.1 有界类型参数 ……………………170
11.1.2 嵌套泛型类型 ……………………171
11.2 使用泛型类型 …………………………173
11.3 泛型方法和泛型构造器 ………………176
11.4 通配符捕获…………………………179
11.5 揭秘：擦除与原始类型 ………………181
11.5.1 运行时擦除……………………181
11.5.2 重载与覆盖 ………………………183
11.6 再谈寻找正确的方法 …………………184
11.7 类的扩展与泛型类型 ………………187
第12章 异常与断言 …………………189
12.1 创建异常类型 ………………………189
12.2 throw ………………………………………………………………191
12.2.1 控制的转移 ………………………191
12.2.2 异步异常 ………………………191
12.3 throws子句……………………192
12.3.1 throws子句和方法覆盖………193
12.3.2 throwS子句和本地方法………193
12.4 try、catch 和 finally……………194
12.5 异常链 …………………………197
12.6 栈轨迹 …………………………………199
12.7 什么时候使用异常 …………………199
12.8 断言 …………………………………200
12.9 什么时候使用断言 ……………………201
12.9.1 状态断言 ………………………201
12.9.2 控制流断言………………………202
12.10 打开和关闭断言………………………203
12.10.1 为什么要开关断言?…………203
12.10.2 在命令行控制断言………………203
12.10.3 彻底移除………………………204
12.10.4 使断言成为必需的……………204
第13章 字符串与正则表达式…………206
13.1 字符序列………………………………206
13.2 String类…………………………206
13.2.1 基本的String操作………………207
4 目 录
13.2.2 字符串比较 ………………………208
13.2.3 字符串字面常量、等同性和
内存限定…………………………210
13.2.4 创建相关字符串 …………………211
13.2.5 字符串转换 ………………………214
13.2.6 字符串和char 数组………………215
13.2.7 字符串和byte数组………………215
13.2.8 字符集编码方式 …………………216
13.3 正则表达式的匹配 …………………217
13.3.1 正则表达式 ………………………217
13.3.2 正则表达式的编译和匹配 ………218
13.3.3 替换 ……………………………220
13.3.4 区域 ……………………………222
13.3.5 效率 ……………………………223
13.4 StringBuilder类………………223
13.4.1 修改缓冲区……………………224
13.4.2 取出数据 …………………………225
13.4.3 容量管理 …………………………226
13.4.4 StringBuffer类 ………………227
13.5 使用 UTF-16 ………………………227
第14章 线程…………………………229
14.1 创建线程 ……………………………230
14.2 使用 Runnable ……………………232
14.3 同步 …………………………………235
14.3.1 synchronized方法 …………235
14.3.2 静态synchronized方法 ………237
14.3.3 synchronized语句 ……………237
14.3.4 同步设计 …………………………240
14.4 wait、notifyAl1和notify ……241
14.5 等待和通知的详细介绍…243
14.6 线程调度 ………………………………244
14.7 死锁 …………………………………247
14.8 结束线程的执行 ………………………248
14.8.1 取消线程 …………………………249
14.8.2 等待线程结束 ……………………250
14.9 结束应用程序的执行 …………………251
14.10 内存模型：同步和 volatile……252
14.10.1 同步动作………………………253
14.10.2 final字段和安全………………254
14.10.3“之前发生”关系 ………………254
14.11 线程管理、线程安全和
ThreadGroup …………………………………………255
14.12 线程和异常………………………258
14.12.1 不要使用stop …………………259
14.12.2 栈轨迹……………………260
14.13 ThreadLocal变量 ………………260
14.14 调试线程……………………………261
第15章 注解…………………………263
15.1 一个简单的注解实例 ………………263
15.2 注解类型 ………………………………264
15.3 注解元素 ……………………………266
15.4 限制注解的适用性 ……………………267
15.5 保存策略 ……………………………268
15.6 使用注解 ……………………………268
第16章 反射…………………………270
16.1 Class类 …………………………272
16.1.1 类型符号 …………………………272
16.1.2 类检查 …………………………273
16.1.3 检查类成员 ………………………277
16.1.4 命名类 ……………279
16.1.5 通过名字获取 Class 对象 ………281
16.1.6 运行时类型查询 ………………281
16.2 注解查询 ………………………………282
16.3 Modifier类 ………………………283
16.4 成员类 ………………………………283
16.5 访问检查和AccessibleObject ……284
16.6 Field类 …………………………284
16.7 Method类…………………………286
16.8 创建新对象和 Constructor类………288
16.9 泛型类型检查 ………………………290
16.9.1 类型变量 ………290
16.9.2 参数化类型 ………………………291
16.9.3 通配符 ………………………291
16.9.4 泛型数组 ………………………291
16.9.5 Type对象的字符串表示 …………292
16.10 数组………………………………292
16.11 包………………………294
16.12 Proxy类…………………………295
16.13 加载类………………………………297
16.13.1 classLoader类 ……………298
16.13.2 为类的使用做准备……………300
16.13.3 加载相关资源……………………301
16.14 在运行时控制断言…………………302
第1章 快速浏览
游览欧洲!17天内游遍10个国家!
——某旅行社窗口的广告语
本章是对Java 编程语言的一次“旋风式旅行”,它可以让你马上就能够开始编写代码。为了
不减慢浏览速度，我们这里并不介绍完整的语言细节，而只是简要地介绍语言的关键点，有关
各个特性的详细讨论将在后续章节进行。
1.1 开始
在Java编程语言中，程序是由类(class)构建而成的，我们可以根据某个类的定义创建出任
意数量的对象，这些对象被称作这个类的实例(instance)。我们可以将类想象成一个工厂，它拥
有制造机械配件的蓝图和说明，而对象就是这个工厂制造的机械配件。
类包含成员(member),主要包括字段(field)和方法(method)等。字段是属于类本身或者类
对象的数据变量，它们构成了类或对象的状态(state)。方法是由操作字段的语句(statement)构
成的集合，用于处理状态。语句定义了类的行为，它们能够对字段或其他变量进行赋值、计算算
术表达式的值、调用方法，并且还能够控制执行流程。
编程语言的第一个程序示例都是打印“Hello, world”,我们也遵循这一传统：
class HelloWorld {
public static void main(String[] args){
System.out.print1n("Hello,world");
}
子
用你所喜欢的文本编辑器将这段程序源代码输入到一个文件中，然后运行编译器将源程序
编译成字节码(bytecode),即Java虚拟机的“机器语言”(本章稍后将对其进行更多的介绍)。编
辑和编译源代码的细节根据系统的不同会有所差别，详细信息可以参考系统手册。在我们最常
用的系统上——即由 Sun公司免费提供的Java 2平台标准版(JavaT2 Platform Standard Edition,
J2SET)开发工具包(Java Development Kit,JDK)上，将Helloworld的源代码保存到一个名为
Helloworld.java的文件中。要对它进行编译，可以输入以下命令：
javac Helloworld.java
要运行该程序，可以输入以下命令：
java Helloworld
这样就会执行Helloworld的main方法。运行程序时显示结果为：
Hello,world
现在我们有了一个具有一定功能的小程序，那么这些程序语句都是什么意思呢?
这个程序声明了一个名为Helloworld的类，它只有一个成员：一个名为main的方法。类
的成员位于类的名字之后的一对花括号{}之间。
main方法是一个特殊的方法：如果像前面的程序那样在类中声明main方法，那么在将这
1
2 第1章 快速浏览
个类作为应用程序来运行时，就会执行 main方法。在运行时，main方法可以创建对象，计算
表达式，调用其他方法，还可以进行定义应用程序行为所需的任何其他操作。
main方法被声明为public,这样 Java 虚拟机中的任何对象都能够调用它，同时它还被声
明为 static,这意味着 main方法属于这个类，并不与该类的某个特定对象相关联。
方法名字的前面是方法的返回类型。main方法的返回类型为 void,即没有返回类型，因
为它不返回任何值。
方法名字的后面是参数(parameter)列表，它是由0个或者多个“类型-名字”对组成的序
列，这些对由逗号分隔，并位于一对圆括号O之间。main方法仅有的一个参数是String 对象
的数组，可以通过名字args来引用它。对象数组通过在类型名后面加上一对方括号[]来表示。
在用命令行执行程序时，args 中将包含来自命令行的程序引元。本章稍后将介绍数组(array)
和字符串(string),main方法中 args的意义将在第2章2.10节进行介绍。
方法的名字和它的参数列表一起组成了方法的签名(signature),而签名又和所有的修饰符
2](如public、static)、返回类型以及可抛出异常列表(本章稍后介绍)一起组成了方法头(head er)。方法声明(declaration)由方法头和方法体(body)组成，方法体就是出现在花括号之间的语
句块(statement block)。
在这个例子中，main的方法体只包含一条调用println方法的语句，分号表示一条语句
结束。通过提供一个对象的引用(本例中为 System.out,即 System类的out字段)和一个方
法名字(println),并用句点(.)将二者隔开，就可以调用该对象的某个方法。
Helloworld使用out 对象的println方法在标准输出流上打印了一个以换行符终止的字
符串，打印出来的字符串是字符串字面常量(string literal)"Hello,world",它被作为引元传给
了print1n。字符串字面常量是包含在一对双引号""之间的字符序列。
练习1.1:在你的系统上，输入 Helloworld,编译并运行它。
练习1.2:试着修改 Helloworld的代码，看看会出什么错误。
1.2 变量
下面的例子打印出了斐波纳契数列(Fibonacci sequence)的一部分，这个无穷数列的前几项
是：
1
1
2
3
5
8
13
21
34
斐波纳契数列的开头两项是1和1,任意后继项都是它前两项的和。斐波纳契数列的打印程序
很简单，它演示了如何声明变量(variable),如何编写一个简单循环，以及如何进行基本的运算。
以下是斐波纳契程序的代码：
1.2 变 量3
class Fibonacci{
/** Print out the Fibonacci sequence for values<50 */
public static void main(String[] args){ ith1
System.out.println(1o);
while(hi<50){
System.out.print1n(hi);
hi=lo+ hi; //.new hi
lo= hi- lo; /* new 1o is(sum -old 1o)
that is,the old hi */
}
}
}
这个例子声明了一个Fibonacci类，它和 Helloworld一样拥有一个main方法。main的前两
行语句定义了两个局部(local)变量：1o和hi。在这个程序中，hi是数列中的当前项，lo是前
一项。与方法体类似，局部变量是在一个代码块中声明的，它们不同于作为类的成员而声明的
字段。声明变量的时候需要在变量名字之前为其指定类型(type)。变量lo和hi都属于int类
型，即为32位的有符号整数，其数值在-23到231-1的范围之内。
Java编程语言具有用于支持整型、浮点型、布尔型和字符型数值的内建“基本”数据类型。与
程序员定义的对象类型不同，这些基本类型表示的是机器能够直接理解的数值数据。我们必须
显式地定义每个变量的类型，这些基本数据类型包括：
boolean 真(true)或假(false)
char 16位Unicode UTF-16字符型(无符号)
byte 8位整型(有符号)
short 16位整型(有符号)
32位整型(有符号) int
long 64位整型(有符号)
float 32位浮点型(IEEE 754)
double 64位浮点型(IEEE 754)
每一种基本类型都有与其对应的对象类型，一般称作包装器(wrapper)类，例如，类Integer就
是int的包装器类。对于基本类型及其对应的包装器类，如果其中的一种类型出现在了需要使
用另一种类型的地方，那么在绝大多数情况下，Java 语言都会自动进行类型转换。
在Fibonacci程序中，我们使用初始值1声明了hi和lo。初始值是在变量声明时通过使用
=运算符的初始化表达式设置的，=运算符也称为赋值(assignment)运算符，它将其左边命名的
变量设置成为其右边的表达式值。
在初始化之前，局部变量是未定义的(undefined),我们不必在声明局部变量的时候对它们
进行初始化，但是如果想在局部变量被赋值之前使用它们，编译器就会拒绝编译这个程序，直
到我们订正了这个错误。
由于1o和hi的类型相同，因此可以使用一种简化的形式来声明它们，即可以通过用逗号
分隔变量名(及其初始化表达式)来声明属于某个指定类型的多个变量。用这种方法，我们可以
用下面这一行等价的代码来代替 main的前两行代码：
int lo=1,hi=1;
3
4
5
4 第1章 快速浏览
也可以用可读性更强的形式来代替：
int lo =1,
hi=1;
注意，上面的换行并不影响语句的含义，代码中所用的换行符、空格、制表符以及其他空白字符
(whitespace)都只是为了方便程序员编写程序。
例子中的while语句演示了循环的一种方式。在计算while中的表达式的值时，如果表达
式的值是 true,则执行循环体，然后再次测试该表达式。while会不断地重复执行，直到表达式
的值变为 false。只要表达式的值不变为false,循环就会一直进行下去，直到某些操作干预进来
使得程序跳出循环为止，比如执行break 语句或者抛出异常。
while的循环体由一条单独的语句组成，它可以是一条简单的语句(比如一个方法调用),
也可以是另一个控制流语句，还可以是一个块(block),块就是一对花括号之间的0条或多条单
独的语句。
while所测试的表达式是一个具有 true或 false值的布尔表达式(boolean expression)。
布尔表达式的形式可以是使用比较(comparison)运算符(<,<=,>,>=)比较两个数值的相
对大小，也可以是使用==运算符或!=运算符分别判断等价性或不等价性。例子中的布尔表
达式hi<50用来判断当前数列中的最大值是否小于50,如果最大值小于50,则打印该值并计
算下一个值。如果最大值等于或者超过50,程序就会跳到while循环体后面的第一行代码，在
本例中，就是main方法的末尾，所以程序就结束了。
为了计算数列中的下一个数值，我们进行一些简单的计算，再次使用=运算符将其右边的
算术表达式的值赋给左边的变量。正如所预料的，+运算符会计算操作数的和，而-运算符会
计算操作数的差。Java语言为基本的整型和浮点类型定义了许多算术运算符，包括加法(+)、
减法(-)、乘法(*)、除法(/)和后面我们将要介绍的其他运算符。
注意，在 Fibonacci例子中，print1n方法接受的是一个整型引元，而在Helloworld例
子中，它接受的是一个string引元。println方法是众多重载(overload)方法之一，所以它们可
以接受不同类型的引元。运行时系统会根据所传入的引元的数量和类型来决定具体要调用哪
个方法。println方法是一个非常强大的工具。
练习1.3:给 Fibonacci 程序的打印列表添加一个标题。
练习1.4:写一个可以生成其他数列的程序，比如生成一个平方数的表。
1.3 代码中的注释
散落在代码之间的普通文字就是注释(comment),总共有三种形式，在 Fibonacci的例子
中都出现过。我们可以利用注释在代码旁边写下描述性的文字，用以向阅读代码的程序员进行
注解。几个月或几年之后，阅读这段代码的人可能就是我们自己。通过对自己的代码进行注
释，可以将自己的工作记录下来。在写注释的时候，因为需要仔细考虑代码的功能，所以我们
经常会发现缺陷。
编译器会忽略出现在/*和*/之间的文本，这种形式的注释可以用于注解一行中的一部
分、一整行或者是更常见的用于定义一个多行的注释(正如上面的例子中那样)。对于单行注释
和行中注释，我们可以使用//,它会告诉编译器忽略本行中它后面的所有文本。
第三种注释出现在代码的最上方，位于/** 和*/之间，这种以两个星号开头的注释被称
作文档注释(documentation comment,简称 doc 注释)。文档注释意在描述它们之后的各种声明，
在前面的例子中，这种注释是针对main方法的。我们可以使用工具对这些注释进行解析，并
1.4 具名常量5
且用它们生成各个类的参考文档。根据惯例，在文档注释或/*…*/注释中的所有行都会以一
个星号开头(这个星号会被文档工具忽略掉),这可以为代码的阅读者提供用于确定注释范围的
直观线索。
1.4 具名常量
常量(constant)是诸如12、17.9以及"Strings Like This"这样的值。正如我们所知的，
常量或字面常量使我们能够指定一些无需求取和再次求取的值，这些值在程序的运行过程中是
保持不变的。
Fibonacci例子打印出了所有值小于50的Fibonacci数字，50这个常量在while循环的表
达式以及描述main方法的文档注释中都用到了。假设我们现在想把这个例子改为打印出值小
于100的所有Fibonacci数字，那么我们需要仔细检查源代码，寻找并且修改出现的所有常量
50。虽然在本例中这是微不足道的，但一般来说这是一个冗长乏味而又容易出错的过程。更糟
的是，如果阅读代码的人看到一个hi<50这样的表达式，他们很可能并不知道常量50实际
代表什么,这样的“魔幻数字”(magic number)破坏了程序的可理解性和可维护性。
具名常量(named constant)是通过名字来引用的常量值，例如，我们可以在Fibonacci例子中
是使用MAX作为名字来引用常量50的。定义具名常量就是声明适当类型的字段并将其初始化
为适当的值，这么做本身并未定义常量，而只是定义了一个字段，它的值可以通过赋值语句进
行修改。为了使它的值保持不变，我们需要将这个字段声明为 fina1。final字段或 final变
量的值一旦经过初始化就不能再改变了，它是不可变的(immutable)。而且因为我们不想让这个
具名常量字段和类的实例相关联，所以我们将它声明为static。
我们可以像下面这样重写Fibonacci例子：
class Fibonacci2 {
static final int MAX= 50;
/** Print the Fibonacci sequence for values < MAX */
public static void main(String[] args){
int lo= 1;
int hi= 1;
System.out.println(lo);
while(hi< MAX){
System.out.println(hi);
hi= 1o+hi;
1o= hi- lo;
}
}
}
这样，修改最大值只需要在程序的一个地方进行一次修改就可以实现，并且循环条件所判断的
内容也会更清楚。
我们可以将相关的常量集中到一个类中，例如在扑克牌游戏中可能会用到以下常量：
class Suit {
final static int CLUBS= 1:
final static int DIAMONDS = 2;
final static int HEARTS = 3:
final static int SPADES = 4;
6
7
}
8
6 第1章 快速浏览
用类的名字，后面加上句点，然后加上成员的名字，可以引用类的静态(static)成员。根据上
面的声明，程序中的花色可以使用 Suit.HEARTS、Suit.SPADES 以及类似的形式来访问，这样
所有的花色名字就都集中到单一的名字Suit中了。注意，调换修饰词 final和 static的次
序不会对结果产生任何影响，但是我们应该保持次序的一致性。你可能已经意识到了，out就
是System类的一个静态字段，所以在前面所有的例子中我们已经访问过静态字段了。
对于类似花色这样具名变量组，更好的选择是将其表示成枚举类型(enumeration type,或简
写为enum)的成员。枚举是一种特殊的类，它要表示的每一个具名常量都有与之相对应的预定
义实例。例如，我们可以使用一个枚举类型来重写花色的例子：
enum Suit { CLUBS,DIAMONDS,HEARTS,SPADES }
每个枚举常量都是一个指向其值所对应的对象的静态字段，如 Suit.HEARTS。通过将所有的具
名常量都表示成对象而非整型数值，我们可以改进程序的类型安全性(type-safety),进而加强它
的健壮性。枚举类型将会在第6章详细介绍。
练习1.5:修改Helloworld程序，使用具名字符串常量表示需要打印的字符串。(可以使
用字符串字面常量初始化字符串常量。)
练习1.6:修改练习1.3中的程序，用具名字符串常量作为标题。
1.5 Uhicode字符
假设我们正在设计一个处理圆形的类，需要用一个具名常量来表示π的值。在绝大多数的
编程语言中，我们都会将这个常量命名为“pi”,因为在这些语言中，标识符(表示名字的技术术
语)只能包含ASCII字符集中的字母和数字。然而在Java 编程语言中，我们可以这么做：
class Circle {
static final double π=3.14159265358979323846;
// ...
}
Java编程语言将我们带进了国际化软件的世界：我们可以使用 Unicode这一国际字符集标准来
编写程序。Unicode包括16位的基本字符1和21位的增补字符，它们为书写世界上使用的主要
语言提供了足够大的字符空间，这就是为什么我们可以在上面的例子中使用π作为常量名字的
原因，π是Unicode中希腊文部分的合法字符，所以在代码中也是有效的。绝大部分现有代码都
是用ASCII(一个7位字符标准)或ISO Latin-1(一个8位字符标准，通常被称作 Latin-1)编写
的，但Java在处理这些字符之前都会把它们转换为 Unicode,所以 Java 使用的字符集总
是Unicode。
1.6 控制流
“控制流”这个术语描述了决定程序中待执行语句及其执行顺序的机制。Fibonacci
程序中的while循环就是一个控制流语句，而块也是控制流语句，它为块中间的语句定义
了线性的执行顺序。其他的控制流语句包括 for、if-else、switch和do-while。我们
对Fibonacci数列程序作如下修改：为数列中的元素添加编号，并且用星号标出数值为偶数
的项：
1.基本多语言平面(Basic Multilingual Plane,BMP),Unicode术语。
1.6 控 制 流7
class ImprovedFibonacci{
static final int MAX_INDEX=9;
/**
* Print out the first few Fibonacci numbers, * marking evens with a'*'
*/
public static void main(String[] args){
int lo=1;
int hi=1;
String mark;
System.out.print1n("1:"+ lo);
for(int i=2;i<= MAX_INDEX; i++){
if(hi == 0)
mark ="*";
else
mark ="";
System.out.print1n(i+":"+ hi+ mark); hi= 1o+ hi;
lo= hi- lo;
}
子
}
新的输出如下：
1:1
2:1
3:2*
4:3
5:5
6:8*
7:13
8:21
9:34 *
为了给数列的元素编号，我们用 for 循环代替了while循环。for 循环是while循环的一
种缩略形式，它增加了变量的初始化和递增部分。ImprovedFibonacci 中的 for循环等价于
如下的while循环：
int i=2; // define and initialize loop index
while(i<= MAX_INDEX){
// ...generate the next Fibonacci number and print it...
i++;// increment loop index }
for 循环的使用同时也引入了一种新的变量声明机制，即在初始化部分声明循环变量。这
种方法可以很方便地定义那些只存在于循环执行过程中的变量，但该方法只能应用于 for 循
环，其他的控制流语句都不允许在语句内部声明变量。循环变量i只可用在 for语句的循环体
中，用这种方法声明的循环变量会在循环结束后消失，这意味着我们可以在后面的 for语句中
重复使用这个变量名。
对于没有接触过C语言或由C衍生出的其他语言的程序员，可能会对代码中的++运算符
9
10
11
8 第1章 快速浏览
感到陌生，++运算符会将与它邻接的变量(在本例中是i)的值加1。如果++运算符出现在
操作数的前面，它就是前缀(prefix)运算符；如果在操作数后面，就是后缀(postfix)运算符。这
两种形式在语义上稍有区别，但我们把相关的讨论放到了第9章。类似地，--运算符将与它
邻接的变量的值减1.并且也有前缀和后缀两种形式。在前一个例子的上下文中，下面的语句：
i++;
等价于：
i=i+1;
像上面这种用某个变量原有的值进行计算，然后将结果赋回给这个变量的表达式，是相当
常见的，所以它有一种缩略方式，例如，另一种表示i=i+1的方式是：
i+=1;
该表达式会将+=运算符右边的值(这里是1)加到左边的变量(这里是i)上。绝大多数的二元
运算符(有两个操作数的运算符)都可以以类似的方式与=结合起来(诸如：+=、-=、*=和
/=)。
在 for循环体中，我们使用了一个if-else语句来判断当前的 hi值是否是偶数。if语
句会对括号之间的布尔表达式进行判断，如果表达式的值是true,就会执行 if子句体中的语
句(也可以是一个块):如果表达式的值是false,就会执行 else子句体中的语句。else部分
是可选的，如果没有else部分，当布尔表达式的值为 false时，程序就什么也不做。在确定所
要执行的子句(如果存在)并且执行它之后.控制权就交给了if语句体之后的代码。
本例使用了取余)运算符(也叫取模运算符)来判断 hi是否为偶数.这个运算符会用其
左边的值除以右边的值，然后得到余数。在这个例子中，如果左边的值是偶数，那么余数就是
0,接下来的语句会将包含有偶数指示符的字符串赋值给 mark;如果左边的值是奇数，就会执
行else 子句，将mark 设置为一个空字符串。
在这个例子中，对println的调用显得更为复杂，因为需要在调用println之前计算出那
些作为引元传递给 println的表达式的值。第一种情况的表达式是"1:"+ lo,它会将lo(初
始值为1)的字符串形式连接到字符串字面常量"1:"之后，得到一个值为"1:1"的字符串。当
至少有一个操作数是字符串的时候，+运算符就是连接运算符，否则它就是加法运算符。在方
法的引元列表中使用连接运算符，相对于冗繁的代码来说，是一种常见的缩略形式：
String temp ="1:"+ lo;
system.out.print1n(temp);
for 循环体中的 println调用构造了一个字符串，该字符串包含当前循环计数i的字符串表
示、分隔符字符串、hi的当前值的字符串表示和marker字符串。
练习1.7:修改 ImprovedFibonacci中的循环，使i由大到小进行计数。
1.7 类和对象
和很多面向对象编程语言一样，Java通过类和对象的概念提供了一种解决程序设计问题的
工具。每个对象都有定义其数据和行为的类，每个类都有三种成员：
●字段是与类及其对象相关联的数据变量，可以用来存储由类执行的计算所产生的结果。
·方法包含类的可执行代码，它们由语句组成。调用方法的方式和构成方法的语句将最终
决定程序如何执行。
●类和接口可以是其他类或接口的成员(很快我们就会看到关于接口的介绍)。
下面声明了一个简单的类，它可以用来表示二维平面上的一个点：
1.7 类和对象9
class Point {
public double x,y;
}
这个Point类有两个字段，分别表示点的x坐标和y坐标，并且这个类(暂时)没有方法。从概
念上讲，像这样的类声明就是一种设计蓝图，它定义了从这个类产生的对象会是什么样子，并
且用指令集定义了这些对象的行为。
类的成员可以有不同级别的可视性(visibility)或称可访问性(accessibility)。Point类中对
x和y的public声明意味着任何可以访问到 Point 对象的代码都可以读取和修改这些字段。
其余的可访问性级别将对成员的访问能力限制在类本身的代码或者其他相关的类的范围之内。
1.7.1 创建对象
对象是通过包含有new关键字的表达式来创建的。从类的定义中创建对象也被称作实例化
(instantiation),所以对象通常也被称为实例(instance)。
新创建的对象将被分配到一个称作堆(heap)的系统内存区域中。所有的对象都是通过对象
引用(object reference)来访问的，任何看起来存有某个对象的变量实际上保存的都是该对象的
引用，这种变量类型称作引用类型(reference type),与之相对的是基本类型，基本类型的变量保
存的是基本类型的值。当对象引用未引用任何对象时，它们就是null。
在大多数情况下，我们并不需要精确地区分对象本身和对象的引用。我们可以说“将对象
传给方法”,实际上我们的意思是“将对象的引用传给方法”。只有当这种区别可能会造成差异
时，才需要仔细地区分它们。在大多数情况下，可以混用“对象”和“对象引用”。
在Point类的例子中，假设我们正在构建一个图形应用程序，它需要跟踪大量的点，那么
我们可以使用特定的Point 对象来表示每一个点。下面的代码展示了我们可以怎样来创建和
初始化 Point 对象：
Point lowerLeft = new Point();
Point upperRight = new Point();
Point middlePoint = new PointO;
lowerLeft.x=0.0;
lowerLeft.y= 0.0;
upperRight.x=1280.0; upperRight.y = 1024.0;
middlePoint.x=640.0;
middlePoint.y=512.0;
每个Point 对象都是唯一的，它们拥有各自的x字段和y字段的副本。例如，修改 lower Left 对象的x字段不会影响 upperRight 对象的x字段的值。这些对象中的字段被称作实例
变量(instance variable),因为在类的每个对象(实例)中，都有一个唯一的字段的副本。
当我们使用new 创建对象的时候，虚拟机会调用一段被称作构造器(constructor)的特殊代
码，它会执行对象初始化所需的一切动作。构造器的名字和它所要构建的类的名字相同，构造
器与方法很相似，例如它也可以接受引元。如果我们在类中没有声明任何构造器，那么编译器
会为我们自动创建一个，它不接受任何引元并且什么也不做。当我们声明"new PointO"语句
时，我们实际上是在要求在内存中分配一个Point 对象，并且因为我们没有传入任何引元，所
以虚拟机会调用自动生成的无参构造器(no-argument constructor)来对其进行初始化。
12
13
10 第1章 快速浏览
1.7.2 静态字段(类字段)
我们需要的通常是各个对象所拥有的字段，因此我们希望一个对象的某个字段能够和从相
同的类实例化出来的其他任何对象的同名字段区别开来。
然而，有时候我们需要的却是被某个类的所有对象所共享的字段，这些被共享的变量被称
为类变量(class variable)或类字段，即特定于类而不是类的对象的字段。
为什么我们会想要使用类变量呢?让我们以索尼的随身听工厂来举例说明。每个随身听都
有一个唯一的序列号，用对象术语来说，就是每个随身听对象都有自己的序列号字段。然而工
厂需要保存下一个要分配的序列号的记录，我们不会让每个随身听对象都保存这个数字，而是
会在工厂中只保存该数字的一个副本，用对象术语来说，就是将它作为类变量来保存。
我们可以通过将字段声明为 static来获得特定于类的字段，因此它们通常被称为静态字
段(static field)。例如，我们经常会用到表示原点的Point 对象，所以应该将它声明为 Point
类中的一个静态字段：
public static Point origin = new PointO;
如果上面的声明出现在Point类的声明中，那么该类中称为 Point.origin的数据就只有一
份，它总是引用到代表(0.0,0.0)这个点的对象上。无论创建多少个Point类的对象，甚至一
个对象都不创建，这个静态字段也还是会存在，而其x和y的值之所以都是0,是因为对于数字
字段来说，如果不使用其他数值对其进行初始化，那么它们的默认值就是0。
现在你可能已经了解了为什么具名常量被声明为 static。
本书中所提到的“字段”这个词，一般是指对象所拥有的字段，而为了表达得更清楚，有时
14 候也使用非静态字段(non-static field)这个词。
1.7.3 垃圾回收器
在使用 new创建了一个对象之后，如何在我们不再需要它的时候去除这个对象呢?答案很
简单，那就是不再引用它。未被引用的对象会自动地被垃圾回收器回收掉，垃圾回收器在后台
运行，并跟踪着各个对象的引用。当一个对象不再被引用时，垃圾回收器就可以将它从内存分
配堆中移除，但有时候会将这个动作的进行推迟到某个适当的时机。
1.8 方法和参数
任何拥有 Point 对象引用的代码都可以对 Point类的对象进行操作，因为Point类的字段
被声明成了public。Point类是一种最简单的类。实际上，有些类确实就是这么简单，设计它们
纯粹是为了满足来自包(一组相互协作的类)的内部需要，或者是为了提供纯粹的简单数据容器。
然而面向对象真正的好处在于将类的实现细节隐藏于数据操作之后。类的操作可以通过方
法来声明，而方法就是通过操作对象的数据来得到结果的指令集合。方法可以访问内部实现的
细节，而这些细节对于其他对象是隐藏的。将数据隐藏于方法之后，使其他对象不能访问，这
就是数据封装(data encapsulation)的基本原则。
如果我们用一个简单的clear方法(清除坐标或将坐标重置为0)来改进 Point类，那么它
可能会变成这样：
public void clear(){
x=0.0;
y= 0.0;
}
1.8 方法和参数11
因为clear方法没有参数，所以方法名后面的括号是空的；之所以把clear声明成 void是因
为它不返回任何值。在类的方法中，可以通过名字直接访问类的字段和其他方法，例如我们可
以直接使用x和y,而不需要显式的对象引用。
1.8.1 调用方法
虽然如你在 Point类中所见，类可以将它的字段设为公共可访问的，但是一般来说，一个
对象不会直接操作其他对象的数据。设计良好的类通常会隐藏它们的数据，只允许本类中的方
法来修改它们。
我们可以使用目标(target)对象的对象引用和方法的名字(两者之间加一个句点)来调用方
法。传给方法的引元(argument)是位于一对圆括号内的数值列表，该列表中的各个项是用逗号
隔开的。没有引元的方法也需要有一对空的圆括号。
方法如返回值，只能返回一个。如果想从方法中返回多个值，就需要先创建一个对象将所
有需要返回的值存放在一个单元内，然后再返回这个对象。
当调用一个方法时，执行流就会离开当前的方法，转而执行被调用的方法。当被调用的方
法执行完毕后，当前的方法会从方法调用之后的代码处开始继续执行下去。当我们开始执行方
法时，从这个方法的角度来看，方法调用的目标对象就成了当前对象或称接收方对象。传给方
法的引元可以通过该方法所声明的参数来访问。
下面有一个名为distance的方法，它是前面例子中Point类的一部分。distance方法
接受另一个Point 对象作为参数，计算出它自己与这个点的欧几里得距离，然后返回一个双精
度浮点结果：
public double distance(Point that){
double xdiff=x- that.x;
double ydiff=y- that.y;
return Math.sqrt(xdiff*xdiff+ ydiff*ydiff); }
return语句会使当前的方法停止执行，并将执行权返回给调用这个方法的方法。如果 re turn语句由表达式组成，那么表达式的值将成为方法调用的返回值。表达式的类型必须与方
法所定义的返回类型相匹配，在上面的例子中，我们使用了Math 这个库类的 sqrt方法来计算
两对x坐标和y坐标之间的差的平方和的平方根。
基于前面创建的lowerLeft和 upperRight 对象，我们可以用如下方式来调用distance:
doubled= lowerLeft.distance(upperRight);
这里，upperRight是作为引元传递给distance的，而distance 则将它看作是参数 that。
在这条语句执行之后，变量d就包含了lowerLeft和upperRight 之间的欧几里得距离。
1.8.2 this引用
有时候，接收方对象需要知道它们自身的引用。例如，接收方对象可能想要把自己添加到
某个对象列表中。这时方法可以使用一个名为 this的隐式引用，而这个 this就是当前(接收
方)对象的引用。下面的clear定义等价于前面的版本：
public void clear(){
this.×=0.0;
this.y=0.0;
15
16
}
12 第1章 快速浏览
我们通常会将 this作为引元传给其他需要对象引用的方法，但是this引用也可以用来显
式地命名当前对象的成员。下面是Point类的另一个名为move的方法，它将x字段和y字段
设置成指定的值：
public void move(double x,double y){
this.x= x;
this.y=y;
}
move方法使用 this说明了具体引用的是哪个x和y。将参数命名为x和y是有道理的，因为
我们传递给方法的是x坐标和y坐标，但这样参数和字段就重名了，这时参数名就会隐藏字段
名。如果我们直接把代码写成x=x,那么就会把x参数的值赋给它自己，而不是所需要的x字
段。表达式 this.x代表的正是对象的x字段，而不是move的x参数。
练习1.8:在Point类中添加一个方法，将当前对象的坐标设置成被传入的某个 Point对
象的坐标。
1.8.3 静态方法(类方法)
正如可以有特定于类的静态字段一样，也可以有特定于类的静态方法，通常被称作类方法
(class method)。类方法通常用来进行针对类本身的操作，这些操作通常作用于静态字段而不是
这个类的某些特定实例。类方法是通过 static关键字声明的，所以也被称为静态方法(static
method)。
和“字段”这个术语一样，“方法”这个词通常是指特定于对象的方法，而有时为了表达清
17 楚，也会使用非静态方法(non-static method)这个术语。
为什么需要静态方法呢?再次以索尼随身听工厂为例。下一个分配的序列号的记录被保存
在工厂中，而不是每一个随身听中。用来返回工厂中下一个可用序列号的方法就应该是静态方
法，而不是对特定的随身听对象进行操作的方法。
前面例子中的distance的实现使用了静态方法 Math.sqrt来计算平方根。Math类拥有
许多方法用以支持常用的数学操作，这些方法都被声明为静态方法，因为它们并不作用于 Math
类的任何特定实例，而是在类的内部组成了一个相关函数的集合。
静态方法不能直接访问非静态成员。当调用静态方法时，不存在该方法能够操作的特定对
象，所以也没有 this引用。我们可以将一个显式的对象引用作为引元传给静态方法来达到访
问非静态成员的目的。但在一般情况下，静态方法会完成与类相关的任务，非静态方法会完成
与对象相关的任务。让静态方法来操作对象的字段，就像让随身听工厂来修改系在金门公园中
慢跑者腰带上的随身听的序列号一样。
1.9 数组
保存单一数值的简单变量很有用，但它们还不能满足很多应用的要求。例如，纸牌游戏程
序就需要将一定数量的Card 对象作为一个整体来进行操作。我们可以使用数组来满足这个
要求。
数组是相同类型变量的集合，它的成员可以通过简单的整型下标来访问。在纸牌游戏中，
Deck 对象可以定义如下：
public class Deck {
public static final int DECK_SIZE= 52;
1.9 数 组 13
private Card[] cards = new Card[DECK_SIZE];
public void print(){
for(int i=0;.i< cards.1ength; i++)
System.out.print1n(cards[i]); }
// ...
}
首先我们声明了一个名为DECK_SIZE的常量来确定一副牌中纸牌的数量，这个常量被声明为
public,所以任何人都可以知道一幅纸牌有多少张。接下来我们声明了一个cards字段来引
用所有的纸牌，它被声明为private,这意味着只有当前类内部的方法可以访问它，也就是任
何其他的类都不能对纸牌直接进行操作。修饰词public和private是访问修饰词，因为它们
控制着谁能够访问类、接口、字段以及方法。
我们通过在类的名字之后加上一对方括号[和]将cards字段声明为Card类型的一个数
组，并且将数组的大小初始化为 DECK_SIZE。数组中的每个card元素都被隐式地初始化为
null,其长度在它创建的时候就固定了，不能被改变。
print1n方法的调用给出了访问数组元素的方法，即用方括号把需要访问的元素的下标括
起来，置于数组名之后。
通过阅读上面的代码，你可能会发现数组对象有一个1ength字段，它表明了数组中元素
的个数。数组的边界(bound)是0到length-1这个闭区间之内的整数。试图访问数组边界之
外的元素是常见的编程错误，特别是在数组元素上做循环的时候。为了捕捉这种错误，所有的
数组访问都会进行越界检查(bounds check),以确保下标在边界之内。如果试图用一个边界之
外的下标来访问数组，运行时系统就会通过在程序中抛出 ArrayIndexoutofBoundsExcep tion异常来报告这个错误。本章稍后会对异常进行介绍。
长度为0的数组是空数组(empty array)。将数组作为引元的方法可能会要求它们所接受的
数组是非空的，所以需要对数组的长度进行检查。然而在检查数组长度之前，我们需要确保数
组引用不是nu11。这两项检查中只要有一项失败，方法就可以通过抛出IllegalArgumentEx ception异常来报告问题。例如，下面是一个计算整型数组平均值的方法：
static double average(int[] values){
if(values == nu17)
throw new IlegalArgumentException();
else
if(values.length == 0)
throw new I1legalArgumentException();
else {
double sum =0.0;
for(int i=0;j< values.length;i++)
sum += values[i];
return sum / values.length;
}
}
虽然这段代码可以正常运行，但是由于使用了嵌套的 if-else语句来确保数组非空，方法中
的逻辑性几乎完全丧失。为了避免使用两个if语句，我们可以用或(OR)运算符(1)来判断数
组是否为 null或者长度是否为0:
if(values ==nul1 |values.length==0)
throw new IllegalArgumentExceptionO);
18
19
20
14 第1章 快速浏览
但遗憾的是，这段代码是不正确的。即使 values为nu11,代码仍然会试图访问它的length
字段，因为一般的布尔运算符总是会同时计算两个操作数。在执行逻辑操作时，这种情况很常
见，所以Java就定义了特殊的运算符来解决这个问题。只有在表达式的值不能通过计算左操作
数来确定的情况下，条件布尔运算符才会对右操作数进行计算，因此，我们可以用条件或运算
符(I1)来订正上面的代码：
if (values == nu11 I|| values.length ==0)
throw new IllegalArgumentException();
现在，如果 values为 nul1,那么就可以确定条件或表达式的值为 true,也就无需访问
length字段了。
二元布尔运算符，即与(&)、或(1)和异或(^),在操作数是布尔值时，它们是逻辑运算符；
当操作数是整数值时，它们就是位运算符。而条件或(I1)和条件与(&&)只是逻辑运算符，并且
只能作用于布尔操作数。
练习1.9:修改 Fibonacci程序，将数列存入一个数组，并在最后打印出各个项的值。
练习1.10:修改 ImprovedFibonacci 程序，将数列存入一个数组。具体做法：创建一个
新类，用这个类来保存每一项的值和用来表示每一项是否为偶数的布尔值，然后使用一个数组
来存放对这个类的对象的引用。
1.10 字符串对象
String类这个类型专门用来处理字符数据序列，并为这些序列的初始化提供了语言级的
支持。String类提供了许多用来操作 String 对象的方法。
在前面给出的类似于Helloworld这样的例子中，我们曾经看到过字符串字面常量。当我
们写出如下的语句时：
System.out.println("Hello,world");
编译器实际上是创建了一个String 对象，用指定的字符串字面常量对其进行初始化，然后将
这个String 对象作为引元传给println方法。
创建 String 对象的时候并不需要指定它的长度。我们只用一条语句就可以完成创建一个
新的 String 对象并对它进行初始化的操作，如下例所示：
class StringsDemo {
public static void main(String[] args){ String myName ="Petronius";
myName = myName+ "Arbiter";
System.out.print1n("Name ="+ myName);
}
}
这里，我们声明了一个名为myName的String变量，并用一个字符串字面常量的对象引用对它
进行初始化。初始化之后，我们使用 String 连接运算符(+)在变量之后连接新的内容，生成
了一个新的 String对象，并且将这个新字符串对象的引用存入变量中。最后，我们在标准输
出流上打印出myName的值。运行这个程序即可得到如下输出：
Name = Petronius Arbiter
连接运算符也有其缩略形式+=,它将原字符串与给定字符串进行连接，然后将连接的结
果赋值给原字符串的引用。下面是升级之后的程序：
1.10 字符串对象 15
class BetterStringsDemo {
public static void main(String[] args){
String myName = "Petronius"; String occupation="Reorganization Specialist";
myName +="Arbiter"; myName +="";
myName +="("+ occupation+")";
System.out.print1n("Name ="+ myName);
}
}
现在，运行程序之后，会得到如下输出：
Name = Petronius Arbiter(Reorganization Specialist)
String 对象有一个1ength 方法，它返回的是字符串中字符的个数。在字符串中，字符下
标的范围是从0到lengthO)-1,我们可以使用charAt方法访问字符串中的字符，该方法以
整数下标作为引元，返回下标对应的字符。从这方面看，字符串与字符数组很相似，但是
String对象并不是字符数组，不能将字符数组赋值给 String引用。然而，可以通过将字符数
组作为引元传给 String的构造器来创建新的 String 对象，也可以通过调用String的 to charArray方法来获得与其内容相同的字符串数组。
String 对象是只读的(read-only)或不可变的(immutable),即String的内容从不改变。例
如，在下面的语句中：
str="redwood";
// ... do something with str .. str= "oak";
第二条赋值语句将一个新的值赋给了变量str,这个值是另一个内容为"oak"字符串对象的引
用。每当我们执行那些看似会改变 String 对象的操作时，诸如 BetterstringsDemo 中的
+=操作，实际上是获得了新的只读的 String 对象，而原有的那个 String 对象并没有被改
变。类stringBuilder和 StringBuffer提供了可变的字符串，我们将在第13章中介绍它
们，同时详细地介绍String。
比较两个String 对象的内容是否相同的最简单途径就是使用equals方法：
if (oneStr.equals(twostr))
foundDuplicate(onestr, twostr);
其他用于比较字符串的子串以及忽略大小写的方法也会在第13章中介绍。如果我们使用= =
来比较字符串对象，那么实际上是在判断 onestr和 twostr是否指向同一个对象，而不是在比
较它们的内容是否相同。
练习1.11:修改 StringsDemo程序，让其使用不同的字符串。
练习1.12:修改 ImprovedFibonacci程序，将它生成的 String 对象存入一个数组，而不
是调用println直接把它们打印出来。
字符串转换和字符串格式化
连接运算符可以通过使用包装器类的 tostring方法，将与之对应的基本类型的数值转换
为字符串，我们无法控制这种转换所产生的字符串的格式。可以借助 java.util.Formatter
类来实现格式化的转换，Formatter类可以将其输出写入字符串、文件或者其他的输出设备。
方便起见，System.out.printf方法(用于“打印格式化”)使用格式化器(formatter)向 Sys-
21
22
23
24
16 第1章 快速浏览
tem.out 写数据。格式化的输出是通过一个格式化字符串(format string)和一组数值来实现的。
格式化字符串包括普通文本和格式化说明，格式化说明会告诉格式化器如何对后面的那些数值
进行格式化。例如，可以使用如下语句打印出带有3位小数的Math.PI值：
System.out.printf("The value of Math.PI is?fn",Math.PI);
它会打印出：
The value of Math.PI is3.142
然而，使用println和字符串连接，我们得到的是：
The value of Math.PI is 3.141592653589793
格式化说明至少由两部分组成：它由一个字符开始，以一个转换指示器(indicator)作为
结束。转换时需要同时指出被格式化的数值类型和格式化的基本形式，例如，表示以普通
的数字形式对浮点数值进行格式化，如前面对 Math.PI所用的那样，然而就表示以科学计
数法对浮点数值进行格式化，如3.142e+00。整型数值可以通过
格式化为普通数字形式，
或通过x格式化为十六进制形式。字符串可通过s进行格式化。
n转换会插入正确的换行符，而这也是println方法自动替我们完成的事情。换行符取
决于当前的系统，它可能不仅仅是简单的\n(换行)字符。如果你对C语言中的printf很熟
悉，那么需要逐渐习惯使用n来代替n。
格式化说明可以提供额外的格式化信息。我们可以使用宽度来指定所要打印的最小字符
数，这有助于数据列的对齐。如果经过格式化的数值的字符数少于指定的宽度，那么格式化说
明会用空格符来填补该数值以使其达到最小的宽度，这使我们能够很容易地对齐数据。有些转
换也允许指定精度值，写法是在一个非负数之前加一个句点。对于使用的浮点数值来说，
精度指明了要保留多少个小数位，在前面的例子中，保留了Math.PI的3位小数，因为在格式
化说明中使用的是.3。如果同时指定宽度和精度，它们的书写形式就是width.precision。格式
化说明中的其他标记可以在其他情况下指定零填补(用0代替空格符)或左对齐(默认是右对齐)。
格式化输出将在第22章中详细介绍。
练习1.13:重写ImprovedFibonacci 程序，要求使用printf代替println。
1.11 扩展一个类
面向对象的主要好处之一就是能够扩展(extend)或子类化(subclass)现有类的行为，并且能
够在操作子类实例的时候继续使用原有类的代码。原有的类被称作超类(superclass)。当我们通
过扩展类来创建新类时，扩展出来的新类会继承(inherit)超类的字段和方法。
如果子类没有对超类的行为进行专门的覆盖(override),它就会继承超类所有的行为，因为
它继承了超类的字段和方法。另外，子类还可以添加新的字段和方法，即可以添加新的行为。
在前面的随身听的例子中，原有的型号带有一个耳机插孔，某个人可以用它去听磁带。新
的型号则带有两个插孔，可以让两个人同时听一盘磁带。在面向对象的世界中，两个插孔型号
扩展了基本的一个插孔型号(或者说是它的子类),继承了基本型号的特性和行为，并且添加了
它自己的新的行为。
用户告诉索尼公司，他们想在使用两个插孔的随身听听一盘磁带的时候能够相互通话。索
尼公司就对其进行改进，加入了双向通信的功能，这样人们就可以一边听音乐一边聊天了。双
向通信型号是两个插孔的型号的一个子类，它继承了超类的所有行为，并且又添加了新的行为。
索尼公司生产了很多其他型号的随身听，新的型号对基本型号的功能进行了扩展，它们子
类化了基本型号，继承了基本型号的特性和行为。
1.11 扩展一个类17
让我们看一个扩展类的例子。现在对前面的Point类进行扩展，以表示显示在屏幕上的像
素，新的Pixel类除x坐标和y坐标之外还需要有颜色：
class Pixel extends Point {
Color color;
public void clear(){
super.clearO);
color = nul1;
}
}
Pixe1类同时扩展了超类Point的数据和行为，它通过添加一个名为color的字段对数据进行
了扩展，并且通过覆盖Point类的clear方法扩展了Point的行为。
任何为Point对象设计的代码都可以使用Pixel对象。如果某个方法需要类型 Point的
参数，而我们传递给它的是Pixel 对象，那么它仍旧可以正常工作。Pixel适用于所有与
Point相关的代码，这个特性被称作多态(polymorphism),即单个对象可以有多种形态，就像
Pixel,它既可被用作 Pixel对象，也可以被用作 Point 对象。
Pixel的行为扩展了Point的行为，被扩展的行为可以是全新的(本例中表现为添加了
color字段),也可以是在遵照原有需求的基础上对原有行为的限制。限制行为的例子可以是
Pixel对象需要存在于某种 Screen(屏幕)对象之中，它的x坐标和y坐标应被限制在屏幕范
围之内。如果原有的Point类没有禁止对坐标进行限制，那么被限制了范围的类就不会与原有
类的行为发生冲突。
子类经常会通过改变一个(或多个)继承而来的方法的实现来覆盖超类的行为，为此，子类
需要定义一个(或多个)方法，它(们)的签名和返回类型必须与超类的某个(些)方法相同。在
Pixel例子中，我们覆盖了clear方法以获得适用于 Pixel的行为。Pixel从 Point 继承的
clear方法只能了解到 Point的字段，显然无法了解到在子类 Pixel中新声明的color字段。
1.11.1 调用超类的方法
为了使Pixel完成正确的“清零”行为，我们为clear方法提供了新的实现，其中首先使用
super引用调用了超类的clear方法。super引用有点像前面提到的 this引用，不同的是
super引用的是超类中的实体，而this引用的是当前对象中的实体。
调用 super.clear(O)看起来是在调用超类去执行clear方法，但实际上调用的是超类
Point的对象。在调用 super.clearO清除了对象中的Point 部分之后，我们添加了将 col or设为合理的空值的新功能。这里我们使用的是nul1,表示不指向任何对象的引用。
如果我们在前面的例子中没有调用 super.clearO会怎么样呢?Pixel的clear方法会
将color设为nul1,但是Pixel类中从 Point类继承而来的x和y变量不会被设置为任何
“清除后”的值。而没有能够清除 Pixel对象包括其 Point 部分在内的所有值，很可能就是一
个缺陷(bug)。
当我们调用 super.method(时，运行时系统会自下而上地在继承层次结构中查找第一个
拥有method方法的超类。例如，如果Point没有clear方法，那么运行时系统会在 Point的
超类中寻找这个方法并调用它，依此类推。
对于所有其他的引用，方法调用使用的是对象的实际类，而不是对象引用的类型。例如：
Point point = new PixelO;
point.clear(;// uses Pixel's clear()
25
18 第1章 快速浏览
在上例中，虽然存有Pixel对象的变量被声明成了Point类的引用，但被调用的仍然是Pixel
的clear方法。然而，如果我们在Pixel的任何一个方法中调用 super.clear(),那么调用
到的将是clear 方法的Point类实现。
1.11.2 object类
没有显式扩展任何其他类的类其实都隐式地扩展自Object类。所有的对象都是类Ob ject的多态形式，所以Object是所有类的对象引用的通用类型：
object oref = new PixelO;
oref= "Some String";
在上例中，oref被正确地赋值为Pixel对象和 String 对象的引用，尽管这两个类除了都以
object作为超类之外没有任何联系。object类还定义了许多重要的方法，我们将会在第3章
26 中介绍。
1.11.3 类型强制转换
下面的代码片段看起来似乎相当合理(如果不是特别有用),但是它会产生编译期错误：
String name = "Petronius";
Object obj= name;
name = obj;// INVALID:won't compile
我们声明并初始化了一个String引用，然后将其赋值给一个通用的Object引用，最后我们试
图将这个指向 String对象的Object引用赋值给原来的那个 String引用。为什么它会出错
呢?问题在于，虽然 String对象总是Object 对象，但是Object 对象不一定是String 对象，
尽管在这个例子中它确实是一个 String 对象，但编译器没有这么聪明。为了通过编译，我们
需要告诉编译器 obj所引用的对象实际上是一个 String 对象，因此它可以被赋值给 name:
name =(String)obj;// That's better!
告诉编译器一个表达式的类型实际上是另一种类型的行为被称为类型强制转换(type casting)或
类型转换(type conversion)。我们可以通过把用圆括号括起的新类型置于表达式之前来执行类
型强制转换。当我们这么做时，编译器不会自动地相信我们，它会检查我们所说的是否真实。
聪明的编译器可能在编译期就能够判断出我们所说的是否真实，否则它会插入一个运行时检
查，以校验强制转换是否确实是允许的。如果我们欺骗了编译器并导致运行期检查失败，那么
运行时系统会通过抛出ClasscastException异常来报告错误。由于Java 编程语言是强类型
的(strongly typed),所以关于类型之间的赋值有很多严格的规定。
练习1.14:编写一组类，表示我们前面提到的索尼随身听产品系列的类结构。使用方法来
隐藏数据，将所有的数据设为private,将方法设为public。哪些方法属于Walkman类?哪
些方法会被添加到扩展的类中?
1.12 接口
27
有时我们只是想声明某个对象必须支持的某些方法，而不会为这些方法提供实现。只要这
些方法的行为符合特定的标准(称作契约，contract),它们的实现细节就无关紧要。这些声明定
义了一个类型，任何实现了这些方法的类都可以被认为具有这种类型，而不管这些方法到底是
如何实现的。例如，我们想要查找某个特定值是否包含在一个集合中，而忽略这些值是如何保
存的，那么我们就需要让这些方法在使用链表、散列表或其他任何数据结构存储值的情况下都
1.12 接口19
可以正常使用。
为了支持这种情况，我们可以定义接口(interface)。接口和类相似，但是它的方法都只有空
的声明。接口的设计者声明了实现(implement)接口的类所必须支持的那些方法，并且声明了这
些方法应该做什么。下面的Lookup接口用于在一个值的集合中查找某个值：
interface Lookup {
/** Return the value associated with the name,or
* null if there is no such value*/
Object find(String name);
}
Lookup接口声明了一个 find方法，该方法接受一个String类型的引元name并返回与name
关联的值，但如果在集合中没有值与 name 关联，该方法则返回nul1。在接口中，并没有为方
法提供任何实现，特定的方法实现是由实现接口的类提供的，所以我们使用分号代替了方法体。
使用Lookup类型引用(实际上是实现了Lookup 接口的对象的引用)的代码可以调用 find方
法，并得到所期望的结果，而不用去管这个对象的实际类型是什么:
void processValues(String[] names,Lookup table){
for(int i=0;i< names.length; i++){
Object value = table.find(names[i]);
if(value != nu11)
processValue(names[i],value);
}
}
一个类可以实现我们所选择的多个接口，下面的例子使用简单的数组实现了Lookup 接口
(为简便起见，这里没有给出用于设定和删除值的方法):
class SimpleLookup implements Lookup {
private String[] names;
private Object[] values;
public Object find(String name){
for(int i=0;i< names.length;i++){
if(names[i].equals(name))
return values[i];
}
return nul1;// not found
}
// ...
}
接口也可以声明 static和 final的具名常量。另外，接口还可以声明其他的嵌套接口和
类，这些嵌套类型将会在第5章详细讨论。接口所有的成员都隐式或显式是public的，所以
任何可以访问到接口的代码都可以访问到它们。
可以使用extends 关键字对接口进行扩展。一个接口可以扩展一个或多个其他接口，在其
中可以添加新的常量，也可以添加任何实现该扩展接口的类都必须实现的方法。
类的超类型(supertype)是指该类扩展的类以及实现的接口，包括这些类和接口的所有超类
型。因此一个对象不仅是它所属的类的实例，也是它的超类型(包括接口)的实例。对象可作为
它的任何超类和超接口(包括这些类和接口的超类型)的多态形式而使用。
类的子类型(subtype)是指扩展自该类的类，包括这些类的所有子类型。接口的子类型是指
28
29
20 第1章 快速浏览
扩展自该接口的接口以及实现该接口的类，包括它们的所有子类型。
练习1.15:编写扩展Lookup接口的接口，声明add和 remove方法，然后用一个新的类实
现扩展后的接口。
1.13 泛型类型
类和接口可以被声明为泛型类型(generic type),泛型的类或接口表示一组相关的类型。例
如，在下面的代码中：
interface List<T>{
// ... methods of List ...
}
List<T>(读作“T的列表”)声明了一个可以用于任何非基本类型T的泛型列表，我们可以使用
这个声明生成 Point对象的列表(List<Point>)、String 对象的列表(List<String>)、In teger对象的列表(List<Integer>),等等。这与能够保存任何object 对象的原始(raw)
List不同，List<String>只能保存 String 对象，编译器在编译期会对其进行检查，例如，
如果我们试图添加一个普通的Object 对象，那么就会得到编译期错误。
前一节中提到的Lookup接口也可以被声明为泛型形式：
interface Lookup<T>{
T find(String name);
}
现在find方法不再返回Object 对象，而是返回T对象，且不管T是什么类型。我们可以声明
一个用于查找整数的类，例如：
class IntegerLookup implements Lookup<Integer> {
private String[] names;
private Integer[] values;
public Integer find(String name){
for(int i=0;i< names.1ength; i++){
if(names[i].equals(name))
return values[i];
}
return nul1;// not found
}
// ... }
类IntegerLookup本身不是泛型类，它只是实现了一个泛型接口，并且用具体类型 Integer
代替了抽象类型参数T。与SimpleLookup类相比，这个类可以将数值存放在一个Integer数
组中，而且 find方法会返回一个Integer。
我们应该如何修改 processvalues方法，使其适用于 Lookup的泛型实现呢?下面是一种
尝试：
void processValues(String[] names,Lookup<0bject> table){
for(int i=0;i< names.1ength;i++){
Object value = table.find(names[i]);
1.13 泛型类型21
if(value != nu)l)
processValue(names[i],value);
}
}
这段程序可以通过编译，并且看起来也很合理，其中，table是某个类的实例，这个类实现了适
用于任何Object的Lookup接口。由于Integer实例也是object实例，所以我们应该能够
执行下面的操作：
Lookup<Integer> 1= new IntegerLookup();
// ... add entries to 1 ...
String[] names ={ "One","two"};
processValues(names,1);// INVALID:won't compile
但我们发现这段代码无法通过编译。问题在于，根据定义，processValues 只能接受实现了
Lookup<Object>类的实例，而IntegerLookup并不满足该条件。虽然 Integer是Object
的子类型，但Lookup<Integer>不是Lookup<0bject>的子类型，所以不能用前者的实例
代替后者的实例来使用。是否存在着可行的方式，使我们可以声明一个方法，它能够处理任何
类型的 Lookup实现类的实例呢?答案是肯定的，我们可以使用通配符(wildcard)来指定类型参
数：
void processValues(String[] names,Lookup<?> table){
for(int i=0;i< names.1ength;i++){
Object value = table.find(names[i]);
if(value != nu11)
processValue(names[i],value);
子
}
通配符就是一个问号(?),它读作“未指定类型的”或“某类型的”:table是一个类的实例，这
个类实现了适用于某类型的 Lookup接口，我们不知道它是什么类型，而且在本例中对此也并
不在意。我们只知道被查找的类型至少是Object,所以我们可以调用 table.find方法，并将
返回值作为Object来存储。现在就可以在processValues 中使用IntegerLookup了。
假设我们知道在程序中只会查找 Integer、Long、Double等所有 Number类的子类。从前
面的例子中可以知道，我们不能使用Lookup<Number>来定义 processValues,但有一种方
法可以限制通配符所能代表的类型：
void processValues(String[] names,
Lookup<? extends Number> table){
for(int i=0;j< names.1ength;i++){
Number value= table.find(names[i]);
if(value != null)
processValue(names[i],value); }
}
?本身是不受限通配符(unbounded wildcard),它可以代表任何类型，而"?extends ×"是受限
通配符(bounded wildcard):它只能表示类型×以及任何扩展或实现X的类型(扩展或实现取决
于X是类还是接口)。这次我们知道 processvalues 的 table.find调用至少会返回一个
Number,所以可以将返回值存人一个 Number类型的变量中。
关于泛型类型还有很多内容，我们将会在第11章中见识到它们的威力。现在我们所掌握
的泛型类型知识足以让我们理解本书前面几章中出现的简单的泛型类型用法。
30
31
32
22 第1章 快速浏览
1.14 异常
当程序出现错误时，你会做什么呢?很多语言通过特殊的返回值(比如-1)来报告错误情
况。程序员通常不检查异常的值，因为他们可能会假设这些错误“不会发生”。另一方面，在原
本清晰直接的逻辑流程中加入错误检测和恢复处理会导致逻辑复杂化，使正常的流程模糊不
清。看起来很简单的任务，如将一个文件读入内存，也大概需要7行代码，而加入错误检测和
报告之后，代码会增加到40行以上，使得正常的操作显得如同大海捞针一样难以辨认，这显然
是不可取的。
检查型异常(checked exception)用来管理错误处理，它们迫使我们必须考虑如何在代码中可
能出现错误的地方处理它们。如果检查型异常未被处理，那么在编译时就会发现，而不会在运
行时让这个未被检查的错误把问题复杂化。
检测到异常错误的方法会抛出(throw)异常。异常可以被调用栈中前面的代码捕获(catch),
这段调用代码可以根据需要处理异常，然后继续执行。未被捕获的异常会终止正在执行的线
程，但在线程终止之前，它的 UncaughtExceptionHandler还有机会以最佳方式对异常作出反
应，有时可能只是报告异常的发生。Threads和 UncaughtExceptionHandlers会在第14章
中详细讨论。
异常就是对象，具有类型、方法和数据。将异常表示为对象很有用，因为异常对象可以包含
数据和方法，它们可以报告特定的异常或用于从这些异常中恢复。异常对象一般都是从 Excep tion类中派生的，这个类提供了一个用于描述错误的字符串字段。所有异常都是类 Throw able的子类，Throwable也是Exception的超类。
使用异常的典型范例是try-catch-finally序列：我们尝试(try)做某些事，如果这么做会抛出
异常，那么我们就捕获(catch)异常，而不论发生什么,最后(finally)我们都需要通过正常路径
或异常路径进行清理。
下面是一个从文件中读取一组数据的getDataSet方法。如果找不到存储数据的文件或者
发生了其他任何VO异常，该方法都会抛出一个异常来描述错误。首先，我们定义了一个新的
异常类型 BadDataSetException,用来描述这种错误。然后我们通过在方法头中使用 throws
子句声明getDataSet方法来抛出这种异常：
class BadDataSetException extends Exception {}
class MyUtilities {
public double[] getDataSet(String setName)
throws BadDataSetException
{
String file = setName+".dset"; FileInputStream in= null;
try {
in= new FileInputStream(file);
return readDataSet(in);
} catch(IOException e){
throw new BadDataSetException();
} finally {
try {
if(in!= null)
in.close();
} catch(IOException e){
1.15 注 解23
// ignore: we either read the data OK
// or we're throwing BadDataSetException
}
}
... definition of readDataSet ...
}
首先，我们将数据集的名字转换成文件的名字。然后，我们试图打开文件，并使用 readData Set方法读取文件。如果一切进行顺利，readbataSet方法会返回一个双精度数组，我们会将
其返回给调用方法的代码。如果打开或读取文件产生了VO异常，将会执行catch子句。
catch子句将创建一个新的 BadDataSetException 对象并将它抛出，这就把I/O异常翻译成
了特定于getDataSet方法的异常。调用getDataSet方法的方法可以捕获这个新的异常并做
出适当的反应。不论是成功地返回数据集合，还是捕获并抛出异常，finally子句中的代码都
会执行，用以在文件已被成功打开的情况下将其关闭。如果在执行close时出现异常，我们会
捕捉它，但会将它忽略。分号本身构成了一条空语句，它什么也不做。忽略异常通常不是一个
好主意，但在这种情况下，要么数据集合已被成功读取，方法已经完成任务，要么方法已经在抛
出异常。如果文件的问题依然存在，那么下次试图使用文件时就会报告异常，那时可以更好地
处理它。
我们可以将 finally子句用于总是必须执行的清理代码。我们甚至可以使用没有catch
子句的 try-finally语句，以确保在没有捕获异常的情况下，清理代码也会执行。
就像 getDataSet方法一样，如果某个方法可能会抛出检查型异常，那么它必须在 throws
子句中声明这些异常的类型。方法只能抛出那些它声明过的检查型异常，这也是它们被称作检
查型异常的原因。方法可以直接使用throw抛出异常，也可以间接调用抛出异常的方法来抛出
异常。RuntimeException、Error类型的异常或这些异常类型的子类都是非检查型异常(un checked exception),它们可以在任何地方被抛出，而不必声明。
检查型异常代表了这样一类情况：虽然它们是异常的，但可以预期它们的发生，并且如果
它们真的发生了，就必须以某种方式进行处理，比如读文件时可能发生的IOException。对方
法抛出的检查型异常进行声明，可以让编译器确保方法只抛出它声明的检查型异常，而不抛出
其他异常。这种检查避免了这种错误情况：我们的方法应该处理另一个方法抛出的异常，但实
际上并没有处理。另外，调用我们的方法的方法也可以确信我们的方法不会产生预料之外的检
查型异常。
一般来说，非检查型异常表示了运行时不能有效恢复的程序逻辑错误。例如，当我们访问
数组越界时，抛出的ArrayIndexoutofBoundsException异常表示程序错误地计算了下标或
者没有校验用作下标的值。这些错误应该在程序代码中进行修改，因为在任何语句中都可能发
生错误，而声明或捕获所有这些错误所产生的异常是不现实的，所以并不对它们进行检查。
练习1.16:在BadDataSetException 中添加字段，用以保存数据集名字和I/O异常，使
得捕获该异常的方法都能知道错误的详细信息。
1.15 注解
注解以结构化的方式提供了程序及其元素(类、方法、字段、变量，等等)的信息，这些信息
能够被外部工具自动处理。例如，在很多开发组织中，所有的代码都会由编写者之外的程序员
复审，对复审代码、复审人以及复审时间的跟踪都需要做大量的记录，这种跟踪是最适合于用自
33
34
35
24 第1章 快速浏览
动工具来完成的任务，而某些代码管理系统确实会支持这类任务。注解使我们可以在被复审的
代码中加入复审信息，例如，我们可以这样给一个类添加注解：
@Reviewed(reviewer="Joe Smith",date = 20050331)
public class Point {
// ...
}
注解可以看作是一种修饰符(就像public或 static一样),并且它应该位于当前行其他修饰
词的前面。我们使用@字符后接一个注解类型(annotation type,本例中是Reviewed)来表示注
解。注解类型是一种特殊的接口，它的成员被称为元素(element)。下面是Reviewed注解类型
的定义：
@interface Reviewed {
String reviewer();
int date();
}
这与接口声明很相似，不同的是interface关键字前面加上了@字符。当我们将注解应用于程
序元素时，需要为所有注解类型的元素提供值，如在上例中：字符串"Joe Smith"用来设置 re viewer元素的值，而整数值20050331用来设置 date元素的值。相关工具可以从源代码或
(更常用的)编译过的类文件中解析这些值，然后确定某些信息，例如，一个类在经过最新的修
改后是否被评审过。
Java语言定义了注解类型的语法，而识别注解的工具则可以确定它们的实际目的。在第15
章之前，我们不会再介绍任何关于注解的内容，只是对它们的适用场景进行了介绍。
1.16 包
名字冲突是开发可复用代码的一个主要问题。无论我们多么小心地为编写的类选择名字，
其他的人还是可能会使用这个名字做其他事情。如果我们使用的是简单的、描述性的名字，那
么这个问题就会变得更加严重，因为这种名字更有可能被其他想要使用简单的描述性名字的人
所使用。像“list”、“event”、“component”这样的词经常被使用，它们几乎肯定会与其他人使用的
名字发生冲突。
在很多编程语言中，名字冲突的标准解决方法是在每个类、类型、全局函数等的前面使用包
前缀(package prefix)。前缀规范创建了命名上下文(naming context),用以确保一个上下文中的
名字不会与另一个上下文中的名字发生冲突。这些前缀一般有几个字符长，而且通常是产品名
字的缩写，比如Xt表示“X-Windows Toolkit”。
当程序使用的包数量不多时，前缀冲突的可能性很小。然而、由于前缀都是些缩写.名字
冲突的可能性就会随包数量的增加而增大。
Java编程语言具有正式的包的概念，它把由类型和子包构成的集合作为其成员。我们可以
命名和导入包，包的名字是分层次的，各个部分用句点隔开。当我们要使用包中的部分内容时，
可以使用其完全限定名(fully qualified name),即用句点隔开的类型名加包名前缀构成的名字，
也可以导入包中全部或部分的内容。导入包中全部或部分的内容，会直接告诉编译器可以在包
中寻找没有在局部定义的类型。包名还使我们能够控制名字冲突，如果两个包中存在同名的
类，我们可以对其中的一个或两个类使用完全限定的类名。
1.17 Java平台 25
下面例子中的方法使用了完全限定名，它利用工具类 Date(见第22章)打印当前的日期和
时间。和其他基于时间的方法一样，该方法用从新纪元(格林尼治标准时间1970年1月1日
00:00:00)到现在的毫秒数作为时间：
class Date1 {
public static void main(String[] args){
java.uti1.Date now = new java.util.Date();
System.out.println(now);
}
}
下面是使用 import声明的类型 Date的版本：
import java.uti1.Date;
class Date2 {
public static void main(String[] args){
Date now = new Date();
System.out.println(now);
}
}
当编译器遇到 now的声明时，它会确定 Date类型实际上是java.util.Date类型，因为这是
编译器所知的唯一的Date类型。导人语句只是直接为编译器提供信息，它们不会使相关文件
“包含”(include)到当前文件中。
包机制并不能完全解决名字冲突问题，因为两个不同的项目也可能使用相同名字的包，这
类问题只能通过规定来解决。标准规定使用开发组织的反向 Internet 域名作为包名的前缀，例
如，如果Acme公司的域名是acme.com,它就可以使用com.acme作为包名的开头，比如 com.
acme.tools。
类总是包的一部分，可以通过在源文件的顶部使用一个包的声明来为它所在的包命名：
package com.sun.games;
class Card {
// ...
}
如果没有在类中使用package声明指定所在的包，这个类就将成为未命名包(unnamed pack age)的一部分。未命名包对于不需要和其他代码一起加载的应用程序(或 applet)来说可能已经
足够了，但是必须为要作为库的类指定具名的包。
1.17 Java 平台
Java编程语言的设计目的是最大限度地提高可移植性，它的很多细节是特别为所有软硬件
实现平台而设计的。例如，双精度类型是64位IEEE 754浮点数。许多语言将精度的定义留给
了具体的实现，而只做出一般的保证(比如最小范围)或者提供询问系统的方法(询问当前平台
上的取值范围)。
Java编程语言的这些可移植性定义针对的是代码所要翻译成的机器语言。源代码被编译成
36
37
26 第1章 快速浏览
Java字节码(bytecode),而字节码是设计用来在Java虚拟机(virtual machine)上运行的。字节码
是抽象机器的机器语言，它运行在各个支持Java 编程语言的系统的虚拟机上。其他语言也可以
被编译成Java字节码。
虚拟机提供了一个运行时(runtime)系统，该系统提供了可以访问虚拟机自身(例如，启动
垃圾回收器)和外部世界(比如输出流 System.out)的能力。运行时系统使用安全管理器(se curity manager)或访问控制器(access controller)来检查安全敏感的操作，例如，安全管理器可以
禁止程序读写本地磁盘或只允许程序通过网络连接特定的机器。程序具体被允许执行哪些操作
是由在程序运行时起作用的安全策略(security policy)所决定的。
当类被载入虚拟机之后，首先由校验器(verifier)对其进行检查，以确保字节码格式正确并
且符合安全要求(例如，字节码绝不能将整数作为引用来访问内存)。
这些特性结合起来为平台独立性提供了一个安全模型，用以执行从网络上下载的具有不同
信任级别的程序。源代码被编译成字节码之后可以在任何装有 Java 虚拟机的机器上运行，这些
代码会在适当的保护级别下运行，以阻止粗心或恶意的类编写者对系统造成危害。信任级别可
以根据字节码的来源进行调整，与来自世界上其他地方的任意一台机器的字节码相比，来自本
38 地磁盘或受保护网络的字节码的可信度更高。
1.18 其他主题概述
我们在这里会简单介绍一些Java的其他特性，它们的细节将在后续章节详细介绍：
·线程：Java语言具有支持创建多线程程序的内建特性。它使用针对对象和针对类的监视
器风格的锁来同步对象和类数据的并发访问，详细内容见第14章。
·反射：反射机制(在某些语言中被称作运行时类型信息，RTTI)允许浏览类的类型和成
员，并允许用编程方式来操作对象。关于反射的更多内容见第16章。
·I/O:java.io包提供了很多不同种类的输入类和输出类。具体的I/O功能见第20章。
●集合：在java.util包中可以找到很多有用的集合类，例如List和HashMap。关干集
合的更多内容见第21章。
·工具接口和类：java.util包还有很多其他有用的类，比如 BitSet、Scanner和 Date。
关于这些工具类的更多信息见第22章。
·国际化：如果我们的程序面向的是世界范围的用户，那么我们需要调整用户界面，使其
能够使用用户的母语与他们进行交互，并且遵循他们本地的习惯，比如时间的表示形式
和数字的格式。有很多类可以帮助我们做到这些，它们主要在java.uti7包和 java.
text包中。国际化和本地化将在第24章进行讨论。
39
注意，我们并不想从这里开始学习!
——《Calvin and Hobbes》(连环漫画)
1.当然，系统可以在片上实现Java虚拟机，即使用特殊的芯片。这不会影响字节码的可移植性，因为芯片也是一种
虚拟机实现。
第2章 类与对象
要事优先，但不必墨守成规。
——Meglos(BBC科幻节目)中Dr.Who的台词
Java 编程语言的基本编程单元是类(Class),类提供了对象的结构，并提供了从类的定义中
构造对象的机制。类定义了方法：即一些可执行代码的集合，它们是计算的焦点，可操纵对象
中存储的数据。方法提供了类的对象所具有的行为。虽然我们仅仅利用基本的数据类型就可以
完成计算，如整数、浮点数等等，但是几乎任何有意义的程序都会创建并操纵对象。
面向对象编程严格区分了做什么(what)与怎么做(how)的概念。“做什么”被描述为方法
(有时也包含一些公共的可用数据)及其相关语义的集合，这些方法、数据和语义的组合常被描
述为类的设计者和使用这些类的程序员之间的一种契约(contract),因为它说明了当我们在对象
上调用某些特定方法时将产生何种结果。这种契约定义了类型(type),所有属于这个类型的对
象都要遵守这个契约。
一般认为类中声明的方法就是该类的完整契约，但这些操作的语义其实也是契约的一部
分，即使它们可能只是在文档中有所描述。两个方法可能拥有同样的名字和参数，并且抛出同
样的异常，但是只要它们的语义不同，它们就不等价。例如，并非每一个被称为print 的方法
都会打印对象的一个副本。有人可能将 print方法的语义定义为“process inteval(处理间距)”
和“prioritize nonterminals(区分非终结符号的优先次序)”,而并非我们所推荐的那种语义。方法
的契约(包含签名和语义)定义了方法的含义。
对象的“怎么做”是由它所属的类来定义的，它定义了这个类所支持的方法的实现。每个对象
都是这个类的一个实例，当在对象上调用某个方法时，就会检查这个类来找到需要执行的代码。 41
对象可以使用其他对象来完成其工作，但我们将从直接实现自身所有方法的简单类开始讨论。
2.1 一个简单的类
下面是一个简单的类，称为 Body',可以用它来存储天体数据，比如彗星、小行星、行星和恒
星：
class Body {
public long idNum;
public String name;
public Body orbits;
public static long nextID=0;
}
类是用关键字class 来声明的，同时要对类赋予名字，并且在花括号中罗列出类的所有成员。
类的声明创建了类型名(type name),因此对属于这种类型的对象的引用，可以直接声明为：
1.好的命名是类设计的关键，Body其实应该叫作 CelestialBody 或者类似的名字。这里我们简写为Body是因
为这本书要多次引用这个类。
42
43
28 第2章 类与对象
Body mercury;
这个声明表示mercury是一个变量，它保存着指向具有 Body类型的对象的引用。这个声明并
未创建对象，它只声明了一个对某个Body 对象的引用。在mercury引用的生存期内，它可以
引用任意数量的Body 对象，这些对象必须被显式地创建。在这方面，Java编程语言不同于那些
在声明变量期间就创建对象的语言。
Body 的第一个版本设计得并不好。当然这里是有意的，我们将在本章中，通过改进这个类
来证明Java语言特性的价值。
2.1.1 类成员
类可以拥有三种成员：
●字段：它们是与类及其对象相关联的数据变量，保存着类或者对象的状态。
●方法：它们包含类的可执行代码并定义了对象的行为。
·嵌套类(nested class)与嵌套接口(nested interface):它们是在其他的类或接口声明的内部
声明的类与接口。
本章我们主要专注于基本成员：字段与方法。嵌套成员将在第5章中讨论。
2.1.2 类修饰符
可以在类声明的前面加上类修饰符来赋予类特定的属性：
·注解(annotation):注解和注解类型将在第15章讨论。
· public:public类是可公共访问的，任何人都可以声明对这种类的对象的引用，或者访
问这种类的公共成员。如果没有该修饰符，类就只能在它所在的包(package)内访问类。我们将
在本章2.3节中学习通用访问控制，包及相关的类和成员的可访问性将在第18章讨论。
· abstract:抽象(abstract)类被认为是不完整的，所以我们不能创建抽象类的实例。通
常这是因为抽象类包含 abstract方法，这些方法必须在子类中实现。我们将在3.7节“抽象类
与方法”中学习与此相关的知识。
· final:final类不允许拥有子类，子类化将在第3章讨论。
·严格浮点(strict floating point):声明为strictfp的类要求类中的所有浮点运算都是精确
运算。详情请见9.1.3节“严格浮点运算与非严格浮点运算”。
类不能既是final的又是abstract的。
类声明的前面可以有多个修饰符，修饰符可以按任意顺序排列，但是我们建议使用上面给
出的顺序排列以增强代码的可读性。
由于在本章我们并不关心类的修饰符，所以我们需要知道一些关于public类的知识：大
多数Java的开发工具都要求public类必须声明在与类同名的文件中，这意味着每个文件中只
能有一个public类。
练习2.1:编写一个简单的Vehicle类，使它(至少)具有当前速度、当前方向(角度)、所有
者的名字等几个字段。
练习2.2:编写一个LinkedList类，使它具有一个object类型的字段和一个可以引用到
下一个LinkedList元素的引用。
2.2 字段
类中的变量称为字段，Body类的name和orbits变量就是例子。字段的声明包含类型名、
2.2 字段29
字段名和可选的初始化子句，这个子句可以为字段赋予初始值。每个Body 对象都拥有自己特
定的三个字段的实例：一个long类型的字段实例，它可以在所有 Body 对象中唯一地标识某个
Body 对象；一个String类型的字段实例，表示该对象的名字；还有一个指向另一个Body 对象
的引用，表示该对象环绕着旋转的天体。对每个单独对象中的这些字段都赋予不同的实例意味
着每个对象都有其自身的状态，这样的字段被称为实例变量，因为改变某个Body 对象中的or bits字段并不会影响到其他 Body 对象。
也可以在字段声明的前面添加修饰符来改变它的属性：
· 注解：注解和注解类型将在第15章讨论。
·访问修饰符：将在2.3节讨论。
· static:将在下面讨论。
· final:将在下面讨论。
· transient:与对象序列化有关，将在20.8节讨论。
· volatile:与同步和内存模型有关，将在14.10节讨论。
字段不可以既是 final的又是volatile的。
当多个修饰符同时作用于某个字段的声明时，我们推荐你使用上面给出的顺序进行排列。
2.2.1 字段的初始化
字段被声明后，就可以通过赋予它相应类型的值来进行初始化。在 Body 示例中，nextID
字段被初始化为零。但是初始化表达式，或者简称初始化式(initializer),并不要求一定是常量，
它可以是对其他的字段或方法的调用，或者二者兼有的一个表达式。唯一的要求是初始化式必
须具有正确的类型，而且，如果它调用了某个方法，可能就不会抛出检查型异常了，因为其外围
没有捕获异常的代码。例如，下面的初始化式都是合法的：
// constant double zero =0.0;
double sum= 4.5+3.7; // constant expression
double zeroCopy = zero; // field
double rootTwo= Math.sqrt(2);// method invocation
double someVal = sum+ 2*Math.sqrt(rootTwo);i/ mixed
虽然初始化式为字段的初始化方式提供了极大的灵活性，但是它们只适用于简单的初始化
模式。我们马上会看到对于复杂的初始化模式，还需要其他的工具。
如果字段未被初始化，那么根据其类型，它将被赋予一个默认的初始值，如表2-1所示。
表 2-1
类 型 初始值
boolean false
char '\u0000'
byte, short,int,long 0
float, double +0.0
object reference null
2.2.2 静态字段
有时候，我们希望某个类的某个字段只有一个实例，这个实例被该类的所有对象共享。我
们可以通过将字段声明为 static来达到这一目的，这种字段被称为静态字段(static field)或者
44
30 第2章 类与对象
类变量(class variable)。当我们在类中声明 static字段时，无论创建了该类的多少个实例，这
个字段的副本都只有一份。
在我们的例子中，Body有一个 static字段nextID,它包含下一个可用的天体标识符。
当加载 Body类并开始初始化时(请查看16.13节“加载类”),nextID字段将初始化为零。我
们将看到每一个新创建的Body 对象的标识符都会被赋值为 nextID的当前值，并且 nextID的
值是递增的。因此，我们在创建Body的所有实例时，只希望有一份 nextID字段的副本。
在Body类的内部，static字段可以被直接引用，但在该类的外部，则需要通过类名来访
问。例如，我们可以用下面的语句打印出 nextID的值：
45 System.out.println(Body.nextID);
对System.out的使用本身就展示了应该如何访问 static字段。当一个类的某个静态成员被
另一个类多次引用，或者当一个类的多个静态成员被另一个类引用时，我们可以通过静态导入
(static import)语句来一次性地命名类的静态成员，从而使代码更清晰，可能还可以节省一些冗
余输入，这一特性将在2.9节讨论。
类的静态成员也可以通过类的对象引用来访问，如：
system.out.println(mercury.nextID);
我们应该避免这种形式，因为它会给人以错觉，好像 nextID是对象 mercury的成员而不是类
Body的成员。引用的类型(而不是它所引用的对象的类型)决定了将在哪个类中查找这个静态
变量。
在本书中，当我们使用术语字段时，通常指的是非静态类型的字段。如果上下文并不明确，
我们将使用术语非静态字段(non-static field)来明确表示。
练习2.3:为Vehicle类添加一个静态字段，用来保存下一辆车的标识号，再添加一个非
静态字段，用来保存每辆车的ID号。
2.2.3 final字段
final变量一经赋值就无法改变，任何要改变 final字段的尝试都会在编译期报错。我们
在前面已经看到过final字段被用来定义具名常量，因为常量的值是不变的。一般地，final
字段用来定义类或者对象的持久属性，这些属性将不随类或对象的生命周期而变化。标识为
final的字段在涉及并发访问时，还有特殊的语义，这将在第14章讨论。
没有初始化器的 final字段被称为空白 final(blank final),在简单初始化字段尚不适宜的
时候可能会用到它。一旦类被初始化(对于 static的 final字段)或者类的对象被完全构造出来
(对非 static的final字段),这些空白final字段就必须被初始化。
46
对于基本类型或者 String类型的 final字段，如果它被一个常量表达式所初始化，也就是
说，被一个在编译期即可确定其值的表达式所初始化，那么该字段就被称为常变量(constant
variable)。常变量很特殊，这是因为编译器视之为数值而不是字段。如果我们的代码引用了—
个常变量，那么编译器并不会产生从对象的字段中取值的字节码，而是会直接将数值插入字节
码。这是一种有用的优化措施，但它意味着如果我们要改变一个final字段的值.那么每一外引
用到该字段的代码都要重新编译。
属性是否可变是由该类被设计用来实现的应用所具有的语义决定的。当我们决定一个字段
是否应为 final的时候，应该考虑以下三个问题：
·该字段表示的是否是对象的不变属性?
·该字段的值在对象创建时是否总是可知的?
2.3 访问控制 31
·当对象被创建时，设置该字段的值是否实际并可行?
如果属性只是不常被改变而非一直不可变，那么就不适宜使用final字段。如果某个字段的值
在对象创建时仍不确定，那么即使在逻辑上该字段的值一旦确定就是不可变的，它也不能被设
置为 final。例如，在模拟天体的例子中，彗星可能会被恒星的重力所捕获而环绕着恒星旋转。
一旦被捕获，彗星就会永远环绕着恒星旋转，直到被摧毁。在这种情况下，orbits字段一经设
定，就会保存一个恒定的值，但是这个值在彗星对象创建时是未知的，因此，这个字段不能是
final的。最后，如果一个字段的初始化代价很大并且这个字段的值并不经常使用，那么将该
字段的初始化推迟到该字段第一次被调用时才执行就会显得很实用，这种做法通常被称为延迟
初始化(lazy initialization),它并不适用于final字段。
如果我们的对象必须是可克隆的或者是可序列化的，那么关于 final字段我们就还需要考
虑一些其他问题。这些内容将在3.9节的“克隆对象”和20.8节的“对象序列化”中分别讨论。
练习2.4:考虑你所给出的练习2.3的解，你认为标识号字段应该是final的吗?
2.3 访问控制
如果每个类和对象的所有成员都能被其他所有的类和对象访问，那么对程序的理解、调试
和维护将几乎不可能实现。我们将无法依赖类所表现的契约，因为任何代码段都能够直接访问
它的字段，并且以违反契约的方式来修改字段。在面向对象编程的健壮性中，一个重要的方面
就是它支持封装(encapsulation)和数据隐藏(data hiding)。为实现这一目标，我们需要一种方式
去控制谁有权访问类或接口的哪些成员，甚至是访问类或接口本身。这种控制是由类、接口和
成员的访问修饰符来限定的。
类中的所有成员都可以被该类自身的代码访问。为控制其他类的访问权限，类成员有4种
访问修饰符：
· private:声明为private的成员只能被包含它的类自身所访问。
·package:包成员无任何访问修饰符，它们只能被包含它们的类和它们所在包中的类所访
问。我们将在第18章讨论包和相关的访问权限。
·protected:声明为protected的成员可以被包含它的类的子类、同一个包中的类以及包
含它的类自身所访问。类的扩展将在第3章讨论。
· public:声明为public的成员可被任何类访问。
private和protected 访问修饰符只能作用于成员，不能作用于类或者接口(除非是嵌套类或
接口)。对于能够被某个类中的代码段访问的成员，其所在的类必须首先可以被该段代码访问。
我们必须认识到，访问控制是在类层次上而非对象层次上实现的，这一点很重要。这意味
着，类成员总是可以被所在类的代码所访问，无论这段代码作用于类的哪个实例上。稍后，在
介绍如何利用方法进行访问控制时，我们将用一个例子来证明这一点，请查看2.6.6节。
我们可以认为public和protected成员是契约式的，因为那些我们控制不到的代码可以保证
它们是可信赖的。因此，当有代码依赖于public 或者 protected 成员的功能时，就不能再改变它
们了，而对package和private成员的访问属于在我们的实现中对外隐藏的那部分内容(同一个包
内的类之间应该是相互关联的)。
我们声明 Body类的字段是public的，因为程序员需要访问它们来实现设计这个类的目
的。在后面的 Body版本中，我们将看到这种设计通常并不高明。
47
48
49
32 第2章 类与对象
2.4 创建对象
在Body的最初版本中，表示特定天体的对象是如下创建和初始化的：
Body sun = new Body(;
sun.idNum = Body.nextID++; sun.name= "Sol";
sun.orbits = null;// in solar system,sun is middle
Body earth= new Body();
earth.idNum = Body.nextID++;
earth.name = "Earth";
earth.orbits = sun;
首先我们声明一个可以引用Body类型对象的引用变量(sun)。如前所述，这种声明并不创建
对象；它只定义了一个引用对象的变量，而所引用的对象必须被显式地创建。
我们用new创建了对象 sun, new构造是目前为止最常用的创建对象的方式(我们将在第
16章介绍其他方式)。在用new 创建对象时，需要指定要创建的对象的类型和构建它所需的所
有引元。运行时系统为存储该对象的字段分配了足够的内存空间，并对它进行了初始化。稍后
我们会看到对象是如何初始化的。初始化完毕后，运行时系统将返回对这个新对象的引用。
如果系统没有足够的空闲空间来创建对象，它可能不得不运行垃圾回收器来尝试回收空
间。如果系统仍无法获得足够的空闲空间，new将抛出OutofMemoryError异常。
创建了新的 Body对象之后，我们接下来初始化它的变量。每个 Body 对象都需要一个唯一
的标识符，它是从 Body的static字段nextID中获得的，代码必须递增 nextID以保证创建下一
个Body 对象时能够得到一个唯一的标识符。
然后我们用类似的方式来创建 earth 对象。这个例子建立了一个太阳系的模型，在此模型
中，太阳是中心，sun的orbits字段为 nul1,因为它不环绕其他天体旋转。我们创建并初始
化 earth时，设置它的orbits字段为sun,而moon 对象的 orbits字段将设置为earth。在
银河系的模型中，sun 将环绕一个假定在银河系中心的黑洞旋转。
虽然我们是用new来创建对象的，但是我们不用显式地删除它们。虚拟机利用垃圾回收
(garbage collection)来管理内存，也就是说，那些可能再也不会用到的对象可以在不需要我们干
预的情况下被垃圾回收器自动回收，从而释放空间。如果我们再也不需要某个对象了.那么应
该终止对它的引用。对于方法中的局部变量，只需要直接从方法返回，即当方法不再运行时，
其中的变量也就不再会用到了。对于更持久的引用，比如对象的字段，可以将其设置为 nul1。
内存管理将在第17章讨论。
练习2.5:为你的 Vehicle类编写一个main方法，用来创建一些车辆并打印它们的字段
值。
练习2.6:为你的LinkedList类编写一个main方法，用来创建一些 Vehicle对象并把它
们放置到列表的连续节点中。
2.5 构造与初始化
新创建的对象会被赋予一个初始状态。字段可以在声明时被初始化为某个值，我们也可以
使用它们的默认值，有时默认值完全可以保证正确的初始状态。但通过简单初始化来创建初始
值经常是不够的，例如，用于创建的代码可能需要提供初始数据或者执行简单赋值表达式无法
表示的操作。
2.5 构造与初始化33
2.5.1 构造器
除了简单初始化之外，类还可以含有构造器(constructor)。构造器是一些语句块，用来在
new将对象的引用返回之前初始化对象。构造器拥有与它们要初始化的类相同的名字，就像方
法一样，它需要零个或多个引元，但是构造器并不是方法，因此也就没有返回类型。如果构造
器有引元，就需要在用 new创建对象的时候，将引元放在类型名后的括号中。构造器将在新建
对象被赋予默认初值且执行了显式的初始化式之后调用。
为了设置新对象的初始值，改进版本的Body类既使用了构造器，也使用了初始化式：
class Body {
public long idNum;
public String name ="<unnamed>";
public Body orbits = nul1; private static long nextID=0;
Body(){
idNum= nextID++;
}
}
构造器声明由下面几部分组成：类名，紧随其后是带有参数列表(也可能为空)的圆括号，然后
是花括号中的语句。构造器可以拥有任何与类成员相同的访问修饰符，但是构造器并不是类的
成员——这个区别通常可以忽略，除非构造器是继承而来的。构造器也可以拥有作用于其上的
注解，见第15章。
Body类的构造器没有接受引元，但是它实现了一个重要的功能——为新创建的对象赋了
一个合适的idNum值。在前面的代码中，程序员常犯的一个错误就是忘记为 idNum赋值或者在
使用过 nextID后忘记递增它，这可能会导致不同的 Body 对象具有相同的 idNum,从而造成依
赖于“所有的 idNum值都不相同”这一契约的代码产生缺陷。
通过将产生idNum的责任转移到 Body类的内部，我们就可以避免此类错误。Body 的构造
器现在是唯一为idNum赋值的实体，因此也是唯一需要访问 nextID的实体。我们可以，并且
也应该将 nextID设置为私有的，使得只有 Body类可以访问它。通过这样的修改，我们为使用
Body类的程序员移除了一个错误来源。
我们现在还可以随意地修改为 Body 对象的 idNum值赋值的方式。例如，将来这个类的某
个实现可能是到数据库中查询已知天体的名字，并且分配一个前面未用到的 idNum值。这种改
变不会影响任何已有代码，因为已有代码根本没有涉及分配idNum的机制。
name和orbits的初始化式已经将它们设置为合理的数值，因此，当构造器从下列调用中
返回时，新 Body 对象中的所有数据字段都会被设置成合理的初始状态。然后，我们可以将对
象的状态设置为想要的值：
Body sun = new Body();// idNum is 0 sun.name="Sol";
Body earth= new BodyO);// idNum is 1
earth.name ="Earth";
earth.orbits= sun;
Body的构造器是在 new创建对象时被调用的，但是这个调用发生在 name和orbits 被设置为
默认初始值之后。
50
51
52
34 第2章 类与对象
在天体的名字和在创建它时它所环绕的天体都已知的情况下，我们经常会看到下面这样的
代码，其中，我们提供了另一个构造器，它接受天体的name 和orbits作为引元：
Body(String bodyName,Body orbitsAround){
this();
name = bodyName;
orbits = orbitsAround;
}
如上面的代码所示，一个构造器可以通过 this()来调用同一个类中的另一个构造器作为其第
一条可执行语句，这被称为显式构造器调用(explicit constructor invocation)。如果我们想要调用
的构造器带有引元，那么可以将这些引元传递给构造器调用——所使用的引元类型和个数决定
了会调用哪个构造器。这里我们调用了无引元的构造器来设定 idNum,这意味着我们不需要复
制 idNum的初始化代码。现在，赋值代码已经简单多了：
Body sun = new Body("sol",nul1);
Body earth = new Body("Earth",sun);
引元的列表决定了哪个构造器会作为new表达式的一部分而被调用。
如果构造器的语句中有显式构造器调用，那么它必须是第一条语句。任何用作显式构造器
调用的引元的表达式都不准引用当前对象的字段和方法。实际上，在构造阶段，还不存在任何
当前对象。
考虑到完整性，我们还需要提供一个只有一个引元的构造器来构造不环绕任何天体旋转的
Body 对象。这个构造器可以替代这样的用法：在调用有两个引元的 Body 构造器的时候，将第
二个参数置为nul1:
Body(String bodyName){
this(bodyName,nu1l); }
而且事实上，这个构造器所做的正是使用另外一个显式构造器调用。
有些类总是要求创建者提供某些数据。例如，我们的应用可能要求所有的 Body 对象都有
名字。为确保所有创建 Body 对象的语句都能提供名字，我们可以将所有的 Body 构造器都定义
为含有name 参数，从而不必操心 name字段的初始化问题。
下面是一些提供专用构造器的常见理由：
●有些类在没有参数时就不会有合理的初始化状态。
·在我们构造某些种类的对象时，提供初始状态会既方便又合理(例如带有两个引元的
Body 构造器)。
·构造对象可能是个代价高昂的操作，所以我们希望对象在被创建时就拥有正确的初始状
态。例如，如果某个类的每个对象都有一张表，那么可以指定表格初始尺寸的构造器就
能够使对象在创建伊始便具有正确尺寸的表格，而不用先创建一个默认尺寸的表格，然
后在调用设置实际尺寸的方法后舍弃掉默认值。
·非public的构造器限制了谁能够使用它来创建对象。例如，通过将某个类的构造器全
部设置为只能在其所在包的内部被访问，我们可以防止使用我们的包的程序员创建该类
的实例。
不带引元的构造器很常见，以至于有一个专门的术语称之为：无参(no-arg)构造器。如
果我们在类中没有提供任何构造器，那么Java语言会提供一个默认的不做任何事情的无
参构造器，这类构造器被称为默认构造器(default constructor),它们只有在不存在任何其
2.5 构造与初始化 35
他构造器的情况下才会由编译器自动提供，这是因为对于某些类来说无参构造器是不正
确的(比如下一章中将提到的Attr类)。如果我们既需要无参构造器，又需要其他带引
元的构造器，就必须显式地提供一个无参构造器。默认构造器与其所在的类拥有相同的
可访问性，即如果类是public的，那么默认构造器也是public的。
另一种形式的构造器称为复制构造器(copy constructor),这类构造器接收一个当前类型的
对象作为引元，然后创建该传入对象的一个副本作为新对象。通常，这种构造器只是为所有的
字段赋予与传入对象相同的值，但是有时它所属的类的语义可能包含着更复杂的动作。下面是
一个简单的Body 复制构造器：
Body(Body other){
idNum = other.idNum;
name = other.name;
orbits = other.orbits;
}
这么做是否正确取决于类的契约以及 idNum需要表达的唯一性。在本例中，我们并不关心这
些。
这种惯用法在Java类库里面使用得并不多，因为直接复制对象的推荐方式是使用克隆
(clone)方法，见3.9节“克隆对象”。尽管如此，很多类都支持“复制”另一个对象的更通用的
构造形式，例如，StringBuilder类和 StringBuffer类(将在第13章中描述),每个类都有
一个接受单一字符序列(CharSequence)引元的构造器，这些构造器允许我们复制已有的
String、StringBuffer或者 StringBuilder 对象；另外每个集合类(将在第21章中描述)都
有一个接受另一个collection作为引元的构造器，因此允许一个集合被初始化为与另一个集
合具有相同的内容(但不需要类型完全一致)。编写正确的复制构造器与编写正确的clone方
法所需考虑的事情是一样的。
构造器也可以声明为抛出检查型异常，throws子句位于参数列表之后，构造器体的左花括
号之前。如果有 throws子句，那么任何调用该构造器作为 new 表达式一部分的方法就都必须
要么捕获这个声明的异常，要么声明将这个异常抛出。异常与 throws子句将在第12章详细讨
论。
练习2.7:为vehicle添加两个构造器：一个无参构造器和一个初始化所有者名字的构造
器。修改main程序以产生与前面相同的输出。
练习2.8:你应该为LinkedList添加什么类型的构造器呢?
2.5.2 初始化块
字段另一种更复杂的初始化方式就是使用初始块。初始块是一段出现在类声明中的语句
块，它位于所有成员、构造器以及声明之外，它可以初始化对象的字段。它们会被优先执行，就
好像它们被放置在类中的每一个构造器的开头那样，如果有多个块，它们将按照在类中出现的
先后顺序执行。只有当类的所有构造器都声明会抛出某个检查型异常时，它的初始块才可以抛
出该异常。
为了展示其用法，我们用一个等价的初始块来替代 Body类中的无参构造器：
class Body {
public long idNum; public String name ="<unnamed>";
public Body orbits = nul1;
53
54
55
36 第2章 类与对象
private static long nextID=0;
{
idNum = nextID++;
}
public Body(String bodyName,Body orbitsAround){
name =bodyName;
orbits = orbjtsAround;
}
}
现在，带有两个参数的构造器就不需要显式地调用无参构造器了，而且不再有无参构造器了，
因此每个人都必须使用两个参数的构造器。
这虽然不是一个非常有意义的初始块应用，但确实展示了这个语法。实际上，初始块在我
们编写没有构造器的匿名内部类(见5.4节)时是最有用的，它们对于那些所有构造器都要执行
的通用代码片段的定义也很有用。当然这也可以通过定义特殊的初始化方法来实现，比方说
init,区别在于，这样的方法无法被识别为构造代码，比如它不能为空白 final字段赋值。初始
块的目的在于初始化，但实际上，我们可以让它做任何事情，编译器并不校验它做了什么。将
初始化代码分散在类的各处并非是一种好的设计，应该审慎地使用初始块，用它们来表示那些
构造器不能单独轻易完成的工作。
2.5.3 静态初始化
我们已经看到，类的 static字段可以有初始化式。但除此之外，我们还可以用静态初始块
(static initialization block)执行更复杂的静态初始化操作。静态初始块除了被声明为 static,并
且只能引用类的静态成员和不能抛出任何检查型异常之外，与非静态初始块很相似。例如，有
时创建一个静态数组并且初始化它的元素必须使用可执行语句来实现。下面是一段初始化质数
数组的示例代码：
class Primes {
static int[] knownPrimes = new int[4];
static {
knownPrimes[0]=2;
for(int i=1;i< knownPrimes.length;i++)
knownPrimes[i]= nextPrime();
}
// declaration of nextPrime ...
}
类内部的初始化顺序是从前到后的，即代码中的字段初始化器或者初始块都是按照从头到
尾的顺序依次执行的。静态初始化器将在类加载之后，真正被使用之前执行(见16.13.2节)。
有了这项保证，就可以确保上例中的 knowPrimes 数组能够在初始块执行之前创建。类似地，
任何要访问静态字段的程序都可以确信该字段已经被初始化。
如果类X中的某个静态初始化器调用了Y中的方法，但是Y的静态初始化器又调用了X中
的方法来设置它的静态值，那么将会发生什么呢?这种循环静态初始化无法在编译期可靠地检
测到，这是因为在编译x的时候，Y的代码可能还没有编写出来。如果产生循环，X的静态初始
化器将只会执行到Y的方法被调用处，当轮到Y调用X的方法时，在执行这个方法之前会执行
2.6 方 法37
x中所有剩余尚未执行的静态初始化器，而X中那些其初始化器仍未执行的静态字段具有的仍
然是它们的默认值(false、'/u0000'、0或者 nul1,具体是什么取决于它们的类型)。
2.6 方法
类的方法通常包含了理解和操纵对象状态的代码。某些类拥有可以让程序员直接操纵的
public或者protected字段，但是在多数情况下，这么做并不好(见3.11节),因为很多对象
都具有这样的任务：它们无法被表示为可以读取或修改的简单数值，必须进行计算。
在第1章中，我们已看到了很多方法的例子，其中所有的演示程序都有main方法，它可以
在Java 虚拟机上运行。下面是另一个创建 Body 对象并打印其字段值的main方法实例：
class BodyPrint {
public static void main(String[] args){
Body sun = new Body("Sol",nu11);
Body earth= new Body("Earth",sun);
System.out.print1n("Body "+ earth.name + " orbits "+ earth.orbits.name +
" and has ID"+ earth.idNum);
}
}
方法的声明包含两部分：方法头(method header)和方法体(method body)。方法头包含可选
的修饰符集、可选的类型参数集、方法的返回类型和签名，还有可选的列出了方法所抛出的异常
的 throws子句。其中，方法的签名包含方法名和由圆括号括起来的参数类型列表(可以为
空),而所有方法必须都有返回类型和签名；类型参数是用来声明泛型方法的，我们将在第11
章讨论它，异常与 throws子句将在第12章详细讨论；方法体由花括号括起来的语句组成。
方法修饰符包含下列几部分：
·注解：注解和注解类型将在第15章介绍。
·访问修饰符：在2.3节讨论过。
·abstract:抽象(abstract)方法的方法体没有在类中定义，是由参数列表后面的分号指代
的，其实现由子类来负责，相关内容我们将在3.7节讨论。
· static:将在下一节讨论。
· final:final方法不能被子类覆盖，我们将在3.6节讨论。
·synchronized:synchronized方法的语义与程序中的并发线程的控制有关，我们将在
14.3节讨论。
· native:我们将在2.11节讨论。
·严格浮点(strict floating point):声明为strictfp的方法要求所有的浮点数运算都要严格
进行。如果方法声明在被声明为strictfp的类中，那么该方法将被隐式地声明为
strictfp。更多细节见9.1.3节。
抽象方法不能是static、final、synchronized、native或严格浮点的，而native方法
不能是严格浮点的。
当多个修饰符同时作用于某个方法的声明时，我们建议采用上面给出的顺序。
2.6.1 静态方法
static方法可以用类来直接调用，而无需用从类中实例化出来的具体对象来调用，因此这
56
57
58
38 第2章 类与对象
类方法也被称为类方法。static方法可以完成类中所有对象的某项通用任务，如返回下一个
可用的序列号或者其他诸如此类的工作。
static方法只能访问类中的 static字段和其他的 static方法。这是因为非 static成
员必须通过对象的引用来访问，而在静态方法中，没有任何可用的对象引用——没有任何 this
引用。
在本书中，我们所使用的术语方法(method),通常是指非 static类型的方法。如果上下文会
使其发生混淆，我们将使用术语非静态方法(non-static method)加以明确。
练习2.9:为Vehicle添加一个静态方法，返回目前为止用到的最大标识号。
2.6.2 方法调用
方法调用就是使用圆点操作符通过引用执行对象的操作：
reference.method(arguments)
在 Bodyprint的例子中，我们调用了在静态引用 System.out所引用的对象的print1n方法，
并传入了单一的由其他字符串连接而成的 String引元。
所声明的每一个方法都将具有指定数量的参数，而每一个参数也都将具有指定的类型。方
法的最后一个参数可以声明为给定类型的参数序列，可以在类型名后加上省略号(…)来表示。
例如，String…表示由零个或者多个String 对象组成的序列。参数序列使得我们可以在调用
方法时传入可变数量的引元，其中一些引元将与该序列对应。这些可变引元方法将在下一节中
介绍。
在调用方法时，对于方法声明中的每一个参数，调用者都必须提供与其类型相对应的引元。
引元不需要与其对应的参数类型完全一致，因为方法会自动进行某些转换，例如，byte引元可
以被转换为int参数，包装对象也可以在必要时被转换为它的基本类型(反之亦然),见8.6节
的“装箱转换”。
方法还具有返回类型，它要么是基本类型，要么是引用类型。如果方法不返回任何值，就
需要将返回类型设置为void。
示例 Bodyprint展示了一种常见的情形，即我们希望查看对象的状态。在这种情形中，类
无需提供对对象的所有字段的访问方法，而只需定义一个方法，让其返回一个表示对象状态的
字符串。例如，Body类中就有这样一个方法，它将返回一个描述该方法是在哪个特定的 Body
对象上被调用的 String:
public String toStringO{
String desc= idNum+"("+ name +")";
if(orbits != nu11)
desc +="orbits"+orbits.toStringO;
return desc;
}
这个方法使用了+和+=来连接 String 对象。它首先构建了一个描述标识符和名字的字符
串，如果这个天体环绕另一个天体旋转，那么我们通过调用 tostring方法就可以追加描述被
环绕天体的字符串。这种递归把那些环绕其他天体旋转的天体所对应的字符串连缀到一起，直
到在递归链中碰到某个不环绕其他任何天体旋转的对象为止，然后其结果字符串由 return语
句返回给调用者。
对象的 tostring方法很特殊，当对象被用于一个使用+操作符的字符串表达式时.将会
调用其 tostring方法以获取一个 String。考虑下列表达式：
2.6 方 法39
System.out.print1n("Body"+ sun);
System.out.print1n("Body"+ earth);
sun和 earth的 toString方法将被隐式调用并产生下列输出：
Body 0(Sol)
Body 1(Earth)orbits 0(Sol)
所有对象都有一个tostring 方法，不管它们的类是否显式地定义了该方法。这是因为，
所有的类都扩展自Object类，并且Object定义了tostring方法。类的扩展与object类将
在第3章讨论。
练习2.10:为Vehicle类添加一个 tostring方法。
练习2.11:为LinkedList类添加一个 tostring方法。
2.6.3 引元数量可变的方法
方法(或者构造器)参数列表中的最后一个参数可以被声明为给定类型的序列。为了指示
某个参数是序列，我们可以在参数的类型之后、名字之前加上省略号(…)。例如：
public static void print(String...messages){
// ...
}
其中，参数messages 被声明为一个 String 对象序列。序列参数允许使用构成该序列的可变
数目(包括0)的引元来调用一个方法，这类方法被称为可变引元(variable-argument)方法，或者
是更常见的 varargs 方法；未声明参数序列的方法称为固定引元(fixed-argument)方法。
在很多情况下都需要处理可变数量的引元。例如，Body 对象已经追踪到了它所环绕的天
体对象，但是了解环绕着它旋转的 Body 对象也很有用。尽管一个给定的天体通常只环绕一个
其他的天体旋转，但是它自身可能会被多个其他的天体所环绕。为了追踪这些信息，我们可以
定义一个Body 对象数组，并且提供一个方法，每次向该数组添加一个环绕该天体旋转的天体，
这并非是一个不合理的解决方案，但是如果我们能够定义一个下面这样的可以传入一个 Body
对象序列的方法，那将会方便得多：
public void setOrbiters(Body...bodies){
// ... store the values ...
}
我们可以按如下方式使用此方法：
Body sun = new Body("Sol",null);
Body earth = new Body("Earth",sun);
Body moon = new Body("Moon",earth);
Body mars = new Body("Mars",sun);
Body phobos = new Body("Phobos",mars);
Body deimos = new Body("Deimos",mars);
earth.setOrbiters(moon);
mars.setOrbiters(phobos,deimos);
你可能很想知道 setorbiters 中的参数序列 bodies是何种类型，其实很简单，就是一个
1.更形式化的说法是，可被传给一个方法调用的引元数目称为调用的数目(arity)。varargs方法是数目为变量的方
法，而固定引元方法是数目固定的方法。
59
60
61
40 第2章 类与对象
Body 对象的数组。将参数声明为序列无外乎就是让编译器构造一个数组，并将其中的元素设
置为实际传入序列的引元。当我们调用某个方法时，编译器会将每一个传入的引元匹配为具名
参数。如果编译器发现有序列参数，它会将所有剩余的引元绑定到一个由序列参数指定其类型
的数组中，记住，序列参数必须是最后被声明的参数。当然，这些引元必须具有恰当的类型才
能够存入数组中。如果没有剩下任何要存入数组的引元，那么就会创建一个长度为0的数组并
将其作为引元来传递。了解了这一点，我们就可以省却编译器的麻烦，自己传入一个数组：
Body[] marsMoons ={ phobos, deimos };
mars.setorbiters(marsMoons);
但是在多数情况下，让编译器做这项工作会显得更轻松一些。
有时候，编译器需要一些帮助才能了解我们调用某个特定方法的意图。例如，假设我们调
用 setorbiters时只有一个引元nul1,那么它表示传入的数组是nul1(也就是没有数组),还
是表示传入了一个长度为1的数组，而该数组唯一的元素为null呢?编译器无法确认并且会
给出一个警告。为消除这种二义性，我们需要将nul7强制转换为合适的类型，例如，对于类型
为T的序列参数，如果我们将其强制转换为T,那么我们将得到一个长度为1的T数组，其唯一
的元素是nul1;如果我们将其强制转换为T[],那么我们将得到一个 nu71数组引用。在方法
重载的上下文中，还会带来其他的二义性，我们稍后会提到(见2.8节的“重载方法”)。
我们已经看到了另一个使用varargs方法的示例，只是你可能还尚未意识到。1.10.1节介绍
的printf方法就被声明为接受一个string 和一个object序列，对于每个格式字符串中的格
式说明符，这个方法都期望能够传入一个与之相对应的object引元。
练习2.12:考虑你的 Vehicle类和 LinkedList类，你能想出一个需要接受可变数量引元
的方法吗?
2.6.4 方法异常与返回
当调用方法时，控制流将从调用方法传人被调用的方法，被调用方法中的语句将按照它们
的语义顺序执行。当发生下列三种情况之一时，方法将结束执行并返回到调用者：执行 return
语句；到达方法结尾；抛出未捕获的异常。
如果一个方法要返回结果，那么它只能返回一个单一的结果，这个结果要么是一个基本类
型的值，要么是一个对象引用。对于需要返回不止一个结果的方法，可以通过以下几种方式来
达到这种效果：返回对象的引用，所有结果都被作为字段存储在这个对象中；传入一个或多个
引用型的对象参数，在其中保存返回结果；返回包含结果的数组。例如，假设我们想编写一个
方法，用它来返回拥有给定银行账户的特定客户可执行的动作，由于可执行的动作可能有多种
(存款、取款，等等),所以必须返回多种权限。我们可以创建一个Permissions类，在其对象
中存储一组 boolean值，用这些 boolean值来表示是否具有执行某个动作的权限：
public class Permissions {
public boolean canDeposit,
canWithdraw,
canClose;
}
下面是通过填充这些字段来返回多个结果的方法：
public class BankAccount {
private long number; // account number
private long balance;// current balance(in cents)
2.6 方 法41
public Permissions permissionsFor(Person who){
Permissions perm = new PermissionsO);
perm.canDeposit = canDeposit(who);
perm.canWithdraw= canwithdraw(who);
perm.canClose = canClose(who);
return perm;
}
// ... define canDeposit et al ...
}
在具有返回值的方法中，每一条通路都必须要么返回一个值(该值可赋值给具有所声明的
返回类型的变量),要么抛出一个异常。例如，permissionsFor方法不能返回一个 String,
因为我们不能将 String 对象赋值给 Permissions类型的变量。但是我们可以将 permis sionsFor的返回类型声明为Object,而无需修改 return语句，因为我们可以将Permis sions 对象引用赋值给Object类型的变量，而这又是因为(正如我们所知的)所有的类都扩展
自Object。可赋值这一概念将在第3章中详细讨论。
2.6.5 参数值
方法中的所有参数都是“按值”传递的，换句话说，方法中参数变量的值是调用者所指派的
引元之值的副本。如果我们将一个double类型的引元传入方法，那么无论传入的值是什么,
该方法的参数都是这个值的副本，而且，该方法对参数值的修改不会影响到调用这个方法的代
码中的值。例如：
class PassByValue {
public static void main(String[] args){
double one = 1.0;
System.out.print1n("before:one ="+ one);
halveIt(one);
System.out.print1n("after: one ="+ one);
}
public static void halveIt(double arg){
// divide arg by two arg /= 2.0;
System.out.print1n("halved:arg ="+ arg);
}
}
下列输出说明，halveIt内部的arg的值被2整除之后并没有影响 main方法中变量 one的值：
before:one = 1.0
halved:arg =0.5
after: one= 1.0
应该注意的是，如果参数是一个对象引用，那么它就只是一个“值”传递的对象引用，而非
对象本身。因此，我们可以在方法内部修改参数所引用的对象，而这不会影响到被传入的引用
本身。但是如果我们修改了对象的某些字段，或者调用了可以修改对象状态的方法，那么对于
程序中所有存有该对象引用的部分而言，都意味着这个对象发生了变化。下面的例子显示了二
者的区别：
62
63
64
42 第2章 类与对象
class PassRef {
public static void main(String[] args){
Body sirius = new Body("Sirius",null);
System.out.print1n("before:"+ sirius);
commonName(sirius);
System.out.print1n("after:"+ sirius);
}
public static void commonName(Body bodyRef){ bodyRef.name="Dog Star";
bodyRef= null;
}
}
该程序产生的输出如下：
before:0(Sirius)
after:0(Dog Star)
注意，sirius所引用的对象的内容已经变了——该对象的名字发生了变化，但是变量 sirius
仍然保持着对 Body 对象的引用，尽管 commonName方法将参数变量bodyRef的值修改成了
nul1。这一点需要解释一下。
图2-1说明了在main方法调用了commonName 之后，各变量的状态：
maisiorius idNum:0 "Sirius"
name orbits:nul1
commonName()
bodyRef
图 2-1
此时，两个变量(main方法中的)sirius和(commonName 中的)bodyRef都引用了相同的底层
对象。当commonName方法修改字段 bodyRef.name时，两个变量所共享的底层对象的名字发
生了改变。但是，当commonName将 bodyRef的值修改为 nul1时，只有 bodyRef变量的值被
改变了，而sirius的值保持不变，这是因为参数 bodyRef是sirius 的值传递副本。在com
monName方法中，我们所修改的只是参数变量bodyRef的值，正如我们在 halveIt方法中只
修改了参数变量arg的值一样。如果改变 bodyRef的值会影响 main方法中的 sirius值、那
么在“after”这一行就会打印出“null”。尽管如此，commonName 中的变量 bodyRef和main中
的变量 sirius都引用了同一个底层对象，所以在 commonName 中所作的修改可以通过 sirius
引用观察到。
有些人说对象是“按引用”传递的，这是不正确的。在编程语言设计中，术语“引用传递”
(pass by reference)真正的含义是当引元传递给函数时，被调用的函数获得的是对原值的引用，
而非原值的副本。如果函数修改了其参数值，那么调用代码中的值也将发生改变，这是因为引
元和参数使用了内存中的同一块地址。如果 Java 编程语言中最终采用的是引用传递来传入参
数，那么就可以通过某种方式来声明 halveIt,使上面的代码能够修改 one的值，或者使 com
monName可以将变量 sirius修改为nul1。但这是不可能的，Java语言并不按引用来传递对
象，而是值传递对象。因为同一个引用的两份副本指向的都是同一个实际对象，所以通过一个
2.6 方 法 43
引用变量所作的修改可以被另一个引用观察到。准确地讲，Java只有一种参数传递方式，即值
传递，这么做有助于保持简单。
我们可以将方法的参数声明为final,使参数的值在方法执行的过程中不会被改变。如果
bodyRef 被声明为final,编译器将不允许我们将它修改为nul1。当我们不想修改某个参数
的值时，可以将它声明为final,这样编译器就可以保证它不会被修改。参数的 final声明还
可以防止在我们想要对字段赋值时，将值赋给了与该字段同名的参数。这种声明还可以帮助编
译器或虚拟机来优化使用 final参数的表达式，因为编译器和虚拟机知道它始终保持不变。作
用于参数的final修饰符属于声明该参数的方法的实现细节，它只会对该方法中的代码产生影
响，而不会影响调用该方法的代码，因此如果我们把某个方法的参数修改为 final是不会影响
到调用该方法的代码的。
2.6.6 使用方法来控制访问
相对来说，带有多个构造器的 Body类已经比只有数据的简单版本使用起来要容易得多了，
并且我们可以确保 idNum会被自动正确地设置。但是在对象创建后，程序员仍然可以设置id Num的字段，从而有可能使对象出错，这是因为idNum字段是public的，因此它被暴露出来以
使其可以被修改。idNum应该是个只读数据，只读数据在对象中很常见，但是并没有任何作用
于字段的关键字能够使得在类的外部对某个字段只能进行只读访问，而只有声明这个字段的类
自身才能够修改它。
为了强制只能进行只读访问，我们必须将字段定义为 final,这样会使其在对象的整个生
命周期内都是只读的，否则我们必须隐藏它。我们可以通过将 idNum设置为private来隐藏
这个字段，同时提供一个新的方法，以便类外部的代码能够通过该方法获得这个字段的值：
class Body {
private long idNum;// now "private"
public String name="<unnamed>";
public Body orbits = null;
private static long nextID=0;
Body(){ idNum = nextID++;
}
public long getID(){
return idNum;
}
//...
}
现在，想获得 Body对象标识符的程序员需要调用getID方法来返回它的值，程序员再也无法
修改标识符了，对类的外部来说，该标识符已经变成只读数据，它只能被 Body类的内部方法修
改。
控制内部数据访问的方法有时被称为访问方法(accessor method),使用它们可以增强类数
据的封装性。
即使应用程序并不要求字段是只读的，也应该把字段设为private,并且添加设置和获取它
65
66
67
44 第2章 类与对象
们的方法，因为这样做使我们可以在以后添加需要的动作。如果程序员能够直接访问类的字
段，那么我们将无法控制他们使用的值，并且无法控制程序在字段的值被改变之后所表现出来
的行为。此外，将字段作为类契约的一部分可以锁定类的实现，因为如果不强制客户端重新编
译，我们就不能改变类的实现。例如，未来的 Body版本可能需要在数据库中查询按天体名索
引的ID号，而并非在对象中实际存储ID号。如果 idNum在客户端可以被访问，这样的修改就
无法实现。正因为这些缘故，在本书后面的例子中，将很少看到 public和protected的字段。
用来获得或设置对象状态值的方法有时候被认为是在定义对象的属性。例如，Body类的
getID方法可以认为是在定义 Body 对象的ID属性，该属性由getID来获取，并通过idNum字
段来实现。某些自动系统，包括那些用于JavaBean构件架构的系统，都使用这种方式来提供
自动属性装配系统，请查看25.3节。我们能够而且应该把 name字段和 orbits字段定义为属
性，即让它们成为私有的，并提供相应的set方法和get方法：
class Body {
private long idNum;
private String name ="<unnamed>";
private Body orbits = nul1;
private static long nextID=0;
// constructors omitted ...
public long getIDO){ return idNum;}
public String getName(){ return name;}
public void setName(String newName){
name = newName;
}
public Body getOrbits(){ return orbits;}
public void setOrbits(Body orbitsAround){
orbits = orbitsAround;
}
}
将字段设置为final是防止对字段进行不必要的修改的另一种方式，但是不变性和可访问
性不应混为一谈。如果字段是不变的，那么不管它可访问性如何，它都应该被设置为 final。
反过来说，如果我们并不希望字段成为类契约的一部分，那么就应该将它隐藏到方法的后面，
而不管这个字段是否是只读的或者是可修改的。
既然我们已经将 Body的所有字段都设置成了private的，我们可以回顾一下，前面的访问
控制是类级别的而非对象级别的。假设一个天体可以被另一个天体所捕获，并强迫着环绕它旋
转，那么我们可以在Body 中定义如下的方法：
public void capture(Body victim){
victim.orbits = this;
}
如果访问控制是对象级别的，那么当我们在一个对象上调用 capture方法时，将无法访问并修
改 victim天体对象的private字段orbits。但由于访问控制是类级别的，所以类中的方法可以
访问这个类的所有对象的所有字段——它只需要一个对要访问对象的引用即可，例如像前面提
到的可以通过参数来获得这样的引用。某些面向对象语言提倡对象级别的访问控制，但是Java
编程语言与它们不同。
2.8 重载方法 45
练习2.13:将你的vehicle类中的所有字段都设置成 private的，并为这些字段添加访
问器方法。哪些字段应该拥有修改它们的方法，哪些不需要?
练习2.14:将你的LinkedList类中的所有字段都设置成private的，并为这些字段添加
访问器方法。哪些字段应该拥有修改它们的方法，哪些不需要?
练习2.15:为Vehicle类添加一个change Speed方法，使之可以将车辆的当前速度修改
为一个传入的值，并且添加一个可以将速度设置为零的stop方法。
练习2.16:为LinkedList类添加一个可以返回列表中元素的数量的方法。
2.7 this
前面已经介绍过(2.5.1节)我们怎样才能使用显式的构造器调用来实现在构造器的起始位
置调用类的其他构造器。我们还可以在非静态的方法中使用 this 这个特殊的对象引用，它指
向的是方法被调用了的当前对象。在static方法中没有 this引用，因为没有可供操作的特定
对象。
this引用最常见的用法就是将当前对象的引用作为引元传递给其他方法。设想有这样一
个方法，它要求把当前对象添加到一个等待某项服务的对象列表中，看起来可能像这样：
service.add(this);
类 Body的capture方法也使用了this来设置当前对象中 victim的orbits字段。
我们可以把 this放置到任何访问字段或者调用方法的语句的前面，例如，在Body类的带
两个引元的构造器中，为 name 赋值的语句：
name = bodyName;
与下式等价：
this.name = bodyName;
按照惯例，this只在必要的时候使用：即要访问的字段的名字被局部变量或参数声明隐藏
了的时候。例如，我们可以把 Body类中带两个引元的构造器改写为：
public Body(String name,Body orbits){
this();
this.name= name;
this.orbits = orbits;
}
在上面的构造器中，name字段和 orbits字段被构造器中同名的参数隐藏了。例如，为了访问
name字段而不是name 参数，我们需要在name前加上前缀 this来指明 name代表对象的字段。
只有在构造器和“set”方法中，用这种方式去刻意隐藏标识符才会被认为是可接受的编程习惯，
然而某些编码指南和开发环境中却提倡即使在这些情况下也绝对不要隐藏标识符。名字解析的
方式将在7.5节的“名字的含义”中介绍。
2.8 重载方法
每个方法都有签名(signature),签名是由方法名及其参数的类型和数量组成的。两个方法
只要具有不同类型或数量的参数，它们就可以具有相同的名字，因为它们具有不同的签名。这
一特性称为重载(overloading),因为一个方法的简单名可以拥有重载的(多个)含义。当我们调
用方法时，编译器将通过引元的类型和数量来寻找最适合的重载方法。下面是我们的 Body类
中的一些 orbitsAround方法，如果当前天体环绕着指定的天体或者环绕着具有指定标识符的
68
69
70
46 第2章 类与对象
天体旋转，那么这些方法将返回 true:
public boolean orbitsAround(Body other){
return(orbits == other);
}
public boolean orbitsAround(long id){
return(orbits != nu11 && orbits.idNum == id);
}
上面的两个方法都只声明了一个参数，但是参数的类型不同。如果用一个 Body 引用作为引元
来调用方法 orbitsAround,那么声明参数类型为 Body的方法版本就会被调用——该版本将
对传入的引用与对象自身的orbits引用进行比较。如果使用一个long类型的引元来调用or bitsAround,那么声明参数类型为long 的方法版本就会被调用——该版本将对传入的标识号
与对象所环绕的天体的 idnum字段进行比较。如果方法调用与上述签名均不符，那么代码将无
法编译。
对于 varargs方法，出于重载的目的，序列参数T...将被作为一个T[]类型的参数来处理。
因此如果两个签名的区别仅仅只是其中一个声明了一个序列，而另一个声明了一个数组，那么
就会产生编译期错误。
签名并不包含返回类型或者抛出异常的列表，并且我们无法基于这些因素来重载方法。关
于Java语言如何判断应该调用哪个可用的重载方法的话题将在9.6.1节的“寻找正确的方法”
中详细讨论。
你可能已经意识到了，构造器也有和方法相同的重载方式。
重载机制的典型应用场合有两种：一种是方法或构造器可以接受以不同形式所表示的相同
信息，就像 orbitsAround的例子中所展示的那样；另一种是方法需要很多参数，但是其中一
些具有默认值，因而不需要提供。例如，Body类有两个重载的构造器：其中一个构造器接受一
个名字和另一个它要环绕的 Body 对象(如2.5.2节所示);另一个构造器只接受名字，表明该
天体不环绕任何其他天体旋转。
我们应该谨慎而仔细地使用重载。尽管基于引元数量的重载通常很明确，但是基于相同数
量不同类型的引元而进行的重载会显得很混乱。如果我们添加了引元可变的方法，那么在阅读
或编写这些方法的调用时，那些基于不同数量的参数的方法也会变得很混乱——具有两个引元
的方法调用是应该匹配为两个固定的参数，还是应该匹配为一个固定的参数和只有一个元素的
序列，亦或是只匹配为一个带有两个元素的序列呢?下面展示的就是几个极度糟糕的使用重载
的例子：
public static void print(String title){
// ... }
public static void print(String title,String...messages){
//.
}
public static void print(String...messages){
// ...
}
如果给定下面的方式调用：
print("Hello");// which print?
那么应该调用哪一个print方法呢?尽管并不明显，但是这个例子的行为具有明确的定义：总
是优先于 varargs 方法而选择固定引元的方法，详细内容见9.6.1节“寻找正确的方法”。因此在
2.9 导入静态成员名 47
上例中，接受单个String参数的print方法将会被调用。相反，下面的调用并不明确，因此
将导致一个编译期错误：
print("Hello","world");// INVALID:ambiguous invocation
上面的方法可以是一个字符串和一个单元素序列，也可以是一个有两个元素的序列。解决这种
二义性的唯一方式就是，如果我们希望方法调用能够与序列参数相匹配，那么就应该传入真正
的数组：
print("Hello",new String[]{"world"});
print( new String[]{ "Hello","world"});
上面的第一个调用现在明显是与带有两个参数的print方法相匹配，而第二个则明显是与带有
单一序列参数的print方法相匹配。
我们可以妥善地避免上面出现的混淆，那就是不要以会导致上面这种二义性的方式来重载
方法。
练习2.17:为vehicle类添加两个 turn方法：一个接受角度数来转弯，另一个接受Vehi cle.TURN_LEFT或vehicle.TURN_RIGHT来转弯。
2.9 导入静态成员名
静态成员一般应该通过它所属的类名来引用，比如 System.out 或者Math.sqrt。这通常
是最佳实践，因为这么做明确地指出了代码需要引用什么。但是如果每次引用静态字段或方法
时都使用类名，那么有时候这会使代码既笨拙臃肿又晦涩难懂。例如，设想我们需要定义数学 71
函数来计算双曲正切(tanh),'这可以通过使用Math.exp函数计算出来：
static double tanh(double x){
return(Math.exp(x)- Math.exp(-x))/
(Math.exp(x)+ Math.exp(-x));
}
Math函数贯穿于整个表达式，看起来很散乱，并且肯定不能提高代码的可读性。为缓解这一问
题，我们可以告知编译器，凡是引用到exp方法的时候，我们表示的都是引用静态方法 Math.
exp,可以用静态导入语句(static import statement)来实现这一目的：
import static java.1ang.Math.exp;
静态导入语句必须出现在源文件的起始部分，即位于任何有关类或接口的定义之前。通过给出
上述静态导入语句，使得在我们的源文件中凡是调用 exp方法的地方都表示要调用Math.exp
(假设我们没有用另一个exp声明把它隐藏了起来，见7.5节“名字的含义”)。现在可以把我们
的例子改写为下面这种更加清晰的形式：
static double tanh(double x){
return(exp(x)- exp(-x))/
(exp(x)+ exp(-x));
}
静态导入语句由关键字短语import static组成，后面跟随要导入的静态成员所在的类或
接口的全称名、一个圆点以及静态成员的名字。与所有的语句一样，它也要以分号结束。
按需静态导入语句(static import on demand statement)用一个星号(*)代替了成员名。它告
1.这个功能是java,lang,math类库的一部分，所以实际上并不需要这样实现。
72
73
48 第2章 类与对象
诉编译器如果发现某个不知来历的名字，那么应该查找由按需静态导入语句所提供的类型，以
查看它是否有一个静态成员具有该名字。如果有，那么编译器将假设我们就是想要引用该静态
成员。例如，如果我们的双曲正切函数是定义了许多数学函数，并且用到了许多Math类中的
静态方法和静态常量的类的一部分，那么我们就可以使用按需静态导入语句来导入所有这些方
法和常量的名字：
import static java.1ang.Math.*;
当名字可以用这种方式来导入时，命名冲突将更容易发生。关于静态导入和按需静态导入
是如何协同工作的，以及它们是如何与在程序中用到的其他名字协同工作的，存在着各种各样
的规定，这些内容将在7.5节的“名字的含义”中讨论。
静态导入的使用可以提高代码的可读性，但是如果被误用，它们也会使得阅读代码的人很
难理解我们的代码究竟要做什么。当读者看到 Math.exp时，能够很清楚地知道它引用的是什
么,但是如果只是exp,就不会这么清晰了。如果代码中有多个按需静态导入语句，读者将不
得不查找每一个类型以确定是否有一个名为 exp的静态成员。作为一条通用规则，请记住，使
用静态导入应该是为了提高代码的可读性和净化代码，而不是为了省略掉一些代码录入工作。
2.10 main方法
调用应用程序的细节因系统的不同而有所不同，但是不论细节如何，我们都必须提供驱动
这个应用程序的类名。在运行程序的时候，系统将定位并运行这个类的main方法。main方法
必须是public、static和void(没有任何返回值)的，并且必须接受单一的 String[]类型的
引元。下面是一个打印 main方法引元的例子：
class Echo {
public static void main(String[] args){
for(int i=0;i<args.1ength;i++)
System.out.print(args[i]+"");
System.out.printin();
}
}
传入 main的String数组包含了程序引元(program argument),它们通常是在用户运行程序时
由用户来输入的。例如，在诸如 UNIX或 DOS shell 这样的命令行系统中，我们可以通过下面的
方式来运行 Echo应用：
java Echo in here
在上面这条命令中，java表示Java的字节码解释器，Echo是类的名字，余下的命令是程序的
引元。java命令将寻找编译过的 Echo 类的字节码，将它载入 Java 虚拟机，并使用包含在
String数组中的字符串来调用 Echo.main方法。其结果是产生下面的输出：
in here
类的名字并未包含在传入 main的字符串中，因为类名是已知的，它就是main声明所在的类。
应用程序可以拥有任意数量的main方法，因为应用程序中的每个类都可以有一个main方
法。到底使用哪个类的main方法是在每次运行程序时指定的，就像运行Echo 时那样。
练习2.18:修改 Vehicle.main,创建带有车主的汽车，车主的名字是在命令行中指定的，
然后将它们打印出来。
2.11 本地方法49
2.11 本地方法
如果我们需要编写一个程序，它想使用某些现有的非Java 编程语言编写的代码，或者我们
需要直接操纵某种硬件，那么我们可以编写本地方法(native method)。通过本地方法我们可以
实现能够用Java语言调用，但却是使用“本地”语言编写的方法，这些本地语言通常是C或者
C++。本地方法是用native修饰符来声明的。因为这种方法是由其他语言来实现的，所以其
方法体用分号指代。例如，下面是一个本地方法的声明，它将向操作系统查询宿主机器的CPU
标识符：
public native int getCPUIDO;
除了是由本地代码实现之外，本地方法与其他方法类似：它们可以被重载和覆盖，可以是fi nal、static、synchronized、public、protected 或者private的。然而，本地方法不能被声
明为 abstract 或者 strictfp。
如果我们使用了本地方法，那么代码的可移植性和安全性就丧失了。例如，在几乎所有我
们希望通过网络下载并运行的程序中(比如 applet),都不能使用本地方法。下载代码的系统所
具有的体系结构可能与我们的系统相同，但也可能并不相同，即便相同，它可能也无法对我们
的系统信任到可以运行任意的本地代码的程度。
本地方法是通过使用那些编写虚拟机的人所提供的API来实现的，这里的虚拟机指的是执
行本地方法的虚拟机。其中，为C程序员制定的标准被称为JNI,即Java 本地接口(Java Native
Interface),对于其他本地语言也有相关的标准，这些API的描述已经超出了本书的范围。
我们面临的重大问题无法在提出这些问题的思想层面上解决。
——阿尔伯特·爱因斯坦 74
75
第 3章 类的扩展
我实际上是个具有极其骄傲高贵的血统之人，我的祖先可远溯至亚当诞生
之前原始质的原始小球，因之，我的骄傲血统绝非常人所能想象。
———Gilbert和 Sullivan,《日本天皇》(歌剧)
第1章简要描述了如何扩展(extend)或子类化(subclassed)一个类，同时还描述了如何将扩
展类的实例用于任何要求使用原类的地方。描述这种能力的术语称作多态(polymorphism),其
含义是指一个给定的类可以具有多种形态，既可以作为它本身的类，又可以作为任何它所扩展
的类。通过扩展得到的新类称作被扩展的类的子类(subclass)或者扩展类(extended class),而被
扩展的类则称作超类(superclass)。
在类的外部可以访问的方法和字段的集合，加上它们应具有的行为的描述，通常称为该类
的契约。契约是类的设计者对类的行为所做的承诺。类的扩展提供了两种形式的继承：
●契约或类型的继承：通过这种继承，子类可以获得超类的类型，因此它可以多态地用于
所有使用超类的地方。
·实现的继承：通过这种继承，子类可以获得超类中可访问到的字段和方法的实现。
类的扩展有很多用途。最常见的是用于特化(specialization),在这种用法中，扩展类定义了
新的行为，因此成了其超类的一个特化版本。类的扩展可能只需要对继承的某个方法的具体实
现进行修改，以使其更加高效。对类的扩展实际上就是在用扩充的契约创建新类，但是，从被
扩展的类中继承的那部分契约并没有改变。改变超类契约的实现方式是合理的，但是绝对不应
该以违反该契约的方式修改其实现。
类扩展机制与访问权限控制机制互相作用，对类所表现的契约的概念进行了拓展。每一个
类都可以表现为两种不同的契约，一个是面向类的用户，一个是面向从该类扩展出来的类。这
两个契约都应该仔细设计。
在使用类扩展机制时，契约的继承和实现的继承总是同时出现。但是可以通过使用接口来
定义新的独立于实现的类型，也可以通过人为地使用组合(composition)和转发(forwarding)来重
用现有的实现，后面的这种做法并不会对类型造成影响。接口与组合将在第4章中讨论。
涉及泛型类的类扩展对于重定义成员、覆盖与重载都具有其特殊的规则，这些规则将在第
11章详细讨论，本章不考虑泛型类型。
3.1 扩展类
为了演示子类化，我们从设计一个用来存储名值对的基本属性类开始。属性名是方便人阅
读的字符串，例如“颜色”或“地点”。属性值是由属性的类型决定的，例如，一个“地点”可以有
一个表示某条街道地址的字符串类型的值，也可以有一个表示经度和纬度的整型值集合。
public class Attr {
private fina1 String name;
private Object value = nul1;
3.1 扩 展 类51
public Attr(String name){
this.name = name;
}
public Attr(String name,Object value){
this.name= name;
this.value = value; }
public String getName(){
return name;
}
public Object getValue(){
return value;
}
public Object setValue(Object newValue){
Object oldVal = value;
value = newValue;
return oldVal;
}
public String toString(){ return name+"='"+ value+"'";
}
}
属性必须得有一个名字，所以Attr类的每一个构造器都要求有一个名字参数。名字必须
是不可变的(所以被标记为 final),因为它可能会被当作(例如)一个存储在散列表或排序表中
的键来使用。在这种情况下，如果name字段是可修改的，那么属性对象将会“丢失”,因为它将
归属于旧名字而非修改过后的新名字。属性的值可以是任意类型的，因此值可以存储在Ob ject类型的变量中，并且可以随时对其进行修改。name和 value都是私有成员，因此只
能经由恰当的方法来访问它们。将它们声明为私有成员不仅可以确保 Attr类的契约总是
能够得到遵守，而且也允许Attr的设计者在不影响类的使用者的情况下自由地更改其实
现细节。
到目前为止你所看到的每一个类都是扩展类，无论它是否被显式地声明为一个扩展类。像
Attr这样没有显示声明扩展其他类的类其实都隐含地扩展了 Object类。Object类位于类继
承层次的根部，它声明了所有对象都要实现的方法，例如在第2章中所见到的 tostring方法。
object类型的变量可以引用任何对象，无论该对象是类的实例还是数组。有关 Object类的详
细描述见3.8节。
下面这个类扩展了属性的概念，用以存储颜色属性，而该属性可能是命名或描述颜色的字
符串。颜色描述可能是诸如“红”或“淡褐”之类的颜色名，这些名字必须是从某张表中查询得
来的，颜色描述也可能是数值，这些数值可以被解释成标准的、更高效的颜色表示法，我们称其
为Screencolor(假设它是在别处定义的)。将一个描述解释成一个ScreenColor 对象的开销
相当大，所以我们最好只执行一次这样的解释。因此，我们通过扩展Attr类来创建 colorAt tr类，以支持用来获取一个被解释出来的 Screencolor对象的方法，这样我们就可以只执行
一次这样的解释：
76
77
78
52 第3章 类的扩展
class ColorAttr extends Attr {
private ScreenColor myColor;// the decoded color
public ColorAttr(String name,Object value){
super(name, value);
decodeColorO);
}
public ColorAttr(String name){
this(name,"transparent"); }
public ColorAttr(String name,ScreenColor value){
super(name,value.toString(O); myColor= value;
}
public Object setValue(Object newValue){
// do the superclass's setValue work first
Object retval= super.setValue(newValue);
decodeColor();
return retval;
}
/** Set value to ScreenColor,not description */
public ScreenColor setValue(ScreenColor newValue){
// do the superclass's setValue work first
super.setValue(newValue.toStringO);
ScreenColor oldValue= myColor;
myColor = newValue;
return oldValue;
}
/** Return decoded ScreenColor object */
public ScreenColor getColor(){
return myColor;
}
/** set ScreenColor from description in getValue */
protected void decodeColor(){
if (getValue()== nul1)
myColor = nul1;
else
myColor = new ScreenColor(getvalue(O); }
}
我们首先创建了一个新的扩展自Attr类的ColorAttr类，它除了具有Attr类Object
所具有的所有行为之外，还添加了新的行为。因此，Attr类就是ColorAttr的
超类，而ColorAttr就是Attr的子类。它们的类层次结构是从子类到超类自下 Attr
而上排列的，看起来如图3-1所示：
ColorAttr 扩展的ColorAttr类主要做了三件事：
·提供了三个构造器：其中有两个与其超类的构造器完全一样，另一个则直 图 3-1
接接受了一个ScreenColor对象作为构造参数。
3.2 扩展类的构造器53
·同时覆盖并重载了超类的 setvalue方法，因此它可以在颜色值发生变化的时候重新设
置颜色对象。
·提供了一个新的getcolor方法，用以返回一个值，该值被解释成为 Screencolor 对象
中的颜色描述。
在下面几节中我们将会看到构造过程的复杂性和继承在不同的类成员上所产生的效果。
注意 decodecolor方法上的protected 访问修饰符的使用。通过将该方法设为protec ted,可以使得该方法能够被当前的类及其子类所访问，但是对外部而言它是不可视的。在3.5
节中你将会看到protected修饰符的真正含义。
练习3.1:以第2章练习中的 vehicle类作为超类，建立一个名为 Passengervehicle的
扩展类，在扩展类中添加一项功能，使其可以计算小轿车上可用的座位数和目前车上已被占用
的座位数。在Passengervehicle类内提供一个新的 main方法，用来建立多个这样的对象并
将它们打印出来。
3.2 扩展类的构造器
扩展类的对象既包含从超类继承的状态变量(字段),也包含只在该类内部定义的字段。要
构造一个扩展类的对象，必须正确地设置这两类状态变量。扩展类的构造器应该只知道如何处
理它自己的字段，而只有超类才知道如何正确地初始化超类的字段，这样超类的契约才能得以
遵守。扩展类的构造器必须通过隐式地或显式地调用其超类的构造器，将继承而来的字段的构
造工作委托给超类。
扩展类的构造器可以使用另一种显式的构造器调用来直接调用其超类的某个构造器，这种
显式的构造器调用就是超类构造器调用(superclass constructor invocation),它是使用 super来调
用的。在ColorAttr类的第一个构造器中就展示了这种调用：
public ColorAttr(String name,Object value){
super(name, value);
decodeColorO);
}
构造器将 name和 value的值传递给超类中相应的具有两个引元的构造器，然后调用它自己的
decodecolor方法，使mycolor持有正确的 Screencolor 对象的引用。
还可以用this代替 super来显式地调用扩展类自己的另一个构造器，以延迟选择到底调
用超类的哪一个构造器，正如 colorAttr类的第二个构造器所示：
public ColorAttr(String name){
this(name,"transparent");
}
我们需要确保每一个颜色属性都具有一种颜色。如果没有提供颜色值，我们就提供默认值
“transparent”,因此，这个只有一个引元的构造器使用一个默认引元(default argument)调用
了具有两个引元的构造器。
如果扩展类构造器的第一条可执行语句既不是调用超类构造器的语句，也不是调用扩展类
的某个其他构造器的语句，那么在子类构造器的任何语句执行之前，扩展类的构造方法都会自
动调用超类的无引元构造器。也就是说，扩展类构造器的第一条语句被认为是如下这条语句：
super(O);
如果超类没有无引元的构造器，就必须显式地调用另一个构造器。
79
80
54 第3章 类的扩展
colorAttr对象的第三个构造器使得程序员可以通过指定Screencolor对象本身来创建
一个新的ColorAttr对象：
public ColorAttr(String name,ScreenColor value){
super(name, value.toStringO);
myColor = value;
}
前两个构造器必须使用 decodecolor方法将它们的参数转换为 Screencolor 对象，这样做肯
定需要一定的开销。如果程序员已经有了可以提供为值的 Screencolor对象时，那么就可以
避免这种转换的开销。在这个例子中，我们提供的构造器的效率得到了提升，但是其能力并没
有增加。
在这个例子中，ColorAttr与其超类的构造器具有相同的签名，但这种安排并不是必需
的。有时使用扩展类的部分好处就在于它可以基于它自己的构造器的多个或零个参数，将有用
的参数提供给它的超类构造器。让扩展类和超类一样没有任何构造器签名的做法其实很常见。
构造器不是方法，也不能被继承。如果超类定义了一系列的构造器，而扩展类希望具有相
同形式的构造器，那么扩展类必须显式地声明每一个构造器，即使这些构造器所做的全部工作
仅仅只是调用相同形式的超类构造器。
构造器顺序依赖
在创建对象时，内存会为所有的对象字段分配空间，包括那些从超类继承来的字段，而且
这些字段会被初始化为它们各自类型的默认值(即所有的数值类型都是0,boolean类型为
false, char类型为'u0000',对象引用类型为null)。在此之后，构造过程分为三个阶段：
1.调用其超类的构造器；
2.用这些字段的初始器和初始化块来初始化它们；
3.执行构造器体。
其中首先执行的是显式或隐式的超类构造器调用。如果使用了显式的 this 构造器调用，那么
这样的调用链将会链接下去，直到找到一个隐式或显式的超类构造器调用为止，然后调用该超
类构造器。超类构造器的执行过程也分为同样的三个阶段，这个过程将会递归地应用，当到达 81
object的构造器时则终止，因为此时已没有可调用的超类构造器了。任何作为显式构造器调
用的组成部分进行计算的表达式都不允许引用当前对象的任何成员。
在第二阶段，所有的字段初始器和初始化块都是按照它们的声明顺序来执行的。在这个阶
段，允许引用当前对象的其他成员，只要它们已经被声明过即可。
最后，执行构造器体中的实际语句。如果该构造器是被显式调用的，那么一旦其执行结束，
控制流就会返回到调用它的构造器，执行那个构造器体的剩余部分。这个过程将会不断地重
复，直到在new构造语句中所使用的构造器体都已经执行完成之后才停止。
如果在构造的过程中异常有抛出，那么 new表达式将会在抛出那个异常的同时终止，此时
不会返回任何对新对象的引用。因为在一个构造器体中，显式的构造器调用必须是第一条执行
语句，所以它不可能捕获另一个构造器抛出的异常。(如果允许捕获这样的异常，那么就有可能
发生用无效的初始状态来构造对象的情况。)
下面是一个例子，可以追踪说明构造过程的不同阶段：
class X{
protected int xMask= 0×00ff;
protected int fu11Mask;
3.2 扩展类的构造器 55
public X(){
ful1Mask =xMask;
}
public int mask(int orig){
return(orig & fu11Mask);
}
}
class Y extends X{
protected int yMask = 0xff00;
ublfulMask I=yMask;
}
}
如果创建一个Y类型的对象，并且逐步地对其进行构造，那么就可以得到每一步执行过后字段
所对应的值，如表3-1所示：
表 3-1
步骤执行的操作 xMask yMask fu11Mask
0 将字段设置为默认值 0 0 0
1 调用Y的构造器 0 0 0
2 调用X的构造器(super) 0 0 0
3调用Object的构造器 0 0 0
4 X的字段初始化 0x00ff 0 0
5 执行X的构造器 0x00ff 0 0x00ff
6 Y的字段初始化 0x00ff 0xff00 0x00ff
7 执行Y的构造器 0x00ff 0xff00 0xffff
理解这个顺序对于在构造阶段调用方法是非常重要的。在调用方法时，总是要获取这个方
法在该对象的实际类型中的实现。如果该方法使用了这个实际类型中的字段，那么这些字段完
全有可能还没有初始化。在第5步中，如果X的构造器调用了mask,那么它使用的 fu11Mask
值将是0×00ff,而不是0xffff。事实确实如此，尽管在对象完全构造之后，对mask 的调用所
使用的 ful1Mask 值是0xffff。
而且，假设类Y的实现覆盖了mask 方法，且在计算中显式地使用了yMask 字段。如果x
的构造器使用的是mask方法，那么实际上它想调用的将是Y的mask 方法，而此时yMask 的值
将是0而不是想要的0xff00。
在设计对象构造阶段调用的这些方法时必须考虑上面这些因素。构造器应该避免调用那些
可覆盖的方法，即不是私有的、静态的或 final的方法。如果确实调用了这样的方法，那么必
须在文档中将它们清晰地列出来，以提醒所有想要用潜在的非常规的使用方式来覆盖这些方法
的人。
练习3.2:输入如上所示的类x和Y,并且添加用以追踪mask 值的打印语句。添加一个
main方法，运行它并查看结果。(提示：使用第1章中给出的带有格式化说明符的 printf
方法将整数以十六进制的格式打印出来。)
82
83
84
56 第3章 类的扩展
练习3.3:如果在构造过程中用扩展类中的值来设置这些mask 是关键所在，那么应该怎样
处理这些问题呢?
3.3 继承与重定义成员
在扩展类时，既可以向类中添加新的成员，也可以重定义现有的成员，重定义一个继承成
员所产生的确切效果将取决于成员的类型。本节将学习有关字段和方法成员的知识，但是有关
嵌套成员的讨论将在第5章中进行。
3.3.1 覆盖
在新的ColorAttr类中，我们同时覆盖与重载了实例方法 setvalue:
·重载(overloading)一个方法(前面已经学过):提供多个具有相同名字的方法，但是它们
具有可以彼此区分开的不同签名。
·覆盖(overriding)一个方法将方法的超类实现替换为自己的实现。它们的签名必须相同，
但是它们的返回类型可以按照某种特定方式而变化，就像下面将要讨论的那样。
重载一个继承而来的方法仅仅意味着我们添加了一个新的方法，它与继承而来的方法具有
相同的名字，但是签名不同。我们把在Attr类中只有一个setValue方法改进为在colorAttr
类中拥有该方法的两种重载形式：
public Object setValue(Object newValue){
// ...
}
public ScreenColor setValue(ScreenColor newValue){
// ...
}
这与在同一个类中声明某个方法的多种重载形式没有任何区别。
覆盖一个方法意味着替换它的实现，这样在子类对象上调用该方法时，被调用的就是该方
法的子类版本。在ColorAttr类中，我们通过提供一个新的 setvalue(Object)方法覆盖了
Attr类的 setvalue(Object),这个新方法首先使用super关键字调用了超类的实现，然后又
调用了decodecolor方法。super引用可以在方法调用中用来访问被当前类覆盖的超类中的
方法，在3.3.6节我们将会学习到有关 super的细节。
在覆盖方法时，其签名必须与超类中的签名相同，如果不同，那么这就是重载，而不是覆
盖。覆盖方法的返回类型可以按照某种具体方式变化：如果返回类型是引用类型，那么覆盖方
法的返回类型可以声明为超类方法所声明的返回类型的子类型。因为对超类的引用总是可以持
有一个对子类实例的引用，所以这种变化是十分安全的，它被引用为一个协变返回类型。当浏
览到第3.9节的对象克隆时，我们就可以看到一个不错的有关这种变化的例子。如果返回类型
是基本类型，那么覆盖方法的返回类型就必须与超类方法的返回类型相同。如果两个方法仅在
返回类型上有区别，那么这就是一个错误，编译器将因此而拒绝这个类。
varargs方法中的覆盖和重载(见2.6.3节)一样，类型为T...的序列参数将被当作一个类
型为T[]的参数对待，这意味着覆盖方法可以将最后一个数组参数“转换”成一个序列，而无需
更改方法的签名，这使得子类的用户可以使用数量可变的引元调用该方法。虽然允许定义一个
将序列替换为数组的覆盖方法，但是这种做法极不可取，因为那样做会引起混乱，并且毫无用
3.3 继承与重定义成员 57
处，所以不要那样做。
覆盖的方法有它们自己的访问修饰符，所以子类可以改变超类方法的访问修饰符，但是只
限于提供更多的访问权限。在超类中被声明为protected 的方法可以被重新声明为protec ted(通常是这样做的),也可以被声明为public,但是不能被声明为private 或包访问权限。
如果一个方法的访问权限较之在超类中的访问权限有所减少，那么就违反了超类的契约，因为
这样的子类实例将不能用来替代超类实例。
覆盖的方法还可以改变其他的方法修饰符，可以随意改变 synchronized、native 和
strictfp修饰符，因为它们是与实现相关的，所有的注解也是如此(见第15章)。覆盖方法可
以是final的，但是很显然，被覆盖的方法不能是final的，查看3.6节“将方法和类标记为
final",可以了解到更多的final方法的含义。实例方法不能与继承而来的静态方法具有相
同的签名，反之亦然。然而，覆盖方法可以被声明为 abstract,即使其超类方法并非是ab stract的，请查看3.7节“抽象类与抽象方法”。
不管覆盖方法中的参数是否是final的，子类都可以修改这个参数；参数的 final修饰符
并不属于方法的签名，它只是实现的细节。另外，覆盖方法的 throws子句可以与超类方法的
有所不同，只要在覆盖方法中列出的每一个异常类型都与超类方法中列出的异常类型相同，或
是其子类型即可。也就是说，覆盖方法的 throws子句中抛出的每一种类型都必须与超类方法
的 throws子句所列出的至少一种类型是多态兼容的，这意味着覆盖方法的 throws子句列出
的类型可以少于超类方法所列出的类型的数量，或是比超类方法所列出的类型更具体，或者两
者兼有。覆盖方法甚至还可以没有任何 throws子句，那表示它不会产生任何检查型异常。异
常和 throws子句将在第12章中详细叙述。
3.3.2 隐藏字段
字段不可以被覆盖而只能被隐藏。如果你在类中声明了一个与超类中的某个字段同名的字段
(无论它是什么类型的),那么虽然超类的字段仍然存在，但是用它的简单名已经无法直接访问它
了，必须使用 super 或超类类型的另一个引用来访问它。在下一节中，我们将给出一个示例。
3.3.3 访问继承的成员
当一个方法访问某个已经被子类重定义过的对象成员时，这个方法将会引用哪个成员呢?
是子类成员还是超类成员?答案取决于成员的类型、可访问性以及引用它的方式。
当通过对象引用来调用方法时，具体要使用方法的哪种实现是由对象实际对应的类来决定
的。在访问字段时，会用到引用的声明类型。下面这个例子将有助于解释上述规则：
class SuperShow { public String str="SuperStr";
public void show(){
System.out.println("Super.show:"+str); }
}
1.在JDK 5.0版本中，javac编译器在两种情况下都发出一条(在某种程度上有些误导的)警告信息，所以我们期
望对序列进行转换时产生的警告可以被移除，因此在将来的版本中将序列转换为数组可能会被认为是一个
错误。
85
86
87
58 第3章 类的扩展
class ExtendShow extends SuperShow {
public String str= "ExtendStr";
public void show(){
System.out.println("Extend.show:"+str); }
public static void main(String[] args){
ExtendShow ext = new ExtendShow();
SuperShow sup= ext;
sup.showO);
ext.show();
System.out.println("sup.str="+ sup.str);
System.out.println("ext.str ="+ ext.str);
}
}
这里只有一个对象，但是我们让两个变量引用了它，其中一个变量的类型是Supershow(超
类),另一个变量的类型是Extendedshow(实际的类)。以下是运行该示例时得到的输出结果：
Extend.show:ExtendStr
Extend.show:ExtendStr
sup.str= SuperStr
ext.str = ExtendStr
对于 show方法，其行为正如所预料的：具体应调用 show方法的哪个版本是由对象的实际类而
不是由引用的类型决定的。当拥有一个 Extendshow 对象时，对show的调用总是会调用到 Ex tendshow的 show方法上，即使通过被声明为 SuperShow类型的引用来访问也是如此。无论
是从类的内部通过调用 Extendshow或 Supershow的另一个方法来调用 show方法(就像本例
所示),还是从类的外部调用它，情况都会如此。
对于 str字段，具体应访问哪个类的字段是由引用的类型决
定的，不是由对象的实际类决定的。实际上，每一个Extendshow
对象都有两个String类型的字段，它们都称作 str,其中一个来
自超类的str字段被 Extendshow自己的称作 str的另一个不同
的字段隐藏了，如图3-2所示。到底访问哪一个字段是在编译期基
于用来访问它的引用的类型确定的。
Object
ExtendShow
str= "ExtendStr"
在一个方法内部，比如 show,对一个字段的引用总是会引用 图 3-2
到在声明这个方法的类中所声明的字段上，如果在这个类中没有
任何有关这个字段的声明，那么它会引用到继承的字段上。因此，在Supershow.show中，对
str的引用是在引用 Supershow.str,而Extendshow.show对str的引用是在引用Extend Show.str。
前面已经看到，方法覆盖使我们可以通过重用现有的代码，用具有扩充的特化功能的对象
对这些代码进行扩展，而这些功能是最初的代码编写者无法预见的。但是对于字段，很难想象
出有什么情况下需要隐藏它们。
如果一个现有方法具有一个 Supershow类型的参数，并且通过该对象的引用访问了str,
那么它获取的将总是Supershow.str,即使该方法实际上是传给 Extendshow类型的对象的。
如果将类设计成以方法而不是字段来获取字符串，那么在这种情况下，调用的将是覆盖方法，
这样就可以返回Extendshow.str了。这种隐藏行为通常是为什么要选择另一种设计方式—
3.3 继承与重定义成员 59
将类定义为包含只能通过方法访问的私有数据——的理由，因为这些公有数据将被覆盖，而不
会被隐藏。
隐藏字段是Java语言所允许的，因为这样做可以使现有的超类实现者能够在不破坏子类的
情况下自由地向超类中添加新的public字段或 protected字段。如果语言禁止在超类和子类
中使用相同的字段名，那么向现有的超类中添加新字段的做法就可能会破坏所有已经使用了这
些名字的子类。
如果向现有的超类中添加新字段时，我们不知道有多少个子类会被破坏，我们就会无所适
从，无法向超类中添加 public字段或 protected字段。纯粹主义者可能会强烈建议类应该只
有private 数据，但是我们并没有这样做，我们可以决定自己的风格。
3.3.4 可访问性与覆盖
一个方法只有当它可以被访问时才可以被覆盖。如果方法是不可访问的，那么它就不能被
继承，而如果它不能被继承，自然也就不能被覆盖。例如，一个private方法在它自己的类的
外部是不可访问的。如果子类定义了一个方法，碰巧其签名和返回类型与超类的某个私有方法
相同，那么它们之间是毫无关系的，也就是说子类的方法并没有覆盖超类的方法。
这在实践中意味着什么呢?子类方法的外部调用(假设它是可以在类的外部被访问到的)
将导致该方法的子类实现被调用，这种行为是正常的。但是请注意，在超类中，任何对私有方
法的调用都将导致该方法的超类实现被调用，而不是与任何名字相像的子类方法。简言之，对
私有方法的调用总是会调用当前类中所声明的方法实现。
当由于超类和子类位于不同的包中而导致某个方法不可访问时，情况会更复杂，我们将在
第18章做进一步讨论。
3.3.5 隐藏静态成员
类中的静态成员(无论是字段还是方法)不可以被覆盖，它们只能被隐藏。事实上，隐藏它
们并不会造成什么影响，但是此时每一个静态字段或方法都必须通过声明它们的类的名字来访
问，因此，它们被子类中的声明所隐藏这一事实并不会产生什么不良后果。如果用引用来访问
静态成员，那么就如同实例字段一样，要由引用的声明来确定所访问的到底是哪一个静态成员，
而并非由它所引用的对象的类型而确定。
3.3.6 super关键字
在类的所有非静态方法中都可以使用 super 关键字。在字段访问和方法调用中，super起
到了一个引用的作用，它将当前对象引用为其超类的一个实例。只有在使用 super的情况下，
方法实现的选择权才是由引用类型来掌控的。对 super.method的调用总是会使用超类定义的
(或继承的)method实现，它不使用在类层次结构中位于更深层次的该方法的覆盖实现。下面
是一个使用super的例子：
class Base {
/** return the class name */
protected String name(){ return "Base";
}
}
88
89
90
60 第3章 类的扩展
class More extends Base {
protected String name(){
return "More";
}
protected void printName(){
Base sref=(Base)this;
System.out.print1n("this.name()= "+ this.name());
System.out.println("sref.name()="+ sref.name());
System.out.print1n("super.name()="+ super.name());
}
}
虽然 sref和 super都使用类型 Base引用到了同一个对象，但是只有 super会忽略对象的真
正类而使用超类的name实现。sref引用与 this的行为相同，它会基于对象的实际类来选择
name的实现。下面是printName的输出：
this.name()= More
sref.name() = More
super.name()= Base
3.4 类型兼容与转换
Java编程语言是强类型的，这意味着在绝大多数情况下，它要在编译期检查类型的兼容性，
通过禁止任何有问题的代码来防止不兼容的赋值。既然我们已经了解了由子类和超类定义的基
本的类型关系，那么我们重温一下有关(显式的或隐式的)赋值中引用类型的兼容性和类型间转
换的一些细节。有关引用类型与基本类型的转换应该如何应用以及何时应用的全部规则，将在
9.4节“类型转换”中讨论。
3.4.1 兼容性
当把一个表达式的值赋给一个变量时，无论是作为初始器或赋值语句的一部分，还是隐式
地将某个引元的值赋给一个方法参数，该表达式的类型都必须与变量的类型相兼容。对于引用
类型来说，这意味着表达式的类型必须与变量声明的类型相同，或是其子类型，或是可以被转
换为这种类型的类型。例如，任何希望接受Attr 对象作为参数的方法都可以接受 ColorAttr
对象，因为ColorAttr是Attr 对象的子类型，这称作赋值兼容(assignment compatibility)1。但
是反过来不行，不能将 Attr对象赋值给ColorAttr类型的变量，或是将 Attr 对象当作引元
传递给期望得到ColorAttr对象的方法。
同样的规则也适用于方法内部的 return语句中所使用的表达式，表达式的类型必须与该
方法声明的返回类型是赋值兼容的。
nul1对象引用是一种特殊情况，因为它与包括数组类型在内的所有引用类型都是赋值兼
容的，即任何一个引用类型的变量都可以被赋值为nul1。
在类型层次结构中，较高层次的类型与较低层次的类型相比，我们说它更宽泛或更不具体，
而较低层次的类型与其超类型相比，我们说它更精确或更具体。当期望得到的是超类型，而接
收到的却是子类型时，就会发生拓宽转换(wideningconversion)。这种转换使得子类对象将被当
1.直接赋值与参数传递之间存在着细微的区别，具体讨论见9.4.1节。
3.4 类型兼容与转换 61
作超类实例来处理，在编译期会对这种转换进行检查，在拓宽转换时程序员不需要做什么。而
另一方面，如果得到的是一个对超类型的引用，并将其转换成了一个对子类型的引用，那么这
种转换就称作窄化转换(narrowing conversion)。窄化转换必须显式地使用强制转换(cast)操作
符。
基本类型的变量或表达式可以通过使用与该基本类型相对应的包装器类的实例将其自动地
转换为引用类型，比如 int值可以转换成Integer 对象。反过来，包装器类的引用类型也可以
转换成所包装的基本类型的值。这些基本类型到其包装器类型的转换称作装箱转换(boxing
conversion),将在第8章讨论。装箱转换的存在意味着object类型的变量可以被赋值给任何用
Java编程语言编写的表达式。
给定上下文(赋值、引元传递、操作数等)中的表达式的类型兼容性将根据其上下文的不同
受到不同的人为或自动的类型转换的影响。拓宽转换与装箱转换就是在某些上下文中会自动应
用的例子。现有的各种类型转换以及它们所应用的环境将在9.4节的“类型转换”中讨论。如果
一个表达式要求进行多重转换，或是没有任何可应用的自动转换(比如窄化转换中的情况),那
么就必须使用强制转换操作符告诉编译器应该应用什么样的转换。
3.4.2 显式的类型强制转换
强制转换用于告诉编译器某个表达式应该被当作具有该强制转型操作所指定的类型来处
理，并且当强制转换作用于基本类型时，它还可以影响到表达式的值。强制转换由作用于表达
式的一对圆括号以及位于这对括号中的类型名组成。在前一个例子中我们在printName方法
里使用了一个拓宽转换，用来将 this强制转换为它的超类类型：
Base sref =(Base)this;
这个转换并不是必需的，但是它强调了我们确实想让当前对象被当作是它的超类的一个实例来
处理。如果我们试着将 sref赋值回更精确的More类型引用，那么显式强制转换就是必需的
了：
More mref=(More)sref;
即使我们知道这个被引用的对象具有正确的类型，编译器也仍然要求进行显式强制转换。
拓宽转换也称作向上强制转换(upcast),因为它将一个类型转换成了继承层次结构中的更
高层的类型，它还可以称作安全强制转换(safe cast),因为它总是有效的。窄化转换通常称作向
下转换(downcast),因为它将一个类型转换成了继承层次结构中的更低层的类型、它还可以称
作不安全强制转换(unsafe cast),因为它有时可能会无效。
当用强制转换来请求进行类型转换时，编译器并不假定该转换是正确的。如果编译器认为
该强制转换是正确的，那么就会应用该操作。如果编译器认为该转换不正确，那么就会产生一
个编译期错误。如果编译器不能在编译期确定该强制转换是否正确，就会执行一个运行时检
查。如果由于强制转换不正确而导致该运行时检查失败，就会抛出一个ClassCastException
异常。
3.4.3 类型检测
我们可以使用instanceof操作符来检测一个对象所属的类，当该操作符左边的表达式是
一个与其右边的类型名赋值兼容的引用类型时，该测试就会返回 true.否则将返回false。因
为null不是任何类型的实例，所以当instanceof作用于 nul1时将总是返回 false。通过使
用instanceof,可以安全地将一个引用向下强制转换而不会抛出任何异常，例如：
91
92
93
62 第3章 类的扩展
if(sref instanceof More)
mref =(More)sref;
请注意，我们仍然需要应用强制转换，这样做是为了使编译器确信我们确实想要将这个对象作
为一个其子类的实例来使用。
如果某个方法并不要求对象具有扩展层次更深的类型，但是却被传入了这样的对象，那么
使用instanceof进行类型检测就非常有用了，因为这样可以利用该对象扩展出来的功能。例
如，sort方法可能会接受一个泛化的List类型的对象作为其引元去进行排序，但是如果它实
际接收到的是一个 SortedList,那么它就不必做任何事，因为这个对象已经排过序了：
public static void sort(List list){
if(list instanceof SortedList)
return;
// else sort the list ...
}
3.5 protected 的真正含义
我们曾经简要地描述过，使一个类成员成为protected 意味着它可以被扩展这个类的类所
访问，但是这句话并不准确。更准确地讲，一个受保护的成员除了可以被类自身以及与其在同
一个包(见第18章)中的代码访问之外，它还可以在一个类中通过对象引用来访问，这些对象引
用至少应该具有与该成员所在的类相同的类型，也就是说，这些引用具有该成员所在类的类型
或者是其某一子类型。通过下面的例子可以更容易地理解它。
考虑一个队列的链表实现：SingleLinkQueue类，它拥有 add和 remove方法，分别用来
将一个对象存储到队尾和从队首上移除一个对象。队列的节点是由 Cel1对象构成的，它们拥
有一个指向队列中下一个cel1 对象的引用和一个指向当前 Cel7 对象中所存储的对象的引用。
class Cell {
private Cel1 next;
private Object element;
public Cel1(Object element){ this.element = element;
}
public Cel1(Object element,Cell next){
this.element = element;
this.next = next;
}
public Object getElement(){
return element;
}
public void setElement(Object element){ this.element =element;
}
public Cel1 getNext(){
return next;
}
public void setNext(Cell next){
this.next = next;
}
}
3.5 protected的真正含义 63
而队列是由对队首单元和队尾单元的引用以及 add和 remove 的实现构成的。
public class SingleLinkQueue {
protected Cel1 head;
protected Cel1 tail;
public void add(Object item){/* ...*/}
public Object remove(){/* ...*/}
}
我们将 head和 tail引用声明为protected的，这样扩展类就可以直接操纵链表的单元，
而不必使用 add和remove方法，否则每次调用这些方法都要涉及元素的包装和解包。
现在有一个开发组决定需要一个优先级队列，该队列中的项是以某种指定的顺序存储的，
而不是总是插入到队尾。因此，这个组在另一个包内定义了一个PriorityQueue类，它扩展了
singleLinkQueue,并且为了能将对象插入到正确的位置，它还覆盖了add 方法。Priori tyQueue类的 add 方法的实现可以访问从 SingleLinkQueue 继承而来的 head和 tail字段，
因为这个实现的代码位于 SingleLinkQueue的一个子类中，所以它所使用的对象引用(this)
的类型与该子类相同，也是PriorityQueue,因此它可以访问 protected 成员，而这正是你所
期望的。
这个小组在设计优先级队列的时候需要一个额外的特性，即它希望能够将两个优先级队列
合并在一起。在合并操作中，目标队列最终将拥有两个队列的所有元素，而被合并的队列将被
清空。merge 操作的开头就像下面这样：
public void merge(PriorityQueue q){
Cell first = g.head;
// ...
}
我们并没有访问当前对象的protected成员，而是访问了一个作为引元传递进来的对象的
protected成员。这是允许的，因为想要进行访问的类是PriorityQueue,而引用q的类型也
是PriorityQueue。即使q是PriorityQueue的子类，这种访问也是有效的。
不久，这个组确定了一个新的需求：希望能够把 singleLinkQueue和PriorityQueue合
并起来。因此这个组定义了一个merge的重载版本，其开头就像下面这样：
public void merge(SingleLinkQueue q){
Ce1l first = g.head:
// ...
}
但这样的代码无法通过编译。
问题在于，想要访问protected 成员的类是PriorityQueue,而被访问对象的引用类型
是SingleLinkQueue。SingleLinkQueue 既不同于priorityQueue,也不是它的子类，因此
该访问是不允许的。尽管每一个priorityQueue都是一个SingleLinkQueue,但并不是每一
个SingleLinkQueue 也都是一个priorityQueue。
此种限制背后的原因在于：每一个子类都继承了超类的契约，并且以某种方式扩充了这个
契约。假设某个子类作为其扩充之后的契约的一部分，对超类的受保护的成员值设置了限制。
如果另一个不同的子类可以访问第一个子类的受保护成员，那么它就能够以可能会破坏第一个
子类的契约的方式来操纵它们，而这应该是禁止的。
任何扩展类都可以访问受保护的 static成员。如果 head是一个静态字段，那么 Priori-
94
95
96
64 第3章 类的扩展
tyQueue中的任何方法(无论是否是静态的)都可以访问它，之所以允许访问，是因为子类不可
以更改其静态成员的契约，原因是它只能隐藏这些成员，而不可以覆盖它们。因此，不存在其
他类会违反该契约的危险。
对于类所在的包内的所有代码来说，声明为protected的成员也都是可用的。如果这些不
同的队列类在同一个包内，那么不但它们可以访问彼此的 head和 tail字段，而且这个包内的
所有无关类型也都可以访问这些字段。同一个包中的类被假定为享有相当高的可信度，并且不
会违反彼此的契约(见第18章)。在列表“private、package、protected、public”中，每一个访问级别
都逐级增加了代码可访问成员的数量。
3.6 将方法与类标记为 final
将方法标记为final意味着没有扩展类可以覆盖这个方法以改变其行为，换句话说，这是
该方法的最终版本。也可以把整个类标记为final:
final class NOExtending {
//...
}
被标记为 final的类不能被任何其他的类扩展，而且 final类的所有方法本身实际上也是
final的。
final类和方法可以提高安全性。如果一个类是final的，那么没有人可以声明一个类去扩
展它，因此也就没有人可以违反它的契约。如果一个方法是final的，那么我们可以充分信赖
它的实现细节(当然除非它调用了非 final的方法)。例如，我们可以在 validatePassword
方法上使用final,以确保它会按照所宣称的行为去执行，而不会被覆盖为总是返回 true。或
者可以将包含这个方法的类标记为 final,使得它永远都不会被扩展从而混淆 validatePass word的实现。
将方法或类标记为 final在类的使用方法中是一种很严格的限制。如果要将一个方法标
记成 final的，那么必须确认它的行为已经是订正过的、完全没有错误的。而且将类或方法标
记成 final会限制类的灵活性，即限制了可以让其他程序员利用该类的代码作为基类并在他们
的代码中添加新功能这种灵活性。将整个类标记为 final可以阻止其他人扩展该类，但对其他
人来讲，这样做就限制了该类的可用性。如果要把所有的类或方法都标记为final,那么一定
要先确认我们确实需要设置这些限制。
在很多情况下，可以通过将一个类中的每一个方法都标记为 final来保留该类的可扩展
性，同时可以达到将整个类标记为 final所实现的安全性。在这种方式中，我们可以信赖这些
方法的行为，同时通过添加新功能而不是通过覆盖方法，仍旧可以对该类进行扩展。当然，fi nal方法所依赖的字段应该是final或private的，否则扩展类就可以通过修改这些字段来改
变其行为。
final带来的另一个好处是它简化了优化工作。当一个非 final的方法被调用时，运行时
系统会确定对象的实际类型，将方法调用绑定到该方法在这个实际类型中的正确实现上，然后
调用这个实现。但是我们可以用更少的步骤来调用一个方法，例如，如果Attr类中的 get Name方法被标记成了final,而我们又拥有一个对 Attr类型或其任何扩展类型的对象的引
用，那么就属于这类情形。在诸如 getName 这类最简单的情形中，方法调用可以被实际的方法
体所取代，这种机制称作内联(inlining)。内联方法使得下面这两条语句将以相同的方式执行：
3.7 抽象类与抽象方法65
System.out.println("id = "+ rose.name);
System.out.println("id ="+ rose.getName());
虽然这两条语句的执行效率是相等的，但是getName方法允许 name字段成为只读的，并且使
我们可以从抽象中得益，因为它允许我们修改其实现。
同样的优化还可以应用于私有方法和静态方法，因为它们也不能被覆盖。
使用 final类可以加快某些类型检查的速度。实际上，这样做是将许多类型检查都变成了
编译期检查，所以可以更早地捕获错误。如果编译器碰到了对final类的引用，它会知道这个
引用所引用的对象就是那种类型(而不是其子类型)。有关这个类的整个类层次结构都是已知
的，因此编译器可以检查出所有对这种类型的使用是有效的还是无效的。如果使用的是一个非
final引用，那么某些检查就只有在运行时才能进行。
练习3.4:将Vehicle和 PassengerVehicle类的哪些方法(如果有的话)标记为final
是合理的?
3.7 抽象类与抽象方法
面向对象编程的一个非常有用的特性就是抽象类(abstract class)的概念。通过使用抽象类，
我们可以声明只定义了部分实现的类，而让扩展类去提供其部分方法或者全部方法的具体实
现。与抽象相对的概念是具体(concrete),如果一个类只拥有具体的方法，包括从超类继承而来
的所有抽象方法的实现，那么它就是一个具体类。
如果一个类的部分行为是为某个给定类型的大多数或全部对象定义的，但是其他行为只对
特定类(而不是泛化的超类)才有意义，那么此时抽象类就显得很有用了，因此我们将这样的类
声明为 abstract,并将每一个在该类中没有实现的方法也都标记为 abstract。(如果只需要
定义一些方法，而并不需要提供其任何实现，那么也可以使用接口，在第4章会对接口进行描
述。)
例如，假设我们想要创建一个基准测试工具，为编写测试代码提供基础设施。这个类的实
现能够了解如何驱动并测量一个基准，但是它事先无法知道哪一个基准测试将会运行。大多数
abstract类都适用于这样一种设计模式：要求其他人提供类中缺少的有关专业知识的部分，
这种模式通常称作“模板方法”模式。在很多情况下，有关专业知识的方法通常是final方法的
最佳候选者，所以专业知识绝不会受到损害。在这个基准测试例子中，缺少的部分是那些需要
测试的代码。下面是这种类的大致模样：
abstract class Benchmark {
abstract void benchmark();
public final long repeat(int count){
long start = System.nanoTime();
for(int i=0;i< count;i++)
benchmark(O);
return(System.nanoTime()- start);
}
}
任何拥有abstract方法的类都必须声明为 abstract。这种冗余有助于读者快速发现这个类
是抽象的，而不用扫描整个类以查看是否有方法被声明为 abstract的。
repeat方法提供了基准测试的专业知识，它可以对基准测试的 count 次重复运行进行计
97
98
66 第3章 类的扩展
时。方法 System.nanoTime可以返回一个以纳秒为单位的时间戳(见23.1.3节)。通过用结
束时间减去开始时间，就可以得到一个花费在基准测试上的时间的近似值。如果计时需要更加
复杂的计算(可能需要测量每一次运行的时间并计算这些时间的变动统计量),那么可以改进这
个方法，但前提是不能影响任何扩展类中所特有的基准测试代码的实现。
abstract方法 benchmark 必须由每一个非抽象的子类去实现，这就是为什么在这个类中
没有它的任何实现，而仅仅只有一个声明的原因。下面是一个Benchmark 的扩展类的简单例
子：
class MethodBenchmark extends Benchmark {
/** Do nothing,just return.*/
void benchmark(){
}
public static void main(String[] args){
int count = Integer.parseInt(args[0]);
long time = new MethodBenchmark().repeat(count);
System.out.println(count+" methods in "+
time+" nanoseconds");
}
}
这个类对空方法 benchmark 的调用所花费的时间和循环的开销进行计时。现在可以用重复测试
的次数来运行 Methodbenchmark 应用，以此来对方法调用进行计时。循环次数是通过引元传
递的，并在引元字符串上使用Integer类的 parseInt方法将其转换成了int,就像13.2.5节
所描述的“字符串转换”那样。
任何一个类都可以覆盖其从超类继承来的方法，并将其声明为abstract,从而使一个具体
方法在类型树的这一点上转换成抽象方法。这个技巧很有用，例如，如果一个类的默认实现作
为类层次结构的一部分是无效的，那么就可以用这个技巧来解决这一问题。
我们不能创建抽象类的对象，因为某些可能会被调用的方法并没有任何有效的实现。
练习3.5:编写一个新的可以对其他事件进行基准测试的扩展类，比如从0循环到一个传入
的参数值需要多长时间。
练习3.6:更改 vehicle类，使其拥有一个 EnergySource 对象引用，在Vehicle对象的
构造器内关联它。其中，Energysource必须是一个抽象类，因为GaSTank 对象的满装度的测
量与Battery 对象的满装度的测量是完全不同的。要在 EnergySource 中设置一个抽象的
empty方法，并在GasTank 和 Battery类中实现它。将一个 start方法添加到 Vehicle类
中，用来确保能量源不是空的。
3.8 Object类
object类是整个类层次结构树的根，每一个类都直接或间接地扩展了Object,因此 Ob ject类型的变量可以引用任何对象，无论是类的实例还是数组。例如，Attr类可以拥有任意
类型的属性，所以它的 value字段被声明为Object类型。这样的类不可以直接持有基本类型
的值，但是可以持有与其相关的包装器类的引用，有关包装器类见第8章。
object类定义了大量的可被所有对象继承的方法，这些方法分为两类：通用方法与支持线
程的方法。线程支持将在第14章中讨论，本节主要描述那些通用方法，以及它们是如何影响每
个类的。这些通用方法包括：
3.8 Object类67
·public boolean equals(object obj):比较接收参数的对象和由obj引用的对象的等
价性，如果它们拥有相同的值则返回 true,否则返回false。如果想确定两个引用所指
向的对象是否相同，可以通过使用==或!=来比较它们。equals方法关心的是值的
等价性，Object 中的equals的默认实现测试的是this==obj的结果，即假定一个对
象仅仅与其自身等价。
·public int hashcodeO:返回该对象的散列码，每一个对象都有一个用在散列表中的
散列码。该方法的默认实现返回的是一个通常有别于其他不同对象的值，在把对象保存
到散列集合中时，就需要使用该方法，正如第21章所描述的那样。
· protected Object cloneOthrows CloneNotSupportedException:返回当前对象的
一个克隆体。克隆体是一个新的对象，它是被调用了clone方法的对象的一个副本。克
隆将在下一节中进行讨论。
· public final class<?> getclassO):返回表示该对象所属类的类型标记(type to ken)。对于每一个类T都有一个类型标记Class<T>(读作“T的类”),它是泛型类
class(将在16.1节讨论)的一个实例。当调用一个Object实例的该方法时，将返回一
个Class<Object>实例；当在一个Attr实例上调用该方法时，将返回一个Class
<Attr>实例，依此类推。
·protected void finalize()throws Throwable:在垃圾回收时终结对象。该方法将
在17.3节的“终结”中详细讨论。
· public String tostringO:返回一个该对象的字符串表示。当将对象引用作为+操
作符的操作数用于字符串的连接表达式时，该方法会隐式地调用 tostring 方法，toS tring的Object版本会构造一个字符串，其中包含对象所属的类名、一个@符号和该实
例的散列码的十六进制表示。
如果想要提供一个有别于Object类中的默认实现所提供的等价性概念，那么就应该覆盖
hashcode方法和 equals方法。在默认实现中，任何两个不同的对象都是不等价的，同时它们
的散列码通常也是不同的。
如果在我们自己的类的等价性概念中两个不同的对象可以是等价的，那么这两个对象必须
返回相同的散列码。这种散列集合所采用的机制要求在表中发现某两个键具有相同的值时，
equals方法必须返回 true。例如，在String类覆盖 equals方法时，如果两个 String 对象具
有相同的内容，那么它将返回 true。如果 String类同时还覆盖了hashcode方法，那么它将返
回一个基于String 内容的散列码，从而使得具有相同内容的两个字符串具有相同的散列码。
术语“同一性”(identity)是用来描述引用等价性的：如果两个引用是同一的，那么这两个引
用之间的==比较将返回true。而术语“等同性”(equivalence)则用来描述值的等价性，这里所
比较的两个对象可能并不是同一的，但是调用equals方法对它们进行比较有可能会返回
true。因此可以说在 equals的默认实现中，同一性和等同性是一致的。类可以把等同性的概
念定义得更广，它可以通过覆盖 equals方法，让该方法基于对象的状态而不是其引用来决定
是否返回true,从而使并非同一的对象可以是等同的。
某些散列表(比如 java.util.IdentityHashMap)关心的是对象的同一性而不是等同性，
如果我们需要编写这样的散列表，那么我们希望与对象的散列码相对应的是其同一性，而不是
其状态。方法 System.identityHashcode的返回值与object类的 hashcode实现为对象返
回的值相同，当然前提是该方法没有被覆盖。如果在要存储的对象上直接使用 hashcode方法，
那么获取的散列码可能是基于等同性的，而不是同一性的，其效率要低很多。
99
100
101
68 第3章 类的扩展
练习3.7:覆盖ColoAttr类的 equals和hashCode。
3.9 克隆对象
Object.clone方法可以帮助我们编写自己的类的克隆(clone)方法，用克隆方法将返回一
个新的对象，其初始状态与调用clone方法的对象的当前状态相同，随后对这个新的克隆对象
所做的修改应该不会对源对象的状态造成影响。
3.9.1 克隆的策略
编写clone方法要考虑到三个重要因素：
·空的Cloneable接口：为了提供一个可以用来克隆对象的clone方法，必须实现它。
·Object类实现的clone方法：它执行的是一个简单的克隆，即把源对象中的所有字段
都复制到新对象中。这个方法对许多类都适用，但是也有可能会需要有一个覆盖方法对
其进行补充。
·CloneNotSupportedExcetpion异常：它可以用来告知使用者某个类不支持clone方
法。
·一个给定的类对待clone可以有4种不同的态度：
·支持clone:这样的类实现了Cloneable接口，并且声明其clone方法不会抛出任何异
常。
·有条件地支持clone:这样的类有可能是一个集合类，原则上它是可以克隆的，但是除
非其内容是可以克隆的，否则它无法成功克隆。这种类型的类将实现Cloneable接口，
但是当它接收到从它想要克隆的其他对象中抛出的CloneNotSupportedException异
常时，将让其clone方法将该异常传递出去。有条件地支持克隆的类的另一种可能情况
是，这个类可能拥有克隆其自身的能力，但并不要求其所有子类也都要具有能够克隆的
能力。
·允许子类支持clone,但并不将其对 clone的支持暴露为公开的：这样的类并不实现
Cloneable接口，但是如果默认的clone实现并不正确，那么这样的类就会提供一个受
保护的clone实现，该实现能够正确地克隆它的字段。
·禁止clone:这样的类并不实现Cloneable接口，但是提供了一个总能抛出 CloneNot SupportedException异常的clone方法。
Object.clone将检查调用该方法的对象是否实现了Cloneable接口，并且在没有实现该
接口的情况下检查它是否会抛出CloneNotSupportedException异常。如果实现了该接口，
object.clone 将创建一个新的对象，该对象的类型与调用clone方法的源对象的类型完全相
同，然后初始化这个克隆对象的字段，使它与源对象的字段具有相同的值。当Object.clone
方法执行结束时，会返回一个新对象的引用。
创建一个可克隆类的最简单的方法是声明它实现了Cloneable接口，并且通过将 clone
方法重新声明为公共的来覆盖它：
public class MyClass extends HerClass implements Cloneable {
public MyClass clone()
1.Cloneable应该拼写为Clonable,但是当意识到这个拼写错误时已经太晚了，不能再做订正了。
3.9 克隆对象 69
throws CloneNotSupportedException {
return(MyClass) super.clone();
}
// ...
}
现在所有的其他代码都可以创建Myclass 对象的克隆体了。在这个简单的例子中，Myclass的
所有字段的值都将由Object.clone 赋值给所返回的新对象。请注意，这个覆盖实现利用了指
定协变返回类型的能力，声明它将返回的是一个Myclass 实例，而不是一个Object实例，这
样可以使调用代码不必提供强制类型转换，但是当返回的是从 super.clone()而得到的值时，
那么就必须在内部提供强制类型转换。
object的clone方法中有一个throws CloneNotSupportedException声明，这意味着
超类可以声明它是可克隆的，但是其子类可以决定该子类自身是不可克隆的，这样的子类就实
现了Cloneable接口，因为它扩展自一个实现了该接口的类，但是事实上该子类不能克隆。为
了使大家明白这一点，可以用扩展类可以覆盖clone方法，使其总是抛出CloneNotSupporte dException异常，并在文档中说明。千万要当心，这样做意味着你无法通过查看一个类是否
实现了Cloneable接口这样的运行时检查来确定一个类是否可克隆。某些不可克隆的类被强
制要求抛出异常来标明这种情形。
3.9.2 正确克隆
大多数类的对象原则上都是可克隆的，即使我们的类并不支持Cloneable接口，也应该确
保其clone方法是正确的。在许多类中，clone方法的默认实现可能是错误的，因为它只是复
制了一个不应该共享的对象的引用。在这种情况中，为了得到正确的clone方法的行为，必须
覆盖此方法，因为默认实现是将源对象中的每一个字段都赋值给目标对象中相同的字段。
例如，如果一个对象有一个数组的引用，那么该对象的克隆体将引用到相同的数组。如果
数组保存的是只读数据，这样的共享引用也许还可以正常工作。但如果数组是一个对象列表，
而这个列表的内容对于每一个对象都应该有所区别，那么我们可能并不想让克隆体对其自身的
列表所进行的操作影响到源对象的列表，反之亦然。
下面是有关上述问题的一个例子。假设有一个简单的整数栈类：
public class IntegerStack implements Cloneable {// dangerous
private int[] buffer;
private int top;
public IntegerStack(int maxContents){
buffer = new int[maxContents];
top=-1;
}
public void push(int val){
buffer[++top]= val;
pub?ic int popO){
return buffer[top--];
}
public IntegerStack clone(){
try {
102
103
104
70 第3章 类的扩展
return(IntegerStack)super.clone();
} catch(CloneNotSupportedException e){
// Cannot happen -- we support clone
throw new InternalError(e.toStringO);
}
}
// ...
}
这里我们覆盖了clone方法，使其成为了公共的，但是我们使用的仍然是其在Object类中的
默认实现。
现在让我们来看看创建Integerstack 对象的代码，将数据压进栈，然后克隆该对象：
IntegerStack first = new IntegerStack(2);
first.push(2);
first.push(9);
IntegerStack second = first.clone();
在使用了默认的clone方法之后，内存中的数据如图3-3所示：
219
buffer- first- top:1
buffer/ second— top:1
图 3-3
现在来考虑一下，如果将来某段代码调用了first.popO),那么接下来调用first.push(17)
时会发生什么情况。first中的栈顶元素将会从9变为17,这是我们所期望的。然而，程序员
可能会惊讶地发现 second的顶层元素也变成了17,因为这两个栈共享一个数组。
上述问题的解决方法是覆盖clone方法，让它复制数组的副本：
public IntegerStack clone(){
try {
IntegerStack nObj=(IntegerStack)super.clone();
nObj.buffer = buffer.clone();
return n0bj;
} catch(CloneNotSupportedException e){
// Cannot happen -- we support
// clone,and so do arrays
throw new InternalError(e.toStringO);
}
}
首先clone方法调用了super.clone,这个调用非常重要，因为超类可能需要解决它自己的共
享对象问题。如果不调用超类的方法，那么可以解决这个类自己的克隆问题，但是可能会产生
新的问题。此外，super.clone最终将调用方法Object.clone,将创建一个具有正确类型的
对象。如果Integerstack的clone方法实现使用new创建Integerstack 对象，那么对于任
何扩展自Integerstack的对象来说，这都将是不正确的，因为扩展类中的 super.clone 调用
给出的是一个Integerstack 对象，而不是一个具有正确扩展类型的对象。随后，super.
clone的返回值被转换成了Integerstack引用。
3.9 克隆对象71
Object.clone对新的克隆对象的每一个字段都进行了初始化，将被克隆的对象中与其相
同的字段的值赋给了它们。因而我们只需编写专门的代码，用以处理那些直接对其进行值复制
之后，产生了错误的字段。Integerstack.clone方法并不需要复制 top字段，因为它已经在
默认的“值复制”中被正确地处理了。但是必须创建一个buffer数组的副本，可以通过克隆该
数组来实现——所有的数组都是可克隆的，clone方法将返回一个与调用clone方法的数组引
用具有相同类型的引用。
在用专门的clone方法进行替换之后，该示例代码在内存中创建的数据如图3-4所示：
29
first—→ buffer top:1 29
buffer second- top:1
图 3-4
克隆是一种可选择的构造形式，但是系统并不会将其识别为构造，这意味着我们必须警惕
地使用只能在构造器中设置其值的空白 final(请查看2.2.3节)。如果final字段的值应该是正
在被克隆的对象中的某个值的副本，那么就不会有任何问题，因为Object.clone 将实现这一
目标。但是如果值复制并不适用于这个字段，那么它就不能声明为是final的。在上面这个例
子中，buffer数组在对象生命周期内是不变的，但是它不能声明为是final的，因为它的值需
要在clone方法中进行显式的设置。
如果一个不应该在克隆体和源对象之间共享的对象不是数组，那么这个对象就应该以某种
方式支持复制。这意味着该对象可能自身支持 clone,或者它有一个可以用来创建复制对象的
复制构造器。比如说，String类并不支持 clone方法，但是它有一个复制构造器可以创建新
的 String 对象，并且其内容与传递给构造器的 String相同。有关何时编写复制构造器的问
题与何时编写clone方法的问题是相同的——你必须做出选择，即何时一个简单的字段复制就
足够了，而何时需要更加具体的行为。复制构造器的一个好处是它可以处理 final类型的字
段，而clone却做不到。
有时并不值得为了使clone正确地工作而费神，而且有些类并不应该支持 clone。在这种
情况下，应该定义一个会抛出CloneNotsupportedException异常的clone方法，这样使用
clone方法的受信任的子类就不会创建出具有不良状态的对象。
我们可以声明所有的子类必须通过覆盖超类中的 clone方法来正确地支持 clone,而这些
覆盖方法应该去掉关于抛出CloneNotSupportedException异常的声明。实现 clone方法的
子类不能抛出CloneNotSupportedException异常，因为我们不能向覆盖了超类方法的子类
方法中添加异常。同样地，如果我们使某个类的 clone方法成为公共的，那么所有从这个类中
扩展出来的子类就都必须具有公共的clone方法，因为子类不能让一个方法的可视性少于它在
超类中的可视性。
3.9.3 浅克隆与深克隆
默认的克隆实现所提供的克隆称作浅克隆(shallow clone)或浅复制(shallow copy),即执行
的仅仅是逐个字段的复制。深克隆(deep clone)将会克隆每一个字段所引用的对象和数组中的
105
72 第3章 类的扩展
每一项，这将产生递归，因此对一个对象进行深克隆将会克隆从该对象可达的所有对象。通常，
无论浅克隆是否恰当，clone方法都会被覆盖以执行深拷贝，正如在IntegerStack 示例中所
描述的那样。
对象序列化机制(请查看20.8节)允许我们将一个完整的对象图写到字节流中，并通过使
106 用这样生成的字节流创建出一个与源对象图等价的副本。与Object.clone相比，序列化提供
了一种可以创建更深层副本的方式。
练习3.8:使Vehicle和PassengerVehicle成为Cloneable类型。这些类应该采取上
述4种态度中的哪一种?对于这些类的克隆方法来说，用object.clone 实现简单复制是否正
确?
练习3.9:编写一个Garage类，令对象用数组来保存一定数量的 Vehicle对象。使Gar age 成为一个Cloneable类型，并为其编写一个合适的clone方法。最后编写一个 Garage.
main方法来测试它。
练习3.10:使LinkedList类(来自第2章练习)成为可克隆的，即令其clone方法返回一
个新的列表，引用与原列表相同的值，而不是克隆这些值。换句话说，对一个列表的修改不应
该影响到另一个列表，但是对列表所引用的对象的修改应该对两个列表都可视。
3.10 扩展类：如何扩展以及何时扩展
编写扩展类的能力是面向对象编程中的一个相当重要的好处。当我们为了添加新功能而扩
展类时，实际上就创建了一个通常称作“IsA”(是一个)关系，即这种扩展创建了一种新的对象，
它“是一”种源类。IsA关系与HasA关系完全不同，在“HasA”(有一个)关系中，一个对象用另
一个对象来存储状态或执行操作，即该对象“有一个”对另一个对象的引用。
让我们看一个例子。设想有一个Point类，它用(x,y)对来表示二维空间中的一个点。我
们可以扩展这个类，比方说创建一个表示屏幕上的彩色像素点的 Pixel类。一个Pixe]“是一
个”(IsA)Point:对一个简单的 Point来说是正确的事物对一个Pixel来说也是正确的。虽然
Pixel类可能会添加表示像素颜色的机制，也可能会添加一个绘制该像素的屏幕对象的引用，
但是由于二维空间中(即显示平面中)的点具有扩展的契约(包括颜色和所在的屏幕),所以一
个Pixel就是一个Point。
107
另一方面，一个圆并不是一个点。尽管一个圆可以用一个点和一个半径来描述，但是点还
有一些任何圆都不具有的用处。例如，如果我们有一个方法可以将一个矩形的中心放在某个特
定点上，那么传入一个圆真的会有意义吗?一个圆“有一个”(HasA)中心，该中心“是一个”点，
但是一个圆并“不是一个”(IsNotA)带有半径的点，因此它不应该成为Point的子类。
正确的选择经常并不那么明显，而且不同的选择是否正确将取决于应用。最终，应用必须
能够运行并且具有实际意义。
正确选择“有一个”关系和“是一个”关系既是微妙的又可能是至关重要的。例如，在使用
面向对象工具来设计雇员数据库时，一种显而易见的普遍方式就是使用一个具有所有人共享属
性(比如名字与雇员工号)的 Employee类，并将其扩展为特定类型的雇员，例如 Manager、En gineer或 Fileclerk。
这样的设计在实际应用中是行不通的，因为一个人常常同时扮演着多个角色。例如，某位
工程师可能同时还是某个小组的代理经理，现在他就必须以这两种身份同时出现。又例如，助
3.11 设计一个可扩展的类 73
教经常即是学生又是大学的员工。
更具灵活性的设计则是创建一个Role类，然后通过扩展它去为诸如 Manager这样的角色
创建相应的类。随后你可以更改 Employee类的设计，使其拥有一个Role对象集。一个人现
在就可以与组织中任何可变的角色集关联起来了。我们已经从认为一个经理“是一个”雇员转
变成了认为一个经理“是一个”角色，并且一个雇员除了可以“有一个”经理的角色，同时还可以
有其他的角色。
如果最初作出的选择是错误的，那么修改已部署系统就会有困难，因为这样的修改需要对
代码进行伤筋动骨的替换。例如，在第一个雇员数据库的设计中的方法无疑是依赖于这样一个
事实，即Manager 对象可以被当作 Employee对象来使用。如果我们不得不修改成基于角色的
设计，那么这个事实就不存在了，并且所有原来的代码都将崩溃。
3.11 设计一个可扩展的类
Attr类是一个设计良好的类的示例，它遵循了第2章中讲到的设计原则。这个类的字段都
是私有的，并且只能通过访问器方法来访问它们，因此可以保护它们免遭违反该类契约的修改
所造成的危险。Attr类为该类的用户提供了一个整洁的接口，同时也将类自身从那些使用它
的类中分离出来，使得它自己的实现可以在将来进行修改。
假如 ColorAttr扩展了Attr,那么我们是否应该重新设计Attr 以使其更适合被扩展呢?
为了让子类可以直接访问 name字段和 value字段，是否应该将它们声明为 protected,而不
是private呢?做出这样的决定需要在利弊之间进行仔细的思考和权衡。将Attr类的字段声
明为 protected并不会使子类受益，因为所有可以在这些字段上执行的动作都可以通过Attr
类所提供的 public方法实现。另一方面，将这些字段声明为protected可以阻止任何将来对
Attr类实现的修改，因为子类将依赖于这些字段和它们所具有的类型，而且能够直接访问它
们。因此在本例中，Attr的当前设计是适用于扩展和一般用途的。
在我们的链表队列类 SingleLinkQueue中，我们将 head字段和 tail字段声明成了pro tected的。在那个例子中，允许子类直接访问链表的表元(cell)在性能方面会有很大程度的提
高，如果可用的工具仅仅只是源类中的 add方法和 remove方法，那么在PriorityQueue中实
现 add的覆盖将是不切实际的。SinqleLinkQueue类处于较低层次这一性质同时也意味着我
们并不关心是否要锁住其实现细节，因为它毕竟是队列的链表实现，并没有真正留下多少可供
修改的空间。如果我们编写的更通用的队列类只是碰巧使用了链表实现，那么就又是另外一回
事了。
非 final的类有两个接口，其中公有接口是为使用该类的程序员提供的，而受保护接口则是
为扩展该类的程序员提供的。不要随意将该类的字段声明成受保护的，因为这两个接口都是真
正的契约，因此应该精心设计。
设计一个可扩展的框架
假设我们想要提供一个用来比较各种不同排序算法的基准测试工具。对所有的排序算法进
行的基准测试必须具备以下特性：它们都有必须操作的数据；这些数据必须支持某种排序机制：
并且实现排序所需的比较与交换的次数是基准测试中的重要评价因素。
我们可以编写一个抽象类来帮助实现这些特性，但是我们无法编写出一个通用的 sort方
法，因为排序的实际操作取决于每一个扩展类。下面是一个 SortDouble类，它可以对 double
108
109
110
74 第3章 类的扩展
类型的数组进行排序，并将所需的交换、比较和测试的次数跟踪记录到我们稍后定义的 Sort Metrics类中：
abstract class SortDouble {
private double[] values; private final SortMetrics curMetrics = new SortMetricsO;
/** Invoked to do the fu11 sort */
public final SortMetrics sort(double[] data){
values= data;
curMetrics.init(;
doSort();
return getMetricsO);
}
public final SortMetrics getMetrics(){
return curMetrics.clone();
}
/** For extended classes to know the number of elements*/
protected final int getDataLength(){
return values.1ength;
}
/** For extended classes to probe elements */
protected final double probe(int i){
curMetrics.probeCnt++;
return values[i];
}
/** For extended classes to compare elements */
protected final int compare(int i,int j){
curMetrics.compareCnt++;
double d1 = values[i];
double d2= values[j];
if(d1== d2)
return 0;
else
return(d1<d2?-1:1);
}
/** For extended classes to swap elements */
protected final void swap(int i,int j){
curMetrics.swapCnt++;
double tmp = values[i];
values[i]= values[j];
values[j]= tmp;
}
/** Extended classes implement this -- used by sort */
protected abstract void doSort();
}
3.11 设计一个可扩展的类75
这个类定义了一些字段，用来保存将要排序的数组(values)和用来跟踪所测操作的测量值对
象(curMetrics)的引用。为了确保这些计数是正确的，SortDouble提供了一些例行方法，当
扩展的排序类需要检查数据或执行比较和交换时，可以使用这些方法。
在我们设计类时，可以决定是否要信任它的扩展类。SortDouble类被设计为不信任其扩
展类，这通常是设计被扩展类的最佳方式。谨慎的设计不仅要能够避免恶意用法，还要能够避
免程序缺陷(bug)。
SortDouble仔细地把对每一个成员的访问权限都限制到了适当的级别，它在其所有非抽
象方法上都使用了fina1,这些因素都是SortDouble类的契约的一部分，包括保护对排序算
法的测量使其免遭篡改。将方法声明为 final即能确保没有扩展类能够覆盖这些方法以改变
其行为，也能尽可能地提高编译器和运行时系统的效率。
SortMetrics 对象描述了一个特定排序的运行开销。这个类有三个公共的字段，它唯一的
任务就是传递数据，因此并不需要将这些数据隐藏到访问器方法中。SortDouble.getMet ricts会返回这些数据的一个副本，所以它就不用给出它的内部数据引用，这样即阻止了创建
SortDouble的代码修改这些数据，也阻止了其扩展类中的代码修改这些数据。下面是Sort Metrics类的代码：
final class SortMetrics implements Cloneable {
public long probeCnt, // simple data probes
// comparing two elements compareCnt,
// swapping two elements swapCnt;
public void init(){
probeCnt = swapCnt = compareCnt =0;
}
public String toString(){
return probeCnt +" probes "+ compareCnt +" compares "+
swapCnt +" swaps";
}
/** This class supports clone */
public SortMetrics clone(){
try {
// default mechanism works
return(SortMetrics)super.clone();
} catch(CloneNotSupportedException e){
// can't happen:this and Object both clone
throw new InternalError(e.toString(O);
}
}
}
下面这个类扩展了SortDouble。SimplesortDouble类实现的 dosort方法采用的排序
算法(“选择排序”)虽然非常慢，但却很简单，其主要优点是编码简单且容易理解：
class SimpleSortDouble extends SortDouble{
protected void doSort(){
for(int i=0;i<getDataLength();i++){
for(int j=i+1;j<getDataLengthO);j++){
111
112
76 第3章 类的扩展
if(compare(i,j)>0)
swap(i,j);
}
}
}
}
现在我们可以编写一个排序算法的测试工具了，只需对它稍做修改就可以用来测试新的算
法。下面给出的就是这个工具的代码，它就像是一个测试 SimplesortDouble类的驱动程序：
public class TestSort {
static double[] testData={
0.3,1.3e-2,7.9,3.17
};
public static void main(String[] args){
SortDouble bsort = new SimpleSortDouble();
SortMetrics metrics = bsort.sort(testData);
System.out.println("Metrics:"+ metrics);
for(int i=0;i<testData.1ength; i++)
System.out.print1n("\t"+ testData[i]); }
}
main方法显示了驱动测试的代码是如何工作的：它创建了一个扩展自 SortDouble的类的对
象，向其提供了用于排序的数据，然后调用了sort方法。而sort方法则存储数据，初始化测
量值，然后调用了抽象方法dosort。每一个扩展类都将 dosort方法实现为执行自己的排序，
在需要时会调用getDataLength、compare和swap方法。在dosort 返回时，计数值反映了每
一个操作执行的次数。为了测试不同的算法，我们可以直接修改 new后面的类名，下面给出的
是TestSort的一次运行结果：
Metrics:0 probes 6 compares 2 swaps
0.013
0.3
3.17
7.9
现在通过这些例子中的类，让我们回到设计一个将被扩展的类这一话题上。为了能让扩展
类更好地访问 SortDouble类对象中的数据，我们仔细设计了 SortDouble的受保护的接口，
但这些数据仅仅只是那些我们希望它们去操纵的数据。在该类的这个设计中，可以根据具体情
况来选择每一个部分的访问权限：
·公共的：类的public部分是为那些测试排序算法开销的代码所设计的。TestSort.
main就是一个测试代码的例子，这段代码提供了用于排序的数据，并且获得了测试的结
果。对于测试代码而言，测量值是只读的。我们为测试代码所提供的公共的 sort方法
可以确保测量值在使用前是初始化过的。
通过将实际的 dosort方法声明为protected的，可以强制测试代码必须通过公共
的 sort方法去间接地调用它，这样，我们可以保证测量值总是会初始化，因此也就避免
了另外一种可能的错误。
对测试代码而言，该类唯一可用的功能就是驱动一个特定排序算法的测试并给出结
果。我们使用方法和访问权限保护隐藏了该类的其余部分，这些部分都是不应该暴露给
测试代码的。
3.12 单重继承与多重继承77
●受保护的：类的protected部分是为那些排序代码所设计的，以产生正确的测量的排
序。protected契约使得排序算法可以通过该排序希望使用的任何方式去检查并修改数
据，以产生一个有序列表。它还为排序算法提供了一个上下文环境，在这个上下文环境
中，该算法可以正确地驱动，从而使其可以被测量。这个上下文环境就是dosort方法。
扩展类被认为是不可信赖的，这就是为什么它只能通过具有数据访问权限的方法间
接地访问这些数据。例如，为了通过避免调用compare方法来隐藏一个比较操作，排序
将不得不使用probe来找出数组中的元素。由于probe的调用也是可以测量的，所以这
种做法最终也没能隐藏任何操作。
另外，getMetrics方法返回的是实际测量值对象的克隆体，因此排序的具体实现
不能修改这些值。
·私有的：类将其自身应该对外部隐藏的数据声明为私有的，这些数据是待排序的数据和
测量值。外部代码不能访问这些字段，无论是直接的还是间接的。
回顾一下，为了避免有意的欺骗和无意的误操作，SortDouble被设计为不信任它的扩展
类。例如，如果将 SortDouble.values(要排序的数组)声明为protected而不是private,
我们就可以去除掉probe方法，因为排序算法常常只对比较和交换的次数进行计数。但是如果
我们真的可以去除掉它，那么编写扩展类的程序员就可以避免使用 swap 交换数据。然而这样
做所得到的测量结果将会是无效的，而且可能很难引起人们的注意。对探测次数进行计数并将
这个数组声明为private可以杜绝某些程序缺陷，同时有意绕开测试的编程方式。
如果我们设计的类不是用来扩展的，那么它的子类很可能会误用它。如果这个类拥有子
类，那么我们必须仔细地设计其受保护的部分，而如果其扩展类并不需要任何特殊的访问权限，
那么最终的设计结果可能是该类没有任何受保护的成员。如果在类中没有设计任何受保护的部
分，那么该类就应该没有任何受保护的成员，而子类将依赖该类的公共契约。
练习3.11:至少找出一个SortDouble类中的安全漏洞，使排序算法可以在测量值上弄假
而不被发现。订正这个安全漏洞，假设该排序算法的作者并未编写 main方法。
练习3.12:编写一个通用的能对任意对象类型进行排序的 SortHarness类。我们如何才
能提供一种用通用方法表示的对象顺序呢?假设我们不能使用<来比较它们。
3.12 单重继承与多重继承
一个新类可以只扩展一个超类，这种模型称作单重继承(single inheritance)。扩展类意味着
新类不仅继承了超类的契约，而且还继承了超类的实现。有些面向对象语言提供了多重继承
(multiple inheritance),使得新类可以继承两个或更多的超类。
当我们想要一个新类结合多个契约并继承这些契约的某些或全部实现时，多 W
重继承就非常有用了。但是当超类有多个时，就会产生超类的行为会以两种方式
X 被继承这一问题。假设在某一时刻，类型树如图3-5所示： Y
这种情况通常称作菱形继承(diamond inheritance),它并没有任何错误。很多合法 Z
的设计所显示出来的也都是这样的结构。但是当W的实现存储了某个状态时，在
图 3-5 对实现的继承上就会产生问题。例如，如果类W有一个名为goggin的公共字段，
并且我们有一个叫作 zref的Z类型对象的引用，那么zref.goggin将引用哪个字段?它可能
会引用X的goggin副本，也可能会引用Y的goggin副本，或者X和Y可能会享goggin的一
个单一副本，因为实际上Z仅仅是W,尽管它同时还是X和Y。解决这样的问题并非易事，并且
还会使对类层次结构的设计和使用复杂化。为了避免这样的问题，Java 编程语言使用了面向对
113
114
115
78 第3章 类的扩展
象编程中的单重继承模型。
单重继承会排斥某些有用的正确设计。多重继承的问题源自实现的多重继承，但是在很多
情况下，多重继承可以用来继承一系列的抽象契约，其中有可能还继承了一个具体实现。如果
能够提供某种方式，使得可以在不继承实现的情况下继承抽象契约，那么就可以获得多重继承
的类型优点，并且不会产生多重实现继承的诸多问题。有关抽象契约继承的术语称作接口继承
(interface inheritance)。Java编程语言支持接口继承，允许我们声明 interface类型，这将是下
一章的主题。
当我们为子孙后代谋划时，应该牢记美德是无法继承的。
——托马斯·潘恩(美国思想家)
第4章 接 口
那些打着蝴蝶结的江郎才尽的家伙们把“指挥”解释为“指示消息”,其实那只是
他们在进行所谓“创作”时，挥舞着指挥棒或手势装腔作势的伎俩。
——弗兰克·扎帕(美国摇滚乐大师)
Java编程语言的基本编程单元是类，但面向对象设计的基本单元是类型。尽管类可以定义
类型，但是如果无需定义类就可以定义类型的话，那将会相当有用而且强大。接口以抽象形式
将类型定义为方法或其他类型的集合，这个集合就构成了该类型的契约。接口不包含任何实
现，因此不能创建接口的实例。当然，类可以通过实现一个或多个接口来拓展其类型。接口是
纯设计的一种表达形式，而类则是设计和实现的混合物。
类可以按照其设计者所选择的任何方式来实现接口中的方法，所以接口具有的可能实现比
类要多得多。在一个应用中，每一个主要的类都应该是某个接口的一个实现，而该接口则体现
了这个类的契约。
类可以实现多个接口。Java 编程语言对接口允许多重继承，但是对实现只允许单重继承，
即一个类只能扩展另一个类。例如，类可以使用接口继承来拓展其类型，然后再使用组合来提
供这些接口的实现。这种设计提供了多重继承在类型方面的灵活性，同时避免了多重实现继承
的缺陷，其代价是程序员需要做一些额外的工作。
在一个给定的类中，其扩展的类和实现的接口统一称作超类型，从超类型的角度来看，新
类就是子类型。新类包括了它的所有超类型，所以对子类型对象的引用可以多态地用于任何需
要其任意超类型(类或接口)对象引用的地方。接口声明正如类声明一样创建了类型名，我们可
以把接口名用作变量的类型名，并且任何其所属的类实现了该接口的对象都可以赋值给这个变
量。
4.1 一个简单的接口示例
许多简单的接口定义的都是一种可归属于各种不同类的不同对象的属性，这些属性经常是
根据对象“有能力”做的事情来定义的。例如，在标准包中，有大量的“能力”(ability)接口，例
如：
·cloneable(可克隆):这种类型的对象支持克隆，就像在3.9节中所讲到的那样；
· Comparable(可比较):这种类型的对象具有某种可以用来比较的次序；
· Runnable(可运行):这种类型的对象表示一个工作单元，它常常在独立的控制线程中执
行(见第14章);
·Serializable(可序列化):这种类型的对象可以写入到一个对象字节流中，以便传送
给另一个新的虚拟机，或者是为了持久化存储而写入流中，以便将来可以将其重建为一
个存活对象(见20.8节的“对象序列化”)。
让我们更具体地来看看Comparable接口。这个接口可以由任意一个类来实现，只要其对
象可以根据该类的“自然顺序”进行相互比较即可。这个接口只包含一个方法：
117
118
119
80 第4章 接口
public interface Comparable<T>{
int compareTo(T obj);
}
接口声明与类声明相似，区别仅在于它使用的关键字是interface,而类使用的关键字是
class。关于接口成员也有一些特殊的规则，很快我们就会讲到。
compareTO方法将接受一个T类型的单一对象引元，然后将它与当前对象进行比较(这个
对象也应该是T类型的),如果当前对象小于、等于或大于引元，则分别返回一个负整数、0和正
整数。
考虑一下我们在第1章中介绍过的Point类的一个变体。点的自然顺序可以是点到原点的
距离，这样我们可以让 Point对象成为可比较的：
class Point implements Comparable<Point> {
/** Origin reference that never changes */
private static final Point ORIGIN= new Point();
private int x,y;
// ... definition of constructors, setters and accessors
public double distance(Point p){
int xdiff=x- p.x;
int ydiff=y- p.y;
return Math.sqrt(xdiff* xdiff+ ydiff * ydiff);
}
public int compareTo(Point p){
double pDist =p.distance(ORIGIN);
double dist = this.distance(ORIGIN);
if(dist> pDist)
return 1;
else if(dist == pDist)
return 0;
else
return -1;
}
}
首先我们声明Point是一个Comparable类。类要实现的接口类型是通过将接口类型罗列在关
键字 implements 之后、定义的类程序体之前(并且在所有 extends 语句之后)来标识的。所有
这些被实现的接口都是该类的超接口(superinterface),且该类必须为其超接口中定义的所有方
法提供一个实现，否则，该类必须声明为抽象的，因此要求其任何非抽象的子类都必须实现那
些未实现的方法。
我们唯一需要实现的 Comparable接口中的方法就是compareTo,为了有效地比较两个
点，我们直接比较它们到原点的距离。
接口像类那样引入了类型名，所以你可以声明具有那些接口类型的变量。例如：
Comparable<Point> p1;
事实上，接口的强大之处正是源于可以只声明和使用具有接口类型而非某个具体类类型的变
4.2 接口声明 81
量。例如，你可以定义一个通用的 sort例行方法，该例行方法可以对任意的Comparable对象
数组进行排序，而不用考虑这些对象的实际类，当然数组中的所有对象都应该具有相同的类型：
class Sorter {
static Comparable<?>[] sort(Comparable<?>[] list){
// implementation details ...
return list;
}
}
但是，接口类型的引用只能用来访问接口成员。例如，下面的代码将会产生一个编译期错
误：
Comparable<Point> obj= new Point();
double dist = obj.distance(p1);// INVALID:Comparable has
// no distance method
如果想把obj当作一个Point对象来对待，就必须显式地将它强制转换为那种类型。
我们可以通过某种接口类型的引用来调用Object 中的任何方法，因为无论一个对象实现
了哪些接口，它总是一个Object 对象，所以它具有这些方法。事实上，任何没有扩展其他接口
的接口都隐式地具有与Object 中所有 public方法相匹配的成员(除非接口显式地覆盖了它
们),因此，下面的代码是合法的：
String desc = obj.tostringO;
它在将一个接口引用赋给了一个Object引用。
4.2 接口声明
接口是通过 interface关键字来声明的，并提供了接口名，以及列在大括号中的接口成
员。
接口可以声明3种类型的成员：
·常量(字段);
·方法；
●嵌套类和嵌套接口。
所有的接口成员都隐式地是公共的，但是按照惯例，public修饰符被省略掉了。在接口中声明
非公共成员是毫无意义的，真正有意义的是我们可以使用接口自身的可访问性来控制对接口成
员的访问。
我们将在第5章中讨论嵌套类和嵌套接口。
4.2.1 接口常量
接口中可以声明具名常量，这些常量被定义成了字段，但是它们都隐式地是public、stat ic和final的。像前面一样，按照惯例，这些修饰符都被省略掉了。这些字段还都必须拥有初
始器，因此空final是不允许的。也可以将注解应用在这些字段上，见第15章。
因为接口不包含任何实现细节，所以它们不能定义普通的字段——这样的定义将会把实现
策略强加给选择实现该接口的类。接口可以定义具名常量，因为这些常量对于类型设计很有
1.在第11章将会学习到泛型方法，sort实际上就应该定义成这种方法。
120
121
82 第4章 接 口
用。例如，一个在其契约中拥有不同级别的冗余度(verbosity)的接口可能会是这样的：
interface Verbose {
int SILENT = 0;
int TERSE = 1;
int NORMAL = 2;
int VERBOSE= 3;
void setVerbosity(int level);
int getVerbosityO);
}
由于为代表特定含义的常量值提供了名字，所以可以将 SILENT、TERSE、NORMAL和 VERBOSE 传
递给 setverbosity方法。在这种特殊情况下，如果冗余度级别能够表示成嵌套在 Verbose接
口内部的枚举类型的常量，那么将会更有效。枚举类型将在第6章讨论。
如果需要在接口中包含共享的、可修改的数据，那么可以通过使用一个具名常量，让其引用
存有该数据的对象来实现。嵌套类很适合于定义这种对象，我们将在第5章中举例说明。
4.2.2 接口方法
在接口中声明的方法都隐式是abstract的，因为没有给出(或者说无法给出)它们的任何
实现。因此，它们的方法体只是一个位于方法头后面的分号。按照惯例，省略了方法声明上的
abstract修饰符。
除注解外，在接口的方法声明上不允许使用其他任何方法修饰符，见第15章。因为接口的
方式隐式地是public的，所以不能再有任何其他的访问修饰符了。它们也不能有任何用于定
义实现特征的修饰符，例如 native、synchronized和strictfp,因为接口不会强加规定实现
的细节。它们还不能是final的，因为它们还没有被实现。当然，在具体类中，这些方法的实
现可以拥有上述的任意修饰符。另外，接口的方法无论如何都不能是static的，因为static
方法不能是abstract的。
4.2.3 接口修饰符
在接口声明的前边可以添加下列接口修饰符：
·注解：注解和注解类型将在第15章讨论。
·public:public接口是公共可访问的。如果没有这个修饰符，接口只能在其自身所处的
包内被访问。
·abstract:所有的接口都隐式地是abstract的，因为它们的方法都是抽象的，即它们没
有任何实现。按照惯例，abstract 修饰符总是会被省略掉。
·严格的浮点：声明为 strictfp类型的接口将使在该接口中定义的所有浮点运算都会严
格地计算赋值。该修饰符可以应用于常量的初始化表达式和在接口中声明的所有嵌套类
型。与类形成对照的是，这并不意味着接口中的所有方法都隐式地是strictfp的，因
为那只是实现的细节。请查看9.1.3节以了解其详细内容。
当多个修饰符作用于同一个接口声明时，我们推荐使用上面列出的顺序。
4.3 扩展接口83
4.3 扩展接口
可以使用extends 关键字来扩展接口。与类不同，接口可以扩展多个其他的接口：
public interface SerializableRunnable
extends java.io.Serializable,Runnable
{
// ...
}
SerializableRunnable接口同时扩展了java.io.Serializable和 Runnable,这意味着在
这两个接口中定义的所有方法和常量与该接口新定义的所有方法和常量一起构成了Serializ ableRunnable的契约。被扩展的接口是新接口的超接口(superinterface),而新接口是其超接
口的子接口。
因为接口支持多重继承，所以在继承图中可能会包含许多条到同一个超接口的路径，
这意味着可以以不同的途径来访问常量和方法。但是，因为接口没有定义方法的任何实
现，也没有提供任何与对象相关的字段，所以也就不存在任何与这种形式的多重继承语义
相关的问题。
4.3.1 继承和隐藏常量
扩展接口继承了其超接口中声明的所有常量。如果一个接口声明了一个和继承而来的某个
常量同名的常量，那么不论它们属于何种类型，新声明的常量都将隐藏继承而来的常量。这种
隐藏和第3.3.2节“隐藏字段”一节中所描述的字段的隐藏是相同的。在该子接口以及任何实现
了该子接口的对象中，所有使用简单名对这个常量的引用都会引用到在子接口中定义的常量
上。而继承而来的常量仍然可以使用该常量的完全限定名来访问，即后面跟有圆点和常量名的
接口名——这是最常见的引用static成员的方式。
interface X{
int val=1;
}
interface Y extends X{
int val=2;
int sum = val+X.val;
}
接口Y有两个常量：val和 sum。在Y内部，如果想引用超接口中所隐藏的 val常量，必
须做这样的限定：X.val。在外部，可以通过一般的静态形式Y.val和Y.sum来访问Y的常
量。当然，还可以通过X.val来访问X的静态常量 val。
当然，这些规则与类的静态字段的继承规则是相同的。
如果某个类实现了Y,那么我们就可以访问Y中的常量，就像它们是在这个类中声明的一
样。例如，假设：
class z implements Y{}
我们可以执行：
System.out.print1n("z.val="+z.val+",z.sum="+Z.sum);
但是不存在任何经由Z可以访问到X.val的途径。然而，如果给定的是Z的一个实例，那么可
以通过显式的强制转换来访问X.val:
122
123
124
84 第4章 接口
Z z= new ZO);
System.out.print1n("z.val="+ z.val+
",((Y)z).val="+(CY)z).val+
",((X)z).val="+((X)z).val);
上述语句执行时将打印出我们想要的结果：
z.val=2,((Y)z).val=2,((X)z).val=1
这与适用于扩展类的static字段的规则也是相同的，所以无论是从超类继承类的静态字段，还是
从超接口继承，都没太大的关系。
尽管从语言的角度看，所有这些规则都是必需的，但是它们其实并没有什么实际意义，因
为没有什么理由需要去隐藏已有的字段，而且对静态字段的所有访问，无论该字段是在类中声
明的还是在接口中声明的，都应该通过声明该字段的类型名来进行。
如果一个接口继承了两个或多个名字相同的常量，那么该常量的所有简单引用都将具有二
义性，从而导致编译期错误。例如，如果给出前面的接口声明和下面的代码：
interface C{
String val= "Interface C";
interface D extends x,C{}
那么D.val这样的表达式是具有二义性的。它表示的到底是整数 val还是String类型的引用
val呢?在D的内部，必须显式地使用X.val或C.val。
如果一个类实现了多个接口，或者它在扩展了一个类的同时还实现了一个或多个接口.那
么它可能也会遇到扩展了多个接口的接口所遇到的隐藏和二义性问题。这个类自己的 static字
段会隐藏从它所实现的接口或者它所扩展的类继承而来的字段，这种对多重继承的非隐藏字段
的简单引用都将会产生二义性。
4.3.2 继承、覆盖和重载方法
子接口继承了在其超接口中声明的所有方法。如果子接口中声明的某个方法与继承而来的
某个方法具有相同的签名(名字和参数列表)和相同的或共变的返回类型，那么新的声明会覆盖
所有的已有声明。接口中的覆盖和类中的覆盖不同，它没有语义方面的影响——接口实际上可
以包含同一个方法的多个声明，但是在其任何一个实现类中，该方法的实现只能有一个。
同样，如果一个接口继承了具有相同签名的多个方法，或者一个类实现了多个不同的接口，
而这些接口包含签名相同的方法，那么只会有一个这样的方法存在。该方法的实现是由实现这
些接口的类最终定义的，在这种情况下不会产生任何二义性。如果这些方法具有相同的签名，
但是返回类型不同，那么其中一种返回类型必须是其他所有返回类型的子类型，否则将会出现
编译期错误。而该接口的实现必须定义一个返回该公共子类型的方法。
实际的问题是，该方法的一个单一实现能否遵循该方法作为不同接口的组成部分而蕴涵的
所有契约呢?在某些情况下这是一种不可能满足的要求。例如：
interface CardDealer {
void draw(); // flip top card
void deal(); // distribute cards
void shuffle();
}
interface GraphicalComponent {
// render on default device void draw();
4.4 使用接口 85
void draw(Device d);// render on 'd'
void rotate(int degrees);
void fil1(Color c); interface CraphicalcardDeler extends CardDealer,GraphicalComponent {}
在这种情况下，很难编写出可以满足两个不同契约的 draw()方法的实现。如果想要同时满足
它们，就不太可能得到预期的效果，即每刷一次屏幕就翻动一张卡片。
就像类扩展中的覆盖一样，覆盖方法抛出的检查型异常不能比被覆盖方法多。也就是说，
如果继承了两个或更多的方法声明，而它们互相之间又没有覆盖，只是抛出的异常有所区别，
那么这个方法的实现必须满足这些声明中的所有 throws子句。和前面一样，主要的问题还是
这些截然不同的方法是否只需拥有一个单一的实现就可以满足所有的契约。我们将在第12章
更进一步地讨论覆盖和异常抛出问题。
如果一个声明的方法和某个继承而来的方法具有相同的名字，但是它们的参数并不相同，
那么所声明的方法就是继承而来的方法的一种重载(overloaded)形式。最终的类实现将会为每
一种重载形式都提供一个方法体。
如果一个声明的方法和某个继承而来的方法或者两个继承而来的方法仅仅是在返回类型上
有所不同，并且其中一种类型并非另一种类型的子类型，那么将会产生编译期错误。
4.4 使用接口
前一章介绍了Attr类，并且展示了如何通过扩展该类来得到一个属性对象的专用类型。
现在我们所需要的就是将属性和对象关联起来的能力。
我们要做的第一个决定就是属性的有无是否要反映在对象类型上。如果你愿意的话，可以
让每个对象都包含一个属性集，并且允许程序员访问属性集。或者你可以这样讲，能够在对象
上存储属性的特性是其类型的一部分，因此它也应该是类型层次结构的一部分。这两种观点都
是正确的。我们认为将存储属性的能力表现在类型层次上是最有用的，所以我们将创建一个
Attributed类型，其他对象可以通过附加 Attr对象来实现属性化。
我们可以通过定义一个作为其他属性化对象超类的类来创建一个Attributed类型。但是
如果这样做，程序员就必须决定是继承Attributed类，还是继承某个其他的有用类。然而我
们的选择是把Attributed定义成一个接口：
public interface Attributed {
void add(Attr newAttr);
Attr find(String attrName);
Attr remove(String attrName);
java.uti1.Iterator<Attr> attrs();
}
这个接口声明了4个方法：一个用来向 Attributed 对象中添加新属性；一个用来查找一个给
定名称的属性是否已被添加到了该对象上；一个用来从该对象中删除属性；最后一个用来访问
当前附加在该对象上的所有属性。
当我们向某个对象中附加属性时，这个对象就会认为它自己就是该 Attr实例的拥有者，
直到该实例被移除为止。如果属性的值修改了，或者它被大量的对象所共享，那么我们所期望
的情况是这样的：程序员能够以某种对应用有意义的方式来对属性的值进行修改或者执行属性
的共享。如果无法信任程序员会这么做的话，那么这些方法应该被特别注明：它们对参数和返
125
126
127
86 第4章 接 口
回值做了保护性的拷贝(defensive copies),以防止有害修改的发生。
属性可以通过attrs方法返回的迭代器(Iterator)对象来访问。Iterator是一个在ja va.util包中定义的用于集合类(collection class)的泛型接口，它提供了对集合类的内容进行访
问的能力(见21.2节的“迭代”)。实际上，Attributed接口定义了一种集合类型(一个属性
集),因此我们可以使用访问集合内容的一般机制，即Iterator类型。使用Iterator还有另
外一个好处：通过使用Iterator的标准容器类(比如 HashMap),可以很容易地实现Attribu ted 接口。
许多提供了Iterator的类都声明它们实现了Iterable接口，这个接口只定义了一个单
一的可以返回Iterator实例的 iterator方法。虽然Attributed 对象确实提供了一个Ite rator,但是让Attributed扩展Iterable接口或者将 attrs 重命名为 iterator的做法都
是错误的。因为对于那些实现了Attributed接口的类来说，这样会限制其控制自身迭代器行
为的能力。例如，这样做将意味着一个Attributed集合类只能提供用于迭代其参数而非其属
性的迭代器。
4.4.1 实现接口
接口以一种纯粹而抽象的形式描述了契约，但是它只有被类实现之后才具有意义。
有些接口是纯粹抽象的，它们没有任何有用的通用实现，因此必须为每一个新类重新实现
新的接口。然而，大部分的接口都可以有几个有用的实现。在Attributed 接口的例子中，我
们可以设想存在着多种使用不同策略存储属性集的可能实现。
如果集合中只有少数几个属性，那么使用一种策略可能既简单又快捷；如果要对查询操作
多于修改操作的属性集合进行优化，那么可能需要一种策略；如果要为经常修改的属性集合进
行优化，那么可能需要一种设计。如果有一个包含了Attributed接口的各种实现的包，那么
类就可以从中选择一个来实现Attributed接口，也可以选择由其自身的实现来实现。
作为一个示例，下面是一个使用java.util.HashMap类的Attributed接口的简单实现。
AttributedImpl类声明它实现了Attributed接口，因此它必须实现该接口中定义的所有方
法。AttributedImpl用一个HashMap实现了这些方法(HashMap 将在21.8.1节讲述)。接下
来，我们将用这个实现为需要添加属性的特定对象集合实现Attributed 接口。首先，我们来
看看AttributedImpl类：
import java.uti].*;
class AttributedImpl implements Attributed,Iterable<Attr> {
protected Map<String,Attr> attrTable=
new HashMap<String,Attr>();
public void add(Attr newAttr){
attrTable.put(newAttr.getName(),newAttr);
}
public Attr find(String name){
return attrTable.get(name);
}
public Attr remove(String name){
return attrTable.remove(name);
4.4 使用接口 87
}
public Iterator<Attr> attrs(){
return attrTable.values().iteratorO;
}
public Iterator<Attr> iterator(){
return attrs();
}
}
attrTable的初始器创建了一个用来存储属性的 HashMap 对象，这个HashMap 对象执行了大
部分的实际工作。HashMap类使用键对象的 hashcode方法对作为键而给定的对象进行了散列
化，这里不需要显式的散列方法，因为String 已经提供了很好的 hashcode实现。
在添加新属性时，属性的 Attr 对象会被存储到散列映射表中它的名字所对应的表元中，
我们可以很容易地在散列映射表中通过名字来查询或移除属性。arrts方法将返回一个有关该
散列映射表的值的Iterator,这样，方法就能访问当前对象的所有属性了。
我们让Attributed 接口的这个实现同时实现了Iterable<Attr>,因为属性是At tributedImpl中包含的唯一事物。为了实现这个目的，我们必须定义 iterator方法，让它返
回和attrs方法相同的值。
4.4.2 使用实现
我们可以通过直接继承来使用像AttributedImpl 这样的实现类。如果有这种实现类可用的
话，那么它就是最简单的工具，因为我们继承了所有的方法及其实现。但是如果需要支持多个接
口或者需要扩展不同的类，那么就必须使用其他方法。最常用的方法就是创建实现类的对象，然
后把所有的接口方法都转发给该对象，同时返回任意值——这种方式通常称作组合(composition)。
在组合和转发中，类中的每一个继承自接口的方法都可以调用另一个对象的实现，并且返
回结果。下面是一个Attributed接口的实现，它使用AttributedImpl 对象创建了一个我们
之前定义过的天体类 Body 的属性化版本：
import java.uti1.Iterator;
class AttributedBody extends Body
implements Attributed
{
private AttributedImpl attrImpl= new AttributedImpl();
public AttributedBodyO){
super();
}
public AttributedBody(String name,Body orbits){
super(name,orbits);
}
// Forward all Attributed methods to the attrImpl object
public void add(Attr newAttr)
{ attrImp1.add(newAttr);}
128
129
88 第4章 接口
public Attr find(String name)
{ return attrImp1.find(name);}
public Attr remove(String name)
{ return attrImpl.remove(name);}
public Iterator<Attr> attrs()
{ return attrImpl.attrs();}
}
在上面的声明中，AttributedBody扩展了Body并实现了Attributed,同时这个声明定义了
AttributedBody的契约。所有的Body方法的实现都继承自 Body类本身，而每个Attribu ted的方法都是通过把方法调用转发给 AttributedImpl 对象的等价方法并返回它的值(如果
有的话)来实现的。这也意味着我们必须添加一个用于转发方法的AttributedImpl类型的字
段，并且初始化该字段，使其指向一个AttributedImpl 对象。
转发很直接，而且工作量也比从头实现Attributed要小得多。如果将来某一天出现了一
个更好的 Attributed实现，转发可以使我们快速改变正在使用的实现。但是转发必须手工设
置，这会是一件相当乏味的工作，而且也很容易出错。
4.5 标记接口
有些接口并未声明任何方法，它们只是将一个类标记为具有某些通用属性。Cloneable接
口就是这样的一个标记接口(marker interface):它既没有方法也没有常量，只是标记了类，使其
可用于克隆机制(见3.9.1节)。
标记接口是契约的简并形式，因为它们没有定义任何语言级的行为——没有任何方法和
值。它们所有的契约都在文档中，而文档则描述了其他类实现该接口时所必须满足的期望。接
口 Serializable和 Externalizable(见20.8节“对象序列化”)都是标记接口，java.rmi.
Remote(见25.6节的“java.rmi远程方法调用”)和 java.util.EventListener(见25.1节
的“java.awt 抽象窗口工具包”)也都是标记接口。
标记接口对实现它们的类的行为有着深远的影响，想想Cloneable接口吧。不要只是因为
130 它们没有任何方法就傻傻地认为它们无关紧要。
4.6 何时使用接口
接口用抽象契约定义了一种类型，而抽象类也同样用抽象契约定义了一种类型，那么我们
究竟应该使用哪一个，何时使用呢?
接口和抽象类之间有两点主要的差异：
·接口提供了一种多重继承的形式，因为我们可以实现多个接口。而类只能扩展一个其他
的类，即使该类只有抽象方法也是如此。
·抽象类可以有部分的实现、protected部分、static方法，等等，但接口只能有public 的常量
和没有任何实现的public方法。
通常，我们可以凭借这些区别来判断在某种特定场合下最好使用哪种工具。如果多重继承显得
很重要甚至还很有用，那么就应该使用接口。但是，抽象类使我们可以提供某些或者全部的实
现，所以它很容易被继承，而用不着显式地转发。另外，抽象类可以通过将某些方法定义为fi nal来控制它们的实现，例如，我们在第3章中给出的 SortDouble类就可以确保排序正确地
进行。然而，如果我们发现自己编写了一个全部都是抽象方法的抽象类，那么我们实际上就是
4.6 何时使用接口89
在编写一个接口。
任何一个希望被继承的主要类，不管它是否是抽象类，都应该是一个接口的实现。虽然这
种方法给我们增加了一点工作量，但是它可以使一大类应用由不可能变为可能。例如，假设我
们创建的是一个Attributed类，而不是一个具有AttributedImpl实现类的Attributed接
口，在这种情况下，程序员如果想创建一个扩展其他已有类的新类，那么就决不能使用At tributed,因为那样的话只能扩展一个类，就无法创建AttributedBody类了。由于Attrib uted事实上是一个接口，所以程序员就有这样一种选择：他们可以直接扩展AttributedIm pl,从而避免使用转发，或者如果他们不能扩展，他们至少可以使用组合和转发来实现该接口。
并且，如果提供的通用实现并不适合，那么他们可以编写自己的实现。我们甚至可以为潜在的
用户提供某个接口的多种可能的实现。不论程序员喜欢哪种实现策略，他们创建的对象都是
Attributed。
练习4.1:使用 EnergySource的接口代替抽象类，重新编写练习3.6的那段程序。
练习4.2:如果原先编写的练习3.12的程序没有使用接口的话，那么使用接口重新编写那
段程序。
练习4.3:前面练习中的LinkedList类应该是一个接口吗?在判定之前，先用实现类来重
写它。
练习4.4:仅使用接口来设计一个集合类层次结构。
练习4.5:考虑下面的类型应该被表示为接口、抽象类还是具体类：(a)treeNode:表示N
元树中的节点；(b)treewalker:按照某种特定顺序(例如深度优先或广度优先)遍历树；(c)
Drawable:用于可由某种图形系统绘制的对象；(d)Application:用于可在图形化桌面上运
行的程序。
练习4.6:对于练习4.5中的每一个问题，当其假设条件发生何种变化时，会使我们改变答
案吗?
有两种构建软件设计的方式：一种是使其尽量简单，直至明显地没有任何缺陷；
另一种是使其尽量复杂，直至没有任何明显的缺陷。
——C.A.R.霍尔(图灵得主)
131
132
第5章 嵌套类和接口
每个非零的有限维内积空间都有一个正交基，这一点是毫无疑问的。
—加州大学伯克利分校一位数学教授
类和接口可以在其他的类和接口的内部进行声明，它们要么声明为成员，要么声明在代码
块内部。这些嵌套类(nested class)和嵌套接口(nested interface)可以有很多不同的形式，其中每
一种形式都有其自己的属性。
定义嵌套类型主要有两个用途。第一，嵌套类和嵌套接口使多个类型可以组织成逻辑上相
关的组，并具有相应的作用域。第二，也是更重要的一点，嵌套类可以简单而有效地连接逻辑
上相关的对象。后一种能力被广泛地用于事件框架，例如，AWT的框架(见25.1节的“java.
awt抽象窗口工具包”)和JavaBeans构件架构(见25.3节的“java.beans 构件”)。
嵌套类型可以看作是其包围类型(enclosing type)的一部分，它们之间是互信关系，彼此可
以访问对方的所有成员。嵌套类型之间的区别取决于嵌套类型是一个类还是一个接口，以及其
包围类型是一个类还是一个接口。嵌套类型既可以是静态的，也可以不是：前者允许简单的类
型结构，而后者定义了嵌套对象与其包围类对象之间的某种特定关系。静态的嵌套类型更加基
础一些，因此我们先讨论这种类型。
5.1 静态嵌套类型
如果嵌套类或嵌套接口被声明为其包围类或包围接口的静态成员，那么它的行为就与非嵌
套的(或顶层的)类或接口是一样的，只是它的名字和可访问性是由其包围类型定义的。嵌套类
133型的名字要表示成 EnclosingName.NestedName。只有当包围类型可访问时，嵌套类型才是可访
问的。
对于逻辑相关的类型而言，静态嵌套类型是一种组织和确定作用域的机制。但是，由于静
态嵌套类型是其包围类型的成员，所以嵌套类型可以访问其包围类型的所有其他成员，包括私
有成员——当然要通过一个恰当的对象引用。这就使嵌套类型与其包围类型之间有了一种很特
殊的特许关系。
因为静态嵌套类型是其包围类型的成员，所以作用于它们的可访问性规则与作用于包围类
型其他成员的规则是相同的。这意味着对于类而言，其静态嵌套类或接口可以具有private、
package、protected或public访问权限，而对于接口而言，嵌套类型隐式是public的。
5.1.1 静态嵌套类
静态嵌套类是嵌套类的最简形式，只要在类声明的前面加上 static修饰符就可以声明一
个静态嵌套类。如果是嵌套在一个接口中，那么这个类声明一般就会是静态的，而且按照惯例，
static修饰符是省略掉的。静态嵌套类的行为与所有的顶层类相似，它可以扩展任何其他的
5.1 静态嵌套类型91
类(包括它所属的包围类)',也可以实现任何接口，它自身也可以被其他可以访问到它的类用来
做进一步的扩展。静态嵌套类可以像顶层类那样声明为final的或者 abstract的，并且可以
使用注解。
静态嵌套类是一种在类型有意义的上下文中用于定义逻辑相关的多个类型的机制。例如，
在第2.6.4节中，我们给出了一个Permissions类，它承载了BankAccount 对象的有关信息。
因为 Permissions类与BankAccount 对象的契约是相关的——即 BankAccount 对象需要和
一个权限集进行通信，所以在这种情况下，嵌套类会是一个很好的候选方案：
public class BankAccount {
private long number;// account number
private long balance;// current balance(in cents)
public static class Permissions {
public boolean canDeposit,
canwithdraw,
canClose; }
// ... }
Permissions类是在BankAccount类内部定义的，这样它就成了 BankAccount 类的一个成
员。在permissionSFor 返回 Permissions 对象时，它能够像引用 balance那样，无需限定
就可以直接用Pemissions来引用这个类：因为Permissions是该类的一个成员。这个类的全
名是BankAccount.Permissions,这个全名清楚地说明了Permissions 类是作为 BankAC count类的一部分而不是作为一个独立的类型而存在的。BankAccount类之外的代码必须使
用这个全名才能引用到Permissions。例如：
BankAccount.Permissions perm = acct.permissionsFor(owner);
如果BankAccount位于名为bank 的包中，那么其全名应该是bank.BankAccount.Per missions(我们将在第18章讨论包)。在我们自己的代码中，在导入 BankAccount.Permis sions类之后，就可以使用简单名 Permissions了，但是这样会丢失有关该类所具有的附属特
性的重要信息。
静态嵌套类是其包围类型的成员。包围在接口中的静态嵌套类隐式地是公共的，而如果是
包围在类中，那么我们可以以任何喜欢的方式来声明其可访问性。例如，可以声明一个类，它
的实现细节是private的。我们把 Permissions 声明为 public,是因为使用 BankAccount
的程序员需要用到Permissions。
因为 Permissions是BankAccount类的一个成员，所以 Permissions 类可以访问
BankAccount类的所有其他成员，其中包括 BankAccount类继承而来的所有成员。例如，如
果Permissions声明了一个方法，该方法接受了BankAccount 对象作为其引元，那么这个方
法就可以直接访问到该账户的number和balance 这两个字段。在这种意义下，嵌套类可以看
成是包围类实现的一部分，因此嵌套类是被完全信任的。
对于静态嵌套类如何被其他类扩展是没有任何限制的——它可以被任何可以访问到它的类
扩展。当然，扩展类无法继承嵌套类对其包围类的访问特权。
嵌套枚举类总是静态的，尽管按照惯例，enum声明中的 static修饰符应该省略。枚举类
1.这是一种非常常见的组织惯用法。
134
92 第5章 嵌套类和接口
将在第6章讨论。
5.1.2 嵌套接口
嵌套接口也总是静态的，而且按照惯例，接口声明中的 static修饰符省略。它们所起的
作用仅仅是一种组织相关类型的机制。当我们观察非静态嵌套类时，将会注意到它们本质上是
135 与实现问题相关的。由于接口没有指定任何实现，所以它们不能是非静态的。
练习5.1:考虑第4章的Attr类和 Attributed接口。它们中的某一个是否应该是另一个
的嵌套类型?如果应该，那么哪一种方式会更有意义呢?
5.2 内部类
非静态嵌套类称作内部类(inner class)。非静态类的成员是与类的实例相关联的——非静
态的字段是实例变量，而非静态的方法是在实例上操作的。与此类似，内部类(通常)也是和类
的实例相关联的，或者更具体地说，内部类的实例总是与其包围类的实例相关联的——即与包
围实例(enclosing instance)或包围对象(enclosing object)相关联。
我们经常需要把嵌套类对象和包围类的某个特定对象紧密地绑定在一起。例如，考虑
BankAccount类的这样一个方法，通过这个方法可以查看到账户上执行的上一个诸如存款或取
款之类的动作：
public class BankAccount {
private long number; // account number
private long balance; // current balance(in cents)
private Action lastAct;// last action performed
public class Action {
private String act;
private long amount;
Action(String act,long amount){
this.act = act;
this.amount = amount;
}
public String toString(){
// identify our enclosing account
return number+":"+ act +""+ amount;
}
}
136 public void deposit(long amount){ balance += amount;
1astAct = new Action("deposit",amount);
}
public void withdraw(long amount){
balance -= amount;
lastAct = new Action("withdraw",amount);
}
// ...
}
Action类记录了账户上的一个单一操作。它未声明成 static的，这意味着它的对象与其包围
5.2 内 部 类93
类 BankACcount的某个对象之间存在关联。
Action对象和 BankAccount 对象之间的关系是在创建 Action 对象时建立的，就像de posit和withdraw方法中所示的那样。在创建内部类对象时，它必须与其包围类的某个对象
相关联。通常，内部类对象是在其包围类的实例方法内部创建的，就像 deposit和withdraw
中的那样。当上述这种情况发生时，当前对象 this将与内部类对象默认地关联起来。在 de posit中创建对象的代码和下面这行更显式的代码是等价的：
lastACt = this.new Action("deposit",amount);
任何 BankAccount 对象都可以用 this来代替。例如，假如我们要增加一个转账操作，它从一
个账户取出一笔指定数量的钱，将其转到当前的账户中——这样的动作需要同时更新两个账户
对象的lastACt字段：
public void transfer(BankAccount other,long amount){
other.withdraw(amount);
deposit(amount);
lastAct = this.new Action("transfer",amount);
other.1astAct = other.new Action("transfer",amount);
}
在这种情况下，我们将第二个Action 对象绑定到other BankAccount 对象上，并且把它作为
第二个账户的最后一次操作存储起来。每一个 BankAccount 对象都应该只引用该 BankAC count 对象是其包围类实例的 Action 对象。例如，在上例中，将同一个Action 对象同时存储
到当前的 BankAccount实例的lastAct字段和 other.1astAct字段中是没有任何意义的。
内部类的声明和顶层类的声明十分相似，只是存在着内部类不能有静态成员(包括静态的
嵌套类型)这个限制，但是对于这个限制，初始化为常量或由常量构成的表达式的 final类型的
static字段是个例外。允许在内部类中声明常量的基本原理和允许在接口中声明常量的基本原
理是一样的，这样做便于那些使用这些常量的类型去定义它们。
与顶层类一样，内部类可以扩展任何其他的类—包括其包围类',也可以实现任何接口并
且可以被任何其他的类扩展。内部类可以声明成 final的或者 abstract的，还可以使用注
解。
练习5.2:创建一个新版本的 BankAccount类，用来记录账户上的最近10次操作。在该类
中增加一个history方法，用来返回History对象；History 对象则每次通过 next方法返回
一个Action 对象，并在到达列表末尾时返回nul1。History 对象应该是嵌套类吗?如果应
该，它应该是静态的还是非静态的?
5.2.1 访问包围对象
Action类的 tostring方法直接使用了包围它的 BankAccount 对象的 number字段。因
为嵌套类是其包围类实现的一部分，所以它能够在不需任何限定的情况下访问其包围类的所有
成员，包括私有字段和方法。内部类可以直接通过其包围对象的名字来使用它们，而包围类中
的这些名字都称为在作用字段内(in scope)。包围类也可以访问其内部类的私有成员，但是只
能通过内部类对象(如lastAct)的显式引用来实现。尽管内部类对象总是与其包围类的某个
对象相关联的，但是反之却并非如此。也就是说，包围类的对象不需要和任何内部类对象相关
联，但是它也可以和多个内部类对象相关联。
1.难以想象为什么想要这么做，而且要想推导出其含义会使人头昏脑胀。
137
138
139
94 第5章 嵌套类和接口
当 deposit创建Action 对象时，包围BankAccount对象的引用会自动存储到新创建的
Action对象中。通过使用这个存储的引用，Action对象就可以直接使用简单名 number来引
用包围BankAccount 对象的 number字段了，就像 tostring方法中所示那样。对于这个包围
对象的引用，其名字是通过在 this前面加上包围类的名字而构成的，这种形式称作“限定-
this"(qualified-this)形式。例如，toString方法可以显示地引用包围 BankAccount 对象的
number字段：
return BankAccount.this.number+":"+ act+""+ amount;
限定-this形式的引用强调了这样一种概念：包围类对象与其内部类对象是紧密地绑定
在一起的，是同一个包围类实现的一部分。限定-super(qualified-super)形式的引用还进一步
强调我们可以访问包围实例的超类中已经被包围类隐藏或覆盖的成员。例如，给定一个扩展类
S的类T,我们可以在类T内部通过在某个表达式中使用 super.mO)来调用其超类S中的某个
方法m的实现。与此类似，在T的内部类中，我们可以通过在某个表达式中使用T.super.mO
(限定-super引用)来调用相同的m实现，对于被T中的字段所隐藏的s中的字段，其访问形
式也与此类似。
嵌套类可以拥有它自己的嵌套类和接口。任何层次的嵌套类或接口都可以以相同的方式获
取包围对象的引用：通过其类名和 this。如果类x是类Y的包围类，而类Y又是类 Z的包围
类，那么类z中的代码就可以使用x.this显式地访问类X的字段。
Java语言并没有禁止使用深层嵌套的类，但是最好不要使用。像类Z这样的两层嵌套类
会有三个名字作用字段：它自己的、它的直接包围类Y的以及最外层包围类X的。阅读Z的代
码的人必须完全理解每一个类，这样才能了解在什么样的上下文中绑定了标识符，以及哪个包
围对象被绑定到了哪个嵌套类对象上。我们推荐在大多数情况下只嵌套一层，两层以上的嵌套
会严重地破坏程序的可读性，最好不要这样做。
5.2.2 扩展内部类
内部类可以像所有的静态嵌套类或者顶层类那样被扩展，唯一的要求是扩展类的对象必须
要和最初的包围类或其子类的对象相关联。通常这不是什么问题，因为扩展的内部类通常是在
其外部类的某个扩展类中声明的：
class Outer {
class Inner {}
}
class ExtendedOuter extends Outer {
class ExtendedInner extends Inner {}
Inner ref= new ExtendedInner();
}
ref字段是在 Extendedouter对象创建时初始化的。ExtendedInner 实例的创建使用了Ex tendedInner默认的无参数构造器，这个构造器会隐式地使用 super来调用Inner 默认的无
参数构造器。而Inner的构造器则需要一个用于绑定的Outer 对象，在本例中隐式地是当前的
Extendedouter 对象。
如果内部类的子类的包围类不是Outer的子类，或者内部类的子类自身不是一个内部
类，那么当通过 super 调用 Inner的构造器时，必须提供一个Outer 对象的显式引用。
例如：
5.2 内 部 类 95
class Unrelated extends Outer.Inner {
Unrelated(Outer ref){
ref.superO;
}
}
当Unrelated 对象的构造过程到达其超类构造器被调用的这一点时，必须要有一个超类对象可
以绑定的Outer类的对象。由于Unrelated本身并不是Outer的内部类，所以对它来说不存
在任何隐式的包围类对象。同样，由于 Unrelated 也不是Outer的子类，所以当前的 Unre lated 对象也不是一个合法的包围对象。我们必须为超类对象提供一个用于绑定的Outer 对
象的显式引用，因此我们选择通过引元来向 Unrelated 的构造器提供这个引用，该构造器在超
类构造器的调用中，会把这个引元作为一个显式的绑定引用来使用。
注意，不能使用内部类的创建语法来在其外部提供Outer 对象，例如：
outer ref = new OuterO;
Unrelated u= ref.new UnrelatedO;// INVALID
因为这种语法为 Unrelated类提供的是一个包围类对象，但是Unrelated 本身并不是一个内
部类。
内部类可以扩展另一个无关的内部类，只要能够为超类提供一个适当的包围类实例即可，
就像刚刚叙述的那样。由此，所产生的内部类就会有两个包围实例：一个用于扩展类，一个用
于超类。然而，这样的设计是相当复杂的，最好避免使用。
5.2.3 继承、作用字段和隐藏
在内部类内部，所有在其包围类中声明的名字都称为在作用字段内，即它们可以直接使用，
就好像内部类的代码是在其外部类中声明的一样。内部类自己的字段和方法(以及嵌套类型)
可以隐藏包围对象的字段和方法，有两种情况可导致这种结果：
·在内部类中声明字段或方法
●由内部类继承字段或方法
在这两种情况中，任何使用简单名的用法都会引用到内部类的成员，无论引用的成员是在
内部类中声明的还是由内部类继承的。对于包围对象中的字段和方法，必须使用限定-this
表达式来显示地访问。
在第二种情况中，使用简单名的用法会误导代码的读者。考虑下面的代码：
class Host {
int x;
class Helper extends Unknown {
void increment(){x++;}// Not what you think!
}
}
increment方法看起来是在对包围它的 Host实例中的x字段进行递增操作，但事实上，Un known类也声明了一个x字段，并且Helper类继承了这个x字段。继承而来的x字段隐藏了
包围类作用字段中的x字段，因此 increment方法是对继承而来的x字段进行递增操作，而不
是对源代码中看到的那个包围类中的x字段进行递增操作。为了避免使读者对这段代码的功能
产生错误的印象，在这种情况下应该尽量避免使用简单名。取代的方法应该是，根据想要引用
的字段，将x的引用显式地限定为 this.x或Host.this.x。
140
141
142
96 第5章 嵌套类和接口
如果一个内部类的方法与其包围类的方法同名，它将隐藏包围类中该同名方法的所有重载
形式，即使在内部类中并没有声明该方法的这些重载形式也会如此。例如：
class Outer {
void print(){}
void print(int val){}
class Inner {
void print(){}
void show(){
print();
Outer.this.print();
print(1);// INVALID:no Inner.print(int)
}
}
}
这里，Inner.print的声明隐藏了Outer.print的所有重载形式。当Inner.show 调用
print(1)时，编译器会报告Inner类没有任何接受整型引元的 print方法，因此 show方法必
须要显式地用Outer.this来限定对outer的print方法的调用。这样做是有道理的，通常，
类内部的重载方法集具有相同的基本契约——它们只是在不同的参数类型上操作而已。如果一
个内部类的方法碰巧与一个包围类的方法同名，那么我们没有理由假设它们会遵循相同的契
约，因此，隐藏包围类的重载形式就可以防止意外地调用一个完全无关的方法。和前面一样，
我们几乎没有什么理由以这种方式去隐藏字段或方法，因此最好一开始就避免使用它。有关方
法调用如何被解析的细节将在9.6.1节的“寻找正确的方法”中讨论。
5.3 局部内部类
就像定义方法体、构造器或初始化块一样，我们可以在代码块中定义内部类。这些局部内
部类(local inner class)就像局部变量一样，并不是声明它们的代码所在类的成员，但是对这些代
码而言它们是局部的。这样的类在定义它们的代码块的外部是无法访问到的.简单地讲就是没
有任何可以引用它们的途径。但是这些类的实例是普通的对象，可以作为引元传递或者从方
法中返回，并且它们在不再被引用之前会一直存在。因为局部内部类是不可访问的，所以
它们不能有访问修饰符，也不能声明成 static的，因为它们是局部内部类。其他所有的
类修饰符(包括注解在内)都可以应用于局部内部类，尽管在实际应用中，只用到了
strictfp和注解。
局部内部类可以访问定义该类的作用字段中的所有变量，包括局部变量、方法参数、实例变
量(假设是一个非静态语句块)和静态变量。唯一的限制是局部变量或方法参数只有在声明成
final时才可以访问。规定这种限制的原因主要是由于多线程问题(见第14章),其次是为了
确保从内部类访问这些变量时，它们都有明确定义的值。假设访问局部变量或参数的方法可以
在定义局部类的方法执行完成以后调用(此时局部变量和参数都不再存在了),那么这些变量的
值就必须在局部类对象创建之前冻结。如果有必要，可将非 final变量拷贝到即将被局部内部类
访问的 final变量中。
下面考虑java.util包中定义的标准接口 Iterator,这个接口定义了迭代一组对象的方
式。这种方式通常用来在容器对象中提供对元素的访问能力，但是它也可以用于任何通用的迭
代：
5.3 局部内部类97
package java.util;
public interface Iterator<E>{
boolean hasNext();
E next() throws NoSuchElementException;
void remove()throws UnsupportedOperationException,
I1legalStateException;
}
如果 next方法要返回更多的元素，那么 hasNext方法将返回 true。remove方法则会从集合
中移除next方法返回的最后一个元素。但是remove是可选的，这意味着该方法的实现允许抛
出 UnsupportedoperationException异常。如果remove 在 next 之前被调用，或者在对
next的一次调用之后多次调用了 remove方法，都会抛出IllegalStateException异常。如
果在没有更多的元素需要返回的情况下调用了next,那么就会抛出 NoSuchElementExcep tion异常——它同样是java.util包的一部分。更详细的内容请查看21.2节的“迭代”。
下面这个简单的方法将会返回一个Iterator,用以遍历由Object实例构成的数组：
public static Iterator<Object>
wa1kThrough(fina1 Object[] objs){
class Iter implements Iterator<0bject> {
private int pos =0;
public boolean hasNext(){
return(pos<objs.1ength);
}
public Object next() throws NoSuchElementException{
if(pos >= objs.length)
throw new NoSuchElementException();
return objs[pos++];
}
public void remove(){
throw new UnsupportedOperationException(O);
}
return new Iter();
}
Iter类是walkThrough 方法的局部类，它并不是包围类的成员。因为Iter 对于 walk Through 方法来说是局部的，所以它可以访问这个方法的所有的 final 变量，特别是参数objs。
Iter定义了一个pos字段，用来跟踪它在objs数组中的位置。(这段代码假设 Iterator和
NoSuchElementException已经从java.util包中导入到了包含 walkThrough 方法的代码
中。)
局部内部类的成员可以隐藏定义它们的程序块中的局部变量和参数，就像它们可以隐藏实
例字段和方法一样。在5.2.3节所讨论的规则适用于所有情况，唯一的区别是一旦隐藏了局部
变量或参数，就无法再引用它们了。
静态上下文中的内部类
我们说过，内部类通常是和包围类的实例相关联的。我们还可以在一个静态上下文中声明
一个局部内部类或匿名内部类(anonymous inner class,见5.4节):在一个静态方法或静态初始
化语句块的内部，或者是作为静态初始器的一部分。在这些静态上下文中，不存在任何相应的
143
144
145
98 第5章 嵌套类和接口
包围类实例，因此内部类实例没有任何相关联的包围类实例。在这种情况下，任何使用限定-
this表达式来引用包围类的实例字段或方法的尝试都将产生编译期错误。
5.4 匿名内部类
如果觉得内部类还是有些多余，我们可以声明一个扩展了某个类或者实现了某个接口的匿
名类(anonymous class),这种类是在用new 进行实例化的同时定义的。例如，考虑walk Through方法，其中类 Iter的是相当轻量级的，而且在该方法的外部不需要这个类。Iter这
个名字对于代码来说并没有添加什么实际的价值，重要之处只在于它是一个 Iterator 对象。
这时我们可以在walkThrough 中将其替换为匿名内部类：
public static Iterator<Object>
wa1kThrough(fina1 Object[] objs){
return new Iterator<0bject>(){
private int pos =0;
public boolean hasNext(){
return(pos< objs.length);
}
public Object next()throws NoSuchElementException {
if(pos >= objs.length)
throw new NoSuchElementException();
return objs[pos++];
}
public void remove(){
throw new UnsupportedOperationExceptionO);
}
};
}
匿名类是在 new表达式中作为语句的一部分而定义的。指定给 new的类型是匿名类的超
类型。因为Iterator是一个接口，所以 walkThrough 方法中的匿名类隐式地扩展了Object
类并且实现了Iterator接口。匿名类不能有显式的 extends 或 implements子句，也不能有
任何修饰符，包括注解。
匿名类不可以有显式声明的构造器，因为它们无法给构造器命名。如果一个匿名类的结构
复杂到了需要显式构造器的程度，那么它也许应该被构造成一个局部内部类。在实际应用中，
许多匿名内部类只需要少量的初始化或根本就不需要任何初始化。不管是哪种情况，匿名内部
类都可以有初始器和初始化块，它们可以访问那些在逻辑上作为构造器引元传递进来的值。有
关构造还剩下一个问题，就是需要调用显式的超类构造器。为了解决这个问题，new 表达式写
成了好像是在构造一个超类的实例，并且此构造方法作为超类的构造方法被调用。例如，下面
的Attr(见3.1节)的匿名子类调用了Attr类的单引元构造器，并且覆盖了setValue方法，
使得在每次值发生变化时，都输出新值：
Attr name = new Attr("Name"){
public Object setValue(Object nv){
System.out.println("Name set to "+ nv);
return super.setValue(nv);
}
};
5.5 继承嵌套类型 99
在Iterator类的例子中，我们调用超类的无参构造器创建了Object 对象——当一个匿
名内部类具有接口类型时，这是唯一可用的构造器。
匿名类简单而直接，但是很容易降低程序的可读性。它们嵌套得越深，程序就越难懂。把
将要执行的匿名类代码嵌套在当前正在执行的方法代码中，会增加程序混乱的可能性。应该尽
量避免超过6行代码的匿名类，并且应该只在最简单的表达式中使用它们。我们在walk Through 这个例子中阐述了这条规则，因为该方法唯一的目的就是返回那个对象。但是如果一
个方法做了更多的工作，匿名类就必须要保持非常小，否则程序将变得难以阅读。如果能够正
确使用匿名类，它们在保持简单类的简单性方面将是一个很好的工具。但是如果被误用，它们
会使程序变得难以理解。
5.5 继承嵌套类型
嵌套类型，不管是静态类、接口还是内部类，其被继承的方式都与字段被继承的方式相同。
如果嵌套类型的声明使用的名字和继承而来的嵌套类型相同，那么它将隐藏继承而来的类型的
定义。实际引用的类型将由所使用的引用类型来确定，在一个给定的类中，实际引用的嵌套类
型可能是在当前类中定义的，也可能是在当前类中继承而来的。
考虑一个对设备建模的框架，这些设备可以通过不同的端口连接到一起。类 Device是一
个抽象类，它捕获了所有设备都具备的一些共同行为。端口也具有一些共同的泛化行为，因此
端口也被建模成了抽象类，并且因为端口只存在于设备内部，所以端口类 Port是设备类 De vice的内部类。一个具体的设备类会为设备定义状态，并为该设备定义具体的内部端口类。
在具体的设备类的构造过程中，对类的具体端口的引用将被初始化：
abstract class Device{
abstract class Port {
// ...
}
// ...
}
class Printer extends Device {
class SerialPort extends Port {
// ..
Port serial = new SerialPortO;
}
具体的设备类和具体的内部端口类本身都可能会被扩展以特化它们的行为。
class HighSpeedPrinter extends Printer {
class SerialPort extends Printer.SerialPort {
// ...
}
}
这样做的意图是用Highspeedprinter.Serialport类来覆盖Printer.Serialport类，
以使得 serial可以设定为引用正确类型的对象。但是Printer类并不会受到这个在High Speedprinter内部定义的 Serialport的新子类的影响，尽管这个新子类看起来具有相同的
名字。
对于这个设计问题，一种解决方式是将内部类对象的构造过程抽象到工厂方法(factory
method)中，这个方法在子类中可以被覆盖，从而构造内部类的正确形式。例如：
146
147
100 第5章 嵌套类和接口
class Printer extends Device {
class SerialPort extends Port {
// ...
}
Port serial= createSerialPort();
protected Port createSerialPort(){
return new Seria1Port();
}
}
现在Highspeedprinter类可以定义自己专有的内部类，并且将工厂方法覆盖为构造该类的实
例。既然我们已经认识到了嵌套类型的定义可以隐藏但不能覆盖，那么我们就不应该尝试让内
部类使用相同的名字，因为我们都知道隐藏通常是一件坏事。
class HighSpeedPrinter extends Printer {
class EnhancedSerialPort extends SerialPort {
// ...
}
protected Port createSerialPort(){ return new EnhancedSerialPortO;
}
}
现在如果构造一个Highspeedprinter 对象，并执行Printer 中的初始器，那么调用的是覆盖
的createSerialPort方法，它将返回一个EnhancedSerialPort实例。
上述例子说明了这样一种情况：子类方法的调用发生在子类对象构造过程完成之前，我们
必须小心确保那些操作是正确的。例如，如果 Enhancedserialport在初始化一个字段时，用
到了包围它的Highspeedprinter实例中的某个字段，那么当 EnhancedserialPort 对象完
成构造过程时，包围对象中的字段拥有的将只是其相应类型默认的“零”值。
另一种设计方案是让Highspeedprinter的构造器直接将 serial重新赋值为引用某个
Enhancedserialport对象。然而，这种方式会导致对最初的 Serialport 对象的不必要的构
造，并且这个构造过程可能是相当费时且不是我们想要的——在这个例子中可能还会涉及硬件
配置。
5.6 接口中的嵌套
我们可以在一个接口中声明嵌套类和嵌套接口，其原因和在类中声明嵌套类和嵌套接口是
一样的：嵌套类和嵌套接口允许我们把与一个接口紧密联系的类型关联到该接口内部。例如，
如果一个类只是用来从接口的某个方法中返回多个值，那么这个类就可以表示成该接口中的嵌
套类：
interface Changeable {
class Record {
public Object changer;
public String changeDesc;
}
Record getLastChangeO;
// ...
}
5.7 嵌套类型的实现 101
getLastchange方法返回一个Changeable.Record对象，这个对象包含一个产生变化的对象
和一个描述其变化的字符串。这个类只有在和 Changeable接口相关时才有意义，因此如果把
它定义成一个顶层类，那么不仅没有必要，而且还会使它与其使用上下文分离。作为一个嵌套
类，它紧紧绑定在它的起源和上下文上，但其他时候它是作为一个普通类使用的。
另一种在接口内部使用嵌套类的用法是为该接口定义一个(部分或完整的)默认实现。这
样实现这个接口的类就可以选择是去扩展这个默认的实现类，还是将方法调用转发到那个类的
实例上。
任何在接口内部嵌套的类或接口都是公共的和静态的。
接口中的可修改变量
我们在4.2.1节中提到过，如果需要在接口中包含共享的、可修改的数据，那么使用嵌套类
是一种简单的实现方法。声明一个嵌套类，用它的字段来存储共享数据，让它提供访问这些数
据的方法，然后维护一个对这个类的某个实例的引用。例如：
interface SharedData{
class Data {
private int x=0;
public int getX(){ return x;}
public void setX(int newX){x= newX;}
}
Data data = new DataO); }
这样 SharedData接口的所有实现者和使用者就都可以通过 data引用来共享共用状态了
5.7 嵌套类型的实现
编译器和运行时系统处理嵌套类型的方式在理想的情况下对程序员应该是透明的，但遗憾
的是，事实并非如此。嵌套类型是作为语言的一个扩展部分添加进来的，而且这个扩展还必须
维护和旧的Java 虚拟机的兼容性，因此，嵌套类型是根据编译器所采用的源代码转换机制实现
的。
作为程序员，我们对这个过程需要了解的唯一一点就是其中使用的名字惯例。考虑一个被
定义为Outer.Inner的嵌套类型，假设它是静态的或非局部的，Outer.Inner 就是该类在源
代码中的名称。在虚拟机级别上，它被重命名为outer $Inner,也就是嵌套类名字中的句点
(.)被替换成了美元符号($)。对于局部内部类，这种转换则更不明确，因为它们是不可访问
的，所以它们的名字并不重要，于是这种类被命名为Outer S NInner,其中Inner是局部类的
名字，而N是一个由一位或多位数字构成的序列。对于匿名内部类，它们的名字所具有的形式
是Outer$N,N同样是一个由一位或多位数字构成的序列。
这些问题在下列两种情况下必须进行处理：第一，当为应用打包类文件时，必须识别所有
名字中有$的奇怪文件；第二，如果使用了将在第16章讨论的反射机制来创建嵌套类实例，那
么就需要了解转换后的名字。但是在大多数编程情况中，这种转换后的名字是可以忽略的。
“原子能如此强大，以至于它只能用来行善或者作恶!”
——Firesign Theatre剧团，《苏门答腊的巨鼠》(广播喜剧)
148
149
150
第6章 枚举类型
有四样事物是我明确了解的：懒惰、悲痛、朋友和仇敌。
有四样事物是我最好没有的：爱情、求知欲、雀斑和怀疑。
有三样事物是我永远都不应该有的：妒忌、自满和太多的香槟。
有三样事物是我应该拥有一生一世的：欢笑、希望和对我的劝诫。
——多萝西·帕克(美国诗人),《清单》
枚举类型(enumeration type)有时也称作被枚举的类型(enumerated type),或者更简单地称
作枚举(enum),这种类型在定义时，所有可能的取值都是已知的。例如，表示一副纸牌花色的
枚举所具有的可能值有：红心、方块、梅花和黑桃；表示星期的枚举所具有的值有：星期一、星期
二、星期三、星期四、星期五、星期六和星期日。
在某些编程语言中，枚举仅仅被当作是一个具名整型值的集合；但是在Java 编程语言中，
枚举是一种特殊类型的类，其枚举的每一个值都有一个实例来表示。
6.1 一个简单的枚举类型的例子
表示一副纸牌花色的枚举可以声明如下：
enum Suit { CLUBS,DIAMONDS,HEARTS,SPADES }
在这种基本的形式中，枚举声明由关键字 enum、命名该枚举的标识符和为该枚举的各种取值或
151 常量进行命名的类型体构成'。按照惯例，枚举常量(enum constant)的名字总是大写的，而这些
枚举常量是枚举类的静态字段：
Suit currentsuit =..;
if (currentsuit == Suit.DIAMONDS)...;
每个枚举常量实际上引用的都是枚举类的一个实例，因此，我们不可以用new来构建枚举实
例——就好像枚举没有任何可访问的构造器一样，我们只能使用那些为枚举常量而创建的对
象。
尽管这种简单的用法看起来和声明一个具名整型常量集合好像没有什么区别，但是它们之
间有一个明显的差异，那就是枚举是完全类型安全的：除了4个定义的 Suit枚举常量和 nul?
值外，我们无法对类型为Suit的引用赋予其他任何值。正如我们将会看到的那样，枚举还提
供了比具名整型常量多得多的复杂用法。
练习6.1:为星期的日期和交通灯的颜色定义简单的枚举。
练习6.2:重新实现练习2.17的解决方案，要求使用一个枚举来表示 TURN_LEFT和 TURN_
RIGHT常量。这里使用枚举有什么好处吗?
练习6.3:重新定义 Verbose接口(在4.2.1节),要求使用一个枚举代替整型常量来描述
1.术语枚举常量引用的是那些在枚举类型中声明的诸如 CLUBS 和 DIAMONDS 之类的值。枚举类型也可以拥有普通
的常量，与其他类一样，这些普通常量是具有各种不同类型的静态 final字段。我们总是使用“枚举常量”来指
代前者，而用普通的“常量”来指代后者。
6.2 枚举声明 103
冗余级别。
6.2 枚举声明
枚举是一种特殊类型的类，但是枚举声明在其形式和使用方式方面的限制与普通的类不
同。枚举声明与类声明有两处差异：第一，它使用的是关键字enum而不是class;第二，在声
明任何类成员(或初始化块)之前，枚举必须首先声明其所有的枚举常量。如果一个枚举除了枚
举常量之外还声明了其他的东西，那么枚举常量的列表必须以一个分号结尾。例如，下面这个
Suit的变体就提供了一个可以告诉我们存在多少种花色的方法：
enum Suit {
CLUBS,DIAMONDS,HEARTS,SPADES;
public static int getSize(){ return 4;}
}
方便起见，我们可以在最后一个枚举常量之后(但是如果有分号的话应该在分号之前)使用
逗号，无论它的后面是否跟随有任何枚举类的其他声明。这对于每行声明一个枚举常量的情形
是很有用的：
enum Suit {
CLUBS,
DIAMONDS,
HEARTS,
SPADES,
}
保留多余的逗号可以使我们在重排这些行时，不必总是要记着在旧的最后一行后面添加逗号并
在新的最后一行后面移除逗号。(数组初始化列表具有与此相同的特性，请查看7.4.3节。)
枚举不能声明为扩展自另一个类型，因为所有的枚举都隐式地扩展自java.lang.Enum,
我们将在稍后讨论它。所有其他类型(甚至是另一个枚举)都不能扩展枚举，因为所有的枚举类
型的行为就好像它们隐式是final的。枚举可以声明它实现了一个或多个接口，即事实上，所
有的枚举都隐式是Serializable(见20.8节“对象序列化”)和Comparable。
枚举可以拥有的成员包括所有种类的类成员：字段、方法和嵌套类型，包括嵌套枚举——尽
管需要用到这种复杂结构的情况极其罕见，因为枚举吸引人的主要地方就在于它的简单性。枚
举常量自身是隐式的静态字段，其类型与声明它们的枚举相同。
每一种枚举类型E都具有两个静态方法，它们是编译器为枚举类型自动生成的：
·public static E[] valuesO:返回一个包含了所有枚举常量的数组，这些枚举常量在
数组中是按照它们的声明顺序存储的。
·public static Evalueof(String name):返回指定名字的枚举常量。如果这个名字
与任何一个枚举常量的名字都不能精确匹配，那么将抛出IllegalArgumenException
异常。
注意，values方法返回的数组长度就可以告诉我们在枚举中有多少个枚举常量，因此在实
际应用中，我们所展示的getSize方法是不需要的。
枚举类型不允许覆盖Object中的 finalize方法，因为枚举实例永远都不能被终结(请查
看17.3节“终结”)。
152
153
104 第6章 枚举类型
枚举修饰符
枚举声明的前面可以有某些修饰符：
· 注解：注解和注解类型将在第15章讨论。
·访问修饰符：嵌套的枚举声明可以拥有任何访问修饰符，但是顶层枚举作为顶层类，其
访问修饰符就只能要么是public,要么省略掉，即只能在它自己的包内被访问。
· static:所有嵌套枚举都隐式地是static的，因为它们包含了静态成员。按照惯例，这个
static修饰符总是省略掉的。
·严格浮点：在声明为 strictfp的枚举内部的所有浮点运算都将严格地计算赋值。详细
内容见9.1.3节。
当多个修饰符作用于同一个接口声明时，我们推荐使用上面列出的顺序。
枚举不能声明为abstract的，因为我们不能扩展它以提供其缺失的方法实现，然而，枚举
可以声明抽象方法，我们很快就会看到这个明显的矛盾是如何解决的。
枚举也不能显式地声明为final的，尽管它的行为看起来好像就是final的。同样，我们很
快就会看到为什么会是这样。
6.3 枚举常量的声明
最简单的枚举常量声明就是为每一个枚举常量取一个名字，正如前面所看到的一样。这些
枚举常量隐式地定义了一个public、static和final的、具有给定名字的字段，它的类型和声明它的
枚举相同。这些隐式定义的字段在构造枚举实例的时候将会按如下描述进行初始化。枚举常量
154 声明不能有任何修饰符作用于其上，注解除外(见第15章)。
6.3.1 构造
如果枚举常量声明中的每个字段只包含一个名字，系统将用(隐式的或显式的)无参构造器
创建该枚举类型的一个对象。枚举可以声明任意多个构造器，就像其他的类一样。通过提供与
构造器的参数类型匹配的引元，我们可以选择使用哪个构造器来创建特定的枚举常量：
enum Suit {
CLUBS("CLUBS"),
DIAMONDS("DIAMONDS"),
HEARTS("HEARTS"),
SPADES("SPADES");
String name;
Suit(String name){ this.name = name;}
public String toString(){ return name;}
}
这里，每个Suit值都有一个name字段，它是由参数为一个 string的构造器设置的，并且在
每一个枚举常量的声明中，我们都提供了构造器所需的 name引元。这对于使用枚举常量来说
是一件非常常见的工作，然而，由于这个功能已经内置了，所以我们不必自己去编写这些名字
字符串——调用一个枚举常量的 name方法就可以得到它的以 string 形式返回的名字。
我们可以从下面的伪代码中体会到一个枚举是如何在内部定义的，这段伪代码显示了上面
的 Suit枚举的一个模拟类定义：
6.3 枚举常量的声明 105
class Suit extends Enum<Suit> // pseudo-code only
implements Comparable<Suit>,Serializable {
public static final Suit CLUBS = new Suit("CLUBS");
public static final Suit DIAMONDS = new Suit("DIAMONDS");
public static final Suit HEARTS = new Suit("HEARTS");
public static final Suit SPADES = new Suit("SPADES");
String name;
Suit(String name){ this.name = name;}
public String toString(O){ return name;}
// ... compiler generated methods ...
}
虽然还需要更详细一点，但是上面的伪代码已经可以给出了一个大致的概念。
要调用的构造器是根据引元类型和构造器参数类型相匹配的一般规则来确定的，见9.6.1
节“寻找正确的方法”。
对枚举构造器的定义有3个限制：
●所有的枚举构造器都是私有的。虽然我们可以在构造器声明中使用private访问修饰
符，但是按照惯例，它应该忽略。私有构造器可以确保枚举类型不会被直接实例化。
●构造器不能显式地调用超类的构造器，超类构造器链是由编译器自动处理的。
●枚举构造器不能使用该枚举的非常量静态字段。
对最后一个限制有必要做些解释。因为每一个枚举常量都是枚举类型的一个静态字段，所
以构造器将在枚举类的静态初始化中执行。由于枚举常量声明必须是该类型中的第一个声明.
所以构造这些值的构造器将总是在静态初始化时首先执行的代码。其他的非静态字段都将在后
面进行初始化，因此，如果一个构造器引用了枚举的某个静态(非常量)字段.那么它得到的将
是默认的未初始化时的值。这种行为几乎总是错误的.因此它直接被禁止了。
声明枚举类型的工作是很简单的：声明一个静态初始化块，让它去做我们想在构造器中做
的事情。这个块可以引用任何枚举常量，也可以迭代所有的枚举常量，因为它们在这个块执行
之前已经构造好了。
练习6.4:扩充练习6.1中构建的交通灯颜色的枚举，使得每个枚举常量都有一个与之相配
的Color 对象，这个对象可以通过 getcolor方法获得。
6.3.2 常量相关的行为
许多枚举都定义了简单的、被动的类型，其唯一的目的就是为了提供具名枚举常量，像
Suit这样的枚举就是一个很好的例子。偶尔地，枚举常量会具有与其相关联的状态，这些状态
由构造器设置，并且可以用枚举的某个方法进行访问。例如.请考虑这样一个枚举.它定义了
我们太阳系的九大行星，同时允许设置或者查询每个行星的质量。在某些情况下，枚举可以表
示一个具有内在行为的实体，因为这种行为在不同的枚举常量之间有所不同，所以它被称作常
量相关的行为(constant-specific behavior)。
假设我们正在编写一个计算机象棋程序’,我们想要表示各种不同种类的象棋子，那么我
1.这个例子基于Tim Peierls所提供的一个例子。
155
156
157
106 第6章 枚举类型
们可能会使用下面这样的一个简单枚举：
enum ChessPiece {
PAWN,ROOK,BISHOP,KNIGHT,KING,QUEEN;
}
操纵各种不同的象棋子的规则可以用一个类 ChessRules来定义，这个类有一个方法，对于指
定种类的象棋子及其当前的位置，它将返回一个可达位置的集合。
Set<Position> reachable(ChessPiece type,Position current){
if(type == ChessPiece.PAWN)
return pawnReachable(current);
else if(type == ChessPiece.ROOK)
return rookReachable(current);
// ...
else if(type == ChessPiece.QUEEN)
return queenReachable(current);
else
throw new Error("Unknown type"); }
reachable方法的工作是把实际的计算分配给知道如何操作具体象棋子的方法，因此它必须考
虑传递给它的象棋子类型的所有可能的取值。不论何时，只要我们看到了使用如上所示的 if else语句链或者是与其等价的 switch 语句(将会在第10章中学到)来区分不同的对象或者是
对象的类型，那么我们就应该问问自己：是否有一种方法可以让对象自己来决定需要做什
么——毕竟，每一个对象都知道它是什么。在本例中，为什么不能向象棋子去询问可达位置的
集合呢?通过向枚举中添加常量相关的行为就可以做到这一点：
enum ChessPiece {
PAWN {
Set<Position> reachable(Position current){
return ChessRules.pawnReachable(current);
}
},
ROOK {
Set<Position> reachable(Position current){
return ChessRules.rookReachable(current);
}
},
// ...
QUEEN {
Set<Position> reachable(Position current){
return ChessRules.queenReachable(current);
}
};
// declare the methods defined by this enum
abstract Set<Position> reachable(Position current);
}
这一次所有的具名枚举常量都跟随了一个类体，它为本例中的枚举常量定义了方法，这些方法
将和前面一样把方法调用分配给恰当的 ChessRules方法。在枚举常量自身内部进行分配的好
处是我们不会忘记对某个具体值进行处理。看一看 reachable方法最初的代码，我们就会发
6.4 java.lang.Enum 107
现：我们很容易忘记处理其中的某一个值，而我们只有在运行时抛出错误时才会意识到这一点。
同时请注意，即使已经在 reachable方法中覆盖了所有的可能取值，我们仍然必须要有那个最
后的 else子句、因为编译器不会去检查我们是否已经覆盖了所有的可能取值以及该方法是否
必须返回一个值或者抛出一个异常。通过使用常量相关的行为，我们把完整性检查提前到了编
译期，这总是一件好事，而且我们可以避免去编写那些永远不会执行到的代码。
那些为每个枚举常量定义的类事实上都是匿名内部类，它们扩展了包围枚举类型，这就是
为什么我们不能把枚举声明为 final的原因：虽然它不能被直接扩展，但是它可以通过这些匿
名内部类被隐式地扩展。
由于有其他的匿名内部类，所以枚举常量的类体可以定义任意的实例字段和方法，但是它
不可以声明静态成员或者定义构造器。要注意的是，由于枚举常量隐式地都是静态字段，所以
这些匿名内部类没有与任何包围实例相关联。
为了能够被直接访问，为每个枚举常量定义的这些方法必须声明为该枚举类型自己的方
法.要么像上面的 reachable方法那样显式地定义，要么通过该枚举类型实现的某个接口来隐
式地定义。枚举类型还可以声明 abstract方法，但前提是这个方法对每一个枚举常量都只有
一个实现。
练习6.5:重做练习6.4,把qetcolor方法变成抽象方法，并为每个枚举常量定义常量相
关的方法，让它们返回正确的 Color 对象。你认为应该使用常量相关的方法来实现吗?
6.4 java.1ang.Enum
所有的枚举类型都隐式地扩展自 java.1ang.Enum2,但是任何类都不能直接扩展 Enum。
虽然 Enum确实提供了一些对于使用枚举非常有用的方法，但是 Enum主要的角色是为所有的枚
举类型建立某些有用的属性，这些有用的方法包括：
·被覆盖的clone方法，它被声明为 final的，并且会抛出CloneNotSupportedExcep tion异常——这使得在任何时候克隆一个枚举实例都是不可能的。
·被覆盖的 hashcode方法和 equals方法，它们被声明为 final的——这样就可以确保
对枚举进行一致而有效的散列，并且可以确保等同性和同一性的一致。
·被实现的 java.1ang.Comparable接口的compareTO方法，它的定义使得枚举常量拥
有了一个基于它们声明顺序的自然排序——第一个声明的枚举常量位于排序的最低位
置。
Enum还提供了一个 tostring方法的实现，它能够返回我们前面提到的枚举常量的名字，
但是我们可以选择去覆盖它。Enum还提供了一个final的name方法，它也能够返回枚举常量
的名字，但是是作为字符串返回的。这两个方法的区别在于 name方法返回的是枚举常量的确
切名字，而 tostrina方法可以被覆盖为返回一个对“用户更友好”的版本的名字.例如.返回"
Diamonds"而不是"DIAMONDS"。
Enum的其他方法还有：
· public final int ordinalO:返回枚举常量的顺序值。枚举常量的顺序值是基于它
们的声明顺序的：第一个声明的枚举常量的顺序值是0,第二个是1,依此类推。
1.Enum实际上是一个泛型类，其定义为 Enum<Textends Enum<T>>。这种循环定义也许是你可能会遇到的最
令人困惑的泛型类型定义，但庆幸的是，研究类型的理论家向我们保证这是非常有效且极具意义的、因此我们没
必要对它考虑太多。
158
159
160
108 第6章 枚举类型
·public final Class<E> getbeclaringclassO):返回表示这个枚举常量所具有的
枚举类型的Class 对象。这与在任何枚举常量上调用Object.getclass方法返回的值
是不一样的，Object.getClass方法返回的值是基于其匿名内部类的对象而设置的。
Enum类还提供了一个有用的静态工具方法valueof,它接受一个枚举类型的类对象和名
字，并从指定的枚举中返回具名枚举常量。如果该名字的枚举常量并不存在于这个枚举中，则
抛出I1legalArgumentException异常。
除 Enum类之外，还有两个非常高效的枚举相关的集合类：EnumSet定义了可供使用的枚
举值的集合，EnumMap是一个特殊的映射，它的键就是枚举值。这些特殊的集合类将在第21章
讨论。
6.5 是否应该使用枚举
我们想要定义为枚举的类型越复杂，就越需要考虑枚举是否是表示这个类型的正确方式。
就像纸牌花色、星期和简单的象棋子这样的枚举一样，如果我们拥有一个有关实例的人所共知
的闭集，那么几乎无需考虑就应该做出定义一个枚举的决定。
如果一个枚举定义的枚举常量具有常量相关的行为，那么我们就必须考虑得更多一些。一
个类型的行为越复杂，使用它的应用就越有可能需要特化其行为。行为的特化是通过子类化来
实现的，但是我们无法子类化枚举，即使特化出来的是一些无碍大局的做法，例如像定义记录
日志或者描述给定枚举类型的版本这样的操作，也是不允许的。我们在选择是否要将一个类声
明为final的时候所作的考虑同样可以应用于选择是否要声明一个复杂的枚举。
通过枚举能够实现，但无法通过声明其他类型的类来实现的事情，其实少之又少。但是正
如我们所看到的，枚举提供的打包机制使用起来要方便得多，尽管它会有些限制。另外，枚举
是Java语言的一部分，并且可以被Java语言的其他部分所识别。例如，枚举常量可以直接在
switch语句中使用(请查看10.3节),而普通的对象引用则不能。我们建议最好使用枚举类型
而不是定义自己的类，除非需要通过子类化来实现特化。
人口普查员问家庭主妇：您是否曾经长过螨虫，如果有的话，有多少?
第7章 语言符号、值和变量
音乐没有什么特别的地方。你所要做的只是在恰当的时候
敲击正确的键，然后就由乐器自己去演奏。
——约翰·塞巴斯蒂安·巴赫
程序最初的形式是包含在文件中的字符序列——源代码，编译器或者解释器根据给定语言
的规则来解释这些字符，其中一些字符表示变量的名字，而另外一些字符则是这种语言所使用
的特定关键字，其他字符则是运算符或者用于分隔其他元素的“标点符号”。所有这些文本结构
就够成了程序的词法元素(lexical element),这些词法元素必须被标识为关键字、注释、字面常
量、变量、运算符或给定语言的其他成分。在本章中，我们将了解Java程序的基本词法元素、可
以表示的字面常量以及能够存储这些常量的各种变量。
7.1 词法元素
编译的第一阶段的任务之一就是扫描词法元素，并生成语言符号(token)。这个阶段将忽略
文本中出现的空白分隔符(whitespace)和注释(comment)——因此Java语言必须定义可接受的
空白分隔符和注释的形式，然后，剩余的字符序列必须全部被解析成语言符号。
7.1.1 字符集
大多数程序员所熟悉的源代码都是由下面两种主要字符集来编写的：ASCII码及其变体(包
括Latin-1)和EBCDIC(扩充的二进制编码的十进制交换码)。这些字符集都包含英语和其他西 161
欧国家语言中所使用的字符。
另一方面，Java编程语言是用Unicode的16位编码机制来编写程序的。Unicode 标准最初
只支持16位字符集，但是现在已经扩展到支持最大到21位的字符集，其最大值是0x10ffff。值
大于0x00fff的字符被称为增补字符(supplementary character),而任何特定的21位值都被称为
代码点(code point)。为了使所有的字符都可以用16位值表示，Unicode定义了一种称作UTF-
16的编码格式，Java 编程语言就是用它来表示文本的。在UTF-16中，所有介于0x0000和
0xfff 之间的值都被直接映射成了Unicode字符，而增补字符则被编码为两个16位值，其中第一
个值来自于高位字符代理(high-surrogate)范围，第二个值来自于低位字符代理(low-surrogate)
范围。想要使用单个完整的代码点值的方法可以接受一个编码为2字节长的char[]的UTF-
16值，或者接受一个单一的直接存有代码点的 int值。在UTF-16序列中，单个的char 被称
作代码单元(code unit)。
Unicode的前256个字符是Latin-1字符集，Latin-1字符集的前128个字符绝大多数和7
位的ASCII字符集中的字符是等同的。当前的环境都可以读入ASCII或 Latin-1文件，并在运
行时把它们转换成Unicode1。
1.Java编程语言一直在跟踪 Unicode标准，见有关参考文献的“进阶阅读材料”。目前支持的 Unicode版本在
Character类的文档中列举了出来。
162
163
110 第7章 语言符号、值和变量
现有的文本编辑器中支持Unicode字符的很少，因此可以使用转义序列(escape sequence)
uxxxx对 Unicode字符进行编码，其中每个x代表一个十六进制数字(0~9和用来表示十进制
数10～15的a~f或A~F)。转义序列可以出现在代码中的任意位置，既可以出现在字符和字
符串常量中，也可以出现在标识符中。转义序列的开头可以有多个u,于是，字符母可以写成
uOb87或uuu0b87'。还需要注意的是，如果我们的编辑器不支持 Unicode字符(或其子集),
那么对于在源代码中出现的、系统默认字符编码机制不包括的所有字符，可能都需要以某种方
式告知编译器，例如可以通过指定源字符集的命令行选项来达到这一目的。
练习7.1:请使用Unicode转义序列编写一个完整的“Hello,World”程序，这只是为了增加
一点趣味性。
7.1.2 注释
源代码中的注释是为了给程序员提供便利，在代码生成阶段它们不起任何作用，因此它们
在扫描过程中被忽略了。Java语言的注释有三种形式：
// comment 从标记//开始到该行行尾的所有字符将被忽略。
/* comment*/ 标记/*和*/之间的所有字符将被忽略。
/** comment*/ 标记/**和*/之间的所有字符将被忽略。这些文档注释必须位
于标识符声明之前，它们将包含在自动生成的文档中。这些注释将在第19章中描述。
Java注释可以包含任何有效的Unicode字符，例如阴阳符(\u262f)、三星符(\u2042)、问叹号
(u203d)、韩圆(u20a9)、吩(u2108)或雪人(u2603)。2
Java注释不允许嵌套，下面的代码看起来很诱人，但实际上无法通过编译：
/* Comment this out for now:not implemented
/* Do some really neat stuff*/
universe.neatStuff();
*/
上面的注释起始于第一个标记/*,结束于其后出现的第一个*/标记。然后对*/之后的代码
继续解析，当遇到后面出现的单个无效的*/时，就会出现语法错误。因此，从程序中移除代码
块的最佳方式是在每行开头放置一个//标记，或者像下面的例子那样使用if(false):
if(false){
// invoke this method when it works
dwimO;
}
这项技术要求将要移除的代码必须是相对完整的，可以使代码毫无错误地通过编译。在本例中
我们假定已经在某处定义了dwim方法。
1.有很好的理由允许使用多个u。当把Unicode 文件转换成ASCII文件时，必须把ASCII码范围之外的Unicode字符
翻译成转义序列。比如，把翻译成wOb87。当需要翻译回来时，就执行相反的替换。但是。如果原来的 Uni
code文件中没有包含母，而是使用了uOb87,情况又会是什么样呢?如果这样的话，反向翻译就不能还原最初
的源文件(对于解析器而言都是一样的，但对代码的阅读者可能就不一样了)。解决的方法是在翻译过程中如果
遇到已经存在的uxxxx,翻译器就在其前面加上一个u,反向翻译器则去掉一个u,如果去掉u之后就不再
含有u了，就用等价的Unicode字符取代该转义序列。
2.这些字符分别是：O,*,?,t,B,和8。
7.1 词法元素 111
7.1.3 语言符号
语言的基本文字是语言符号。解析器首先将源代码分解成语言符号，然后弄清楚代码是由
哪些语句和标识符等构成的。空白分隔符(空格、水平制表符、换行符和换页符)除了分隔语言
符号或者作为字符及字符串字面常量的内容之外，没有其他特殊的意义。对于有效的Java程
序，可以在不改变其含义的情况下，将任意数量的语言符号间的空白分隔符(字符串和字符序
列之外的空白分隔符)替换为不同数量(但不能是0个)的空白分隔符。
两个语言符号之间必须用空白分隔符来分隔，否则它们就组合成了一个单个的语言符号。
例如，在下面的语句中：
return 0;
不能省略 return和0之间的空格符，否则就会组合成一个单个的标识符 return0,上面的语
句将变成一条无效的语句：
return0;
尽管解析器会忽略额外的空白分隔符，但是对代码阅读者来说，适当地使用额外的空白分隔符
可以提高代码的可读性。注意，解析器将注释当作空白分隔符一样对待。
Java的符号化器(tokenizer)是“贪婪”的，在构建下一个语言符号时，它要抓取尽可能多的
字符，而不关心所构建的语言符号序列是否有效。于是，就因为++比+长，表达式
j=i+++++i;// INVALID
被解释成无效的表达式
j=i++++ +i;// INVALID
而不是有效的表达式
j=i+++++i;
7.1.4 标识符
标识符是诸如变量、常量和标号之类被声明实体的名字，它们必须以字母开头，紧随其后的
是数字、字母或两者兼而有之。在Unicode中，术语字母(letter)和数字(digit)的定义比较宽泛：
如果某个符号被认为是人类语言中的一个字母或数字，那么就可以在标识符中使用它。Java的
“字母”可以包括来自于亚美尼亚文、韩文、果鲁穆奇文、格鲁吉亚文、梵文和几乎当今世界的任
何书面文字。因此，不仅 kitty是有效的标识符，而且macka,kouIka,心一，U?60高5L4,
和“猫”等也都是有效的标识符'。Java的“字母”还包括所有的货币符号(如：$、￥和f)和连接符
(如_)。
标识符中的字符只要稍有区别就会使其成为不同的标识符。Java 标识符是区分大小写的：
A、a、á、A、和A等都是不同的标识符。看起来相同或几乎相同的字符很容易混淆，例如，拉丁语
中字母n的大写N和希腊语中字母v的大写N看起来很像，但实际上它们是不同的字符(分别
是u004e和u039d)。避免混淆的唯一方式就是用一种语言来编写所有的标识符，这样它们
使用的就是同一个字符集，而程序员就会知道键入的标识符到底是E还是E2。
标识符的长度可以根据自己的喜好来定，但是使用时应注意风格，标识符太长会很难被正
确使用，并且会使代码变得混乱。
1.这些词分别是“cat”或“kity”的英语、塞尔维亚-克罗地亚语、俄语、波斯语、泰米尔语和中文的书写形式。
2.一个是西里尔字母，另一个是ASCII字符。猜出来的有奖。
164
112 第7章 语言符号、值和变量
7.1.5 关键字
在Java语言中，其关键字有特殊的意义，因此不能被用做标识符。下表列出了所有的Java
关键字(标有*号的是目前还没有使用的保留字):
165
abstract
assert
boolean
break
byte
case
catch
char
class constt
for switch continue new gotot synchronized default package if private do this
double implements protected throw
else import public throws
instanceof transient enum return
int extends short try
final interface void static
finally strictfp volatile long
float while native super
虽然 nul7、true和 false看起来像是关键字，但事实上它们是字面常量，就像数字12一
样，所以它们没有出现在上面的表中。但是，不能把 nul1、true或 false用作标识符，就像不
能把12用作标识符一样。它们可以用作标识符的一部分，如 annulled、construe和 false hood等。
7.2 类型和字面常量
每个表达式都有其类型，该类型决定了表达式能产生什么样的值，而表达式的类型是由表
达式中所使用的值和变量的类型所决定的。类型分为基本类型和引用类型。
Java的基本数据类型有：
boolean true或 false
char16位Unicode UTF-16字符(无符号的)
byte8位有符号模2补码整数
short16位有符号模2补码整数
int 32位有符号模2补码整数
long 64位有符号模2补码整数
float 32位IEEE-754浮点数
double 64位IEEE-754浮点数
在java.lang 包中声明了与Java的每一种基本数据类型相对应的类，这些包装器类(即
Boolean、Character、Byte、Short、Integer、Long、Float和Double)还定义了一些有用的常
量和方法。例如，大多数包装器类都声明了常量MIN_VALUE和MAX_VALUE,分别表示相关联的
基本类型的最小值和最大值。
Float类和 Double类还具有NaN、NEGATIVE_INFINITY 和 POSITIVE_INFINITY常量。
这两个类还提供了 isNaN方法，用于检查一个浮点值是否“非数”,也就是检查该值是不是一个
没有任何有效结果的浮点表达式的值，比如零被零除。NaN 值可以用于表示无效的浮点值，这
与使用null表示没有引用任何对象的对象引用的用法类似。在第8章中将详细讲解包装器类。
Java中没有任何无符号的整数类型。如果需要使用来自程序之外的无符号值，则这些值必
须被存储为更长的有符号类型。例如，由模数转换器产生的无符号字节可能会被读入到 short
类型的变量中。
Java的引用类型包括类类型、接口类型和数组类型。这些类型的变量可以引用相应类型的
7.2 类型和字面常量 113
对象。
Java中每种类型都有字面常量，也就是相应类型的常量值的字面表达形式。下面几节将介
绍如何指定每种类型的字面(未命名)常量。
7.2.1 引用型字面常量
对象引用的唯一字面常量是null,它可以用于任何需要引用的地方。按照惯例，null表
示一个无效的或未创建的对象，它不属于任何类，甚至不属于Object类，但是nul7可以赋给
任何引用型变量。
7.2.2 布尔型字面常量
布尔型的字面常量是true和 false。
7.2.3 字符型字面常量
字符型字面常量是通过将字符置于两个单引号之间来表示的，如'Q',任何有效的 Unicode
字符都可以置于两个单引号之间。我们可以在字符型字面常量内部使用Unicode字符uxxxx,
就像在其他地方使用它们一样。某些特殊的字符可以用转义序列表示：
\n
\t
换行( u000A)
水平制表符(u0009)
b
\r
\f
\
退格(u0008)
回车(u000D)
换页(u000C)
反斜线(u005C)
\' 单引号(u0027)
\" 双引号(u0022)
\ddd 八进制字符，其中每个d的取值范围为0~7
八进制字符常量最多可以含有3个数字，并且不能超过\377(wOOff)。例如，字符型字面
常量'12'和'n'相同。增补字符不能用字符型字面常量表示。
7.2.4 整型字面常量
整型常量是八进制、十进制和十六进制的数字串。这类常量的起始字符用来声明其基数：
前导0表示八进制数(基数8);前导0x或0X表示十六进制数(基数16);其他所有的数字都是
十进制数(基数10)。下面所有的数字都具有相同的值：
29 035 0x1D 0xld
以小写1或大写L结尾的整型常量属于long型，例如29L;我们通常使用L,因为1(小写
的L)很容易和数字1混淆。除此之外，整型常量都属于 int类型。如果将 int类型的字面常
量直接赋值给 short类型的变量，且它的值在 short类型的有效取值范围之内、那么整型字面
常量就会被当作 short字面常量处理。同样的情况也适应于将整型字面常量直接赋值给 byte
类型的变量。在其他所有情况下，把 int类型的字面常量赋值给 short或 byte类型的变量
时，必须进行显式类型强制转换。(见9.4.2节“显式类型强制转换”。)
7.2.5 浮点型字面常量
浮点型常量可以用十进制或十六进制形式表示。十进制形式的组成是：带有可选小数点的
166
167
168
114 第7章 语言符号、值和变量
十进制数字串，其后是可选的指数字母e或 E,字母后面是可选的有符号整数。浮点数中至少
要包含一个数字。下面的所有字面常量表示的都是相同的浮点数：
18.1.8el .18E+2 180.0e-1
十六进制形式的组成是：0x或0X,后面是带有可选小数点的十六进制数字串，数字串后面
是必需的表示二进制指数的字母p或P,字母后面是可选的有符号整数。二进制指数表示按照
2的幂进行缩放。下面所有的字面常量表示的也都是相同的浮点数(十进制的18.0):
0x12p0 0x1.2p4 0x.12P+8 0x120p-4
浮点常量都属于double类型，如果它们以f或F结尾，则属于 float类型，如18.0f,而
以d或D结尾则表明它是double类型的常量。零有两种：正的(0.0)和负的(-0.0)。当用
==比较正零和负零时，它们是相等的，但是，在有些计算中使用它们会产生不同的结果。例
如，如果除0,表达式1d/Od的结果是+四，而1d/-0d的结果是-0。没有任何字面常量可
以表示无穷或 NaN,只能使用 Float和Double类中定义的符号常量来表示(见第8章)。
double类型的常量不能直接赋给 float类型的变量，即使 double类型的常量的值在
float类型的有效范泛围内也是如此。唯一能够直接赋值给 float类型的变量和字段的常量
是float类型的常量。
7.2.6 字符串型字面常量
字符串字面常量是通过将字符串置于两个双引号之间来表示的，如"along"。除了换行符
和双引号之外，其他所有字符都可以置于字符串字面常量中。在字符串的中间不允许出现换行
符，如果想在字符串中嵌入换行符，就必须使用转义序列\n,而嵌入双引号则需使用转义序列
\"。字符串字面常量引用的是String类型的对象，想了解有关字符串的更多内容，请阅读第
13章。
字符串中的字符可以用八进制数字语法来指定，但是3个八进制数字必须都得用上，因为
这样就可以避免字符串中八进制的值和八进制的有效数字位相连时产生的错误。例如：字符
串"0116"等于"\t6",而字符串"\116"等于"N"。
7.2.7 类字面常量
每种类型(基本类型或引用类型)都有与之相关联的表示该类型的Class 类的实例.这此
实例通常被称为给定类型的类对象(class object)。我们可以直接在某种类型后面加上".class"
来命名该类型的类对象，例如：
String.class
java.1ang.String.class
java.util.Iterator.class
boolean.class
前两个类字面常量引用的是同一个Class类的实例，因为 String和java.1ang.String是同
一种类型的不同名字。第三个类字面常量引用的是前面4.4.2节提到过的 Iterator接口的
class实例。最后一个引用的是表示基本类型 boolean的Class 实例。
因为Class类是泛型的，所以对于引用类型T,它的类字面常量的实际类型是Class
<T>,而对于基本类型，其实际类型是Class<W>,其中W是基本类型的包装器类。但是要
注意类似这样的情形：boolean.class和 Boolean.class是类型Class<Boolean>的两个
不同对象。泛型类型将在第11章讨论，而Class类将在第16章讨论。
练习7.2:编写一个类，为每一种基本数值类型都声明一个字段，并且尝试使用不同的字面
7.3 变 量 115
常量形式给它们赋值。例如，将3.5f赋值给 int类型的字段。哪种类型的字面常量可以赋值
给哪种类型的字段?改变所采用的值的大小，看看有没有影响。
7.3 变量
变量是Java程序中的存储区字段',用来存储值，也可以把值赋给变量。变量包括字段、代
码块中的局部变量和参数。变量声明描述了变量的标识符(名字)、类型以及其他属性，变量声
明的类型部分指明了被声明的实体支持哪些类型的值和行为。变量的其他属性包括注解和修饰
符，其中注解可以用于所有种类的变量声明，我们将在第15章讨论。
7.3.1 字段和局部变量的声明
字段和局部变量是用相同的方法声明的。声明可以分为三个部分，它们按顺序依次是：修
饰符、类型和标识符列表。每个标识符都可以可选地由与其相关的初始化式对其赋初值。
对于相同类型的变量，采用逐个声明的方式和多个同时声明的方式没有任何差别。例如：
float x,y;
和
float x;
float y;
是相同的。
所有的初始器都被表示为使用恰当类型的表达式进行赋值的操作(使用=运算符)。例如：
float x=3.14f,y=2.81f;
和
float x=3.14f,
y= 2.81f;
相同，但是后者的可读性更好。此表达式的另外一种表示方法，也是首选的表示方法：
float x=3.14f;
float y=2.81f;
字段变量是类或接口的成员，它们是在类或接口的程序体内声明的。字段可以用初始器在
初始化块中或者在构造器中进行初始化，但是因为它们有默认的初始值，所以实际上它们根本
不需要进行初始化，就像在2.2.1节讨论的那样。字段初始化和可以用于字段的修饰符在第2
章中已经讨论过了。
局部变量可以在语句块的任何地方声明，不一定是语句块的起始位置，它们既可以被声明
为基本类型，也可以被声明为引用类型。作为特殊情况，局部变量也可以在 for循环的初始化
部分进行声明见10.5节“for”。局部变量在使用之前必须被赋值2。局部变量没有任何默认的
初始值，因为没有对其赋初值通常是程序中的缺陷。编译器将会拒绝编译不能保证变量在使用
之前已经被赋值的代码：
1.类型变量不是存储区域，所以不在我们讨论的范围之内，它们仅适用于泛型类型的声明，我们将在第11章
讨论。
2.在技术术语中有这样一个概念：变量是“被明确赋值的”。除非确定局部变量已经被明确地赋值，否则编译器将
不允许使用局部变量。
169
170
171
116 第7章 语言符号、值和变量
int x;//没有初始化，不能使用
int y= 2;
x=y*y;// 现在x的值是4
int z=x;// ok,使用×是安全的
当控制流到达声明局部变量的语句块的结尾时，局部变量将不复存在，而所有被局部变量
引用的对象都将服从标准的垃圾回收规则。
除了注解，唯一能应用于局部变量的修饰符是final。当局部变量会被局部或者匿名内部
类访问时，就需要将其声明为是final的，另见下面有关final变量的讨论。
7.3.2 参数变量
参数变量是在方法、构造器或者 catch 块中声明的参数(见12.4节“try、catch和 final ly")。参数声明由可选的修饰符、类型名和单一的标识符组成。
参数变量没有显式的初始器，因为它们是在方法或构造器被调用时用传递进来的引元值，
或在 catch 块中捕获到异常对象的引用隐式初始化的。当参数变量所在的块执行结束时.参数
变量也将不复存在。
和使用局部变量一样，除了注解外，可以应用于参数变量的唯一修饰符是 final。
7.3.3 final变量
final修饰符用于声明变量的值只能被设置一次，之后它就一直保持这个值，也就是说，
该变量的值是不可改变的。任何变量、字段、局部变量或参数都可以被声明为 final。声明为
final的变量在使用之前必须初始化.这项工作通常是在声明时直接进行的
final int id = nextID++;
用户可以推迟 final字段或final 局部变量的初始化，这样的 final变量叫作空白 final( blank fi nal)。空白 final字段必须在初始化块或构造器(如果它是实例字段)中初始化，而空白final局部
变量和任何其他局部变量一样，必须在使用之前初始化。
当字段的值取决于构造器的引元时，就可以使用空白 final 字段：
class NamedObj{
final String name;
NamedObj(String name){
this.name= name;
}
}
或者当我们必须计算一个比初始化式要复杂的值时，也可以使用空白 final字段：
static final int[] numbers = numberList();
static final int maxNumber;// max value in numbers
static {
int max = numbers[0];
for(int num :numbers){
if(num>max)
max = num;
}
maxNumber = max;
7.4 数组变量 117
}
static int[] numberList(){
// ...
}
编译器将会校验在所有静态初始化块结束时，所有的静态 final字段是否已经被初始化；以
及在一个对象的所有构造路径结束时，其非静态 final字段是否已经被初始化。如果编译器不能
确定它们已经被初始化，就会产生编译期错误。
如果赋给变量的值是以其他变量的值为条件来确定的，那么就可以使用空白 final局部变
量。和所有的局部变量一样，编译器将会确保final局部变量在使用之前被初始化。
通常只有在局部变量和参数将会被局部或匿名内部类访问时，才将其声明为是final的。但
是也有些人提倡作为一种风格，可以总是将参数声明为是final的，以避免在对字段或其他变量
赋值时意外地对参数进行了赋值。对是否应该使用 final字段在2.2.3节中已经讨论过了。
7.4 数组变量
Java数组是有序的元素集合。数组元素可以是基本类型，也可以是对对象的引用，包括对
其他数组的引用。数组本身也是扩展自Object的对象。数组声明
int[] ia = new int[3];
声明了一个名为ia的数组，该数组初始化时引用了一个具有三个 int值的数组。
在数组变量的类型声明中忽略了数组的维数，因为数组的元素个数是在使用new创建数组
对象时决定的，而不是在声明数组变量时决定的。数组对象的长度在其创建时就固定了，并且
不能再改变。注意，这里是说数组对象的长度是固定不变的，在上面的例子中，可以在任何时
候将一个不同长度的新的数组赋值给数组变量ia。
用户可以根据元素在数组中的位置来访问它。数组的第一个元素的下标值是0,最后一个
元素的下标值是数组的长度减1。我们可以通过使用数组名加上被方括号括起来的元素下标值
来访问数组中的元素。在上例中，数组的第一个元素是ia[0],最后一个元素是ia[2]。每次
使用下标时都会受到虚拟机的检查，以确保它在该数组下标值的正确范围之内。如果下标越
界',就会抛出ArrayIndexoutofBoundsException异常。下标表达式必须是int类型的，这
也就限制了数组的最大长度。
可以使用数组的length字段(它隐式地是public和 final的)来获得数组的长度。在我
们的例子中，下面的代码遍历了数组中的每一个元素，并打印出每一个元素的值：
for(int i=0;i<ia.length;i++)
System.out.println(i+":"+ ia[i]);
长度为0的数组被称作空数组(empty array),nul1数组引用和对空数组的引用存在着巨大
的差异：空数组是一个真正的对象，只是它没有任何元素。用从方法返回空数组来代替返回
nul1是很有用的，因为一方面，如果一个方法返回null,那么用户在使用这个方法之前必须
显示地检查返回值是否为 nul1,另一方面，如果该方法返回一个可能为空的数组，用户在使用
这个方法时，只需要用数组的长度验证下标是否有效即可，而不需要其他的特殊检查。
1.检查范围通常都是经过优化的，例如，它能确保循环下标变量总是在有效范围内，但是Java会保证你绝对不会使
用超过范围的下标值。
172
173
174
118 第7章 语言符号、值和变量
如果你喜欢，还可以将方括号放在变量名的后面，而不是类型的后面：
int ia[]= new int[3];
这种声明方式和前面对ia的最初定义是等价的。但是，第一种风格更好一些，因为它把类型声
明完整地放在了一起。
7.4.1 数组修饰符
一般的修饰符都可以应用于数组变量，主要取决于这个数组是字段，还是局部变量。必须
牢记的重要问题是修饰符能够应用于数组变量，但不能够应用于该变量所引用的数组元素。将
数组变量声明为 final意味着数组引用在初始化后不能被改变，而不是数组元素不能被改变，
而且也不存在任何方式可以将修饰符(特别是final和 volatile)应用于数组元素。
7.4.2 数组的数组
Java支持数组的数组。例如，声明和打印一个二维矩阵的代码，可能如下：
float[][]mat = new float[4][4];
setupMatrix(mat);
for(int y=0;y<mat.1ength;y++){
for(int x= 0;x< mat[y].1ength;x++)
System.out.print(mat[y][x]+"");
System.out.print1n();
}
在创建数组的数组时，必须指定它的第一维(最左边的维),其他维可以以后确定，而同时
指定多维是嵌套的 new语句集合的简化形式。上面用new 创建多维数组的方式也可以显式地
编写为：
float[][] mat = new float[4][];
for(int y=0;y<mat.1ength;y++)
mat[y]= new float[4];
“数组的数组”的好处之一是每个嵌套的数组都可以有不同的大小。我们可以仿照4×4的
矩阵构造一个二维数组；但我们也可以创建一个一维数组，其元素是4个int类型的一维数组，
这4个数组可以根据存储数据的需要而具有不同的长度。
7.4.3 数组初始化
当数组被创建时，它的每个元素都被初始化为其类型的默认初始值，其中，数字类型的默
认初始值是0,char类型的是'\u0000',boolean 类型的是 false,引用类型的是nu]1。当
我们声明引用类型的数组时，实际上是在声明该类型的变量的数组。考虑下面的代码：
Attr[] attrs = new Attr[12];
for(int i=0;i<attrs.length;i++)
attrs[i]= new Attr(names[i],values[i]);
使用new创建数组之后，attrs变量就具有了一个对数组的引用，所引用的数组包含12个均被
初始化为null的Attr变量，这些Attr 对象自身是在执行循环时创建的。
在数组变量声明的后面，可以用大括号提供一组由逗号分隔开的值，并用这些值来初始化
数组。下面的数组声明创建并初始化了一个数组对象：
7.4 数组变量 119
String[] dangers={"Lions","Tigers","Bears"};
下面的代码具有相同的效果：
String[] dangers = new String[3];
dangers[0]= "Lions";
dangers[1]= "Tigers";
dangers[2]="Bears";
当在声明数组的同时进行初始化时，并不需要显式地使用new来创建数组，因为系统会隐式地
自动完成数组的创建，所创建的数组长度由给定的初始值的个数决定。如果你喜欢，也可以显
式地使用new,但是，在这种情况下，我们必须省略数组的长度，因为它同样是由初始值的列表
来决定的。
string[] dangers = new String[]{"Lions","Tigers","Bears"};
这种数组创建表达式允许我们在任何地方创建并初始化数组。例如，我们可以在调用方法
的时候创建并初始化数组：
printstrings(new String[]{ "one","two","many"});
其中，使用new创建的未命名的数组被称作匿名数组(anonymous array)。
初始化值列表的最后一个值的后面可以有逗号，这对于多行初始化来说是非常方便的，因
为我们可以重新排序、增加或移除值，而不需要记住一定要在旧的最后一行后面加上逗号，从新
的最后一行后面删除逗号。
可以通过嵌套数组初始器来对数组的数组进行初始化。下面的例子声明了一个数组，并用
Pascal 三角的前几行对其进行了初始化，其中每一行都由其自己的数组来表示：
int[][] pascalsTriangle= {
{1},
{1,1},
{1,2,1},
{1,3,3,1},
{1.4.6.4,1}
};
数组的数组的下标值是从最外层开始向内层标识的。例如，在上面的数组中，pascalsTrian gle[0]指的是包含一个元素的那个int型数组，pascalsTriangle[1]指的是包含两个元素的
那个 int型数组，依此类推。
为了方面起见，system类提供了一个arraycopy 方法，用于将一个数组赋值给另一个数
组，从而取代那种通过遍历数组的每一个元素来进行赋值的操作——我们将在23.1.3节“工具
方法”中详细讨论。
7.4.4 数组和类型
Object
数组隐式地扩展了Object。假定我们有一个类x,
还有扩展了类X的类Y和类 z,以及它们每种类型的数
组，那么它们的类层次关系如图7-1所示： X X[] int[] float[]
这种类关系使得数组具有多态性。我们可以把数组赋值
给类型为Object的变量，也可以采用强制转换将其转换
回来。任何需要类Y的超类X的数组的地方，都可以使
用Y类型的对象数组。这个看起来很自然，但是需要在
Y ZY[] Z[]
图 7-1
175
176
177
120 第7章 语言符号、值和变量
运行时进行检查，而有时候我们并不希望进行这样的检查。X的数组可以包含Y对象的引用或
者Z对象的引用，但是Y的数组不能包含对X对象或者Z对象的引用。下面的代码在它的最后
两行运行时会产生ArrayStoreException异常，因为它违反了上面提到的规则：
// a Y array Y[] yArray = new Y[3];
// valid:Y is assignable to X X[] xArray = yArray;
XArray[0]= new YO);
// INVALID:can't store X in Y[] xArray[2]= new X(O);
// INVALID:can't store Z in Y[] xArray[1]= new ZO);
如果xArray是对真正的X[]对象的引用，那么在其中同时存储X和Z对象就是有效的。但是
xArray实际上是对Y[]对象的引用，所以在其中存储X引用或Z引用都是无效的。如果需要
确保在数组中没有存储不正确的引用，那么就需要在运行时检查像上面这样的赋值。
和所有的其他对象一样，数组创建之后都服从于正常的垃圾回收机制。它们继承了Ob ject的所有方法，并且还实现了Cloneable接口(见3.9节)和 Serializable接口(见20.8
节“对象序列化”)。由于数组没有定义自己的任何方法，仅仅继承了Object的方法，所以其
equals方法总是基于同一性的，而不是基于等同性的。java.util.Arrays类中的equals方
法(见21.12节“Arrays 工具类”)是通过计算基于数组内容的散列码来比较数组的等同性的。
在数组的“对象性”上存在的主要限制是它们不能被扩展，因而无法增加新方法。下面的构
造就是无效的：
class ScaleVector extends double[]{// INVALID
// ...
}
在某种意义上，数组的作用和 final类是一样的。
练习7.3:编写一个程序计算深度为12的Pascal 三角形，把三角形的每一行都存储到一个
长度适中的数组中，然后将所有的行数组都存储到一个包含12个int型数组的数组中。请设计
你自己的解决方案，使用每一个行数组的长度(而不是常数12)来打印结果。然后在不改变你的
打印方法的前提下，使用一个不是12的常数来打印结果。
7.5 名字的意义
标识符为程序中的许多事物都指定了名字，包括类型、变量、字段和方法等。当我们在程序
中使用了某个特定的名字时，编译器必须确定这个名字指的是什么,以便判断用户是否正确地
使用了该名字，从而保证生成正确的代码。确定名字意义的规则要在方便性和复杂性之间进行
权衡，在极端的情况下，语言可能要求程序中的每个名字都是唯一的，这种做法虽然简化了编
译器的工作，但是却给程序员带来了很多不便。如果对名字的解释是基于使用它的上下文环境
的，那么程序员就可以很方便地复用这些名字(例如始终用i作为 for循环的循环控制变量),
但是，编译器必须能够确定每个名字的意义，对所有阅读代码的人也是如此。
可以通过两种机制来实现名字管理：第一，为不同类型的名字分配不同的命名空间
(namespace);第二，采用作用字段来控制在某段程序中声明的名字对其他程序段的可见性。不
同的命名空间使得我们可以对方法或字段赋予相同的名字(尽管我们不推荐这样做),而作用字
段则使得用户可以对所有的 for 循环采用同名的循环控制变量。
在Java中有6种不同的命名空间：
·包名
7.5 名字的意义121
·类型名
●字段名
·方法名
·局部变量名(包括参数)
·标号
在程序中使用某个名字时，它的上下文会帮助确定该名字的类型。例如，在表达式x.f=3
中，我们知道f一定是字段，而不是包、类型、方法或标号，因为我们对它进行了赋值；同时，它
也不可能是局部变量，因为我们是把它作为x的一个成员来访问的。我们知道x一定是类型
名、字段或者局部变量的对象引用，具体是哪一种需要通过搜索包围其声明的作用字段来确定，
正如将要看到的那样。
在编写代码时(尤其是组合不同来源的代码时),使用隔离的命名空间可以为我们提供更大
的灵活性，但是，它有可能会被滥用。请考虑下面这段病态但完全有效的代码：
package Reuse;
class Reuse {
Reuse Reuse(Reuse Reuse){
Reuse:
for(;;){
if(Reuse.Reuse(Reuse)== Reuse)
break Reuse;
}
return Reuse;
}
}
每个名字的声明都有其可以使用的作用字段，具体的规则根据名字的类型(类型名、成员
名、局部变量等等)不同而有所不同。例如，方法中的参数的作用字段是整个方法体；局部变量
的作用字段是声明该局部变量的语句块；在 for 循环的初始化部分声明的循环变量的作用字段
是从该句开始，一直到 for循环结束。
名字不能在其作用字段之外被使用，例如，类中的一个方法不能引用另一个方法的参数。
然而，作用字段可以嵌套，内部作用字段可以访问在未进入它之前在外部作用字段中声明的所
有名字。例如，如果在方法体中声明了for 循环，那么 for循环的循环体就可以访问在该方法
中声明的局部变量。
当名字作为变量使用时，其含义是通过在不同的命名空间中搜索该名字声明的当前作用字
段和包围作用字段来确定的。搜索顺序如下：
1.搜索在语句块和 for 循环中声明的局部变量，以及作为 try语句的catch子句的参数
的局部变量，接着搜索在所有包围代码块中声明的局部变量。这条搜索规则将递归地应用于该
名字，直至找到包含上述语句块的方法，或者直到不再存在任何包围块为止(和初始化块的情
况一样)。
2.如果代码在方法或构造器中，则搜索方法或构造器的参数。
3.搜索类或接口的字段，包括所有可访问的继承而来的字段。
4.如果该类型是嵌套类型，则搜索包围块中的变量或包围类中的字段。如果该类型是静态
嵌套类型，则仅搜索包围类型的静态字段。这条搜索规则将持续作用于更外部的所有包围块和
包围类型。
5.搜索类或接口的静态字段，特别是在静态import语句中声明的字段。
178
179
180
181
122 第7章 语言符号、值和变量
6.搜索类或接口在按需静态import语句中声明的静态字段。
对于方法名的搜索过程和字段相似，只是从步骤3开始，就在当前的类或接口中搜索方法了。
确定如何访问类成员也有一些特殊的规则，正如将要在9.6节“成员访问”中看到的那样。
这个搜索顺序确定了将会找到哪个声明，这意味着在外部作用字段中声明的名字可以被在
内部作用字段中声明的名字所隐藏。例如，这意味着局部变量名可以隐藏类成员名，嵌套类成
员可以隐藏包围实例成员，局部声明的类成员可以隐藏继承而来的类成员'。
隐藏通常是一种不好的风格，因为人们在阅读程序的时候必须检查层次关系中的所有级
别，以确定正在使用哪个变量。然而，为了使本地代码更具有健壮性，仍然允许使用隐藏。如
果不允许隐藏外部变量，那么向类或接口中增加新的字段就可能会破坏子类中已有的代码，因
为这些代码可能使用了具有相同名字的变量。变量作用字段机制是为了向整个系统提供保护，
而不是为了向重用标识符名字提供支持。
为了避免混淆，不能在代码块的嵌套作用字段内使用隐藏。这意味着方法中的局部变量不
能和该方法的参数重名，for 循环变量也不能和局部变量或参数重名。例如，一旦代码块中有
一个局部变量名为über,我们就不能在其嵌套块中定义一个新的名字也为über的变量：
{
int über =0;
{
int über = 2;// INVALID:already defined
// ...
}
}
然而，在同一个代码块中或者在同一个方法的不同(非嵌套)代码块中，不同的(非嵌套)
for 循环可以使用相同的名字声明变量。
如果名字出现在期望出现类型名的地方，那么必须在不同的类型作用字段内搜索这个名
字。类型作用字段是通过包来定义的，其搜索顺序如下：
1.当前类型，包括继承类型。
2.当前类型的嵌套类型。
3.显式命名的导入类型。
4.在同一个包中声明的其他类型。
5.隐式命名的导入类型。
另外，类型名也可以被隐藏，但是类型总是可以通过它的完全限定名而被显式地引用，这
个完全限定名包括包信息，例如 java.1ang.String。包和类型导入将在第18章讨论。
为了从头开始制作苹果派，你必须首先创建整个宇宙。
——卡尔·萨根，《宇宙》
1.从技术上讲，术语隐藏(hiding)是为说明最后一种情况而保留的，即继承的成员被局部声明的成员所隐藏。其他
情况都被称作遮蔽(shadowing)。这两者没有明显的区别，所以本书中都直接称作“隐藏”。
第8章 包装器类
我要把自己装在信封中，
我要给自己涂点胶水，在头顶上贴些邮票!
我要把自己寄给你。
———伍迪·格思里(美国民谣大师),《我把自己寄给你》
将基本数据类型(byte、float等)和引用类型(类和接口)分离开完全是效率和熟悉度与表
达力和一致性的折中结果。和使用平凡的 int类型相比，使用对象可能会产生过多的开销，而
使用int类型则既快捷又方便，但是当我们需要把它存放到一张散列表中时，还是使用对象更
快捷、更方便。为了缓和这种分离所带来的矛盾，Java编程语言为每一种基本类型都提供了一
个包装器类(wrapper class),这些包装器类的层次关系如图8-1所示：
Object
Boolean Character Number Void
Byte Short Integer Long Float Double
图 8-1
Java语言在许多上下文环境中都提供了基本类型及其包装器类型之间的自动转换，特别是
在赋值和传递引元的时候。例如，我们可以编写：
Integer val=3;
val被赋值为引用了数值为3的Integer类的实例。
把基本类型的值转换为包装器对象的过程通常称为装箱转换(boxing conversion);反之，将
基本类型的值从包装器对象中提取出来的过程则称为拆箱转换(unboxing conversion)'。这些转
换将在8.6节“装箱转换”中详细讨论。这些自动转换使我们能够很容易地按照Object引用去
编写通用的类，它既可以处理引用类型，也可以处理基本类型。例如，HashMap类，它只能存
储对象引用，而不能存储基本数据类型(见21.8.1节“HashMap”),但是int类型的数据可以
作为键(key)传递给它，因为 int类型的数据能够被自动转化成 Integer类的实例。
int key = ...;
map.put(key, value);
我们使用int类型的变量可以保证效率和便利性，同时在需要时还可以获得与该基本类型相对
应的对象，真是两全其美。
使用包装器类型的另一个目的是为那些与类型相关的方法和变量(诸如字符串转换和值域
常量等)提供一个归宿。例如，下面的代码表示我们需要检查是否能够对某个特定的值进行快
1.使用包装和装箱这两个术语完全是历史原因。
183
184
185
124 第8章 包装器类
速单精度浮点运算，以及这个值所需的值域是否大于 float 基本类型所能提供的值域。如果确
实需要更大的值域，那么我们就必须对其进行基于 double的计算：
double aval = Math.abs(value);
if(Float.MAX_VALUE >= aval && aval >= Float.MIN_VALUE)
return fasterFloatCa1c((float) value);
else
return slowerDoubleCalc(value);
下面的小节我们将详细介绍每一种特定包装器类的方法和常量，但是首先让我们来看一看
大多数包装器类所共有的东西。
8.1 通用字段和方法
除了个别的说明以外，下面的小节定义的构造器、常量和方法都是为所有的包装器类定义
的。这些定义的事物有一个共同的例外，即Void类，它几乎什么都不支持，请查看8.2节。
对于将字符串转换为其他值的构造器和方法，每一个包装器类都定义了这些方法所能接受
的字符串的有效形式，这些内容将在每一个包装器类的小节中详细介绍。对于数值类型，无效
的字符串格式会导致抛出 NumberFormatException异常。
在包装器类的许多地方都用到了术语基数(radix),它是数值基数的另一种称法。例如，将
长整型(long)数解码(decode)为以8为基数的数意味着要将这个数解码为以8为数字基的数。
基数允许的范围为2~36。
在下面的描述中，Type指的是包装器类，而 type指的是相应的基本类型。
8.1.1 构造
每一个包装器类都为它所包装的基本类型值定义了一个不可变的对象，这意味着一旦创建
了某个包装器对象，该对象所代表的值就不能再改变了。因此如果通过new Integer(1)语句
创建了一个对象，它的值将始终保持为1,而且没有任何Integer类的方法可以让我们去改变
这个值。
每一个包装器类都有下面这样的构造器：
·接受一个基本类型的值，并创建一个与之相应的包装器类对象的构造器。例如构造器
character(char)和Integer(int)。
·将单一的一个String 参数转换为包装器类对象初始值的构造器(Character类型除外，
它没有这样的构造器),例如 new Float("6.02e23")。
每一个包装器类 Type都包含以下方法：
· public static Type valueof(typet):该方法返回一个指定的 Type类型的对象，其
值为t。
· public static Type valueof(String str):该方法返回一个指定的 Type类型的对
象，其值是通过解析 str得到的，例如 Float.valueof("6.02e23")和 Integer.val ueof("16")。Character类没有该方法，就像它没有字符串转换的构造器一样。
这些方法可以返回全新构造的实例或者已缓存的实例。出于效率方面的考虑，我们应该总是优
先使用 valueof方法，而不是直接使用构造器，除非我们确实需要具有相同值的不同实例。
8.1.2 常量
每一个包装器类，除Boolean类之外，都定义了以下三个字段：
8.1 通用字段和方法 125
·public static final type MINLVALUE:该字段定义了这种数据类型所能表示的最小
值。例如，对Integer来说这个最小值为-23。
· public static final type MAX_VALUE:该字段定义了这种数据类型所能表示的最大
值。例如，对Integer来说这个最大值为231-1。
·public static final int SIZE:该字段定义了表示这种类型的数据所需要的数字位
数。例如，对于Integer来说这个值为32。
所有的包装器类都定义了下面这个字段：
·public static final class<Type> TYPE:该字段是一个对Class 对象的引用，这
个Class 对象表示的是与这种数据类型相对应的基本类型。从像7.2.7节所述的那种
.class类字面常量表达式中所得到的Class 对象与该字段是等同的。例如，Integer.
TYPE与我们从 int.class 表达式所得到的对象相同。需要注意的是int.class 和In teger.class会产生两个不同的class实例，它们都具有Class<Integer>类型。
8.1.3 公共方法
每一个包装器类都实现了Comparable<T>接口，因此它们定义了下面的方法：
·public int compareTO(type other):该方法将被调用了该方法的对象与作为参数传
递进来的对象(具有相同类型 Type)进行比较，按照小于、等于或大于关系分别返回小于
0、等于0或大于0的值。
对于数值类型，这种比较遵循的是通常的数学法则；但是，Float 和Double具有与
float和double不同的特定的排序属性，见8.4.2节。对于Boolean,值 true 比
false大，这一点与 boolean不同，boolean没有定义关系操作符“<”和“>”。对于
character,这种比较执行的是严格的数值比较，根本没有考虑字母表顺序或区域特定
的顺序。
每一个包装器类都提供了一个用来提取它所包装的值的方法：
· public type type valueO:该方法返回与当前的包装器类对象相对应的基本类型值。
例如，Integer.valueof(6).intvalue()返回6。
每一个包装器类都覆盖了下列的Object成员：
·public String tostringO:该方法返回一个表示这个包装器类对象所包装的值的字
符串。对于数值型包装器类，总是使用十进制来表示。
·public boolean equals(object obj):如果两个对象类型相同且包装的是相同的值，
则该方法返回true。例如，对于两个 Integer 对象x和y,当且仅当x.intvalueO=
=y.intvalue()成立时，x.equals(y)为true。如果obj与当前对象的类型不同，或
者为空(null),则返回 false。
·public int hashcodeO):该方法返回一个可用于散列表的基于所包装对象的值的散列
码。
下面的其他方法提供了基本类型值与字符串之间的相互转化：
· public static type parsetype(String str):该方法将字符串str转换为一个具有
指定基本类型 type的值。例如，Integer.parseInt("10")返回的值为10。这等价于
先调用一个用字符串转换的构造器，然后使用 typevalue()方法提取出结果，但该方法
并不构造对象。Character中没有这个方法，就像它没有字符串转换的构造器一样。
·public static String tostring(typeval):该方法返回一个表示给定基本类型值的
186
126 第8章 包装器类
字符串。例如，Double.tostring(0.3e2)返回字符串"30.0"。
所有的包装器类都有这些方法，因此我们并没有把它们列举在每一个包装器类的描述中。包装
器类的系统属性的获取和解码方法将在23.1.2节“系统属性”中详细介绍，因此本章将不对此
进行讨论。
8.2 Void类
对于上述所有的规则，Void类是一个例外。这是因为它没有包装任何值，没有提供任何方
法，而且也不能被实例化。它只有一个静态的 TYPE 字段，该字段包含了一个对Class 对象
void.class的引用。Java语言没有 void基本类型，void仅仅是表示没有返回类型的占位符。
Void类表示缺少实际的返回类型，并且它仅用于反射(见16.7节“Method类”)。
8.3 Boolean类
Boolean类是boolean类型的包装器类。它的解码字符串的构造器、valueof方法和
187parseBoolean方法都能够将字符串"true"理解为 true,而不管该字符串的大小写是如何混
杂的。所有的其他字符串都会被解释为 false。
Boolean类有两个静态的对象引用，它们分别对应于每一个基本的 boolean类型值：
Boolean.TRUE 和 Boolean.FALSE。
8.4 Number类
Number类是一个抽象类，它被所有表示基本数字类型的包装器类(Byte、Short、Inte ger、Long、Float和Double)所扩展。
Number类的抽象方法返回的是其对象被转换成的基本类型值：
public byte byteValueO
public short shortvalue(
public int intvalue()
public long longvalueO
public float floatvalueO
public double doublevalueO
每一个扩展自Number的类都覆盖了这些方法，在与显式的强制转换相同的规则下，它们将其
自己的类型转换成了所需的其他类型。例如，假设有一个值为32.87的Float 对象，在该对象
上调用intvalue得到的返回值是32,这和强制转换(int)32.87得到的结果相同。
8.4.1 整型包装器
类 Byte、Short、Integer和 Long都扩展自 Number,它们以类的形式表示了相应的整数
类型。除了标准的Number方法，每一个整型包装器类都支持以下方法：
·public static type parseType(String str,int radix):该方法使用给定的基数
将字符串 str 转化为一个指定类型(type)的数值。例如，Integer.parseInt
("1010",2)返回10,而Integer.parseInt("-1010",2)返回-10。字符串中的字
符必须都是有效的给定基数的数字，只有第一个字符可以用减号来表示这是一个负数
值。如果str包含任何其他字符(包括前导和结尾的空白字符),或者字符串表示的数值
8.4 Number类 127
超出了该类型所能表示的范围，又或者是radix超出了范围，那么都将会抛出一个Num berFormatException异常。
· public static Type valueof(String str, int radix):该方法返回一个类 Type的
包装器对象，该对象的值是用指定的基数对 str解码而得到的。需要注意的是，没有与
这种形式等价的构造器，这个方法等同于一个两步骤的过程：解析字符串，然后使用这
个值构造一个新的包装器对象。例如，Integer.valueof("1010",2)等价于 new In teger(Integer.parseInt("1010",2))这样一个复杂的表达式。
· public static Type decode(String str):该方法返回一个类 Type的包装器对象，
该对象的值是从 str中解码出来的。若该字符串以减号开始，则它所表示的就是负数。
数字的基数也是从 str中解码出来的：十六进制数以#、0x或者0X开头，而八进制数则
用以0开头的字符串表示，除此之外的其他数字都被视为十进制数。这与parse Type和
valueof方法不同，在这些方法中我们必须传递一个基数作为引元。例如，Long.de code("OxABCD")会返回一个值为43981的long型数值，而Long.decode("ABCD")则
会抛出 NumberFormatException异常。与此相反的是，Long.parseLong("OxABCD",
16)会抛出 NumberFormatException异常，而Long.parseLong("ABCD",16)则会返
回一个值为43981的long型数值。(字符#用于在多种外部数据格式中表示十六进制数，
因此 decode 方法能够很方便地理解它。)
对于每一个包装器类，基于字符串的构造器、parseType(string str)方法和 valueof方法的
执行与 parse Type(String str,int radix)一样，如果没有指定基数就会使用十进制。
此外，Integer和 Long 还都拥有以下方法，其中 type表示 int或long:
·public static string tostring(typeval,int radix):该方法返回一个以给定基
数表示给定值的字符串。如果基数超出了范围，就会用10作为基数。
· public static String toBinarystring(type val):该方法返回一个以二进制补码
表示给定值的字符串。对于正数，这个值与 tostring(value,2)所得到的值相同。对
于负数，其负号被编码进了二进制位中，因此得到的值不是一个以减号开始的字符。例
如，执行Integer.toBinarystring(-10)会返回"11111111111111111111111111110110"。
这些表示负数的字符串不能使用对应的parseType方法，因为对于给定的类型，这些字
符串所表示的值总是超出其MAX_VALUE。
·public static String tooctalstring(typeval):该方法返回一个以无符号的八进
制格式表示给定值的字符串。例如，执行 Integer.tooctalstring(10)会得到"12"。
负数值的处理方法和 toBinarystring 中所描述的方法一样。例如，执行 Integer.
tooctalstring(-10)会得到"37777777766"。
·public static String toHexstring(typeval):该方法返回一个以无符号的十六进
制格式表示给定值的字符串。例如，执行Integer.toHexString(10)会得到"a"。负
数值的处理方法和 toBinarystring 中所描述的方法一样。例如，执行Integer.to Hexstring(-10)会得到"fffffff6"。
注意，上述字符串格式中没有任何一种包含关于在这种格式中所使用的基数的信息，也就是说，
在这些字符串中，没有表示八进制的前导0或表示十六进制的前导0x。如果需要基数信息，我
们就必须自己构造它。
Short、Integer和Long 这些类都有一个 reverseBytes 方法，这个方法所返回的值的字
节排列顺序与传入的值相反。例如，Integer.reverseBytes(0×0000ABCD)将返回一个表示
188
189
190
128 第8章 包装器类
十六进制的0xCDAB0000的int型数值。Integer和Long还提供了一组位查询方法：
·public static int bitcount(typeval):该方法返回 val的二进制补码中1的个数。
·public static type highestoneBit(typeval):该方法返回的值中只有一位是1,其
余位均为0,并且这一位1在返回值中的位置和 val中最高位(最左边)的1的位置相同。
· public static type lowestoneBit(type val):该方法返回的值中只有一位是1,其
余位均为0,并且这一位1在返回值中的位置和 val中最低位(最右边)的1的位置相同。
·public static int numberofLeadingZeros(typeval):该方法返回将 val的最高位
的1之前的所有位用0补齐的值。
· public static int numberofTrailingzeros(typeval):该方法返回将 val的最低
位的1之后的所有位用0补齐的值。
· public static type reverse(typeval):该方法返回的值是通过将val的二进制位
逆序排列得到的。
·public static type rotateLeft(type val, int distance):该方法返回的值是通
过将 val的各个二进制位向左循环移位得到的。在左移过程中，最高位将从左边移出。
并成为右边的最低位。如果左移的距离是负数，则相当于右移正数个单位的距离。
·public static type rotateRight(typeval,int distance):该方法返回的值是通
过将 val的各个二进制位向右循环移位得到的。在右移过程中，最低位将从右边移出，
并成为左边的最高位。如果右移的距离是负数，则相当于左移正数个单位的距离。
最后，Integer和Long 都定义了数学上的signum函数，这个函数接受一个值并根据这个
值是负数、0还是正数分别返回-1、0或+1。
8.4.2 浮点型包装器类
Float类和 Double类都扩展了Number类，它们以类的形式表示了float类型和 double
类型。除个别例外，这两个类型的方法和常量的名字都是相同的。在下面的列表中，虽然只列
出了Float类的方法，但是如果我们把其中的 Float和 float分别替换为 Double和 double,
那么就可以得到 Double类中与之对应的字段和方法。除了标准的 Number类方法之外，Float
和 Double都拥有下列常量和方法：
· public final static float POSITIVE_INFINITY:该常量表示+的值。
· public final static float NEGATIVE_INFINITY:该常量表示-0的值。
·public final static float NaN:表示非数(NaN)。这个常量为我们提供了一种无需
比较测试某个值就可以得到NaN值的途径。我们可能会觉得有些奇怪的是，NaN= =
NaN 总是false,这是因为NaN 值不是一个数，它不等于任何数值，甚至不等于它自身。
为了测试一个数是否是NaN,必须使用isNaN方法。
·public static boolean isNaN(float val):如果 val是一个NaN值，则该方法返回
true。
· public static boolean isInfinite(float val):如果val是正无穷或者负无穷，则
该方法返回true。
· public boolean isNaNO:如果该对象的值是一个NaN 值，则该方法返回 true。
·public boolean isInfiniteO):如果该对象的值是正无穷或负无穷，则该方法返回
true。
除了通常的构造器形式以外，Float 还有一个构造器，它能够接受一个 double型的引元，
8.5 Character类129
并在将其转化为 float型之后作为自己的初始值。
与float和 double类型的值相比，Float和 Double对象的行为与之完全不同。这两个
包装器类都定义了一个排序规则，该顺序认为-0小于+0,NaN大于所有的值(包括+0),所
有的NaN 彼此都是相等的。
当转换成字符串时，NaN 值返回字符串"NaN",+0返回"Infinity",-○返回"-In finity"。接受字符串的构造器和 parse Type方法都是按照 valueof方法的形式定义的，该
方法接受以下形式的字符串：
·"NaN"值或带有可选前导字符+或-的"Infinity"
·浮点字面常量
·十六进制浮点字面常量
与整型包装器类不同的是，接受到的字符串要先去掉前导和结尾的空白分隔符。如果字面
常量的形式包含float 或 double后缀指示符，例如"1.0f",那么这个指示符会被忽略掉，并且这
个字符串会直接转换为所请求类型的值。
为了让我们能够操作浮点值表示中的各个位，Float 提供了将其作为 int型而获取其 int
型位模式的方法，同时还提供了将int型位模式转换为 float 数值的方式(按照适当的 IEEE
754单精度浮点数位布局标准)。Double类提供了等价的方法，在double数值与long型位模
式之间进行相互转换：
·public static int floatTOIntBits(float val):该方法返回一个 int值，该值是
float数值的位表示。所有的NaN 值都总是用相同的位模式来表示。
·public static int floatTORawIntBits(float val):除了对NaN 会返回确切的位模
式外，该方法等价于floatTOIntBits,它不是将所有的NaN都映射为同一个值。
· public static float intBitsToFloat(int bits):该方法根据给定的位模式返回对
应的 float值。
8.5 Character类
Character类将 char类型表示成了类，它提供了可以确定字符类型(字母、数字、大写等)
和在大小写之间进行相互转换的方法。
由于char是16位的数值，而Unicode 允许21位的字符，即所谓的代码点(code point),所
以许多 Character类的方法都被重载了，以使它能够接受表示任意代码点的 char型数值和
int型数值。这些方法将在下面穿插讲解，伪类型 codepoint将用来表示char或int类型的
代码点数值。
除了MIN_VALUE和MAX_VALUE 这两个常量以外，character类还提供了两个常量MIN_
RADIX和MAX RADIX,它们是在数字字符和整型数值之间进行相互转换的方法所能理解的最小
基数和最大基数，而基数必须在2~36的范围之内，大于9的数值的数字用字母A~Z或者它们
的小写形式来表示。以下三个方法实现了字符和整型值之间的相互转换：
·public static int digit(codepointch,int radix):该方法返回ch被当作给定基
数中的数字时所表示的数值。如果基数无效或者ch不是给定基数中的数字，则方法返
回-1。例如，digit('A',16)将返回10,digit('9',10)返回9,而digit('a',10)
返回-1。
·public static int getNumericvalue(codePoint ch):该方法返回数字ch表示的数
值。例如，字符\u217F是罗马数字M,因此 getNumericvalue('\u217F')将返回
191
192
193
130 第8章 包装器类
1000。这些数值都是非负的。如果ch没有对应的数值表示，则方法返回-1;如果它有
对应的数值但不是非负的整型值，例如分数值1/4('u00bc'),那么 getNumericvalue
方法将返回-2。
· public static char forDigit(int digit, int radix):该方法返回指定数字在指定
基数中的字符值。如果该数字在指定的基数中是无效的，那么该方法返回字符
'u0000'。例如，forDigit(10,16)返回'a',而 forDigit(16,16)返回'u0000'。
Unicode 中有三种字符状态：大写、小写和标题。大写和小写是大多数人所熟悉的，标题是
用来区别那些由几个部分构成的多个字符的，这些字符在用作标题时通常会有不同的写法，即
单词中的首字母通常是大写的。例如，在字符串"ljepotica"中，首字母是小写的字母lj
(u01c9,一个在扩展拉丁字符集中用来书写克罗地亚文中双字母单音字的字符)。如果这个
词出现在书本的标题中，并且希望每一个单词的首字母都大写时，正确的步骤是对每一个单词
的首字母使用toTitleCase方法，从而得到"Ljepotica"(其中Lj的 Unicode码为\u01c8)。
如果错误地使用 touppercase,就会得到错误的字符串"LJepotica"(其中LJ的 Unicode码为
u01C7)。
所有的字符写法问题都是按照 Unicode 中给出的定义来处理的。例如，在格鲁吉亚文中，
大写字母被认为是古代的写法，并且通常避免使用大写字母。因此，尽管 toLowerCase方法会
将大写的格鲁吉亚字母转换为小写形式，但是toupperCase方法并不会将小写的格鲁吉亚字
母转换成大写形式。正因为这种复杂性，我们不能假定将所有的字符全部转换成大写或小写，
然后比较它们的结果就可以得到忽略大小写的比较结果。无论如何，下面的表达式都会返回一
个字符：
character.toupperCase(character.toLowercase(ch));
我们可以将该字符与另一个构造相似的字符进行比较，从而按忽略大小写的方式测试两者是否
相等。如果产生的两个字符相等，那么我们就可以判定这两个字符除了大小写形式可能会有所
不同之外，在其他方面全都相同。大小写转换的方法如下：
·public static codePoint toLowercase(codePointch):该方法返回ch对应的小写
字符。如果该字符没有相应的小写形式，就会直接返回ch本身。
·public static codepoint touppercase(codePointch):该方法返回ch 对应的大写
字符。如果该字符没有相应的大写形式，就会直接返回ch本身。
·public static codePoint toTitlecase(codePointch):该方法返回一个与ch相对
应的标题形式的字符。如果该字符没有相对应的标题形式，就会返回 touppercase
(ch)的结果。
Character类有许多方法可以用来测试一个给定的字符是否属于任意的 Unicode字符集中
的某个特定类型(例如，isDigit方法能识别某个字符是埃塞俄比亚文中的数字还是高棉文中
的数字)。这些方法接受一个char或 int类型的代码点，并返回 boolean类型的测试结果。
这些方法如表8-1所示。
我们还可以测试一个char类型的值是低位字符代理(isLOwSurrogate)还是高位字符代
理(isHighsurrogate),一个具体的 int类型代码点是Unicode 增补代码点(isSupplemen tarycodepoint)还是16位的 Unicode基本代码点(isvalidcodePoint),以及一个char类型
的值对是否是代理字符对(issurrogatePair)。
1.“Ljepotica”是克罗地亚语中“美女”的爱称，它经常被用作表示钟爱和钦佩。
8.5 Character类131
表 8-1
方法 该字符……
isDefined 是否定义过的Unicode字符?
isDigit 是否数字?
isIdentifierIgnorable 是否在任何标识符中都可以被忽略(比如方向控制指示符)?
isISOControl 是否ISO控制符?
isJavaIdentifierstart 作为源代码标识符的第一个字符是否有效?
isJavaIdentifierPart 作为源代码标识符第一个字符后面的字符是否有效?
isLetter 是否字母?
isLetterorDigit 是否字母或数字?
iSLOwerCase 是否小写字母?
isspacechar 是否空格?
iSTitleCase 是否标题形式的字母?
isunicodeIdentifierstart 作为Unicode标识符的第一个字符是否有效?
isunicodeIdentifierPart 作为Unicode标识符第一个字符后面的字符是否有效?
isUpperCase 是否大写字母?
iswhitespace 是否源代码中的空白分隔符?
Unicode标识符是由 Unicode 标准定义的。Unicode标识符必须以一个字母开头(连接符如
“_”,货币符号如“￥”等在 Unicode 中都不是字母，虽然它们在Java 编程语言中是字母),并且
只能包含字母、连字符(如“_”)、数字、数字字母(如罗马数字)、组合标记、非空白标记或可忽略
的控制字符(如文本方向指示符)。
所有这些类型的字符以及其他一些字符都是由Unicode标准定义的。静态方法 getType返
回一个int值，用于定义该字符的Unicode类型，其返回值是如下的一些常量：
194
COMBINING_SPACING_MARK
CONNECTOR_PUNCTUATION CONTROL
CURRENCY_SYMBOL DASH_PUNCTUATION DECIMAL_DIGIT_NUMBER
ENCLOSING_MARK
END_PUNCTUATION
MODIFIER_LETTER
MODIFIER_SYMBOL
NON_SPACING_MARK
OTHER_LETTER
OTHER_NUMBER
OTHER_PUNCTUATION
OTHER_SYMBOL
FINAL_QUOTE_PUNCTUATION
FORMAT
INITIAL_QUOTE_PUNCTUATION
LETTER_NUMBER
LINE_SEPARATOR
LOWERCASE_LETTER
MATH_SYMBOL
PARAGRAPH_SEPARATOR
PRIVATE_USE
SPACE_SEPARATOR
START_PUNCTUATION
SURROGATE
TITLECASE_LETTER
UNASSIGNED
UPPERCASE_LETTER
Unicode被划分为一些由相关字符构成的块，静态嵌套类 character.Subset 就被用来定
义这些 Unicode字符集的子集。静态嵌套类 character.UnicodeBlock 扩展了 Subset,用来
定义标准 Unicode字符块的集合，这些块可以从静态字段 UnicodeBlock 中获得。静态方法
UnicodeBlock.of返回一个表示某个特定字符所属的 Unicode字符块的 UnicodeBlock 对象。
195
196
132 第8章 包装器类
UnicodeBlock类还为所有这些块定义了一些常量，例如 GREEK、KATAKANA、TELUGU 和 COM BINING_MARKS_FOR_SYMBOLS。of方法会返回这些值中的某一个，或者在指定字符不属于任
何一个Unicode字符块时返回 nul1。例如，以下代码：
boolean isShape =
(Character.UnicodeBlock.of(ch)==
Character.UnicodeBlock.GEOMETRIC_SHAPES);
可以测试一个字符是否属于GEOMETRIC_SHAPES块。
如果两个Subset 对象是相同的对象，那么它们定义的就是相同的 Unicode子集，这项语义
之所以能够得以执行，是因为在 Subset类中将 equals和hashcode声明成了final的，并且
在定义这些方法时，为这些方法定义了默认的Object行为。如果出于某些原因我们需要定义
自己的子集，那么我们应该提供一种和of方法相似的方式，使得对于我们定义的每一种不同子
集，都可以得到与其相对应的单一的 Subset 对象。
使用UTF-16字符集
使用字符序列时，无论是char数组、字符串还是其他实现了charSequence的类型(见第
13章),都会因为增补字符需要被编码为一个char值对而变得复杂。为了简化这个步骤，
character类定义了一组方法来协助编码和解码代理对，并计算它们在字符值序列中的出现次
数：
·public static int charCount(int codepoint):该方法返回编码给定的代码点所需
的char数值的个数。对于增补字符，其返回值为2,否则返回值为1。
·public static int codePointAt(char[]seq,int index):该方法返回 seq 中给定
下标处所定义的代码点，此处将增补字符处理为由 seq[index]和 seq[index+1]构
成。该方法有一个接受附加 limit引元的变体，其中引元限制所使用的 index+1必须
小于引元所指定的值。
·public static int codePointAt(Charsequence seq,int index):该方法返回 seq
中给定下标处所定义的代码点，此处将增补字符处理为由 seq.charAt(index)和 seq.
charAt(index+1)构成。
·public static int codePointBefore(char[] seq, int index):该方法返回 seg中
给定下标处之前定义的代码点，此处将增补字符处理为由 seq[index-2]和 seq[in dex-1]构成。该方法有一个接受附加 start引元的变体，其中引元限制所使用的 in dex-1和index-2必须大于或等于该引元所指定的开始位置。
·public static int codePointBefore(CharSequence seq,int index):该方法返回
seq中给定下标处所定义的代码点，此处将增补字符处理为由 seq.charAt(index-2)
和 seq.charAt(index-1)构成。
·public static int codepointcount(char[]seq,int start,int count):该方法
返回从 seq[start]到seq[start+1ength]的字符中所定义的代码点的个数，并考虑
了使用代理对的情形。任何不成对的代理值都会被当作一个单一的代码点来处理。
·public static int codePointcount(CharSequence seq,int start,int end):该
方法返回从 seq.charAt(start)到seq.charAt(end)的字符中所定义的代码点的个
数，并考虑了使用代理对的情形。任何不成对的代理值都会被当作一个单一的代码点来
处理。
8.6 装箱转换 133
· public static int offsetBycodepoints(char[] seq, int start,int count, int
.index, int numberofcodepoints):该方法返回 seq数组中从 index开始跳过 num berofcodePoints个代码点处的下标值，该方法仅考虑从 seq[start]到 seq[start+
length]的子数组，同时也考虑到了代理对。该方法通过跟踪代理对，使得我们可以跳
过给定数量的代码点，而不必人为地循环数组。对于找到的任何不成对的代理值，都将
算作是一个代码点。
· public static int offsetByCodePoints(CharSequence seq,int index, int
numberofcodePoints):该方法返回CharSequence 中从 index开始跳过numberof Codepoints个代码点处的下标值，并考虑到了代理对的情况。
·public static char[] tochars(int codepoint):该方法将给定的代码点转换为它
的UTF-16表示，即包含一个char或两个char的数组。如果给定的codepoint无效，
则会抛出IllegalArgumentException异常。
· public static int tochars(int codepoint,char[] dst, int dstBegin):该方法
将给定的代码点转换为它的UTF-16表示，将结果存放在数组 dst 中以 dst[dstBe gin]开始的位置，并返回写入该数组的字符数(1或2)。如果给定的 codepoint无效， 197
则会抛出IllegalArgumentException异常。
·public static int tocodePoint(char high, char low):该方法将给定的char值
代理对转换为它们所表示的增补代码点的值。该方法不检查 high 和low构成的代理对
的有效性，因此我们必须自己用isSurrogatepair检查它们的有效性。
所有这些使用下标的方法都可以抛出 IndexoutofBoundsException异常，如果我们试图访问
的下标超出了给定数组或 CharSequence的范围，那么由于对下标有效范围存在着强制性的限
制，所以这些访问将产生这个异常。
8.6 装箱转换
基本类型的变量能够自动转换为它的包装器类的实例，这种自动转换被称为装箱转换。包
装器对象就像“箱子”一样，其中存放着相应的基本类型的值。其反向转换(即将包装器类的实
例转换为基本类型值的转换)被称为拆箱转换。
装箱转换会将所有基本类型的值v都替换为与其具有相同值的包装器对象，包装器对象的
类型与v的类型是相对应的。例如，假定
Integer val =3;
那么 val将引用一个Integer 对象，因为3是一个int型的值；val.intvalueO将返回值3。
拆箱转换会接受一个包装器对象的引用并提取出它的基本类型值。拿上面那个例子来说，
int x= val;
等价于显式的
int x= val.intvalue();
其中，变量x的值为3。如果 val是一个 short引用，那么在对 val拆箱的过程中将会调用
val.shortvalue(),其他类型的拆箱转换也与此类似。如果该包装器引用为nul1.那么这个
拆箱转换将抛出 NullPointerException异常。
装箱转换和拆箱转换在许多上下文环境中都会被自动应用，例如在赋值和引元传递时，因
此基本类型和引用类型几乎是可互换使用的。然而，这种转换并不是在任何场合都能进行的，
特别是不能像处理对象那样直接解除对基本类型的变量或值的引用。例如，给定一个int型变
198
199
134 第8章 包装器类
量x(同上),表达式x.tostringO)是通不过编译的，但是，我们可以通过先对其进行强制转换
来解决这个问题，例如：
((object)x).tostring()
能够自动进行装箱和拆箱的确切的上下文环境将在9.4节“类型转换”中讨论。
理想情况下，我们可以在任何需要的地方使用装箱转换，而无需再三考虑。实际上，我们
需要意识到，装箱转换可能需要分配一个包装器类的实例，这将会消耗内存，而且可能会由于
内存不足而失败。由于包装器类是不可变的，所以两个拥有相同值的对象是可以互换使用的，
因此实际上不需要创建拥有相同值的两个不同的包装器类对象。Java语言中存在着这样一个事
实：对于某些类型来说，在其某些值域内进行的对相同值的装箱转换将总是产生相同的对象。
这些类型和值域如表8-2所示：
表 8-2
类型 值域
boolean true,false
byte 所有值
char u0000~ u00ff
short -128~127
int -128～127
假定我们有下面的方法：
static boolean sameArgs(Integer a,Integer b){
return a == b;
}
那么,下面的调用将返回true:
sameArgs(3,3)
而下面的调用将返回 false:
sameArgs(3,new Integer(3))
虚拟机的实现可以选择去扩充这些类型和值域。我们可以随意确定何时创建包装器类的实
例：可以早早地创建它们并将其存储在一个查找表中，或者可以在需要时创建它们。
要敢于天真。
——R.巴克敏斯特·富勒(美国哲学家、建筑师及发明家)
第9章 运算符和表达式
工作有两种：
第一种，改变位于或靠近地球表面的物质相对于其他物质的位置；
第二种，让别人去这么做。
——伯特兰·罗素(英国哲学家、数学家)
本章将介绍编程语言基本的计算要素，即运算符和表达式。我们现在已经见过了许多代
码，对代码的组成元素也很熟悉了，本章将详细描述这些基本元素。
在讲解每一个运算符时，我们都会介绍它的基本操作，以及这些基本操作所作用的操作数
的类型，例如是一个基本数值类型还是一个引用类型。程序中表达式的实际求值过程还可能会
涉及9.4节所描述的类型转换。
9.1 算术运算
以下列出的是可以在所有基本数值类型上运算的二元算术运算符：
加法 +
-
减法
* 乘法
/ 除法
% 取余
Java还使用一元的-运算符来取反。下面便是将一个数的符号取反的代码：
val = -val;
为了确保完整性，Java还有一元的+运算符，如+2.0。
这些二元算术运算符的确切动作取决于涉及的操作数的类型。接下来的小节将介绍整数运
算和浮点运算的不同规则。
9.1.1 整数运算
整数运算是模2的补码运算(modular two's-complement arithmetic),也就是说如果一个值
超出了其类型(int或long)的范围，那么它的值就是以这个范围值为模，减去模的结果。因此
整数运算决不会有上溢(overflow)或下溢(underflow),只会出现回绕(wrap)的情况。
整数除法采用了向0舍去的方式(7/2等于3,而 -7/2等于-3)。对于整数类型来说，
除法运算和取余运算遵循以下规则：
(×/y)*y+×y==×
所以7等于1,而-7等于-1。在整数运算中，被0除或被0除取余都是非法操作，会抛
出ArithmeticException异常。
字符运算其实就是将char 隐式转换成 int之后的整数运算，见9.3.2节“表达式类型”。
201
202
136 第9章 运算符和表达式
9.1.2 浮点运算
浮点运算既有可能产生结果为无穷大的上溢(对于 double类型或float类型数值过大),
又有可能产生下溢(对于 double类型或 float类型数值过小)。下溢会导致精度丢失，可能足
以产生0值'。对于非法表达式，例如用无穷大除以无穷大，其结果是用NaN 表示的，即“非数
(Not-a-Number)”。
有穷大的操作数的运算是在double或 float类型的精度限制范围内按照我们的期望执行
的，并且所产生的浮点运算结果的正负符号也和我们的预期相同。两个相同符号的数相乘，其
结果为正数；两个不同符号的数相乘，其结果为负数。
两个无穷大相加，如果它们符号相同，则其结果是同符号的无穷大；如果它们符号不同，则
其结果为NaN。符号相同的无穷大相减，结果为NaN;符号不同的无穷大相减，结果为与左操
作数符号相同的无穷大。例如，(-(-0))等于。。凡是涉及NaN 的算术运算，其运算结果
都是NaN。上溢将产生带有对应符号的无穷大，下溢也将产生带有对应符号的零值。浮点运算
中有负0值即-0.0,它和+0.0是相等的，尽管它们的值相等，但这两个0还是会产生不同的
结果。例如，表达式1f/0f结果为正无穷大，而1f/-0f结果为负无穷大。
如果下溢的结果为-0.0,并且假设-0.0==0.0,那么我们怎样测出这个负0值呢?我
们必须在一个符号敏感的表达式中使用这个0值，才能测出结果。例如，如果x为一个0值，那
么表达式1/x将产生负无穷大(当×为负0值时)或正无穷大(当x为正0值时)。
关于无穷大的运算规则和常规的数学运算是一致的。某个无穷大加上或减去任何数，其结
果还是那个无穷大。例如，对于任何有穷数x,(-∞+x)的结果均为-0。
我们可以使用包装器类 Float和Double中的常量 POSITIVE_INFINITY和NEGATIVE_IN FINITY来得到一个无穷大值。例如，Double.NEGATIVE_INFINITY是double类型的负无穷
大值。
无穷大和0相乘，结果为NaN。无穷大和一个非0的有穷大的数相乘将产生对应符号的无
穷大。
浮点除法和取余运算可能会产生无穷大或NaN 的结果，但是决不会抛出异常。表9-1显示
了各种组合的结果：
表 9-1
X y x/y xy
无穷 ±0.0 ±的 NaN
无穷 ±0 ±0.0 X
±0.0 ±0.0 NaN NaN
±0 无穷 ±四 NaN
±的 ±0 NaN NaN
另外，浮点取余运算(???前面所描述的整数取余运算很类似，其他不同的取余运算见22.9节
“Math类和 StrictMath类”一节中的 IEEEremainder方法。
练习9.1:编写一段程序，分别以+、-、*、/为运算符，以两个无穷大为操作数，然后显示
1.探测非0下溢是一个复杂的问题，超出了本书的范围。
9.2 通用运算符 137
运算结果。要确保你既尝试了同符号无穷大的运算，也尝试了符号相反的无穷大的运算。
9.1.3 严格浮点运算和非严格浮点运算
浮点运算有两种运行模式：严格浮点模式(FP-strict)和非严格浮点模式(not FP-strict)。
为简单起见，我们分别称之为严格模式(strict)和非严格模式(non -strict)。严格浮点运算遵循
精确浮点运算的限制规则：当我们执行严格浮点运算的代码时，在所有的Java 虚拟机实现上的
运行结果都是精确相等的。非严格模式的浮点运算的运行规则有所放松，这些规则允许使用某
些浮点表示方法，以避免在严格运算中会产生的上溢或下溢。这就意味着在不同的虚拟机上，
某些非严格浮点运算的应用可能会产生不同的运行结果。非严格浮点运算的执行速度也可能要
比严格浮点运算快，因为那些放松的规则允许使用底层硬件直接支持的表示方法。
浮点运算的严格性由是否有strictfp修饰符决定，它可以用来修饰类、接口或方法。当声
明一个方法是strictfp时，该方法中的所有代码都会遵循严格限制规则来执行。当使用
strictfp来修饰类或接口时，其中的所有代码(包括初始器和嵌套类型中的代码)都会在严格
模式下执行。要判断一个表达式是否是严格的，需要检查所有包含这个表达式的方法、类和接
口；如果其中任何一个被声明为 strictfp,那么这个表达式就是严格的。例如，如果在严格的
外部类或严格的方法中声明了一个内部类，那么这个内部类也是严格的。但是，严格性不可继
承，类或接口声明中出现 strictfp并不意味着它的扩展类或接口也是严格的。
使用到浮点数的常量表达式始终是在严格模式下执行的，反之，如果不需要计算结果可重
复，那么在这个原则之下，可以执行没有标记为 strictfp的代码。如果我们想在所有的Java
虚拟机实现之间保证逐位的精确结果，就必须在相关的方法、类和接口上使用 strictfp修饰
符。我们还应该注意一点，虚拟机可以总是按严格模式的执行方式来满足非严格浮点运算的规
则：非严格浮点运算并不要求虚拟机的执行效果要不同，它只是在对不要求执行结果可重复的
代码进行优化时，为虚拟机提供了一定的自由尺度。
非严格浮点运算执行时允许表达式中间结果的取值超出通常的float或 double类型表示
范围，这种扩展范围的表示法避免了那些在采用标准的表示法时会产生的上溢和下溢，但是字
段、数组元素、局部变量、参数和返回值总是使用标准表示法的。当扩展范围表示法被转换成标
准表示法时，会采用最接近它的那个可表示的数值。
如果我们想要对这些问题有一个全面的理解，应该参考《Java语言规范(第3版)》(The
JavaMLanguage Specification,Third Edition)。
9.2 通用运算符
除了主要的算术运算符之外，还有其他一些很有用的用于比较和处理值的运算符。在接下
来的小节中还将讨论成员访问运算符、方法调用运算符和类型转换运算符。
9.2.1 递增运算符和递减运算符
运算符++和--分别是递增运算符和递减运算符，它们只能用于数值型变量或数值型数组
元素。表达式i++等价于i=i+1,但是前者的i只计算了一次。例如，语句
++arr[whereO];
只调用了一次 where方法，并且只使用了一次它的结果来作为数组的下标。另一方面，在下面
的语句中：
arr[where(]= arr[whereO]+1;
203
204
138 第9章 运算符和表达式
方法 where 被调用了两次：第一次用来确定等号右边的数组下标，第二次用来确定等号左边的
数组下标。如果 where方法在每次调用的时候都返回不同的值，那么该表达式的结果和上一句
++表达式的结果就会完全不同。为了避免第二次调用where方法，就必须将 where方法的结
果暂时保存起来，递增(和递减)运算符就提供了一种更简洁的表达式来实现以上功能。
递增运算符和递减运算符既可以作为前缀运算符(prefix operator),也可以作为后缀运算符
(postfix operator),也就是说，它们可以出现在操作数的前面，也可以出现在操作数的后面。如
果运算符出现在前面(前缀),那么该运算将在返回表达式的值之前执行；如果运算符出现在后
面(后缀),那么该运算在表达式原来的值被使用之后才执行。例如：
class IncOrder {
public static void main(String[] args){
int i= 16;
System.out.print1n(++i+""+ i+++""+ i);
}
}
此段代码的输出为：
171718
表达式 ++i将i的值先递增(preincrement)至17,然后计算出表达式的值(17);表达式i++
则先用i的当前值(17)计算出表达式的值，然后再将i的值后递增(postincrement)至18;最后
一个表达式i的值就是中间的后递增表达式运行之后的i值。在一个表达式中多次改变变量的
值会使代码难以理解，应该避免出现这种情况。
递增运算符++和递减运算符--也可以用于 char型变量来得到它的后一个或前一个
205 Unicode字符。
9.2.2 关系运算符和判等运算符
Java语言提供了一套标准的关系运算符和判等运算符，它们的结果都是 boolean值：
> 大于
>= 大于等于
< 小于
<= 小于等于
等于
不等于
关系运算符和判等运算符都可以作用于基本数值类型，它们具有通常的数学含义。
浮点数大都遵循正常的排序顺序(-1.0小于0.0小于正无穷),只有NaN 例外。几乎所有
的关系运算符和判等运算符在测试数和NaN 之间的关系时都会返回 false,只有!=例外，它
始终返回 true。如果是两个NaN 进行运算，结果也是如此。例如：
Double.NaN ==Double.NaN
的返回值总是false。如果要测试一个值是否为NaN,需要使用类型相关的NaN 测试方法：静
态方法 Float.isNaN(float)和 Double.isNaN(double)。
只有判等运算符==和!=可以作用于boolean型数值。
1.还有另一种方法可以用来测试 NaN:如果x是NaN值，那么x!=x的结果就为 true。这样的方法虽然有趣，但
是不太容易理解，所以最好还是用其他方法来检验。
9.2 通用运算符 139
可以将上述这些运算符组合起来构成“逻辑异或”测试。以下代码只有在x和y符号相同
(或都为0)时才会调用 samesign方法，否则会调用differentsign方法：
if((x<0)==(y<0))
sameSign();
else
differentSign();
判等运算符也可以用于引用类型。如果两个引用 ref1和 ref2 引用了相同的对象或者都
为nul1,那么表达式 refl == ref2 的值就为 true,就算这两个引用具有不同的类型声明也是
如此；否则，表达式的值就为false。
判等运算符测试的是引用的同一性(identity),而不是对象的等同性(equivalence)。如果两
个引用指向同一个对象，那么它们是同一的；如果两个对象逻辑上拥有同样的值，那么它们是
等同的，等同性是通过Object定义的equals方法来进行检验的。对于那些等同性和同一性
不是一回事的类，我们应该覆盖这个方法，因为Object.equals假定一个对象只和它本身等
同。例如，String类覆盖了 equals方法用来测试两个String 对象是否拥有相同的内容，见
第13章。
9.2.3 逻辑运算符
逻辑运算符将多个布尔表达式连接起来产生布尔值，从而提供了布尔代数的通用运算：
& 逻辑与(AND)
| 逻辑或(OR)
A 逻辑异或(XOR)
! 逻辑非
&& 条件与(AND)
11 条件或(OR)
“逻辑与”的结果是当且仅当两个操作数都为 true时才为 true,而“逻辑或”的结果是当且仅
当任何一个操作数为 true 时就为 true。“异或”的结果为 true的条件是两个操作数中必须有一个
为true但不能两个同时都为 true,这和测试两个操作数是否相等是等同的，所以我们可以将前
面的例子重写为：
if((x<0)^(y<0))
differentSign();
else
sameSign();
一元运算符!用来对一个布尔值取反或者说求逆，所以!true与 false相同，!false与
true相同。
布尔值一般可以直接进行测试。如果x和y是布尔值，那么代码
if(x |l!y){
// ...
}
要比下面这段等价的代码更简洁、更精悍：
if(x== true IIy==false){
// ...
}
206
207
208
140 第9章 运算符和表达式
8&(“条件与”)和|Ⅱ(“条件或”)运算符与简单的&和|运算符的逻辑功能是相同的，但
是当左边的操作数已经可以决定整个表达式的真值时，&&和|运算符就可以避免再对右边的
操作数做计算。基于这个原因，它们有时也被称为“短路运算符”(short-circuit operator)。例如：
if(w && x){ // outer "if"
if(y |l z){ // inner"if"
// ... inner "if"body
}
}
只有当w和x均为 true时，内层的 if才会执行。如果w为false,那么就不会对x求值，因
为整个表达式已经可以确定为 false。只有当y或z为true时，内层if的代码体才会执行。
如果y为true,那么就不会对z求值，因为整个表达式已经可以确定为 true。
许多Java代码依赖于这条规则来保证程序的正确性和高效性。例如，这种短路计算可以确
保下面这段代码的安全性：
if(0<= ix&& ix< array.1ength && array[ix]!=0){
// ...
}
这段代码首先执行了越界检查，当ix在界内时才会去访问array[ix]的值。由上可知，Java
中不存在任何“条件异或”运算符，因为XOR的真值总是要由两个操作数的值共同决定。
9.2.4 instanceof
运算符instanceof用来计算一个引用所引用的对象是否是特定的类或接口的实例，其左
边是一个对某对象的引用，右边是一个类或接口的名字。我们已经在3.4.3节中学到了有关
instanceof的知识。
9.2.5 位操作运算符
以下是二进制位操作运算符：
& 按位与(AND)
—
^
按位或(OR)
按位异或(XOR)
位运算符只能作用于整数类型(包括char类型),并且在两个操作数的每一对二进制位上
执行运算。如果两个二进制位均为1,那么它们的AND结果为1;如果两个二进制位中任意一
个为1,那么它们的OR结果为1;只有当这两个二进制位的值不相同时，它们的XOR 结果才为
1。例如：
0xf00f&0×0ff0结果为0×0000
0xf00f 10x0ff0结果为0xffff
Oxaaaa ^0xffff结果为0x5555
还有一个一元的按位求反运算符～,它对操作数逐位求反。值为0×00003333的 int 型数
的求反结果为0xffffcccc。
尽管位运算符和逻辑运算符使用了相同的字符表示，但是它们是完全不同的。例如，运算
符&是逻辑与运算符还是按位与运算符完全取决于它的操作数的类型。因为逻辑运算符只能作
用于布尔值，而按位运算符只能作用于整数类型，所以任何涉及不同类型操作数的表达式都会
9.2 通用运算符 141
产生编译期错误，如表达式 true &0xaaaa。
还有一些用于对整数数值移位的位操作运算符：
<< 向左移位，右边补0
向右移位，左边补最高位(符号位)
向右移位，左边补0
移位表达式的左边是要移位的数或变量，右边是移位的位数。例如 var>>>2表示将 var中
的各个位右移2位，也就是将最低的两位挤掉并在高位补充两个0。
两个右移运算符分别用来做算术移位(>>)和逻辑移位(>>>)。算术移位通过在移位
时将原来的符号位(最高位的二进制位)的值不断填充到最高位来保留值的符号，而逻辑移位则
不断在最高位补0,它经常用于从一个数值中提取其部分二进制位的操作。例如，在二进制编
码的十进制(binary coded decimal,BCD)数中，每个十进制数字被表示成4个二进制位(从0×00
到0×09,其他的二进制位表示则为无效),这样的话每个字节就可以编码两个十进制数字。想
要提取低位上的数字，只需对这个数和掩码0×0f进行AND操作，从而使高位上的数字被置为
0;想要提取高位上的数字，只需将这个数逻辑右移4位，从而使想要的数字移到最低有效位
(least significant position)而且高位全部填充为0:
class BCD {
static int getBCDLowDigit(byte val){
return(va1&0x0f); }
static int getBCDHighDigit(byte val){
return val >>>4; }
}
移位运算符与其他大部分二进制整数运算符相比，有一条稍为不同的类型规则。对于移位
运算符来说，结果的类型是它左边操作数的类型，也就是被移位的数的类型。如果移位操作的
左边是一个int型数，那么移位的结果也将是一个 int 型数，就算移位的位数采用long型表
示也一样。
如果移位的位数大于被移位数值的类型长度或者移位的位数是负数时，其真正移位的位数
就与代码中提供的位数有所不同了。移位操作中的实际移位位数是用类型长度减去1的值来对
代码中提供的位数做掩码屏蔽所得的结果。例如，对于32位的 int 型数，所用的掩码为0x1f
(31),所以表达式(n<<35)和(n<<-29)都等价于(n<<3)。
移位运算符只能作用在整数类型上。很少存在需要去操作浮点数的二进制位的情况，如果
确实需要操作浮点数的二进制位，那么可以使用 Float类和 Double类之间的转换方法，就像
8.4.2节“浮点包装器类”所讨论的那样。
练习9.2:编写一个方法，用来确定传入的 int型参数的二进制位中1的个数，要求只使用
位操作运算符(也就是说，不能使用Integer.bitcount)。然后将你的答案和文献中的算法做
一下对比(请查看进阶读物中“通用编程技术”)。
9.2.6 条件运算符?:
条件运算符根据布尔表达式的结果为整个表达式赋值，它赋的值只能是两个值中的一个。
下面的语句
value =(usersetIt?usersvalue:defaultvalue);
209
210
211
142 第9章 运算符和表达式
等价于
if(userSetIt)
value= usersValue;
else
value= defaultValue;
使用if语句和使用?:运算符的主要区别在于后者具有一个值，所以它可以用作表达式中的一
部分。条件运算符使表达式更紧凑，但是程序员并不认为使用它会更清晰，我们应该根据具体
情况来选择使程序更清晰的语句。这里使用括号将条件运算符表达式括起来完全是个人风格问
题，实际中可以有多种变化，而Java语言本身并不要求使用括号。
条件运算符表达式的类型由第二个和第三个表达式(在上例中就是指 usersvalue和 de faultvalue)的类型决定。如果这两个表达式的类型是一样的，那么它们的类型也就是整个表
达式的类型。否则的话，将遵循以下这些比较复杂的规则：
·如果一个表达式是基本类型，而另一个表达式可以通过拆箱操作转换成与它相兼容的基
本类型，那么就会执行拆箱操作，然后重新考虑整个表达式。
·如果两个表达式都是基本数值类型，那么其结果的类型也是基本数值类型、如果需要的
话可以采用数值提升(numeric promotion)规则。例如，在下面的语句中：
double scale =(halveIt?0.5:1);
两个表达式分别为double型(0.5)和int型(1)。int型数可以赋值给 double型，所
以1被转换成1.0,因此整个条件表达式的类型也是double型。
·如果一个表达式是int型常量，而另一个表达式的值是byte型、short型或者 char型，
那么由于int型值可以赋值给更小的类型，所以其结果的类型就是那个更小的类型。
·如果一个表达式是基本类型，而另一个表达式是引用类型，并且后者不能通过拆箱操作
转换成相兼容的数值，或者两个表达式均是基本类型但不兼容，那么就对基本类型执行
装箱操作，这样我们就有两个引用类型了。
·如果是两个不同的引用类型，那么整个表达式的类型就是它们的第一个公共超类型的类
型。例如，如果两个表达式是不相关的类型，但都实现了Cloneable接口，那么整个表
达式的类型就是Cloneable;如果一个表达式是int型而另一个表达式是String型，
那么整个表达式的类型就是Object。
还有一点需要注意，如果这两个表达式中的任何一个是void类型(可能是因为该表达式调
用了一个返回值为void类型的方法),那么就会产生编译期错误。
鉴于其组成形式，这个运算符也被称作问号/冒号运算符，又因为它是Java语言中唯一的
三元(三个操作数)运算符，所以也称为三元运算符。
9.2.7 赋值运算符
赋值运算符=执行的操作是将它右边的操作数表达式的值赋给它左边的操作数，其中，它
左边的操作数必须是一个变量(要么是一个变量名、要么是一个数组元素).它右边的表达式类
型必须是可赋值给左边变量的类型(可能会需要强制转换),见9.4节。
赋值操作本身就是一个表达式，它计算出的结果就是所赋的值。例如、假设有 int型变量
z,赋值操作
Z=3;
的值就是3。这个值可以继续赋给另一个变量，然后计算出结果也是3,然后再继续赋给第三个
9.2 通用运算符 143
变量，依此类推。因此，赋值操作可以写成将一组变量赋予相同值的赋值链：
X= y=z=3;
这也意味着赋值操作可以作为计算另一个表达式时的附带操作，但是这被认为是一种不好
的编码方式。可接受的这种编码方式的常见例子是在一个循环表达式中进行赋值和测试，例
如：
while((v= stream.nextO)!= nu77)
processValue(v);
这里的下一个值是从 stream中读入的，并且被存入到了变量v中。如果读到的值不是nul1,循
环会继续执行，继续读取下一个值。需要注意的是，因为赋值操作的优先级比判等运算符低(见
9.5节“运算符优先级和结合性”),所以必须用括号将赋值表达式括起来。
简单的=是赋值运算符最基本的形式，除此之外，Java 语言中还有许多其他的赋值形式。
所有二元算术运算符、逻辑运算符和位操作运算符都可以和=连接，组成另外一种赋值运算
符—--复合赋值运算符(compound assignment operator)。例如，
arr[whereO]+=12;
与
arr[whereO]= arr[where(]+12;
相同，只是复合赋值操作中左边的表达式只计算一次。在本例中，第一个表达式只计算了一次
arr[whereO],而第二个表达式则计算了两次，这一点在前面讲述 ++运算符时就已经提到过。
假设有一个类型为T的变量 var、一个数值 expr和一个二元运算符op,表达式
var op= expr
等价于
var =(T)((var)op(expr))
只是前者中 var仅计算一次。这就意味着只有当运算符op作用的类型是合法的，op=操作才
是合法的。例如，不能将运算符 <<=作用于double型变量，因为运算符 <<不能作用于
double型数值。
注意上例中展开式中所用到的括号。表达式
a*=b+1
等价于
a= a*(b+1)
但不等价于
a=a* b+1
尽管a+=1与++a和a++都相同，但是人们更习惯也更喜欢用++。
练习9.3:回顾一下你做的练习7.3的答案，看看是否可以用本章学到的运算符把你的代码
改写得更清楚、更简洁。
9.2.8 字符串连接运算符
我们可以使用运算符+来连接两个字符串。以下是一个例子：
String boo = "boo"; String cry = boo+"hoo"; cry +="!";
System.out.print1n(cry);
212
213
214
144 第9章 运算符和表达式
输出如下：
boohoo!
只要两个操作数中至少有一个是String类型，运算符 +就会被解释成字符串连接运算
符。如果只有一个操作数是String类型，那么另一个操作数会被隐式转换为String类型，见
9.4.3节“字符串转换”。
9.2.9 new
运算符 new是一元前缀运算符(unary prefix operator),它只有一个位于运算符之后的操作
数。技术上，new 表达式也被称作实例创建表达式(instance creation expression),因为它负责创
建某个类或数组的实例，这个表达式的值是指向被创建对象的引用。new的用途和相关的构造
器问题在本书2.5.1节已经详细讨论过了。
9.3 表达式
表达式是由运算符及其操作数组成的，通过计算可以得到它的结果。这个结果可能是一个
变量或数值，也可能什么都没有，因为表达式可能是对一个被声明为 void的方法的调用。表
达式可以简单到只有变量的名字，也可以复杂到具有一系列的方法调用、变量访问、对象创建，
甚至还有那些使用其他运算符、更进一步的方法调用和变量访问的多个子表达式的结果的组合。
9.3.1 计算顺序
不管表达式有多复杂，其含义总是明确定义的。运算符的操作数都是按照自左向右的顺序
计算的，例如，对于表达式×+y+z,编译器会先计算 x,然后计算y,再把它们的结果加起
来，然后再计算 z,最后把z加到前面的结果中去。编译器不会在计算x之前先计算y,也不会
在计算y或×之前先计算 z。类似地，作为方法调用或构造器调用的引元表达式，也是遵循自
左向右的顺序计算的；这一点对于多维数组中的数组下标表达式来说也是一样的。
只要上例中x、y或z之间具有任何相互影响的副作用，那么计算的顺序就会显得很重要。
例如，如果x、y或z调用的是会影响到对象的状态或者是会打印出一些结果的方法，那么我们
就必须注意它们是否会按照其他顺序计算。Java语言可以保证这种情况不会发生。
除了运算符&&、和?:以外，其他的运算符在执行运算之前，都会先求出它的每一个操作
数的值，甚至对于那些会抛出异常的操作也是如此。例如，用0去除整数会抛出ArithmeticE xception,但是这也是在两个操作数都计算完之后才抛出的。类似地，方法调用或构造器调用
的所有引元也是在调用之前计算出来的。
如果在计算二元运算符的左操作数时产生了异常，那么将不会计算右操作数。类似地，如
果一个表达式作为方法或构造器的引元，在计算它的过程中产生了异常，那么它右边的参数表
达式也就不会被计算了，数组下标表达式也是如此。计算的顺序是很明确的，并且一旦发生异
常，计算就会中止。
当使用new创建对象时，还有一点细节需要注意。如果没有足够的内存空间用来创建新对
象，那么就会抛出OutofMemoryError异常。这个异常是在计算构造器的引元之前抛出的(因
为在为对象分配内存空间时不需要那些引元的值),这种情况下不会计算那些引元。相反地，在
创建数组时，必须首先计算数组维数表达式以判断需要分配多少内存空间，因此，创建数组时
可能会抛出的OutofMemoryError 异常，这是在计算维数表达式之后才抛出的。
9.4 类型转换 145
9.3.2 表达式类型
每个表达式都有其类型，表达式的类型是由其组成部分的类型和运算符的语义来决定的。
如果将算术运算符或位操作运算符作用在整型数值上，那么这个表达式的结果类型就是
int型，除非有一边或两边的操作数是long型，那样的话结果就是long型。这个规则并不适
用于移位运算符表达式的类型，因为移位运算符表达式的类型与它右边操作数的类型无关。所
有的整数运算都是在 int型或 long型精度下执行的，所以较小的 byte和 short 整数类型经
常在求值之前被提升为 int类型。
只要算术运算符的任意一个操作数是浮点型的，那么这个操作就将以浮点运算形式执行。
这样的操作是在float型精度下执行的，除非其中至少有一个操作数是double型的，那样的
话其计算将使用double类型，而其结果也将是double类型的。
只要运算符+的任意一个操作数是String类型的，或者 += 左边的操作数是String
类型的，那么运算符+ 就会执行字符串连接操作。
对于在表达式中使用的 char类型的值，将通过把高16位置为0的方式将其转换成 int型
的值。例如，Unicode字符\uffff会被当作整数0×0000ffff来处理。这种处理方式与处理
short类型的值0xffff的方式完全不同：short类型的0xffff通过符号扩展得到的结果等
于-1,而与它相等的 int类型的值是0xffffffff。
以上是在表达式中可能发生的所有不同类型转换的例子，为了判定表达式的类型，接下来
将会详细讨论所有的类型转换。
9.4 类型转换
Java编程语言是一种强类型(strongly typed)语言，也就是说，几乎所有的情况下，它都是
在编译时就检查类型的兼容性情况。Java语言通过禁止任何可疑的语句来防止不兼容赋
值，它还提供了强制转换机制用于只有在运行时才能判断出类型兼容性的情况，或者需要
将基本类型显式地强制转换以防止丢失范围的情况，比如将 double型赋值给 float型。
在3.4节中我们已经讨论过了类型兼容性和引用类型的转换问题，本节将要讨论的是转换
的整体概念，包括基本类型转换的情况和包括引用类型转换的情况，以及什么场景下转换
会自动执行。
9.4.1 隐式类型转换
有些转换是自动发生的，不需要我们做任何工作，这种转换就是隐式(implicit)转换。
所有数值型的值都可以赋给其类型支持更大范围的数值变量，这就是拓宽基本类型转换
(widening primitive conversion)。例如，char类型可以用于任何 int类型合法的地方，浮点数值
可以赋值给任何具有相同或更高精度的浮点变量。
我们还可以使用隐式拓宽转换将整型转换成浮点型，但是反之则不可以。整型转换成浮点
型不会产生精度丢失的现象，因为任何浮点类型的范围都要比整型的范围大。
保持数值的数量级并不等于保持数值的精度，有些隐式转换可能会丢失精度。例如，
考虑将 long型数值赋值给 float型变量的情况，float是32位的数据类型，而 long是
64位的数据类型。尽管 float可以存储更大范围的数据，但是 float存储的有效位数比
long要少得多，所以在将long型数值赋值给 float 型变量时可能会丢失精度。考虑下
面的情况：
215
216
217
146 第9章 运算符和表达式
long orig =0x7effffff00000000L;
float fval = orig;
long lose =(long)fval;
System.out.println("orig ="+ orig);
System.out.println("fval="+ fval);
System.out.print1n("lose = "+ lose);
前两个语句创建了一个long 型数值，并把它赋值给了一个float型变量。为了表明这样做丢
失了精度，我们将 fval显式强制转换成 long型，并把它赋值给另一个变量(显式强制转换将
在后面介绍)。如果我们检查一下输出结果，便会发现float 型数值丢失了精度：因为赋值给
float型变量 fval的long型变量 orig和通过显式强制转换产生的 long型变量lose的值
不相同：
orig = 9151314438521880576
fval= 9.1513144E18
lose = 9151314442816847872
为了方便，编译期整型常量无需强制转换就可以赋值给较小的整数类型，只要这个常量的
值确实可以放在这个较小的整数类型中，并且该整数不是long 类型的。例如，下例中的前两
个赋值语句是合法的，但最后一个是不合法的：
short s1= 27;// implicit int to short
byte b1 = 27;// implicit int to byte
short s3= 0x1ffff;// INVALID:int value too big for short
这种从较大类型到较小类型的转换就是窄化基本类型转换(narrowing primitive conversion)。
总之，表达式求值时可能会用到以下7种不同类型的转换：
●拓宽或窄化基本类型转换
·拓宽或窄化引用类型转换
●装箱或拆箱转换
·字符串转换
这7种转换本书都已经讨论过了。它们可能会发生在如下5种不同的场景中，但是在任何给定
的上下文中，只可能发生它们中的某些转换：
·赋值：这种上下文产生在将表达式的值赋给变量的时候，其中可能会涉及下列变换：拓
宽基本类型转换；拓宽引用类型转换；其后可以紧跟拓宽引用类型转换的装箱转换；其
后可以紧跟拓宽基本类型转换的拆箱转换。
如果结果表达式的类型是byte、char、short或 int,并且该结果表达式是一个常量表达
式，那么只要变量的类型是byte、short或char而且所赋的数值可以放在这种类型中，就可以
应用窄化基本类型转换。例如我们前面讨论过的将 int型字面常量27赋给 short型变量的例
子。如果变量的类型是Byte、Short或character,那么在窄化基本类型转换之后还可以应用
装箱转换：
Short sl = 27;//implicit int to short to short
·方法调用：对于作为引元而传递给方法调用的表达式的类型，如果对其进行检查，那么
就会产生这种上下文。基本上，可以应用于赋值上下文的转换就都可以应用于该上下
文，只有窄化基本类型转换是例外，不可以用于该上下文。例如，一个需要 short 参数
的方法不能接受27作为参数，因为27是int类型的，此时必须使用显式强制转换。这
种限制原则使得在存在重载的情况下可以更容易地判断出应该调用哪个方法。否则，如
9.4 类型转换 147
果我们将一个short参数传递给既可以接受 int也可以接受 byte的方法，那么究竟是
将这个 short拓宽转换成 int,还是将它窄化转换成 byte呢?
●数值提升：正如9.1节所讨论的那样，通过应用拓宽基本类型转换，数值提升保证了算
术表达式的所有操作数都具有合适的类型，如果必要的话可以在拓宽基本类型转换之前
先使用拆箱转换。
●强制转换：强制转换潜在地允许任何转换，但是可能会在运行时出错，接下来的一节会
讨论到这个问题。
·字符串转换：字符串转换发生在使用字符串连接操作时(见9.2.8节),在9.4.3节“字符
串转换”中会作进一步的讨论。
9.4.2 显式类型强制转换
当某种类型不能通过隐式转换赋值给另一种类型时，通常它可以通过执行窄化转换而被显
式地强制转换为另一种类型，而且强制转换要求新类型的新值是对旧类型中的旧值的最佳表
示。有些强制转换是不允许的(例如，boolean型不可以强制转换成 int型),但是double型
可以通过强制转换赋值给long型，就像下面的代码这样：
double d=7.99;
long 1=(long)d;
当浮点数强制转换为整数时，其小数部分将按向0舍入的方式舍去，例如，(int)-72.3
等于-72。Math和 StrictMath类中还提供了一些以其他方式将浮点数向整数舍入的方法，
详细信息见22.9节“Math 和 StrictMath”。当浮点数 NaN 强制转换为整数时，其结果为0。
那些不能用整型表示的太大或太小的浮点数会转换为int型和 long型的MAX_VALUE 或MIN_
VALUE。如果要将浮点数强制转换成 byte、short或 char类型，那么首先要将它转换为 int型
或long型(由浮点数的数量级决定),然后再按下面所描述的方法舍去高位将其转换为较小的
整数类型。
double型也可以显式强制转换为float型，整数类型也可以显式强制转换为较小的整数
类型。当 double型要强制转换为float型时，可能会发生三种不良结果：精度丢失、得到0
值，或者当原来的 double型有穷值超出 float型范围时，得到的将是无穷大。
整数类型之间是通过舍去高位的方法进行转换的。如果较大的整数类型的数值可以放在它
要强制转换的较小的整数类型中，那么将不会有任何损失。但是如果较大的整数类型的数值超
出了它要强制转换成的较小的整数类型的范围，那么舍去高位就会改变它的值，甚至还可能改
变它的符号。下列代码：
short s=-134;
byte b=(byte)s;
System.out.print1n("s="+s+",b="+b);
之所以会产生下面的输出结果，是因为s被存储到b中时，其高位被舍去了：
S= -134,b= 122
char型可以强制转换为任何整数类型，反之亦然。当整数强制转换为char型时，只用到
了它的低16位数据，其他的均被丢弃了。当char型强制转换为整数类型时，增加的高位将全
部填充为0。一旦这些位都被设置好之后，它们就会像在其他所有数值中一样地被处理。下面
是一组将巨大的 Unicode字符分别强制转换为 int型(隐式)和 short型(显式)的代码。int
218
219
220
148 第9章 运算符和表达式
型的结果是正数，等于0×0000ffff,因为该字符的高位置成了0,但是同样的位在 short型中
的结果是负数，因为 short型的最高位是符号位：
class CharCast {
public static void main(String[] args){
int i= '\uffff';
short s=(short)'\uffff';
System.out.println("i="+i);
System.out.println("s="+ s);
}
}
该程序的输出如下：
i= 65535
S= -1
9.4.3 字符串转换
有一种比较特殊的隐式转换，它既可以作用于基本类型，也可以作用于引用类型，这种转
换就是字符串转换。只要运算符+的操作数中至少有一个是String类型的，那么该运算符就
可以被解释为字符串连接运算符，而且如果另一个操作数不是String类型的，那么它也会被
隐式地转换为 String类型，所有的基本类型都已经定义为执行这种转换。所有的对象都可以
通过 tostring方法进行转换，该方法既可以从Object 中继承而来，也可以被覆盖以提供一个
有意义的字符串表示。例如，下面的方法使用guillemet字符将字符串括了起来，这种格式在
许多欧洲语言中被用作引用标志：
public static String guillemete(String quote){
return '《'+ quote+'》';
}
这种从基本类型和对象到字符串的隐式转换只有在涉及字符串的表达式中使用了运算符+
或+=的时候才会发生，其他任何情况都不会发生这种转换。例如，对于接受 String 参数的
方法，必须传递给它一个String,我们不能传递给它一个对象或基本类型的参数，然后将其隐
式转换为 String。
当 nul1引用被转换为 String时，其结果为字符串"null",因此 null引用可以用于所有
的字符串连接表达式。
9.5 运算符优先级和结合性
运算符优先级反映了运算符相互之间“粘性”的相对强弱。运算符有不同的优先级，例如，
关系运算符比布尔逻辑运算符的优先级高，所以我们可以编写如下代码：
if(min<=i&&i<=max)
process(i);
而不会产生任何歧义。因为*(乘)比-(减)的优先级高，所以表达式
3-3* 5
的值为 -12,而不是0。使用括号可以覆盖优先级顺序，例如上例中，如果需要的结果是0,那
么其实现代码可以这样写：
9.5 运算符优先级和结合性149
(3-3)*5
当两个相同优先级的运算符依次排列时，运算符的结合性(associativity)就决定了究竟哪个
运算会先执行。因为+(加)是左结合的，所以表达式
a+b+C
等价于
(a+b)+C
下表按照优先级从高到低的顺序列出了所有的运算符，其中除了用 expr相连的一元运算
符、创建和强制转换运算符(也是一元的)以及条件运算符(是三元的)以外，其他的全是二元运
算符。具有相同优先级的运算符位于表中的同一行：
后缀运算符
一元运算符
创建或强制转换
乘法
加法
移位
关系
等价
与
异或
或
条件与
条件或
条件
赋值
[].(params) expr++ expr--
++ expr--expr+expr-expr~!
new(type)expr
* /%
+-
<< >>
<= instanceof <>
==!=
&
^
—
&&
II
?:
=+=-=*=/=?>>=<=>>>=&=^= |=
几乎所有的二元运算符都是左结合的，而赋值运算符是右结合的。也就是说，a = b=c
等价于a =(b=c),这也是可以组成赋值链的原因。条件运算符?:也是右结合的。
在表达式中，如果布尔表达式中嵌入了赋值或者使用了按位操作，那么通常都需要用到括
号。举个前一种情况的例子，查看下面的代码：
while((v = stream.nextO)!= null)
processvalue(v);
由于赋值运算符比等价运算符的优先级低，所以如果没有括号，上述代码就将等价于：
while(v=(stream.next(O)!= nu11))//INVALID
processvalue(v);
这大概就不是我们想要的程序了。这段程序也极有可能成为非法代码，因为只有在v是boole an类型这种特定的情况下，这段程序才是合法的。
很多人发现，按位运算符和逻辑运算符&、^和|的优先级很难记，因此在复杂表达式中，
我们应该用括号将这些运算符括起来，以提高可读性并确保正确的优先顺序。
我们一般很少用括号，只有在没有括号代码就会很不清楚的情况下才会使用。运算符优先
级是语言的一部分，应该全面掌握。有些人喜欢大量使用括号，但我们建议大家不要到处使用
括号，那样会让代码变得难以理解，看起来就好像是没有任何 LISP固有优雅风格的LISP。
练习9.4:利用本章学到的知识，不通过编写程序，指出下列表达式中哪些是非法的，以及
221
222
223
150 第9章 运算符和表达式
那些合法表达式的类型和值分别是什么:
3<< 2L-1
(3L << 2)-1
10<12 == 6> 17
10<< 12 == 6>> 17
13.5e-1loat.POSITIVE_INFINITY
Float.POSITIVE_INFINITY+ Double.NEGATIVE_INFINITY
Double.POSITIVE_INFINITY- Float.NEGATIVE_INFINITY
0.0/-0.0==-0.0/0.0
Integer.MAX_VALUE+ Integer.MIN_VALUE
Long.MAX_VALUE+5
(short)5*(byte)10
(i<15?1.72e3f:0)
i+++ i+++--i//i=3 at start
9.6 成员访问
我们可以(例如在 ref.method()中)使用圆点(.)运算符来访问类型中的实例成员(in stance member)和静态成员(static member)。因为类型可以继承其超类型的成员，所以就有许多
关于在任意给定的情况下访问的到底是哪个成员的规则，这些规则大部分在第2章和第3章中
已经详细介绍过，这里我们只是简单回顾一下。
可以通过使用类型名或对象引用的方式来访问静态成员。如果使用的是类型名，所指的成
员就是在该类型中声明的成员(如果该类型中没有这个成员的任何声明，那么它就是从父类中
继承而来的成员)。如果使用的是对象引用，那么访问哪个成员则由该引用所声明的类型来确
定，而不是由所引用的对象的类型来确定。在类的内部，对静态成员的引用总是指向该类中声
明的成员，或是该类中继承而来的成员。
可以通过对象引用来访问非静态成员，既可以是显式的引用，也可以是隐式的 this(或者
包围对象之一),采用第二种方式的前提条件是，非静态成员必须是当前对象(或者包围对象)
的成员，而字段和嵌套类型也必须是基于这个对象引用的声明类型而被访问的。类似地，在方
法的内部，对字段和嵌套类型的引用总是指向在这个类中的声明或者继承而来的声明。相反的
是，方法则是基于所引用对象的类而被访问的。另外，方法的重载意味着系统必须基于编译期
在方法调用中所使用的引元的类型来确定究竟要调用哪个方法，这一过程将会在下一节中详细
讨论。可以用于方法成员的运算符只有一个，就是方法调用运算符O。
如果将.运算符用于一个值为 null的引用，那么就会抛出 NullPointerException异
常，除非访问的是静态成员。在那种情况下，不需要考虑引用的值，因为只需要知道引用的类
型就可以定位成员所在的类了。
寻找正确的方法
要想正确地调用一个方法，我们必须提供适当的引元个数和类型，这样才可以在类中找到
唯一与之相匹配的方法。如果这个方法没有被重载，确定正确的方法就会很简单.因为和这个
方法名相关联的参数数量只有一个。如果这个方法被重载了，那么想要选择正确的方法就会变
得复杂得多。编译器使用了一种“最明确”(most specific)的算法来进行匹配，其主要思路如下：
1.确定为寻找该方法所要搜索的类或接口。这一步到底如何完成主要取决于方法调用的
形式。例如，如果是用类名来调用它的静态方法，比如 Math.exp,那么为寻找方法 exp 所要搜
9.6 成员访问 151
索的类就是Math。另一方面，如果方法名没有以任何方式进行限定，比如 exp(n),那么在调
用该方法的代码所处的作用域内必定有一个具有这个名字的方法，这个方法将会在特定的类或
接口中定义，而第2步中要搜索的就是这个类或接口。需要注意的是，本步中只用到了方法的
名字来确定搜索的范围。
2.找出在该类或接口中可以应用于该调用的所有方法，即所有满足下列条件的可访问方
法：具有恰当的方法名；可以接受传入的引元个数；所传入的参数类型可以赋值给所有的引元。
这个匹配过程分为三个阶段：
i.尝试做这样的匹配：不做任何装箱转换；不考虑引元数目可变的可能情况。也就是说，
编译器直接查找声明的参数个数和引元个数一致并且参数(包括基本类型和引用类型)
类型和提供的相应的引元相匹配的方法。
ii.如果上一步中没有找到匹配的方法，那么就要再次尝试匹配，但这一次匹配时需要考虑
装箱转换，这样基本类型的值就可以传递给对象，反之亦然。
iii.如果还是没有找到匹配的方法，那么就再次尝试匹配，这一次匹配时需要考虑引元数
目可变的可能性，这样引元的数目就可以超过声明的参数的数目。
3.在备选方法集合中，如果一个方法的所有参数类型都可赋值给集合中另一个方法相应的
参数，那么就会从集合中移除后一个方法，因为它是一个较不具体的方法。例如，如果备选方
法集合中有一个接受Object 参数的方法和另一个接受 String参数的方法，那么接受 Object
的方法就会被移除，因为 String可赋值给object,所以接受 string的方法更具体。如果我
们传递的是一个String引元，那么我们肯定想让专门处理字符串的方法来处理它，而不是让
可以处理任何对象的泛化的方法来处理它。
4.如果最后只留下一个方法，那么这个方法就是最具体的，并且它将会被调用。如果留下
的方法不止一个，并且它们具有不同的签名，说明这个方法调用不够明确，其调用代码是不合
法的，原因在于没有找到任何最具体的方法。如果所有留下的方法具有相同的签名，那么当它
们都是抽象方法时，可以任选一个；如果其中只有一个不是抽象方法，那么就选择它；否则，说
明该方法调用也是不明确的，而且是不合法的。
如果要详细描述的话，这个算法是非常复杂的，主要是由于它可能涉及泛型类型或方法，
请见第11章。感兴趣的读者也可以参考《Java语言规范(第3版)》(The JavaT" Language Specifi cation,Third Edition)上的详细资料。
一旦选中了某个方法，该方法就确定了方法调用预期的
返回值类型和可能会抛出的检查型异常。如果预期的返回值
类型不能被调用代码所接受(例如，方法返回的是一个
String,而方法调用被用作了数组下标),或者检查型异常
没有被正确处理，那么就会抛出编译期错误。
Dessert
Cake
例如，假设有如图9-1所示的类型层次结构：
再假设还有几个重载的接受特定Dessert 参数组合的方法： 图 9-1
void moorge(Dessert d,Scone s) {/* first form */}
void moorge(Cake c,Dessert d) {/* second form */}
void moorge(ChocolateCake cc,Scone s){/* third form */}
void moorge(Dessert... desserts) {/* fourth form*/}
1.引入这三个阶段的目的是为了维护与Java 编程语言旧版本的向后兼容性。
224
225
226
152 第9章 运算符和表达式
现在考虑下列对 moorge 的调用：
moorge(dessertRef, sconeRef);
moorge(chocolateCakeRef, dessertRef);
moorge(chocolateCakeRef,butteredSconeRef);
// INVALID moorge(cakeRef, sconeRef);
moorge(sconeRef, cakeRef);
看上去所有的调用都和第四种形式相匹配，而事实上如果没有其他的重载形式的话，确实
如此。但第四种形式作为一种接受可变数目引元的方法，只有当其他那些明确声明接受两个具
有可赋值类型参数的备选方法都不匹配时，编译器才会考虑它。
第一个调用使用了第一种形式的moorge方法，因为它们的参数和引元的类型正好匹配。
第二个调用使用了第二种形式，因为第二种形式是唯一一个所提供的引元可以赋值给参数类型
的形式。这两种情况中，要调用的方法都是在方法匹配算法的第2步之后就明确了的。
第三个调用需要多加考虑，可选的重载方法包括所有三种具有两个参数的形式，原因在于，
chocolatecake引用可以赋值给这三种形式中任何一个的第一个参数，Butteredscone引用
可以赋值给这三种形式中任何一个的第二个参数，而且三种形式中没有一种形式的签名是恰好
匹配的。因此在算法第2步之后，备选集中还有3个备选方法。
第3步需要消除集合中比较不具体的方法。在这种情况下，第一种形式被移除，因为第三
种形式更具体，具体表现在Chocolatecake引用可以赋值给第一种形式中的 Dessert 参数，
而Scone引用也可以赋值给第一种形式中的 Scone参数，所以第一种形式比较不具体。同样，
第二种形式也要被移除。然后，可选的方法就已经减到了只剩一个，即第三种形式的 moorge
方法，这也就是将会被调用的方法。
第四个调用是非法的。在算法第2步之后，可选方法集合中包括的是第一种形式和第二种
形式。因为没有哪一种形式的参数可以赋值给另一种形式的参数，所以在第3步中，没有任何
一种形式被移除。由此可知，这个调用是不明确的，编译器将无法解析，所以它是非法的
moorge调用。可以通过显式地将其中一个引元强制转换为Dessert 类型来消除这种不明确
性：如果强制转换的是cakeRef,那么就调用第一种形式；如果强制转换的是sconeRef,那么
就调用第二种形式。
最后一个调用使用了第四种形式。在第1步的第一阶段之后，就已经没有可选的方法了，
并且也没有任何可供考虑的装箱转换，所以编译器在第三阶段中开始考虑第四种形式。带有两
个引元的调用是可以与一个具有单一序列参数的参数列表相兼容的，而且这两个引元的类型可
以赋值给这个序列的类型，所以二者匹配。因为这是在第1步之后唯一匹配的方法，所以调用
的就是该方法。
这些规则也适用于基本类型。例如，int可以赋值给 float,解析重载方法调用时就必须
考虑到这一点，正如上例中考虑到 Butteredscone引用可以赋值给 Scone引用一样。但是
这些规则对于隐式地将整型转换为较小类型的转换并不适用，例如，如果某个方法接受 short
型的引元，而我们提供的却是int型的，那么就必须显式地将 int强制转换为short;否则，
不管它是何值，都不能和 short型参数匹配。
这个方法的解析过程发生在编译期，是以对象引用的声明类型和引元的值为依据的。这一
过程确定的是应该调用方法的哪种形式，而不是确定调用方法的哪种实现，在运行时将使用方
法被调用的对象的实际类型来寻找编译期所确定的方法的具体实现。
方法之间不可以只在返回类型或可能抛出的异常列表上有所区别，因为那样的话，会有很
多不明确的地方，以致于无法确定调用的是哪种重载的方法。例如，如果有两个
9.6 成员访问153
doppelg ?nger方法，区别仅在于一个返回int而另一个返回 short,那么这两种方法在下面
的语句中将具有同样的意义：
double d = doppelg ?ngerO;
同样，对于抛出的异常也存在类似的问题，因为对于从调用重载方法的代码中抛出的异常，
我们既可以捕获其中的任何一个，也可以捕获所有的，还可以一个都不捕获。如果两个方法只
在抛出的异常上存在差别，就无法确定究竟该使用哪一个。
这种模糊性并不是总能在编译期就发现。例如，为了添加一个新的方法，超类可能会做修
改，而且新方法与扩展类中的某个方法只在返回类型上存在差别。如果扩展类没有被重新编
译，那么这个错误就不会被发现。在运行时也不会产生问题，因为被调用的方法的具体形式是
在编译期就已经确定的，所以虚拟机只会在扩展类中寻找该方法。类似地，如果对某个类进行
修改，以添加某个方法的新的重载形式，而调用这个方法的类没有被重新编译，那么该类就不
会调用这个新方法，因为要调用的方法的形式是在编译期就已经确定的，并且这个确定的形式
和新方法的形式是不同的。
数学一直是我学得很差的科目。
我无法让老师相信我的答案是以反讽形式表示的正确答案。
——卡尔文·特里林(美国名记者)
227
228
第 10章 控 制 流
“请你告诉我，在这里我应该走哪条路呢?”
“这主要取决于你想去哪儿。”
——刘易斯·卡罗尔，《爱丽丝梦游仙境》
仅由一组连续的语句组成的程序肯定是有用的，因为这些语句会按照它们的书写顺序执
行。但是控制语句执行顺序的能力极大地提升了Java 编程语言的价值，这种控制就是测试某些
条件并根据测试结果执行不同的语句。本章介绍了几乎所有可以控制执行顺序的控制流语句
(control flow statement),但异常和断言将在第12章中单独介绍。
10.1 语句和块
表达式语句(expression statement)和声明语句(declaration statement)是两种基本的语句，我
们在前面已经看到过很多它们的例子了。表达式语句(如i++或方法调用)是以分号结尾的表
达式，分号通常被当作是语句的结束',而实际上分号自身也是一条语句，只是它什么也不做，
是空语句(empty statement)。并非所有的表达式都能成为语句，因为将x<=y这样的表达式单
229 独作为语句通常是毫无意义的。只有下面这几种表达式能够在末尾加上分号变成语句：
·含有=或某个 op=操作符的赋值表达式
●前缀或后缀形式的++和--
●方法调用(不论它们是否有返回值)
·使用new来创建对象的对象创建表达式
声明语句的正式名称为局部变量声明语句(local variable declaration statement),它可以声明
变量并将其初始化为某个值，这在7.3.1节中讨论过，它们可以出现在块内部的任何地方，而
不只是在开始处。局部变量只在包含其声明的块的执行期间存在，并且在使用之前必须被初始
化——要么在声明的时候被初始化，要么在声明之后被赋值。如果在局部变量被初始化之前使
用它们，程序将不能通过编译。
局部类声明语句用来声明局部内部类，可以在声明它的块中使用。局部类在5.3节中详细
讨论过。
除上面列举的表达式语句之外，还有许多其他类型的语句会影响程序的控制流，例如if语
句和 for语句。本章将详细介绍各种类型的语句。
花括号{和}将零或多条语句组成块(block),我们可以在任何允许使用语句的地方使用块，
因为块也是语句，只不过它是一个合成品。
1.终止符(terminator)和分隔符(separator)是有区别的。声明中标识符之间的逗号是分隔符，因为它位于列表的各
个元素之间。分号是终止符，因为它终止了每条语句。如果分号是语句的分隔符，那么在代码块最后的那个分
号就将是多余的(这取决于语言设计者的决定),而且可能是非法的。
10.2 if-else 155
10.2 if-else
条件控制流最基本的形式就是if语句，它会选择是否执行后面的语句，其语法如下：
if(expression)
statement1
else
statement2
该语句首先会计算expression(必须是boolean或 Boolean类型的表达式)的值。如果它的值是
true,就执行 statementI;否则如果存在else子句，就执行 statement2,其中else子句是可选的。
我们可以通过将一个if加入到前一个if的else子句中来构成一个测试系列。下面的方
法将一个属于某个特定单词集合的字符串映射成了用某个值去执行的一个动作：
public void setProperty(String keyword,double value)
throws UnknownProperty
{
if(keyword.equals("charm"))
charm(value);
else if(keyword.equals("strange"))
strange(value);
else
throw new UnknownProperty(keyword);
}
如果前面有多个不带else子句的if,会怎么样呢?例如：
public double sumPositive(double[] values){
double sum = 0.0;
if(values.length>1)
for(int i=0;i< values.length; i++)
if(values[i]>0)
sum += values[i];
else // oops!
sum = values[0];
return sum;
}
上面的else子句看起来是与数组长度的判断绑定在一起的，但这只是缩进造成的假象，在这
里缩进应该被忽略掉。实际上，else子句应该和离它最近的那个没有else子句的 if语句绑
定。因此，上面的这段代码应该等价于：
public double sumPositive(double[] values){
double sum=0.0;
if(values.length >1)
for(int i=0;i< values.length;i++)
if(values[i]>0)
sum += values[i];
else// oops!
sum = values[0];
return sum;
}
230
231
232
156 第10章 控 制 流
这可能并不是我们想要的。我们可以使用花括号来构成语句块，从而将else子句和第一个 if
绑定起来：
public double sumPositive(double[] values){
double sum=0.0;
if(va)ues.1ength>1){
for(int i=0;i< values.length;i++)
if(values[i]>0)
sum += values[i];
} else {
sum = values[0];
}
return sum;
}
练习10.1:通过在循环中使用if-else,编写一个方法，该方法接受一个字符串参数并返
回一个字符串，返回的字符串是通过将参数字符串中的特殊字符替换成Java语言中的等价字符
而生成的。例如，对于在中间含有"的字符串，应该产生用\"来替换"的返回字符串。(7.2.3节
列出了所有的特殊字符)。
10.3 Switch
switch语句允许我们根据表达式的值将控制流转到语句块的某个带标号的入口点。下面
是switch语句的一般形式：
Switch(expression){
case n:statements
case m:statements
default:statements
}
其中的表达式必须是整数类型(char、byte、short、int 或它们对应的包装器类)或者枚举类
型。switch的语句体被称作 switch 块(switch block),它包含可以将 case 标号作为前缀的语
句，而case标号则是一个整数或枚举常量。如果switch 表达式的值与某个 case标号的值相
匹配，控制流就会转到该标号之后的第一条语句。如果找不到相匹配的 case 标号，控制流就
会转到default标号之后的第一条语句，这时如果没有default标号，整个 switch语句将会
被跳过。
例如，考虑4.2.1节中Verbose接口：
interface Verbose {
int SILENT =0;
int TERSE = 1;
int NORMAL = 2;
int VERBOSE = 3;
void setVerbosity(int level);
int getVerbosityO;
}
程序根据冗余级别转储对象的状态，在较高的冗余级别上添加新的输出，然后打印下一个较低
10.3 switch 157
的冗余级别的输出：
Verbose v=...;// initialized as appropriate
public void dumpState(){
int verbosity = v.getVerbosityO;
switch(verbosity){
case Verbose.SILENT:
break;// do nothing
case Verbose.VERBOSE:
System.out.printin(stateDetails);
// FALLTHROUGH
case Verbose.NORMAL:
System.out.print1n(basicState);
// FALLTHROUGH
case Verbose.TERSE:
System.out.println(summaryState);
break;
default:
throw new IllegalStateException(
"verbosity="+ verbosity);
}
}
一旦控制流转到某个 case标号之后的语句，那么该语句之后的那些语句就会根据它们的语义
依次执行，即使这些语句拥有它们自己的不同的 case标号也是如此。例子中的 FALLTHROUGH
注释显示了控制流在此处继续执行到(fall through)下一个 case标号，从而到达下面要执行的代
码。因此，如果冗余级别是VERBOSE,则打印全部的三个输出部分；如果是NORMAL,则打印两
个部分；如果是TERSE,则只打印一个部分。
case或 default标号不会让控制流跳出 switch,它们也没有暗含要结束语句执行的意
思。如果我们想在switch 块中结束语句的执行，必须显式地将控制流转出switch 块，可以使用
break 语句来做到这一点。在switch 块中，break 语句会将控制流转到switch 之后的第一条
语句，这也就是为什么我们要在完成 TERSE输出之后要使用 break 语句。如果没有这个
break,程序会继续执行 default标号的代码，从而每次都抛出异常。与此类似，SILENT这种
情况只执行了break 语句，因为没有任何东西需要打印。
在某些环境下，控制流继续执行到下一种情况是很有用的，但是在大多数情况下，都应该
在所有的 case标号对应的代码之后加上一个break 语句。良好的编程风格建议我们务必使用
某种形式的 FALLTHROUGH 注释表示继续执行是有意的。
一条语句可以对应多个 case标号，这就允许在多种情况下执行同一个动作。在下面的例
子中，我们使用switch 语句来决定如何将十六进制数字位翻译成整数：
public int hexValue(char ch)throws NonHexDigitException {
switch(ch){ case 'O':case '1':case '2':case '3':case '4':
case '5':case '6':case '7':case '8':case ·9':
return(ch -'0');
233
234
235
158 第10章 控 制 流
case 'a':case 'b':case 'c':
case 'd':case 'e':case 'f':
return(ch- 'a')+10;
case 'A':case 'B':case 'C':
case 'D':case 'E':case 'F':
return(ch -'A')+10;
default:
throw new NonHexDigitException(ch);
}
}
该程序中没有任何break 语句，因为在控制流继续执行之前，return语句退出了switch块(以
及整个方法)。
我们应该使用break、return或 throw来结束switch 中的最后一组语句，就像我们在前面
的case语句块中所做的那样，因为这样做可以在添加新的case时，降低意外落过switch 中原
来最后一部分的可能性。
所有的case标号都必须是枚举常量或常量表达式——这些表达式必须含有字面常量或由
常量表达式初始化的具名常量，并且它们对于switch 表达式的类型必须是可赋值的。在任何
单个的 switch语句中，每个case的值都必须是唯一的，并且最多只能有一个 default标号。
当使用枚举作为switch表达式时，如果我们遗漏了某种情况，是不会得到任何警告的，因
此我们需要自己确保每种情况都考虑到了。为了防止枚举类型因重定义而拥有额外的常量，我
们应该总是包含直接抛出异常的 default情况。
只有完全位于switch块中的语句才可以拥有case标号。例如，这意味着我们不能将控制
流转到位于某个循环中的switch块内部的语句，或者某个嵌套代码块中的语句。然而我们可以
在switch 块中跳过局部变量的声明和初始化(但我们并不推荐这么做),这样做的效果是，该局
部变量仍然被认为是声明过的，但其初始器尚未执行。由于局部变量必须被初始化，所以任何
试图读取该变量值的代码都会产生编译期错误，因为第一个使用该变量的地方应该是对它的赋
值。
switch块的第一条语句必须用标号标示，否则它就是不可达的(所有的情况都会跳过它)并
且代码不能通过编译。
练习10.2:使用switch重写练习10.1中的方法。
练习10.3:使用练习6.1中的“星期日期”枚举来编写一个方法，该方法将一周中的某一天
作为参数，如果这一天是工作日就返回 true,否则就返回false。首先使用嵌套的 if-else语
句来实现，然后使用switch语句。你觉得哪一种方式写出的代码更简洁呢?
10.4 while和 do-while
while循环看起来像这样：
while(expression)
statement
其中的expression 也只能是boolean 或 Boolean类型的，它的值将首先被计算出来，如果是
true,就执行语句(也可能是一个块)。一旦语句执行完毕，expression的值将会被重新计算，如
果还是true,语句将会再次执行。这样重复下去，直到expression的值成为 false,这时控制流
10.5 for 159
就转到了while之后。
我们在第1章的第二个程序中已经介绍了while循环，即 Fibonacci程序：
while(hi< MAX){
System.out.println(hi);
hi = 1o+ hi;
1o= hi-lo;
}
程序将循环地打印和计算新的Fibonacci数值，直到计算出的最大值超出了最大限制。
while循环会执行零次或多次，因为第一次计算出来的表达式值时就可能是false。有时
我们会想让循环体至少执行一次，这正是为什么我们需要do-while循环的原因：
do
statement
while(expression);
在这里，expression的值会在语句执行之后被计算。当表达式的值为 true时，语句会反复执行。
do -while循环中的语句几乎总是一个块。
练习10.4:在前面练习的解答中选择一些你使用了 for循环的程序，使用while循环将它
们重写。你能用do-while将它们重写吗?你会这么做吗?如果不会，那又是为什么呢?
10.5 for
for语句有两种形式：基本形式和增强形式。其中，基本形式更普通也更强大。
10.5.1 基本的for语句
我们可以使用基本的 for语句对一定范围内的值从头到尾进行循环。它看起来像这样：
for(initialization-expression;
loop-expression;
update-expression)
statement
initialization-expression可以用来声明和/或初始化循环变量，它只会执行一次。然后
计算 boolean或 Boolean类型的 loop-expression的值，如果该值为 true,就会执行循环
体中的语句。在执行了循环体之后，将会计算update-expression的值，该计算通常会更新
循环变量的值，然后再重新计算 loop-expression的值。这个循环将会不断地重复，直到
7oop-expression的值变为 false。上面的程序大致等价于：
{
initialization-expression;
while(Toop-expression){
statement
update -expression;
}
}
for语句中的update-expression总是会执行，除非在循环体中出现了continue(见10.8
节“continue”)。
for 循环中的初始化和更新部分可以是一组用逗号分隔的表达式，与大多数操作符的操作
236
237
238
160 第10章 控 制 流
数类似，这些用逗号分隔的表达式将会从左到右地进行计算。例如，如果要从一个数组的两端
以两个相对的方向移动下标，可以使用如下代码：
for(i=0,j= arr.length -1;j>= 0;i++,j--){
//...
}
正如在7.3.1节所描述的，for循环的初始化部分也可以是局部变量声明语句。例如，如
果i和j不会在 for 循环之外使用，我们可以将前面的例子写成：
for(int i= 0,j= arr.1ength -1;j>=0;i++,j--){
//..
}
如果我们使用了局部变量声明，那么表达式中逗号之后的每个部分都会被视作是这个局部
变量声明的一部分。例如，如果我们想打印出某个链表中的前MAX个成员，就需要在遍历列表
所有成员的同时维护一个计数器。我们可能会做如下的尝试：
for(int i=0,Cell node = head; // INVALID
{
i<MAX && node != nul1;
i++,node = node.next)
System.out.print7n(node.getElementO);
}
但这是不能编译的：在变量声明中，逗号是用来分隔多个变量声明的，但这里的Cel7是一个类
型，不是一个变量。不同类型的变量的声明是以分号隔开的不同语句，如果我们将上面程序中
的逗号改成分号，那么这个 for循环就会有4个部分而不是3个部分，这也是错误的。如果我
们需要初始化两个不同类型的变量，那么它们当中的任何一个都不能在 for循环中声明：
int i;
Cel1 node;
for(i=0,node = head;
i< MAX && node != null:
i++,node = node.next)
{
System.out.println(node.getElementO);
}
典型的情况是，for循环用来在某个范围的数值上迭代某个变量，直到达到这个范围的某
个逻辑结尾。我们可以定义这个迭代范围，例如，for 循环经常用来迭代某个链表的所有元素
或跟踪某个数学数列的值。这种能力使得Java语言中的 for 结构比许多其他语言中的等价结
构更为强大，那些其他语言都对 for风格的结构进行了限制，使得只能在某个数值范围内递增
变量。
下面是这种循环的一个例子，它被设计用来计算使得10大于或等于某个值的最小的 exp
值：
public static int tenPower(int value){
int exp,v;
for (exp = 0,v= value-1;v>0;exp++,v/= 10)
continue;
return exp;
}
10.5 for 161
在这种情况下，两个变量通过步进经历了不同的范围。只要循环变量v大于0,指数值就会增
加并且v会被10整除。当循环结束时，10的值是大于等于 value的10的最小次幂。在每次
循环迭代中，测试值 value和指数exp都会被更新。在这种情况下，使用一组逗号分隔的表达式
是确保两个变量步调总能一致的好办法。
这个循环的体只是一条简单的continue语句，它启动了循环的下一次迭代，而循环体什
么都不做.循环的所有工作都集中在 for语句自身的测试和迭代子句中。这里的continue风
格是产生空循环体的一种方法；另外一种方法是在 for所在行使用一个单独的分号，或者使用
一个由花括号括起来的空代码块。在for所在行的末尾使用一个分号的方法是很危险的，如果
这个分号被不小心地删掉或者忘记加上的话，紧跟在 for后面的语句就会悄悄地成为 for的循
环体。
for 结构中的所有表达式都是可选的，如果不写 initialization -expression或 up
date-expression,它们在循环中的部分将会被直接忽略掉；如果不写 loop-expression,
它会被假设为 true。因此，编写无限循环的常用方法是将其写成“永久”循环：
for(;;)
statement
可以预料的是，循环可以被某些其他的方式所终止，例如使用 break 语句(稍后将进行描述)或
者抛出异常。
按照惯例，只有在对一定范围内的相关数值进行循环时才使用 for循环。使用与 boolean
类型的循环测试无关的初始化表达式和增量表达式会违反这个惯例，这是一种拙劣的编程风
格。
练习10.5:编写一个方法，它接受两个char参数，打印这两个值之间的所有字符，包括这
两个端点。
10.5.2 增强的for语句
增强的 for语句通常被称为 for-each 循环，它提供了一种在数值集合上进行迭代的更为
紧凑的形式，其形式如下所示：
for(Type 7oop-variable:set -expression)
statement
其中，set-expression必须被确定为对象，该对象定义了我们想要进行迭代的数值集合。
7oop-variable是一个局部变量，它的类型必须适合于数值集合的内容。每次进行循环时，
loop-variable都会从集合中取出下一个值，同时执行 statement(也可以用loop-varia
ble来执行某些操作),循环会一直继续下去，直到集合中没有留下任何未被取出过的值。
set-expression必须被确定为数组实例或者实现了 iava.1ana.Iterable接口的对
象——所有的集合类都满足这个条件，见第21章。下面是一个使用数组的例子，我们重写了
1.9节中的 average方法：
static double average(int[] values){
if(values == null| values.length == 0)
throw new I1lega1ArgumentException();
double sum = 0.0;
for(int val:values)
239
162 第10章 控 制 流
sum += val;
return sum / values.1ength;
}
其中，for语句读作“对于 values 中的每一个代码体”,每次循环中我们都将下一个值(val)
加到sum上，这与下面的基本 for语句等价：
for(int j=0;j< values.length;j++){
int val = values[j];
sum += va1;
}
对数组使用for-each 循环的优点在于我们不必手工维护数组下标，也不必检查数组的长度，
它的缺点是for-each 只能在单独一个数组上向前循环，并且只能查看数组的元素。如果我们要修
改某个数组元素，就需要知道这个元素的下标，而这种信息在增强的 for语句中是得不到的。
使用增强的 for语句的主要动机是要能更方便地迭代集合类或更一般的任何实现了 Iter able接口的其他类。Iterable接口定义了单一的 iterator方法，它返回的是对象的 Itera tor(见21.2节“迭代”)。回想我们在第4章定义的那个AttributedImpl类，我们可以定义
240一个方法打印出AttributedImpl对象的所有属性：
static void printAttributes(AttributedImpl obj){
for(Attr attr:obj)
System.out.print7n(attr);
}
我们也将它读作“对于obj中的每个attr”,它只是较冗长的显式地使用了迭代器的基本 for
语句的一种语法上的简写：
for(Iterator<Attr> iter = obj.iteratorO;
iter.hasNext();
/* no update expression */)
{
Attr attr = iter.next();
System.out.print1n(attr);
}
和前面一样，增强的 for语句的优点在于它为访问所要迭代的元素提供了简单的语法结构。但
是我们不能使用迭代器的 remove方法来改变这个集合，也不能同时迭代多个集合，如果我们
需要这种能力，就必须使用基本的 for语句和显式的迭代器。
10.6 标号
可以通过给语句加标号来赋予它们名称，我们可以使用这些名字来引用语句。标号位于它
所要命名的语句之前，每条语句只允许有一个标号：
Tabe7:statement
标号只能被break 语句和 continue语句引用(下面将对它们进行讨论)。
10.7 break
使用break 语句可以退出任何块，而不仅仅是switch块。break 语句有两种形式，一种
10.7 break 163
是无标号的(unlabeled)break:
break;
另一种是有标号的(labeled)break:
break labe7;
无标号的 break会终止最内层的switch、for、while或 do语句，并且它也只能出现在这些语
句当中。有标号的break可以终止任何被标号标示过的语句。
break 最常见的用法是跳出循环，在下面的例子中，我们在一个Contained 对象引用的数
组中寻找其第一个空位：
class Container {
private Contained[] objs;
// ...
public void addIn(Contained obj)
throws NoEmptySlotException
{
int i;
for(i= 0;i<objs.length;i++)
if(objs[i] == nu11)
break;
if(i>= objs.1ength)
throw new NoEmptySlotExceptionO;
objs[i] = obj; // put it inside me
obj.inside(this);// let it know it's inside me
}
}
为了终止外层的循环或块，我们需要用标号标示外层的语句，并在 break 语句中使用它的
标号名：
private float[][] matrix;
public boolean workOnFlag(float flag){
int y,x;
boolean found= false;
search:
for(y=0;y< matrix.length;y++){
for(x=0;×< matrix[y].1ength;x++){
if(matrix[y][x]== flag){
found = true;
break search;
}
}
}
if(!found)
return false;
// do some stuff with flagged value at matrix[y][x]
return true;
241
242
}
243
164 第10章 控 制 流
在这里我们标示了外层的 for循环，如果我们找到了所需要的值，就使用有标号的break 来终止内
层和外层的循环，这样就简化了循环的逻辑，因为我们不需要在循环表达式中加入!found子句。
注意，有标号的break并不是goto,goto语句允许在代码中不加选择地任意跳转，这将
造成控制流的混乱。另一方面，引用某个标号的break或continue只会退出或重复特定的被
标示过的块，这时的控制流显然是受监控的。例如，下面是workonFlag的一个修改过的版本，
它标示的是一个块而不是一个循环，这就使得我们可以完全省去 found标志：
public boolean workOnFlag(float flag){
int y,x;
search:
{
for (y= 0;y<matrix.1ength; y++){
for(x=0;x<matrix[y].1ength;x++){
if(matrix[y][x] == flag)
break search;
}
}
// if we get here we didn't find it
return false;
}
// do some stuff with flagged value at matrix[y][x]
return true;
}
我们应该慎重地使用break 语句，并且要考虑到代码的清晰性。任意地跳出循环或语句会
造成控制流代码的混乱，使得理解和维护代码变得更为困难。有些编程风格干脆禁止使用
break,但这是一种极端的立场。为了避免使用 break 而扭曲循环的逻辑所产生的代码可能比
使用break 的代码更加混乱难懂。
10.8 continue
continue语句只能在循环( for、while或do)中使用，它将控制流转到循环体的末尾并且
继续进行循环。在while循环和do循环中，这会使执行流转到循环表达式的计算上。在基本
的for循环中，continue会使执行流先转到更新表达式的计算上，然后再转到循环表达式。
在增强的 for 循环中，如果数值集合中还存在下一个元素，那么执行流就会转到这个元素上。
与break 语句类似，continue语句也有无标号的形式：
continue;
和有标号的形式：
continue labe7;
在无标号的形式中，continue会把控制流转到最内层的循环体末尾，而有标号的形式会把控
制流转到带有那个标号的循环的末尾，但这个标号必须属于某个循环语句。
continue经常用来跳过循环范围内的某个元素，该元素可以被忽略或者被简单的代码进
行处理。例如，一个含有简单的“skip”符号的语言符号流可以按照下面的方式处理：
while(!stream.eof(O){
token = stream.nextO;
10.10 什么?没有goto? 165
if(token.equals("skip"))
continue;
// ... process token ...
}
有标号的continue为了进行具名循环的下一次迭代会跳过所有的内层循环。在前面的例
子中，continue并不需要任何标号，因为在这个例子中只有唯一的一个外层循环。然而，考虑
一下用于迭代一个二维矩阵的值的嵌套循环，假设这个矩阵是对称的(matrix[i][j]== ma trix[j][i]),在这种情况下，我们只需要迭代半个矩阵。例如，下面的方法将一个对称矩阵
中的每个值都乘以了2:
static void doubleUp(int[][] matrix){
int order = matrix.1ength;
column:
for(int i=0;i< order;i++){
for(int j=0;j<order;j++){
matrix[i][j]= matrix[j][i]= matrix[i][j]*2;
if(i== j) continue column;
}
}
}
每次到达矩阵的对角线元素时，程序就会从在列上进行迭代的外层循环继续执行，从而跳过本
行的其余元素。
10.9 return
return语句会终止一个方法的执行并返回到它的调用者。如果方法没有返回值，那么可
以使用简单的 return语句：
return;
如果方法拥有返回类型，那么 return语句必须包括属于某种类型的表达式，这种类型可以赋
值给返回类型。例如，如果一个方法返回的是double型的，那么它的 return语句就可以含有
double、float或整型的表达式：
protected double nonNegative(double val){
if(val<0)
return 0;// an int constant
else
return val;// a double
}
return 也可以用来退出构造器。由于构造器并未指定返回类型，所以 return不需要带有
任何数值。构造器是作为 new 过程的一部分而被调用的，该过程在最后会返回一个新对象的引
用，但是每个构造器只是这个过程一个部分，所以没有任何构造器会“返回”最后的那个引用。
10.10 什么?没有goto?
Java 编程语言中没有可以将控制流转到任意语句的goto结构，尽管在与Java相关的语言
244
245
246
166 第10章 控 制 流
中goto是很常见的。对于goto 在其他语言中的基本用途，Java提供了其他的解决方案：
●在嵌套循环中控制外层循环：使用有标号的break和continue语句来满足这种需要。
·当得到答案或发现错误时，需要跳过不在循环中的代码块的剩余代码：使用有标号的
break。
·在退出方法或代码块之前执行清理代码的工作：使用有标号的break,或者更为简洁地
使用try语句的 finally结构(将在第12章中介绍)。
有标号的break 和continue的优点是它们将控制流转到了严格受限的地方。finally块
在控制流转移的位置上受到了更为严格的限制，但是它适用于所有的情况，包括产生异常的情
况。使用这些结构，我们可以写出没有goto的干净代码。
过激的行为无助于理解。
——希思科特·威廉姆斯(英国诗人、演员)
1.虽然没有被使用，goto仍旧是一个保留字，和const一样。它们之所以会被保留是有历史原因的：它们两个都
来自于与Java紧密相关的编程语言，如C和C++,保留它们可以让编译器清楚地建议程序员——他们使用了
没有意义的东西。有时，编译器还可以给出关于如何在Java 编程语言中使用 const的建议。
第 11章 泛型类型
那些没有任何恶习的人的问题在于，你一般可以非常肯定他们一定具有某些让人讨厌的美德。
——伊莉莎白·泰勒(美国女演员)
在Java编程语言中，Object类构成了类层次结构树的根，这样其他类通过声明它们能够
处理Object就可以处理任意的对象类型。在第3章中，我们看到 SingleLinkQueue类使用
cel1对象保存了我们想要保存在队列中的Object引用，虽然这样提供了巨大的灵活性，但是
也有不便之处：例如，如果我们知道出问题的元素是String 对象，那么我们必须每次都强制转
换remove方法的返回值。
将Object 对象用作泛化的引用同样也是潜在不安全的，没有什么可以阻止程序员误将
Number而不是String添加到队列中，而这个错误只有在运行时将强制转换应用于 remove方
法产生失败并抛出ClassCastException异常时才会发现。为了避免这些问题，我们必须定义
不同的队列类来保存每一种特定类型的元素，比如 SingleLinkstringQueue 或 Sin gleLinkNumberQueue,但是这样又带来了许多不便：按照这种方式复制代码既拖沓冗长，又低
效，而且易于出错；它处理任意一种队列都会显得很笨拙；我们最终可能会有大量的基本相同
的类，它们只是在某几个方法的返回类型与参数类型上有所不同。理想状况下，我们可能想编
写这样一个 SingleLinkQueue类：它可以被特化为包含任何特定种类的对象，并且对于每一
个队列对象，我们都可以定义其将要保存的类型。这就是泛型类型(generic type)存在的意义。
让我们从一个新版本的泛型Cell类开始：
class Cell<E>{
private Cell<E> next;
private E element;
public Cel1(E element){
this.element = element;
}
public Ce11(E element,Cell<E> next){
this.element = element;
this.next = next;
}
public E getElement(){
return element;
}
public void setElement(E element){
this.element = element; }
public Cell<E> getNext(){
return next;
}
public void setNext(Cell<E> next){
this.next = next;
}
247
}
168 第11章 泛型类型
这个类现在被声明为Cell<E>(读作“E类型的Cell”),其中E表示cel1对象可以保存的元
素所具有的类型。在这个泛型版本的Cel1中，每一个在原来版本的Cel1中使用Object的地
方现在都使用了名字E。E被称为类型变量(type variable),它可以被具体的类型所替代。E并
不是特指的名称——例如也可以是ElementType,但是E是“元素”(element)的一个很好的缩
写。按照惯例，类型变量可以用单个字母来命名：E代表元素类型，K代表键类型，V代表值类
型，T代表通用类型，等等。
要创建一个cel1对象，我们必须告诉编译器希望用哪个具体的类型来替换 E。例如，保存
String 的Cel1可以像下面这样构造和引用：
Cel1<String> strcell= new Cell<String>("Hello");
请注意，在这里有两处都需要用到具体类型的信息：一处是在strcel1的类型声明中，一处是
作为构造器调用的一部分。
当然，我们的单元不能直接这样使用，它们是SingleLinkQueue类的一个内部组成部分，
SingleLinkQueue类的声明如下：
class SingleLinkQueue<E>{
protected Cell<E> head;
protected Cell<E> tail;
248
public void add(E item){
Ce]l<E> cel]= new Ce1l<E>(item);
if(tail== nul1)
head = tail = cel1;
else {
tail.setNext(cell);
tail= cel7;
}
}
public E remove(){
if(head == nu71)
return nul1;
Cell<E> cell= head;
head = head.getNext();
if(head == nul1)
tail= null;// empty queue
return cel1.getElement();
}
}
元素类型为E的队列是由一系列E类型的单元组成的。同样地，每一个在原来的类中使用Ob ject类的地方，现在使用的都是类型变量E。另外，每一个Cell都被替换成了Cell<E>。
我们可以创建并使用String类型的队列，就像这样：
SingleLinkQueue<String> queue=
new SingleLinkQueue<String>();
queue.add("Hello");
queue.add("World");
11.1 泛型类型声明 169
现在，当我们调用remove时就不再需要任何强制转型了：
String hello= queue.removeO);
同时，再也不会有可能将错误类型的元素添加到队列中了：
queue.add(25);// INVALID:won't compile
泛型在定义这些种类的集合类时是非常具有价值的，我们将会在第21章中看到这一点，同
时泛型在许多其他场合也很有用处。
11.1 泛型类型声明
cel1<E>类的声明是泛型声明(generic type declaration)的一个实例，它声明Cel1类是一
个泛型类，其中类型变量E被称为泛型声明的类型参数(type parameter)。当我们使用诸如 Cel1
<String>这样的类型名时，实际上是提供了一个具体的类型引元(type argument)(String)
来替换泛型参数(E),因此也就引入了一个参数化类型(parameterized type)。这与方法调用过程
有些类似，在方法调用过程中，所声明的参数都被赋予了具体的引元值，因此，诸如 Ce11
<String>这样的参数化类型的用法也被称为泛型类型调用(generic type invocation)。
泛型声明可以包含多个用逗号隔开的类型参数，例如，Map接口(见21.8节)定义了一个泛
化的键与值之间的映射，因此它被声明为 interface Map<K,V>,其中K是键类型的类型参
数，而V是值类型的类型参数。
当我们定义泛型类时，所有对这个泛型类的调用都是这个类的表达式。将变量 strce11声
明为Cell<String>就是在告诉编译器 strcel1将引用一个Cell<E>类型的对象，其中E
是String类型的，而不是告诉编译器创建一个新的Cell<String>类。Cell<String>和
cell<Number>并不是两个分离的类，它们两个都是同一个类 Cell的泛型类型调用，只不过
以两种不同的方式应用到了两个不同的对象上。类Cell被称为对应于泛型类声明Cell<E>
的原始类型(raw type)。
下面的代码十分清楚地表明了确实只有一个类，因为same的值是 true:
Cell<String> strCel1= new Cell<String>("Hello");
Cell<Integer> intCel1= new Cell<Integer>(25);
boolean same=(strCel1.getClass()== intCel1.getClass(O);
这可能会让你觉得惊讶，因为我们会认为Cell<String>就是一个类，但实际上只有Cel1这
一个类。在构造器调用中使用<String>和<Integer>并不是在定义类、它们只是声明了将
要被构造的对象的类型信息，使得编译器可以检查对该对象的使用是否正确。在运行时，对象
中并不包含任何泛型类型信息，在上面的例子中，包含元素"Hello"的Cel1对象并不知道它被
构造成了Cell<String>,因为这个信息已经被擦除了；这个概念将在本章稍后部分介绍(见
第11.5.1节)。
无论可能存在多少个不同的参数化调用，泛型类都只有一个单一的类定义，这一事实对我
们能用泛型做什么和不能做什么产生了一些影响。我们接下去将会讨论这些影响，不过所有这
些影响可以归结为一句话：因为只有一个类，所以我们无法做那些只用一个类无法做到的事。
这一事实导致的第一个结果是：具有类型参数的泛型类，假设该参数为E,不能将E用作静
态字段的类型或是用于任何静态方法和静态初始器中。因为要想这样做，就要求对于E的每一
种可能的类型都要有不同的字段和方法。但是由于只有一个类，所以只有一个实际的静态字段
或方法，这样代码就无法依赖于E的值。静态成员从来都不依赖于特定的参数化这一事实，通
过我们不能用参数化的类型名来引用静态成员这一规则得到了强化。例如，如果 Sin-
249
250
170 第11章 泛型类型
gleLinkQueue有一个静态的 merge 方法，那么它必须像这样被调用：SingleLinkQueue.
merge,而像SingleLinkQueue<Integer>.merge这样的调用将无法通过编译。类似地，为
了强化只有一个单一的类对象这一事实，像SingleLinkQueue.class 这样的类字面常量只能
使用原始类的名字。
在泛型类的定义中，类型参数可以出现在任何我们通常是要放置具体类型名的非静态声明
中：在字数声明、方法返回类型或参数类型声明、局部变量声明，以及嵌套类型声明中。其中大
多数情况的例子都可以在Cell类和 SingleLinkQueue类中看到。
有两个地方只能使用类名而不能使用类型参数——那就是创建对象和数组。例如，下面的
代码在错误地试图将队列的元素暴露成一个数组：
class SingleLinkQueue<E> {
// ...
public E[] toArray(){
int size = 0;
for(Cell<E> c= head; c!= null;c= c.getNext())
size++;
E[] arr= new E[size];// INVALID:won't compile
// ... copy in elements ...
}
}
我们不能实例化E或是创建一个E的数组，这与我们不能拥有类型为E的静态字数有着相同的
原因：单一的类只有单一的 toArray定义，编译器必须在编译期确定将要生成哪些用于创建对
象或数组的代码，而编译器无法根据E随机的类型来生成 new String[size]或是new Inte-
251 ger[size]。
现在我们可能想知道编译器会对类型参数做些什么?答案是如此令人疑惑地简单：编译器
会使用最泛化的可用类型来表示类型参数(经常是Object),并使用类型强制转换来确保类型
的正确性。我们可以将泛型看作是一种(潜在地经过优化的)编写所有那些强制转型的快捷方
式，稍后将会进一步地解释。
那么我们如何将队列的元素暴露为数组呢?我们可以暴露队列的大小，然后让调用者去创
建并传递一个拥有正确大小和类型的数组(稍后我们会展示)或者我们可以让调用者提供E的
类型符号(type token)(实际类型引元的Class 对象),并使用反射来创建一个拥有正确大小的
数组(见16.10.1节“泛型数组和动态数组”)。
练习11.1:回顾练习2.2中的LinkedList类，将其重新编写为一个泛型类。
练习11.2:重写第3章中的Attr类，使其成为一个泛型类。
练习11.3:练习11.2方法可行吗?Attr成为泛型对在第4章中定义的Attributed接口
产生了什么样的影响?这对Attributed 对象意味着什么?
11.1.1 有界类型参数
在Cell<E>的泛型类定义中，类型变量E可以完全替换为任何引用类型。但是有时候允
1.这是在运行时的对象中没有任何有着参数化类型的信息所造成的结果，见11.5节。
11.1 泛型类型声明 171
许在泛型类中使用任意的类型引元并没有多大意义，例如，排序集合只能保存可排序类型的对
象。就像我们多次看到的那样，定义可以被排序的事物的途径就是让它实现Comparable接
口，Comparable自身就是一个泛型接口，拥有一个单一的类型变量，用来标识当前的类型可以
与何种类型进行比较。通常，给定类型的对象应该只与具有相同类型的其他对象进行比较，因
此典型的可比较的Value类应声明为：
class Value implements Comparable<Value> {
// ...
}
与此相同，排序集合将限制它的类型参数必须是实现了Comparable接口的类型：
interface SortedCollection<E extends Comparable<E>>{
// ... sorted collection methods ...
}
这里E被限制成“扩展”了Comparable<E>的类型，因此我们必须了解无论我们提供了
什么样的类型引元，它都会保证支持Comparable接口中的方法，我们称 Comparable接口为E
类型的上界(upper bound),而E则是一个有界的(bounded)类型参数。在这里使用的关键字 ex tends的含义很宽泛，即可以是“扩展”也可以是“实现”,这取决于后面跟随的类型是类类型还
是接口类型。任何给定的类只能扩展一个其他的类，但是可以通过类或接口实现多个接口。类
型边界可以通过以下方式来表示这样的多重依赖关系：声明类型参数扩展了一个类或接口，并
在后面跟随一个由“&”符号分隔开的其他必须实现的接口的列表。例如，字符序列的排序集合
可以像下面这样声明：
interface SortedCharSeqCollection<E extends Comparable<E>
& CharSequence> {
// ... sorted char sequence collection methods ... }
例如，这样的集合可以保存String 对象。
11.1.2 嵌套泛型类型
嵌套类型也可以被声明为拥有其自己的类型变量的泛型。因为静态成员不可以引用它们自
己的类中的类型变量，所以任何静态嵌套类型中的类型变量与任何外部类型的类型变量之间都
有所区别，即使它们拥有相同的名字。例如，如果想要把Cell 对象设计成仅在 Sin gleLinkQueue对象内部使用，那么将Cel1设计成 SingleLinkQueue内部的一个静态嵌套类
就是合理的：
class SingleLinkQueue<E> {
static class Cel1<E>{
private Cell<E> next;
private E element;
public Cel1(E element){ this.element = element;
}
public Cel1(E element,Cell<E> next){
this.element = element;
1.稍后你将看到与此稍有不同的更好的声明，但现在我们仍然让它保持简单。
252
253
254
172 第11章 泛型类型
this.next= next;
}
public E getElement(){
return element;
}
/* ... rest of Cel1 methods as before ...*/
}
protected Cel1<E> head;
protected Cell<E> tail;
/* ... rest of SingleLinkQueue methods as before ...*/ }
cel1类和 SingleLinkQueue 类的代码并没有改变，只是Cel1类被声明成了 Sin gleLinkQueue内部的一个静态嵌套类。这两个类中都用到了类型变量E,因为单元是队列的
一部分，由此单元的元素类型必须与队列元素的类型相匹配，但是它们拥有不同的名字。两个
不同的E类型在 head和 tail的声明中被关联起来，其中 SingleLinkQueue类的E类型参数
定义了参数化类型Cell<E>。与往常一样，我们应该仔细地选择名字以避免混淆。如果类型
变量应该总是表示相同的类型，那么就应该使用相同的名字；如果它们可以是不同的类型，那
么就应该使用不同的名字。
如果嵌套类型是一个内部类，那么外部类声明中的类型变量对它来说就是可以访问的，并
且可以直接使用。例如，队列的另一种替代设计是使用非泛型内部类来定义单元对象：
class SingleLinkQueue<E>{
class Cel1{
private Ce11 next;
private E element;
public Cel1(E element){
this.element = element;
}
public Cel1(E element,Cell next){
this.element = element;
this.next = next; }
public E getElement(){
return element;
}
/*... rest of Cell methods ...*/
}
protected Cel1 head;
protected Cel1 tail;
public void add(E item){
Cel1 cell= new Ce11(item);
if(tail == nu11)
head = tail= cell;
else {
tai1.setNext(cell);
tail= cel1;
}
11.2 使用泛型类型 173
}
public E remove(){
if(head == nu11)
return nul1;
Cel1 cell= head;
head = head.getNext();
if(head == nu11)
tail = nul1;// empty queue
return cel1.getElement();
}
/* ... rest of methods ...*/ }
这一次单元的元素类型直接与其所属的队列的元素类型进行了绑定，因此也就不需要将 Cell
声明为泛型类了。
如果我们选择了使用泛型内部类，那么内部类中的类型变量就会隐藏外部类中与其同名的
任何类型变量，但通常是应该避免隐藏的。
当嵌套类型是泛型时，深层嵌套的类型也往往是一个问题。嵌套类型和泛型类型都增加了
程序复杂性的程度，而它们的结合更是极大地加深了这种复杂性。
11.2 使用泛型类型
为了使用泛型类型，我们必须为每一个类型参数都定义一个合适的参数化类型，以提供所
需的类型引元。例如，我们在前面看到过：
SingleLinkQueue<String> queue=
new SingleLinkQueue<String>O;
变量 queue的类型是SingleLinkQueue<String>,构造器调用也声明了参数化类型 Sin gleLinkQueue<String>。参数化类型必须为泛型类型所声明的每一个类型参数都提供一个
类型引元。
与使用非泛型类型相比，使用泛型类型需要做更多的准备：当我们需要声明字段、局
部变量、方法参数或返回类型时，我们必须指定想要使用的合适的参数化类型。例如，一
个域应该是SingleLinkQueue<String>类型呢，还是应该是SingleLinkQueue<Num
ber>类型的?或者它是否应该能够引用任何队列，比如 SingleLinkQueue<Object>
类型?这看起来是一个很容易回答的问题——实际上好像我们要做的就是要回答它：我们
应该指定一个类型参数，它可以赋值给任何我们想要赋值的类型。但问题是，我们指定这
种类型的方式并不是上面所展示的那种方式，因为泛型构造子类型的方式并不像我们所想
象的那样。
子类型化和通配符
假设我们想编写一个方法来统计某个 List中的所有元素的总和，其中List是java.
util包中的集合接口之一，我们将在21.6节中描述它。自然，我们只能计算数字的总和，因此
我们要求传入的列表只包含 Number 对象。下面的代码看似可以解决这一问题：
static double sum(List<Number> list){
double sum = 0.0;
255
256
257
174 第11章 泛型类型
for(Number n:list)
sum += n.doubleValue();
return sum;
}
上面代码的目的是可以将任何其元素与Number 兼容的List对象传递给sum的方法，但那不是
参数化类型 List<Number>的含义：它表示传递进来的对象要与元素被声明为Number的
List 兼容。如果我们试图用List<Integer>去调用 sum方法，那么我们的代码将不能编译：
List<Integer> 1= new ArrayList<Integer>();
1.add(1);
1.add(4);
1.add(9);
double sum = sum(1);// INVALID:won't compile
问题在于即使Integer是Number的子类型，List<Integer>也不是List<Number>的子
类型。这与数组相反，在数组中Integer[]是Number[]的子类型。
我们必须找到一种方法来声明一个List,使其元素类型是与 Number相兼容的任意类型，
能够实现这一目的的方式就是使用通配符“?”:
static double sum(List<? extends Number> list){
double sum =0.0;
for(Number n:list)
sum += n.doubleValue();
return sum;
}
在这个例子中，通配符表示我们需要任意类型的 List,只要该类型是Number 或是Number的
子类即可。更正规地讲，我们需要一个有界通配符(bounded wildcard),其中Number 构成了我
们所期望的类型的上界：无论我们得到什么类型，它必须至少是一个Number。
我们也可以指定通配符类型必须与某个类或是其超类相同，可以通过使用super而不是
extends 关键字来实现这一目的。例如，我们可以使用List<?super Integer>来匹配一个
List,其元素是Integer 或是其任何超类，即：List<Integer>、List<Number>、List
<Serializable>、List<Comparable<Integer>>或者 List<Object>。在这种情况
下，该类型表示通配符类型的下界(lower bound)。
请注意，有界通配符与有界类型变量不一样，它只可以拥有一个单一的边界，要么是上界，
要么是下界。例如，如果我们想将列表的类型限制为其包含的元素至少是value类，同时还要
实现了Serializable,那么我们就不能将其声明为List<? Extends value& Serializ able>。
当然，我们也可以使用无界通配符(unbounded wildcard)。例如，List<?>表示任意类型
的列表，其隐含的上界是Object。但是请记住，List<?>并不是List<0bject>的另一种
写法，而是List<? extends Object>的另一种写法。
与无通配符的版本相比，包含有界通配符的参数化类型之间的关联方式与我们所期望的方
式相吻合，例如，List<?extends Integer>是List<? extends Number>的子类型，而
List<?extends Number>自身还是List<?>的子类型。类似地，List<?super Number>
是List<?super Integer>的子类型。另外，无通配符的参数化类型是相应的有界通配符参
数化类型的子类，例如，List<Number>是List<? extends Number>的子类，和List
<Integer>一样。虽然这是一个很好的特性，但有界通配符的有无所导致的行为之间的差异
11.2 使用泛型类型 175
可能会成为导致混乱的缘由。或许下面图11-1能够描述得更清晰：
List<?>
List<0bject> List<? extends Number>
List<? extends Integer> List<Number>
List<Integer>
图 11-1
通配符的这些属性使它们不仅很有用，而且还是有效使用泛型类型的精华所在。无论何
时，只要方法接受的参数是参数化类型的，或者方法返回的是参数化类型，该参数化类型就几
乎总是应该用某种通配符形式来表示。典型情况下，参数使用的是有下界的通配符，而返回类
型使用的是有上界的通配符——但是如果在参数类型和返回类型之间存在着某种约束关系，那
么就有可能不能使用通配符了。即使是参数化类型的类型边界，也经常会使用通配符来表示。
回忆一下 Sortedcollection<E>接口的例子，我们限制了类型参数E,让它必须扩展Compa rable<E>。这看起来很合理：要对一个集合排序，我们需要集合中的元素必须互相之间是可
比较的。但实际上，这项约束过于严苛了：对于类T的两个元素，要想让它们互相之间可以比
较，并不需要T必须扩展Comparable<T>,而只需要T扩展Comparable<S>,其中S是T
或T的任何超类型。例如，如果Value类实现的是Comparable<0bject>,那么它仍然可以
正确地比较两个value对象——但它只是碰巧可以做得更多。因此，Sortedcollection应该
声明如下：
interface SortedCollection<E extends Comparable<? super E>>{
// ... sorted collection methods ...
}
通配符在sum这个例子中对于获得我们所需的灵活性是很重要的，但它们也有局限性：由
于通配符表示的是未知类型，所以我们无法做任何需要类型已知才能做的事情。例如，对于具
有无界的或有上界的通配符类型的变量，我们不能通过它将元素添加到它所引用的队列中：
SingleLinkQueue<?> strings =
new SingleLinkQueue<String>();
strings.add("Hel1o"); // INVALID:won't compile
SingleLinkQueue<? extends Number> numbers =
new SingleLinkQueue<Number>();
numbers.add(Integer.valueOf(25));// INVALID:won't compile
这是一个合理的约束，因为在通常情况下，如果传递进来的是一个未知类型的队列，我们
1.由于引用字面常量 null没有任何类型，所以类型系统将允许你在调用 add方法时传入 nul1,但这是一种几乎
没有任何实际意义的边界情况。
258
259
260
176 第11章 泛型类型
将无法得知在其中可以存储什么类型的对象，因此我们无法在要求元素属于其他类型的队列中
存储 String 对象(或者Object、Number 对象等等)。我们也不能在已知其元素属于Number对
象或 Number的子类对象的队列中保存Number 对象，因为在子类对象的情况下传递泛化的
Number 对象是不正确的。但是，如果是上面的strings,我们可以调用 remove并将结果赋值
给object引用——因为返回值必须与Object兼容。类似地，如果是numbers,我们也可以调
用 remove方法并将结果赋值给Number引用———因为返回值必须至少是Number。
与此不同的是，如果是有下界的通配符类型，那么通配符必须与边界或者是边界的超类相
同，因此，向队列中添加与下界类型相同的元素始终是正确的。例如，下面这个方法是百分之
百正确的：
static void addString(SingleLinkQueue<? super String> sq){
sq.add("Hel1o");
}
无论传递给 addstring的是什么样的队列，都可以确保它可以保存 String 对象。
通配符可以在大多数的声明中使用：字段、局部变量、参数类型和返回类型。但是我们不能
用它们命名 extends 或 implements子句中的类或接口。类(或接口)所扩展或实现的任何参
数化类型都必须是实体类型，其中的直接类型引元并不是通配符。例如，我们不能定义实现了
List<?>接口的类。但是，类型引元本身可以是参数化类型的，并且该参数化类型带有的类
型引元可以是通配符，因此，实现List<List<?>>是允许的。
我们将会在第21章详细探讨集合类的时候看到更多关于通配符使用的例子。
11.3 泛型方法和泛型构造器
前面我们提到 SingleLinkQueue类可能想要将队列中的元素暴露为一个数组，然后我们
注意到不可能用类型变量E来创建数组，而且调用者应该传入一个包含正确大小和类型的数
组。下面是对定义这样一个方法的第一次尝试：
public E[] toArray_v1(E[] arr){// too restrictive!
int i= 0;
for(Cel1<E> c= head;
c!= nu11&& i<arr.length;
C=C.getNextO)
arr[i++]=C.getElement();
return arr;
}
这个方法能够正常工作。如果我们在SingleLinkQueue <String>的某个实例上调用 toAr ray_v1并传入一个String[],那么将会有个数与数组大小相同的队列元素被复制到数组中，
然后这个数组将被返回。这个定义的问题正如我们在通配符的讨论中所猜到的那样、它过于严
格了。在当前这个例子中，它将仅接受 String[],而不能接受诸如 object[]这样的引元-
尽管把 String 对象存储到Object[]中也是完全合法的。
我们能否使用通配符来帮助我们解决这样的问题呢?遗憾的是，不可以。为了使用通配
符，我们试图编写出下面这样的代码：
public?[] toArray(?[]){...}// INVALID:won't compile
但这不是合法的语法：通配符表示的是参数化类型定义中的未知类型，而“?[]”并不是参数化
类型。我们需要做的就是引入另一个类型变量，比如T,并用它来描述数组的类型，而我们在方
11.3 泛型方法和泛型构造器 177
法中引入新类型变量的方式就是声明该方法是泛型方法(generic method)。
我们可以通过在方法修饰符和方法返回类型之间定义类型变量来声明泛型方法，这与为泛
型类或泛型接口声明类型变量很相似。以下是如何将 toArray方法定义为泛型方法的代码：
public <T> T[] toArray(T[] arr){
Object[] tmp= arr;
int i= 0;
for(Cel1<E> c= head;
c!= null && i<arr.1ength;
C= C.getNextO)
tmp[i++]= c.getElement();
return arr;
}
注意类型变量T仅用在了方法头中，用以限制参数类型与返回类型必须相同，因为在方法体内，
我们并不关心类型T是什么。但同时还要注意，在方法体内，我们实际上使用了一个类型为
Object[]的局部变量，它引用的是实际传入的数组。这是必需的，因为该数组的类型是T,而
getElement方法返回的是E,这两者是不同类型的——T可能是Object类型的，而E是
String类型的。我们可以将E强制转换为T,但只有在E和T兼容的情况下才会成功，由于这
样的强制转换是不受检查的强制转换，所以将会产生编译器警告信息(见11.5.1节“运行时擦
除”)。因此，我们要使用Object[]变量来跳过这个问题。
现在你可能会问自己：“类型E和T既然是兼容的，那么在它们之间难道不应该存在某些
限制吗?”逻辑上讲，可以有这样的限制：T的类型必须和E或E的超类型相同。遗憾的是，无
法表示这样的限制。通配符只能给出类型下界，因此我们不能将<T super E>写作类型变量。
无论如何，这样的限制并不是严格必需的。假设我们有一个SingleLinkQueue<Object>,
并且知道我们只会用String实例对其进行填充，那么我们为什么不能传递给 toArray方法一
个String[]呢?因为 String不是Object的超类。因此，实际上不会有任何编译期类型检查
会去检查T和E之间是否兼容，我们只能依赖运行时类型检查，而这常常只有在将一个引用存
储到数组中时才会发生。
泛型方法和泛型构造器通常用于以下两种情况：一种是需要引入类型变量来限制不同参数
的参数化类型，一种是像 toArray那样限制参数与返回类型。例如，考虑 SingleLinkQueue
的merge操作，通过它将源队列的元素移动到目标队列中。为了实现合并，源队列的元素必须
与目标队列的元素类型相同，或者是其子类型，我们可以利用通配符来声明这样的泛型方法：
public static <E> void merge(SingleLinkQueue<E> d,
SingleLinkQueue<? extends E> s)
{
// ... merge s elements into d... }
我们也可以引入第二个类型变量比如S来替代通配符以达到相同的效果。那么哪个更可取呢?
通常的规则是尽可能地使用通配符，因为比起使用多个类型参数的代码来说，使用通配符的代
码更具可读性。当我们决定使用类型变量时，要先问问自己这个类型变量是不是用来关联两个
或多个参数的，或者是不是用来关联参数类型和返回类型的。如果答案是否定的，那么通配符
应该就足够了。在上面的例子中，S只会出现在一个地方，因此可以直接用通配符来代替它。
泛型方法并不需要在泛型类型中声明，如果确实这样做了，那么它们的类型变量就会有差
异了。对于内部泛型类型，如果泛型方法声明的类型变量与该方法所在的类或接口中的类型变
261
262
263
178 第11章 泛型类型
量同名，那么外部的类型变量将被隐藏。最后要注意的是，像merge 这样的静态方法可以是泛
型方法，虽然它不能引用它自己的泛型类中的任何类型变量。
泛型调用和类型推断
如果我们调用了像 toArray或 merge 这样的泛型方法，那么编译器必须像为其他方法调
用所做的那样，去确保我们传入的引元都具有正确的类型，并且任何返回值都赋值给了具有正
确类型的变量。在我们创建泛型类的实例时，就是在用参数化类型把某个特定的类型引元绑定
到该类的类型变量上。类似地，我们也可以参数化方法调用来为方法类型变量提供类型引元。
例如，考虑下面这个直接返回其引元的泛型方法：
<T> T passThrough(T obj){
return obj;
}
我们可以将 passThrough作为 String类型的方法来调用：
String s1= "Hello";
string s2= this.<String>passThrough(s1);
这个参数化的方法调用告诉编译器T应该被当作 String类来处理，同时 passThrough 的引元
和返回值必须做相应的校验。
幸运的是，我们很少需要显式地参数化一个方法调用。当缺少类型引元时，编译器将从静
态引元类型以及返回类型被使用的方式中推断出将会使用何种类型。例如，下面的对 pass Through 的调用与前一个例子是等价的，但是它利用了类型推断来建立T的类型：
String s1= "Hello";
String s2= passThrough(s1);
在此种情况下，参数类型被推断为 String,它是变量s1的静态类型，这意味着返回类型也是
String。这与对s2的赋值是兼容的，因此用推断出来的 String类型来进行调用是合法的。
下面对 passThrough 的调用也是合法的：
String s1= "Hello";
0bject ol= passThrough(s1); // T=> String
Object o2= passThrough(CObject)s1);//T=> Object
在第一种情况中，引元类型是String,期望的返回类型是Object。T的推断类型仍然是
String,这意味着返回类型也是String,这与对object变量o1的赋值是兼容的，因此使用
推断类型 String进行调用是合法的。在第二种情况中，因为引元的静态类型是Object(这是
强制转换而来的),所以推断类型也是Object,这使得返回类型也是Object,因此我们再次得
到了兼容的赋值，于是该调用也是合法的。大体上，类型推断会在满足类型变量所施加的限制
条件的类型集中寻找最具体的类型——这可不是一件易事。
类型推断是基于传入的引元表达式的静态类型来进行的，而不是基于它们的动态类型进行
的，因此下面的代码无法通过编译：
String s1= "Hello";
s1 = passThrough((object)s1);// INVALID:won't compile
静态引元类型Object要求T作为方法的返回类型也必须是Object(或者是Object的超类，
如果有的话),而s1是String类型，这要求T必须是可赋值给 String 的类型，但是根本没有
这样的类型，因为我们不能将Object赋值给 string 引用。当然，我们可以通过插入额外的强
制转换来告诉编译器我们知道返回的对象的确是String类型的：
11.4 通配符捕获179
s1=(String)passThrough((object)s1);
实际的类型推断过程和控制它的规则都是极其复杂的，但是大多数时候，我们无需关心实际的
推断类型到底是什么,只要代码能够通过编译就行了。例如，如果某个泛型方法接受了两个类
型为T的参数，并且我们在调用它时传入了一个List<String>和一个List<Number>,那
么推断类型将会是List<?>。推断也是确定哪个方法将被调用的过程中的一个组成部分，我
们很快就会看到。
推断过程可能会产生像Object或 String 这样的简单类型，也可能会产生更复杂的类型，
对这些复杂类型来说，不存在任何可以表示它们的单一的类或接口的声明——例如，一个即是
Runnable也是Cloneable的类型。这些复杂的类型常常被称为交集类型(intersection type)。
对于每一个类型变量上的限制条件，都存在着一个可以满足该限制条件的类型集，而这些集合
的交集就包含了推断类型。
最后要注意的是，如果我们的确想要创建参数化的方法调用，那么请记住我们不能参数化
仅使用了简单方法名的调用：
String s1= "Hello";
String s2 = <String>passThrough(s1);// INVALID:won't compile
我们必须恰当地限定方法名，例如对实例方法使用 this或 super关键字，或是对静态方法使
用类名。
11.4 通配符捕获
通配符表示的是未知类型，但是无论何时只要使用了具有通配符类型的变量，编译器就必
须将其当作具有某种具体类型的变量来处理，以便编译器可以检查对它的使用是否正确。这个
具体的(但仍旧是未知的)类型被称为通配符的捕获(capture),我们最常碰到通配符捕获的地方
是在当我们以错误的方式使用某个参数化类型时，编译器所产生的错误信息中。例如，回忆一
下试图将 String 对象添加到通过无界通配符引用来访问的队列中的错误情形：
SingleLinkQueue<?> strings =
new SingleLinkQueue<String>();
strings.add("Hel1o"); // INVALID:won't compile
我们所使用的编译器对于这段代码所产生的错误信息是：
add(capture of ?)in SingleLinkQueue<capture of?> cannot be applied to(java.lang.String)
这条信息告诉我们当使用通配符引用 strings 时，队列的类型是SingleLinkQueue<cap ture of?>,因此传递给 add的参数类型也是“capture of?”。因为 String与“capture
of ?”并不兼容，所以这样的调用是不允许的。即使通配符是有界的，就像在前面使用数字队列
("?extends Number”)的例子中一样，传递给 add 的参数类型是“capture of?extends
Number”,它与Integer仍然是不兼容的，尽管Integer是Number 的子类型。
如果通配符总是由其捕获来表示，那么看起来就好像是一旦我们拥有一个通配符类型，只可
以将它用于任何期望使用通配符类型的地方。确实，这是一条确保类型系统完整性的基本规则。
但是，现在要面对的是这条基本规则又施加了一个相当烦人的限制。通配符表示的是任何
类型，类似地，泛型方法的类型变量表示的也是任何类型。但是在这条基本规则之下，通配符
类型只能在期望出现它的地方使用。这就排除了这种可能性：将通配符类型传递给拥有由类型
变量定义的参数的泛型方法。考虑一下Collections类中的 synchronizedList 工具方法，
其中collections类是第21章将要详细叙述的java.util包的一部分，它的工作是接受一个
264
265
180 第11章 泛型类型
任意的列表对象并返回一个对这个列表进行备份的新的列表对象，但是该列表对象中的所有方
法都是synchronized的，这使得对列表的访问是线程安全的(见第14章)。该方法声明如下：
static <T> List<T> synchronizedList(List<T> list){...}
并不存在任何逻辑上的原因表明我们不能传递一个由通配符类型引用的列表：
static void processList(List<?> list){
List<?> slist= Collections.synchronizedList(list);
// ... process the list
}
因此，这样做是非常安全的，而且相当方便!
虽然在通常情况下，我们不能在期望出现List<T>的地方使用List<?>,因为该通配
符所表示的实际类型是否与T兼容是未知的，有一条特殊的规则在泛型方法的通配符类型和类
型变量之间的鸿沟上架起了一道桥梁。这条规则允许(在恰当的环境下)通配符的捕获可以被
表示为某种未知的泛型类型x,然后在调用中推断T就是X。我们实际上并不需要知道X是什
么——无论它是什么,所产生的对列表的使用方式都可以保证是类型安全的。
这种从通配符捕获到类型T的转换被称为捕获转换(capture conversion),它是对9.4节中我
们所讨论的其他类型转换的补充。
为了使捕获转换得以进行，在所涉及的通配符捕获与类型变量之间必须存在一个唯一的映
射，这使得在何时可以应用捕获转换这一点上存在着某些通用的限制。
首先，捕获转换无法应用于类型参数被多个方法参数所使用的情形。考虑下面这个合并两
个列表的工具方法：
static <T> List<T> merge(List<T> first,List<T> second){
/* ...*/
}
如果我们试图将类型为List<?>的引元传递给 first和 second,那么即使我们传递的是同
一个引用，也会失败。问题在于，解析该方法调用的过程本质上是用X替换第一个引元的类型，
用Y替换第二个引元的类型，然后查看T是否可以被唯一地确定。但是由于X不同于Y,所以
这使得捕获转换无法应用。
其次，只有当类型变量定义于顶层泛型类型时，才可以使用捕获转换。例如，假定我们有
这样一个方法：
static <T> void processListOfLists(List<List<T>> list){
/* ...*/
}
然后我们试图使用List<List<?>>类型的引元来调用它，那么通配符捕获将不能唯一地确
定外层List的元素类型。该方法要求传递一个所有元素都是相同类型的List,但是一个元素
类型为List<?>的列表可以包含List<String>、List<Object>等等，因此捕获转换不
能应用于这种情况。
最后，像通常情况一样，我们无法在任何需要知道通配符类型的地方使用通配符引用。例
如，假设有如下的方法；
static <T> void addToList(List<T> list,T t){
/* ...*/
}
我们不能传递List<?>类型的引用，因为T的推测类型是“capture of?”,而对于参数t来
11.5 揭秘：擦除与原始类型181
说，不存在任何我们可以传递给它的与“capture of ?”兼容的类型。或者从另外一个角度来
看，T的类型将由我们传递给t的类型确定，无论它是什么,它都不可能是“capture of?”,因
此T的类型无法被唯一地确定。
11.5 揭秘：擦除与原始类型
正如我们数次指出的，无论从泛型类型中可以形成多少种参数化类型，每一个泛型类型也
都只有一个类。这就引发了一个问题：这个类型究竟是什么?对于像Cell<E>这样的类，
Cel1<String>和Cell<Number>到底共享的是什么类型呢?
为了确定这个问题的答案，编译器使用了一个称为擦除(erasure)的处理过程(因为编译器
本质上是要从编译过的类中擦除所有的泛型类型信息)。泛型类型或参数化类型在被擦除之后
就是一个不加任何修饰的类型名了，它被称为原始类型(raw type)(见附录A.3.1“原始类型、
‘不受检查的’警告以及桥接方法”),例如，Cell<E>的擦除就是Cel1。类型变量的擦除就是
其第一个边界的擦除，例如，对<E>中的E的擦除是其隐式的上界 Object。对<E extends
Number>中的E的擦除是其显式的上界Number,就像它在<E extends Number &
Cloneable>中的情形一样，因为Number是它的第一个边界。编译器通过有效地将每一个类
型变量替换成其擦除类型，为泛型类型擦除生成了一个类定义。当使用参数化类型，并且在泛
型类型的擦除中得到的类型信息与所期望的类型不匹配时，编译器会插入一个强制类型转换。
例如，如果我们在一个作为 SingleLinkQueue<String>而被创建，并赋值给 String引用的
对象上调用 remove方法，编译器将会插入一个转换到String 的强制类型转换，因为 Sin gleLinkQueue<E>中的类型变量的擦除仅仅是Object。
我们需要理解擦除的过程，因为它会在两类关键的地方影响我们的程序：
·涉及泛型类型的运行时动作
·方法的重载和覆盖
让我们从运行时的问题开始。
11.5.1 运行时擦除
擦除在运行时的影响是很容易描述的：任何在运行时需要知道类型引元值的实体都是不允
许的。这带来了下面的结果，有些我们已经讨论过了：
·我们不能实例化仅被表示成类型参数的类型，也不能创建这种类型的数组，因此对于类
型变量T,我们不能执行 new TO)或 new T[n]。
·我们不能创建其元素类型是参数化类型的数组，除非用于该参数化类型的所有类型引元
都是无界通配符。例如，"newList<String>[1]”是非法的，而“newList<?>[1]"
则是合法的。
·我们不能使用 instanceof来查看一个对象是否是某个参数化类型的实例，同样除非该
参数化类型的所有类型引元都是无界通配符。instanceof测试是运行时测试、而在运
行时参数化类型已经被它的擦除所替代了。既然它没有像我们所期望的那样执行测试，
编译器当然会拒绝它。如果的确想进行这样的测试，可以将参数化类型替换为它的
擦除。
·涉及类型参数或参数化类型的强制转换将被替换为该类型的擦除的强制转换(请看下面
的讨论)。
·catch子句不能被声明为它将捕获由类型变量所表示的异常，即使该类型变量的边界是异
266
267
268
269
182 第11章 泛型类型
常类型，因为异常的确切类型必须在编译期才能知道。(但是，我们可以抛出被这样引用
的异常，并且可以在方法的 throw子句中声明类型变量。)
·泛型类不允许直接或间接地扩展Throwable。由于我们无法捕获泛型异常，所以声明它
们也没有什么意义。
·我们不能在类字面常量表达式中使用参数化类型(例如 SingleLinkQueue<String>.
class),这强化了只有一个类对象的概念。
对于创建参数化类型数组的限制可能有一定局限性，但它很重要。例如，让我们考虑一个
List的实现，它提供了一个 split方法，将返回被大量子列表分割后的列表内容。将子列表
当作一个列表数组返回看起来似乎很合理，因此对于实现了List<T>的类，其 split方法将
返回List<T>[]。我们确实可以声明这样的方法，但在实现时将会困难重重。我们无法创建
其构件类型为List<T>的数组，任何尝试返回某种不具体的数组类型(比如 List[])的做法
都会产生“不受检查”的警告(见下文)。我们不能创建诸如 List<T>[]这样的泛型数组的原
因在于对数组的正确使用是无法通过类型系统来强制要求的，这是因为数组存储检查是基于其
构件类型的擦除的，而不是基于构件类型实际的参数化类型的，因此我们可以在我们假定其构
件类型为List<String>的数组中存储任何类型的List。不允许我们创建泛型数组就可以避
免这样的问题，从程序员的角度来看，尝试着使用合适的参数化类型集合会比使用数组更好。
例如，split方法可以被定义为返回List<List<T>>。
在数组创建和 instanceof中，允许对参数化类型使用无界通配符，因为这样的类型与其
原始类型是完全等价的。例如，创建 List<?>[1]与创建List[1](其构件类型为原始类型的
数组)是完全等价的。但是，这两种形式之间有一个显著的区别：原始类型允许不安全的操作，
但是会导致编译器抛出警告，而通配符形式禁止不安全的操作，所以它将会引起编译期错误。
泛型类型信息在运行时的缺失，则意味着涉及类型参数或参数化类型的强制转换可能不会
具有所预期的效果：因为我们无法检查一个对象是否是某个参数化类型的实例，所以在运行时
无法检查到该类型的强制转换，除非所有的类型参数都是无界通配符。在理想情况下，每一个
使用泛型的地方都不允许使用这样的强制转换(例如使用instanceof情况)。但是必须提供某
种程度的泛型代码与非泛型代码的互操作性，所以强制转换是允许的，但是只允许转换到类型
变量或参数化类型的擦除的强制转换，而此时编译器往往会抛出“非检查型的”警告(见附录A.
3.1)。这条警告在提醒我们这个强制转换要么在运行时不会被检查，要么在编译时无法保证是
类型安全的。例如，拥有 SingleLinkQueue<?>参数的方法可以将该参数强制转换为 Sin gleLinkQueue<String>,并向其中添加 String,这将引起编译器抛出“非检查型”警告。在
运行时，实际对 SingleLinkQueue 的类型强制转换将会成功执行，即使队列实际的类型是
SingleLinkQueue<Number>,String也可以被添加到其中，这打破了队列的类型完整性。
这个破绽只有在remove方法调用试图将返回实例强制转换为 Number 时才会被发现，此时将
抛出运行时的ClasscastException异常。然而请注意，如果强制转换并不涉及对类型参数的
修改，那么这个转换就是相当安全的，并且不会产生任何警告。例如，将Collection<T>强
制转换为List<T>并不需要对T作任何检查。
涉及参数化类型的强制转换在许多情况下是不可避免的，例如，如果某个方法声明返回的
是一个(很可能是非泛型的)超类型对象，而实际返回的对象的类型是泛化的子类型，这时我们
就需要将其强制转换为该泛型的子类型。在这样的情况下，我们应该使用只涉及无界通配符的
强制转换，并将结果赋值给也声明了无界通配符的变量。事实上，我们需要使用强制转换就意
味着会丢失有价值的类型信息，并且没有任何方式可以在运行时恢复这些丢失的信息，因此转
11.5 揭秘：擦除与原始类型183
换到参数化类型的强制转换应该总是使用无界通配符。例如，考虑passThrough方法的非泛
型版本：
Object passThrough(Object o){
return o;
}
我们用一个List<String>实例来调用它：
List<String> 1= new ArrayList<String>();
Object o= passThrough(1);
List<String> list1=(List<String>)o;// unchecked
List<String> list2=(List)o; // unchecked; raw type List<?> list3 =(List)0; // OK:but raw type List<?> list4=(List<?>)0; // OK
强制转换为List<String>的做法与强制转换为List<?>(或者是等价的原始类型List)
是等效的。在运行时，我们可以拥有某种类型的列表，但我们不能确认它就是一个List
<String>,因此使用强制转换将引发“非检查型的”警告。强制转换为原始类型List本身是
没有问题的，但是将其赋给list2 就会引发“非检查型的”警告，因为这里也无法保证该对象就
是一个List<String>。我们可以通过将其赋给 List<?>类型的变量来消除这个警告，就
像上面的list3——这个强制转换将检查该对象是否是某种类型的列表，以及list3是否可以
保存对这种类型列表的引用。我们应该用转换到 List<?>的强制转换来代替直接转换到
List的强制转换，因为它更清晰地表示了List是一个泛型类型。原始类型是为了保持在泛型
出现之前的遗留代码的完整性而存在的；当我们编写代码时，最好坚持使用泛型表达式这一概
念，而不要使用遗留的原始类型。
不可避免地要用到原始类型的地方就是类字面常量表达式的内部和访问静态成员时，这强
化了这样一个事实：我们正在访问的目标与任何的泛型类型参数化都无关。
在极少数的情况下，我们可能需要明确地知道一个值是否拥有某种特定的参数化类型，即
使类型系统无法在运行时进行校验，对这个参数化类型的强制转换(随之而来的是“不受检查
的”警告)对于保证我们的代码能够通过编译来说也是至关重要的。就像上文提到的，我们需要
强制转换这一事实将意味着类型信息的丢失，因此我们对此的第一个反应应该是要避免丢失类
型信息。如果我们无法做到这一点，就必须清晰地记录下为何会产生“非检查型的”警告，以及
为什么我们可以肯定缺少运行时的类型检查不会带来任何问题。
11.5.2 重载与覆盖
在第2章中我们将重载方法定义成了具有相同名字和不同签名的方法。之后，在第3章中
我们将覆盖方法定义为在子类中与其超类型中可以访问到的方法具有相同名字和相同签名的方
法。当方法签名涉及类型变量时，这些定义必须稍作修改。
首先，“相同的签名”这一定义对于两个泛型方法来说，要求它们拥有相同数量的类型变
量，并且相应的类型变量具有相同的边界。此外，毕竟第二个方法中所使用的类型变量都是用
第一个方法中的类型变量的名字重命名过的，所以它们的形式参数类型必定是相同的。
其次，我们要讨论的是覆盖等价的(override-equivalent)签名，而不是要求相同的(或不同
1.对clone方法的实现就是这样一种情况，见附录A.3.2。
270
271
184 第11章 泛型类型
的)签名：当两个方法的签名相同，或者它们的签名的擦除相同时，我们就说它们具有覆盖等价
的签名。
根据新的定义，当两个方法有着相同的名字，而且没有覆盖等价的签名时，它们就是重载
的方法。考虑这样的一个类：
class Base<T>{
void m(int x){}
void m(T t) {}
void m(String s){}
<N extends Number> void m(N n){}
void m(SingleLinkQueue<?> q){}
}
这里定义了5个不同的方法m的重载版本。将每个方法的签名都替换为它的擦除，我们就可以
得到下面这些对应的方法集：
void m(int x){}
void m(Object t){}
void m(String s){}
void m(Number n){}
void m(SingleLinkQueue q){}
对于类或接口来说，声明两个方法具有相同的名字和相同的签名擦除的做法是一种错误。因
此，试图在 Base 中定义下面这些版本的m方法的做法都是错误的：
void m(Object o){}
void m(Number n){}
<G extends String> void m(G g){}
void m(SingleLinkQueue<0bject> q){}
在上面的每一种情况中，其签名的擦除都匹配了另一种签名的擦除。
当子类型中的方法与超类型中可以访问到的方法拥有相同的名字并拥有覆盖等价的签名
时，子类的方法就可能潜在地覆盖了超类中的这个方法。之所以说是“潜在地覆盖了”是因为有
一个额外的条件必须满足：子类方法的签名必须与超类方法的签名相同，或者必须与超类方法
签名的擦除相同。这一约束使得覆盖成了“单行道”:非泛型类型方法可以覆盖泛型类型方法，
但反之却不可以。之所以允许我们这么做，是为了让我们可以在泛化一个现有类的同时，不会
破坏先前覆盖了这个类的方法的现有子类。
让我们继续上面的例子，扩展Base如下：
class Derived<T> extends Base<T>{
void m(Integer i){} // new overload
void m(Object t){} // overrides m(T t)
void m(Number n){} // overrides m(N n)
}
它引入了m方法的一种新的重载形式，并定义了m方法的两个覆盖实现。
当考虑到重载与覆盖时，我们要记住一条简单的规则：一定要考虑到方法签名的擦除，并
记住我们不能对继承而来的方法进行泛化。
11.6 再谈寻找正确的方法
在9.6.1节“寻找正确的方法”中，我们列出了编译器在确定对于给定的方法调用表达式，
11.6 再谈寻找正确的方法185
应该调用方法的哪一种形式时所使用的基本算法。我们现在可以考虑一下泛型类型和泛型方法
(以及泛型构造器)对这个基本算法所造成的影响了。
对该算法的改动可以总结如下：
1.如果方法调用包含了显式的类型引元，那么任何潜在可应用的泛型方法都必须拥有相同
数量的类型参数。如果非泛型方法也是潜在可应用的，那么实际的类型引元将被忽略。
2.如果调用中没有任何显式的类型引元，但是有一个泛型方法可以应用，那么首先，要根
据该方法调用中所使用的引元表达式的静态类型来推断该将哪种类型引元传递给这个泛型方
法。如果不能推断出任何可以满足类型参数的所有约束条件的类型，那么这个方法将不适用。
3.在每一个阶段，一旦确定了潜在可应用的方法集，就可以像前面所述的那样搜索可应用
的方法。对于泛型方法，显式的(如果有的话)或推断出来的类型引元将确定引元类型是否与形
式参数类型相兼容。
4.在搜索最具体的方法时，如果需要考虑泛型方法，则会再次使用类型推断。但是，这一
次将不再根据实际的引元表达式的类型来推断；相反，主要考虑的是泛型方法的形式参数与那
些被测试是否是最具体的方法的形式参数之间的关系。简单地说，确定是否是最具体的方法的
测试考虑的只是有关方法所声明的参数类型，而不是在方法调用中所使用的引元的类型，这将
在下面举例说明。
5.对最具体的方法的搜索并不是基于“签名的异同”的，而是基于签名是否是覆盖等价的
(如前所述)。
6.如果最具体的方法是一个泛型方法，那么方法调用表达式的类型就是该泛型方法的推断
返回类型，这与上面第2点中应用类型推断所确定的类型一样。
例如，考虑如下的两个m方法的重载版本：
void m(String key,Object val){
// ...
}
<S,T extends Number> void m(S key,T val){
// ...
}
现在让我们考虑下面这个m的调用：
m("hello","world");
这两种形式的m方法都是潜在可应用的，因为它们都拥有正确的名字和正确数量的参数。方法
调用的两个引元都是引用类型，而这两个方法中没有一个具有可变数量的参数，因此在寻找正
确方法时，只需要第1阶段即可。首先，必须推断泛型方法的类型引元。然而，如果想要这样
做，就需要String 扩展自 Number;但事实并非如此，因此泛型形式并不可应用。非泛型形式
是可应用的，因为它精确地匹配了第一个引元类型，并且在第二个引元中，String 也是可以赋
值给 Object的。既然只有一个可应用的方法，那就是它了。
现在考虑下面这个m的调用：
m(new object(),29);
两个方法又都是潜在可应用的。泛型方法的类型在对引元29进行装箱转换之后被推断为<0b ject,Integer>。非泛型方法无法匹配第一个引元，因为Object无法兼容 String,所以它
是不可应用的。泛型方法可以精确地匹配第一个引元，在经过包装转换之后，也可以匹配第二
个引元(第2阶段)。因此，泛型方法是唯一可应用的方法。
272
273
186 第11章 泛型类型
与上面两个调用不同的是，下面的m方法的调用就是含糊不清的了：
m("hel1o",Integer.valueOf(29));
两种形式的方法都是潜在可应用的，同样的也只有第1阶段会起作用。泛型方法调用的推断类
型是<String,Integer>,而非泛型方法既可以精确地匹配第一个引元类型，也可以匹配第
二个引元类型，因为Integer是Object。泛型形式也可以精确地匹配这两个引元，因此这两
个方法都是可应用的。下一步是确定哪种形式是最具体的方法。首先，我们来看看非泛型方法
是否比泛型方法更具体，其过程如下：
1.由于第二个方法是泛型的，因此要进行类型推断，但是这一次要考虑的是String 应该
是可转型为S的，Object应该是可转型为T的，这样推断出来的泛型方法的类型是<String,
Object>。注意目前没有考虑T的边界。
2.接下来执行一项检查，看看第一个方法的每一个参数是否都是第二个方法相应参数的
(推断)类型的子类型。在这个例子中，第一个方法的参数类型和第二个方法的推断参数类型是
相同的，因此该项检查通过。
3.由于第二个方法是泛型类型的，因此还需要进行第二项检查，看看第一个方法的参数类
型是否都是第二个方法的泛型类型参数边界的子类型。考虑第一个参数，S的边界是Object,
因此我们测试 String是否是Object的子类型，当然结果是肯定的。然而T的边界是Num-
274 ber,测试Object是否是Number的子类型，结果是否定的。
由于这项检查失败，所以非泛型方法并没比泛型方法更具体。现在我们必须确定泛型方法是否
比非泛型方法更具体。处理过程如下：
1.这一次第二个方法不是泛型的，因此无需进行任何类型推断。
2.接下来执行一项检查，看看第一个方法的每一个参数是否都是第二个方法相应参数的类
型的子类型。在这个例子中，将会检查S是否是String的子类型，T是否是Object的子类
型。类型变量仅仅是其边界(包括边界的超类)的子类型，因此S是Object的子类，而T是
Number 的子类。由于S是Object的子类而不是String的子类，所以该项检查失败。
由于检查失败了，因此泛型方法并不比非泛型方法更具体。既然两个方法都不比另一个方
法更具体，那么这个调用就是含义不清的，编译器会因此而拒绝它。
通俗地讲，一个方法比另一个方法更具体，说明所有对第一个方法的调用都可以由第二个
方法来处理。让我们看看这里的两个方法，泛型方法最泛化的签名具有类型为Object和Num ber的参数。因此如果我们考虑第一个参数，我们传递给非泛型方法的任何东西都必须是一个
String,而一个String 就是一个Object,因此泛型方法可以接受所有的传递给第一个方法的
第一个引元。因此如果只考虑第一个参数的话，非泛型方法就比泛型方法更具体。但是反过
来，泛型方法可以接受不是String 对象的第一个引元，因此泛型方法不比非泛型方法更具体。
我们再考虑第二个参数，我们可以将任何对象传递给非泛型方法，但是只可以将 Number 对象
传递给泛型方法。因此，在第二个参数上非泛型方法并不比泛型方法更具体。由于没有哪一个
方法更具体，所以该调用被认为是含糊的。
我们可以通过两种方式来去除这种含糊性。第一种方式是我们可以将第一个引元强制转换
为Object,这样非泛型方法就不再是可应用的了，因此泛型版本将会被调用：
m((object)"hello",Integer.valueof(29));
另一种可选的方式是将第二个引元强制转型为object,这样泛型方法就不再是可应用的了，因
此非泛型版本将会被调用：
m("hello",(Object)Integer.valueof(29));
11.7 类的扩展与泛型类型 187
请注意，将调用本身参数化并不会自动地排斥那些非泛型的方法——在确定它们的可应用性时
并不考虑类型引元。
即使重载没有涉及泛型，也应尽量审慎地使用，用它只是为了提高程序清晰度。当泛型掺
合进来之后，更容易使得所创建的程序的意图只有通过详尽地查阅语言规范才能确立。要尽量
避免在同一方法上混合使用泛型重载和非泛型重载，除非有非常具有说服力的理由。
11.7 类的扩展与泛型类型
泛型类型为类型系统添加了额外的维度，并迫使我们必须更深入地思考如何定义类与接
口，以及如何使用现有的类与接口。我们可以扩展非泛型类以产生泛型的或者非泛型的子
类型；我们也可以扩展泛型类以产生泛型的子类型，或者扩展具体的参数化类型以生成非
泛型的子类型，再或者还可以融合这两者。这种灵活的程度是压倒性的，但关键是要关注
我们的新类和新接口表示的是什么样的抽象，以及我们继承的类与接口表示的又是什么样
的抽象。
例如，List<E>接口表示的是列表的泛型接口，该列表包含某种类型的元素。如果要实
现这个接口，我们可能会提供一个可以处理任何元素类型的通用实现，那么在这种情况下，我
们的类也将是一个泛型类，比如：
class GeneralList<E> implements List<E>{/* ...*/}
或者我们可能会提供一个特化的实现，将其编写为可以处理某种特定类型的元素，比如
String,因此它本身并不是泛型，它将实现参数化的接口 List<String>:
class StringList implements List<String>{/* ...*/}
现有的非泛型类，比如 AbstractEventservice,可能提供了基本的功能，我们必须在应
用中将它作为一个框架来扩展。我们可能会定义一个不需要任何泛型的具体实现：
class RemoteEventService extends AbstractEventService {
/* ...*/
}
或者可能会为各种不同种类的事件定义一个泛型的服务：
class LocalEventService<T extends Event> extends
AbstractEventService {/* ...*/}
各种可能实际上都取决于所涉及到的类型的语义。
当我们选择扩展一个参数化类型时，需要仔细地考虑其中蕴涵的含义，特别是在实现一个
接口时，因为一个类不能同时继承对同一个接口进行不同参数化而得到的两个接口类型。例
如，考虑一下 Comparable接口。如果你定义了一个可比较的类 value,那么它自然会被声明
成下面的样子：
class Value implements Comparable<Value> {
// ...
}
假设我们现在为了增加额外的状态扩展了value类，扩展得到的 Extendedvalue类应该定义
其对象只能与 Extendedvalue 对象做比较，因此我们希望能够像下面这样定义：
class ExtendedValue extends Value
implements Comparable<ExtendedValue> {// INVALID!
// ...
275
276
}
277
188 第11章 泛型类型
但这样的代码无法通过编译，因为 Extendedvalue企图同时实现Comparable<Value>与
Comparable<Extendedvalue>,这是不允许的。一旦我们扩展或实现了参数化类型，就有了
固定的当前类及其所有子类的参数化形式，因此我们需要仔细思考这么做所蕴涵的含义。在
Comparable的例子中，我们没有其他选择，只有接受这个限制，虽然我们不能改变该类型的参
数化形式，但是可以覆盖 compareTo的实现来确保只有子类实例可以被比较操作接受，而超类
实例会被拒绝。回忆一下11.2.1节的 Sortedcollection这个例子，如果我们想接受一个
Comparable对象，那么正确的途径是声明为Comparable<?Super T>而不是Comparable
<T>。这不仅更通用(前面曾解释过),同时还顾及了可比较的类T实际上可能无法实现Com
parable<T>这一事实。
泛型类型是一个强大的工具，可以使我们更有效地编写程序，但是它是一件较难掌握的工
具，并且很容易被误用。完全掌握泛型类型需要对类型理论有很好的了解，特别是协变(covari ant)与逆变(contravariant)的类型特性，这些已经超出了本书的范围。如果感兴趣的话可以看
看，“进阶读物”中列有有关此类主题的补充材料。
几乎所有的人都可以在逆境中屹立不倒，但是如果想
真正测试一个人的品格，赋予他权力吧!
——亚伯拉罕·林肯
第 12章 异常与断言
一个松动的齿轮就可以让你的M203枪榴弹发射器在你最不希望的时刻走火。
这将使你成为部队中不受欢迎的人。
——美军《PS》杂志，1993年8月
在执行过程中，应用程序可能会遇到严重程度不同的各种错误。当调用对象的方法时，该
对象可以发现内部状态问题(变量值不一致),探测它操纵的对象或数据(例如文件或网络地
址)的错误，判定它是否和它的基本契约相冲突(例如从已经关闭的流中读入数据),等等。
许多程序员根本没有测试所有可能发生的错误条件，而且理由很充分：如果在执行下一条
语句之前，每个方法调用都要检查所有可能发生的错误，那么代码将会变得难以理解。这种折
中方案导致了正确性(检查所有的错误)和清晰性(没有用许多错误检查把代码的基本流程搅
乱)之间的矛盾。
异常为不搅乱代码而进行错误检查提供了一种简洁的途径。异常还提供了一种直接标示错
误的机制，这种机制没有间接地使用诸如必须受检查的字段这样的标志或者其他具有副作用的
方式。异常将方法可以标示的错误条件设置成为方法契约的显式部分，因为异常列表可以被程
序员看到，由编译器检查，并且如果需要的话，还可以被覆盖该方法的扩展类所保留。
异常是在遇到非预期的错误情形时抛出的，它会被方法调用栈中更深层的包围子句所捕
获。未被捕获的异常会导致线程终止执行，但是终止之前，线程的 UncaughtExceptionHan dler有机会尽其所能地处理这个异常，一般情况下是打印一些有用的信息(例如调用栈)说明
异常是从何处抛出的——见14.12节“线程与异常”。
12.1 创建异常类型
异常都是对象。所有的异常类型，即所有为可抛出(throwable)对象设计的类，都必须扩展
Throwable或者它的某个子类。Throwable类包含一个用来描述异常的字符串，这个字符串是
通过构造器参数进行设置的，并且可以通过getMessage方法获取。按照惯例，大多数新的异
常都扩展自 Exception,它是Throwable的一个子类。异常类型不允许是泛型类型的。
异常主要是检查型异常
(checked exception),这意味着
编译器将检查我们的方法是否
只抛出了它们声明自己会抛出
的异常。标准运行时异常(runt ime exception)和错误(error)扩
展了RuntimeException 或者
Error,它们是不受检查型异常
(unchecked exception)。下面图
12-1是异常类型层次图的顶端：
Object
Throwable
Error Exception
LinkageError RuntimeException
ArrayIndexOutOfBoundsException
图 12-1
279
280
281
190 第12章 异常与断言
检查型异常表示的情形是：虽然这种情况是异常的，但是一定程度上它的发生是可以预计
的，而且一旦这种情况确实发生了，就必须以某种方式来处理。要使这种异常能够被检查到，
必须表明这种异常的存在，并且要确保方法的调用者会以某种方式来处理异常，或者至少会有
意识地选择忽略它。
不受检查的运行时异常表示的情形是：大体上说，它反映了我们的程序逻辑中的错误，而
且不能在运行时得到恢复。例如，当我们访问的数组越界时，将会抛出ArrayIndexoutof BoundsException异常，它告诉我们程序错误地计算了下标值，或者对这个数是否能够用作下
标的校验失败了。这些错误应该在程序代码中纠正，因为我们所编写的任何语句都可能会出
错，所以必须声明或捕获由这些错误所导致的所有异常是完全不现实的——因此它们是不受检
查型。
Error类和它的子类定义了一系列的这样的错误，这些错误表示故障发生在虚拟机自身中
(VirtualMachineError)或者发生在虚拟机试图执行应用时(LinkageError)。这些错误也
是不受检查的，因为它们在应用的控制或处理能力之外。应用代码应该绝少直接抛出这种错误
异常，如果确实有这种异常的话。
几乎所有我们创建的异常都应该扩展自 Exception,使它们都成为检查型异常，这些新的
检查型异常表示的是在我们的库或者应用中可能会发生的异常情况。我们通常可以通过抛出一
个现有的运行时异常来处理代码中发生的任何运行时问题——已经有足够多的这种类了，其中
总是有一个能够很好地和发生的错误匹配，否则如果这个错误相当普通，那么抛出一个Runt imeException类本身的实例就够了。偶而，我们可能也想扩展现有的运行时异常类以提供额
外的有关所发生的异常的信息。在更罕见的情况下，我们可能需要定义与我们的应用领域相关
的新的运行时异常类。请记住，当遇到不受检查型异常时，应该根据好的文档来确定正确的用
法，因为编译器在这方面帮不了我们。
有时候，如果用来描述异常情况的数据比 Exception类所提供的数据多，会更有用。在这
种情况下，我们可以通过扩展 Exception来创建包含这些附加数据(通常是在构造器中设置
的)的新类。
例如，假设给第4章讨论的Attributed 接口中添加一个 replacevalue 方法。这个方法
用一个新值来替换某个具名属性的当前值。如果该具名属性不存在，那么就应该抛出一个异
常，因为可以很合理地假设只能对现有的属性作替换。这个异常应该包含属性的名字。为了表
示这个异常，我们创建了NoSuchAttributeException类：
public class NoSuchAttributeException extends Exception {
public final String attrName;
public NoSuchAttributeException(String name){
super("No attribute named \""+ name+"\"found");
attrName = name;
子
}
NoSuchAttributeException扩展了Exception,并且添加了一个接受属性名字的构造器；它
还添加了一个公共的 final 域来存储数据。这个新添加的构造器用一个描述到底发生了什么的
字符串调用了超类的构造器。这个定制的异常类型在编写捕获这种异常的代码时就会发挥作
用，因为它既有人类易理解的错误的描述，又有产生错误的数据。添加有用的数据是创建新异
常类型的一个原因。
12.2 throw 191
另外一个创建新异常类型的原因是异常的类型是异常数据的重要组成部分，因为异常是根
据它们的类型而被捕获的。为此，就算我们不打算添加新数据，也要创造NoSuchAttribute Exception。通过使用这种方式，只关心这个异常的程序员就可以只捕获它，而把其他的异常
排除在外，例如排除Attributed接口中的方法产生的异常，或者相同的代码区内的其他对象
上所使用的方法产生的异常。
大体上，当程序员想要处理一种有别于其他种类的异常时，他就应该创建新的异常类型，
这样程序员就可以利用异常类型来执行正确的代码，而不必检验异常的内容以确定这些代码是
真正关注这个异常的，还是恰巧捕获了一个不相关的异常。
12.2 throw
我们可以使用throw语句来抛出异常：
throw expression;
其中 expression 计算出来的值或变量必须可赋值给 Throwable,简单地讲，必须是对 Throw able对象的引用。例如，以下是对第4章的AttributedImpl 所实现的 replacevalue的一
个补充：
public void replaceValue(String name,Object newValue)
throws NoSuchAttributeException
{
Attr attr= find(name); // look up the attr
if(attr == null) // it isn't found
throw new NoSuchAttributeException(name);
attr.setValue(newValue);
}
replacevalue方法首先在当前的Attr 对象中查找那个名字。如果存在，就通过向其构造器
提供属性名来抛出一个NoSuchAttributeException类型的对象。因为异常也是对象，所以
在被抛出之前，必须先创建。如果该属性存在，它的值就会被新值所取代。我们也可以通过调
用一个本身就会抛出异常的方法来产生异常。
12.2.1 控制的转移
当抛出异常时，导致异常的语句或表达式被称作意外中止(complete abruptly)。语句的这种
意外中止将导致调用链逐级展开，因为其中的每一个语句块或方法调用都会意外中止，直至异
常被捕获。如果异常没有被捕获，执行线程就会在给线程的 UncaughtExceptionHandler一
次处理该异常的机会之后终止——见14.12节“线程与异常”。
一旦发生了异常，异常发生点之后的动作就都不会发生了。如果左操作数的计算引发了异
常，那么就不计算右操作数的任何部分了；同样，如果左引元表达式的计算引发了异常，那么就
不计算右边的引元了。这时将要发生的下一个动作要么是在finally块中，要么是在捕获这个
异常的catch块中。
12.2.2 异步异常
throw语句可以产生同步(synchronous)异常，例如被0除的算术异常——这种异常是作为
执行某条特定指令的结果而直接发生的，此时不是执行 throw就是执行被0除。相反，异步
(asynchronous)异常可以发生在任何时候，与正在被执行的指令无关。
282
283
284
192 第12章 异常与断言
异步异常只能以两种特定的形式发生。第一种是Java 虚拟机的内部错误，这种异常之所以
被认为是异步的，是因为它们是在执行Java虚拟机的内部指令而不是程序的指令时引发的。无
需多言，对于内部错误，我们什么也做不了。
第二种机制就是使用被弃用的 Thread.stop方法，或者是相关的没有被弃用的Java虚拟
机工具接口(JVMMTool Interface,JVMTI)中的 stopThread方法，其中JVMTI是虚拟机的本地
代码接口，可以用来监督和控制正在运行的应用。这些方法允许在目标线程的执行过程中在任
何代码点抛出任何类型(检查型或不受检查型)的异步异常。这种机制本质上是危险的，这就是
为什么它在 Thread类中已经被弃用的原因。我们将在第14章中进一步讨论它。
12.3 throws子句
replacevalue方法的定义声明了它可以抛出哪些检查型异常。Java语言之所以要求这样
的声明，是因为调用这个方法的程序员需要像对它的正常行为的了解程度一样了解它可以抛出
的异常。方法抛出的检查型异常与它的返回值一样重要，因此两者都必须声明。
方法可以抛出的检查型异常是用throws子句来声明的，它声明了一个用逗号分隔的异常
类型列表。只有那些没有在方法体内部被捕获的异常才必须列出来。
我们可以在 throws子句中抛出扩展自任何异常类型的异常，因为我们可以在任何希望出
现某个类的超类的地方多态地使用这个类。方法可以抛出多个检查型异常类(所有这些异常都
是某一特定异常类的扩展),但在 throws子句中仅声明这些类的超类即可。但是这样做，我们
就会潜在地对调用这个方法的程序员隐藏一些有用的信息：他们将无法知道可以抛出哪些扩展
异常。出于建档的目的，throws子句应该尽可能地完备和详细。
throws子句定义的契约非常严格——我们只能抛出在 throws子句中声明过的检查型异
常，不论我们直接使用 throw还是通过调用其他方法间接地使用它，抛出任何其他类型的检查
型异常都是非法的。一个方法没有 throws子句并不意味着它不能抛出任何异常：这仅仅意味
着不能抛出检查型异常。
所有标准的运行时异常(例如 ClassCastException 和ArithmeticException)都是
RuntimeException类的扩展。更严重的错误需要用扩展自Error的异常来标示，这些异常随
时随地都有可能发生。RuntimeException和 Error是仅有的我们不需要在 throws子句中列
出的异常类型，它们是普遍存在的，每个方法都潜在地可以抛出它们，这就是编译器不检查它
们的原因。对于这些运行时异常，例如 IllegalArgumentException,应该总是对抛出它们的
具体条件进行文档说明，尽管它们没有在throws子句中出现。有关如何为方法抛出的异常建
立文档的内容见第19章。
因为检查型异常必须在 throws子句中声明，由此断定任何在方法外或构造器外使用
throws子句的代码段都不能抛出检查型异常。这意味着静态初始化器(static initializer)和静态
初始化块不能抛出检查型异常，直接抛出或调用一个会抛出此类异常的方法都不可以。非静态
初始化器或非静态初始化块被认为是类的构造器的一部分，所以它们允许抛出检查型异常，只
要类的所有构造器都声明了这些检查型异常即可。
检查型异常的处理是有严格要求的，因为这样做有助于避免因未处理错误而带来的缺陷。
经验表明程序员会忘记处理错误，或者是把编写错误处理代码的工作推迟到遥远的未来。
throws子句清晰地表明了方法中将会抛出哪些异常，而且可以确保被调用者会以某种方式处
理它们。
如果我们调用了在其 throws子句中列出了检查型异常的方法，那么我们有三种选择：
12.3 throws子句193
·捕获这个异常并处理它。
·捕获这个异常，并通过抛出在我们自己的 throws子句中声明的异常类型来把它映射为
我们自己的异常。
·在我们的 throws子句中声明这个异常，并且让该异常穿过我们的方法(尽管我们可能会
有一个首先执行清除的 finally子句，见12.4.1节“finally”)。
前两种选择要求我们捕获其他方法抛出的异常，这些我们马上就会学到。
我们应该在 throws子句中显式地列出我们所知道的要抛出的所有异常，即使当我们可以
用几个异常共享的某个超类来囊括这些异常时，也需如此，因为这是一个很好的自描述文档
(self-documentation)。对于决定需要显式化到何种程度，我们应该做仔细的考虑。如果我们是
在设计一个通用的接口或超类，那么应该考虑对那些实现它的类要限制到什么程度。在接口的
throws子句中定义一个我们要用到的通用异常，并让实现类在可能的情况下把它细化，这样的
做法可能会十分合理。这种策略被用在了java.io包中，它为它的方法定义了一个可以抛出的
通用的IOException类型，而让实现类抛出与正在被处理的I/O类型相关的异常。例如，通过
网络通道实现I/O的类可以抛出各种与网络相关的IOException的子类，而处理文件的类则
可以抛出与文件相关的子类。
12.3.1 throws子句和方法覆盖
当我们覆盖继承而来的方法，或实现继承而来的抽象方法时，覆盖方法的 throws子句必
须和继承而来的方法(不管是不是抽象的)的 throws子句相兼容。
其简单的规则是：覆盖或实现的方法不允许在 throws子句中比继承而来的方法声明更多
的检查型异常。制定这条规则的理由十分简单：用来处理原来方法声明的代码不会捕获任何其
他的检查型异常，所以也就不允许抛出这样的异常。已声明异常的子类型是允许抛出的，因为
它们可以在为它们的超类型而编写的 catch 块中被捕获。如果覆盖或实现的方法没有抛出检
查型异常，那么该方法就不必重新声明它。例如，就像我们在3.9.1节看到的“克隆策略”那样，
实现了Cloneable接口的类不需要声明clone可能会抛出 CloneNotSupportedException异
常。是否声明这类异常是一个设计问题，如果我们在覆盖方法中声明了这类异常，那么就允许
我们的类的子类在该方法中抛出这类异常，否则就不可以。
如果某个方法声明是多重继承的，也就是说它存在于多个继承接口中，或者同时存在于一
个继承接口和一个超类中，那么这个方法的 throws子句就必须满足所有继承而来的 throws
子句。和我们在4.3.2节“继承、覆盖和重载方法”中讨论的一样，在这样的多重继承情况中，真
正的问题在于方法的一个单一实现是否可以遵循所有继承而来的契约。
12.3.2 throws子句和本地方法
本地方法的声明(见2.11节)可以提供一个throws子句，用来强制这个方法的所有使用者
都必须捕获或者重新声明指定的检查型异常。但是，本地方法的实现是在Java 编译器控制之外
的，所以无法检查它们以确保它们只会抛出声明过的异常。编写得好的本地方法应该只抛出它
们声明过的那些检查型异常。
练习12.1:为你在前面练习中构建的LinkedList类创建一个ObjectNotFoundExcep tion类。添加一个在列表中查找某个对象的 find方法，该方法要么返回包含待查对象的
LinkedList 对象，要么在待查对象没有在该列表中找到时抛出你创建的异常。为什么这样做
比找不到对象时返回 null要好呢?ObjectNotFoundException 应该包含什么样的附加数
285
286
287
194 第12章 异常与断言
据呢?
12.4 try、catch 和 finally
可以通过 try块中的包围代码来捕获异常。try块的基本语法是：
try{
statements
} catch(exception_typel identifier1){
statements
} catch (exception_type2 identifier2){
statements
}finally{
statements
}
其中要么必须出现至少一个catch子句，要么必须出现 finally子句。try语句的语句体会一
直执行到有异常抛出或者顺利执行完毕。如果抛出了异常，每个 catch子句按顺序从前到后检
验该异常对象的类型是否可赋值给在 catch子句中声明的类型。当找到一个可赋值的 catch
子句时.它的语句块就会被执行，同时其标识符会被设置成该异常对象的引用，任何其他的
catch子句都不会再执行。某个特定的 try 语句可以和任意多个(包括0个)catch子句相关
联，只要每个 catch子句捕获的都是不同种类的异常即可。如果没有发现任何合适的catch子
句，该异常就会渗透出这个 try语句，到达任何可能拥有可以处理该异常的catch子句的外层
try语句中。
如果try 语句中有finally子句，那么在try 内的所有其他处理都完成之后，finally的
代码将得到执行。不管 try是以何种方式结束的(正常结束；通过异常结束；通过诸如 return
或break 这样的控制流语句结束),情况都将如此。
下面的示例代码准备处理 replacevalue方法抛出的一个异常：
0bject value = new Integer(8);
try {
attributedObj.replaceValue("Age",value);
}catch(NoSuchAttributeException e){
// shouldn't happen,but recover if it does
Attr attr = new Attr(e.attrName,value);
attributedObj.add(attr);
}
try建立了一条期望正常完成某些事情的语句(必须放在一个块里)。如果所有事情都成功地完
成了，那么这个块就结束了。如果 try块中的代码在执行过程中抛出了异常，那么不管是通过
throw直接抛出的，还是通过代码中调用的某个方法间接抛出的，try 内的代码都将停止执行，
并开始检查后面的catch 子句，看它是否想要捕获抛出的异常。
catch子句有点像只有一个参数的内嵌方法，即要捕获的异常。就像方法的参数一样，异
常“参数”可以被声明为 final的，也可以将注解应用于其上。在catch子句的内部，我们可以
尝试着从异常中恢复，也可以清理掉它并重新抛出异常，以便调用我们的代码的代码也有机会
去捕获它。否则catch 也可以在做完它需要做的事情之后就到达 trv语句的底端.在这种情况
下，控制流就转到了try语句后面的语句上(如果有 finally子句的话，则是在执行完 finally
12.4 try、catch和finally 195
子句之后)。
使用通用的catch子句(例如捕获 Exception类型异常的catch子句)来捕获异常通常不
是一种很好的选择，因为它会捕获所有的异常，而不仅仅只是我们感兴趣的那个。例如，如果
我们在代码中使用了这样的语句，它可能会把ClasscastException异常同属性不存在这样的
问题等同处理。
我们不能把捕获超类异常的catch子句放在捕获子类异常的catch子句的前面。catch
子句是按顺序检查的，所以把捕获某种异常的 catch子句放在捕获该异常的扩展类型的 catch
子句前面是一种错误。因为第一个子句总是捕获异常，而第二个子句从来都不会执行。因此编
译器不会接受下面的代码：
class SuperException extends Exception {}
class SubException extends SuperException {}
class BadCatch{
public void goodTry(){
/* This is an INVALID catch ordering */
try {
throw new SubException();
} catch(SuperException superRef){
// Catches both SuperException and SubException
} catch(SubException subRef){
// This would never be reached
}
}
}
try语句每执行一次都只能处理一种异常。如果 catch 或 finally子句抛出了另一个异常，那
么就不会再次检查 try的catch子句了，因为catch 和 finally子句在 try子句自身的保护
之外。这样的异常当然可以被任何内部嵌套了catch或 finally子句的外层 try块来处理。
finally
try语句的finally子句提供了一种机制，不论是否抛出了异常，都会执行一段代码。通
常情况下，finally子句被用来清空内部状态或者释放非对象的资源，例如存储在局部变量中
的打开的文件。下面的方法在完成工作后将关闭文件，即使发生了错误也是如此：
public boolean searchFor(String file,String word)
throws StreamException
{
Stream input = nul1;
try {
input = new Stream(file);
while(!input.eof())
if(input.next().equals(word))
return true;
return false; // not found
} finally {
if(input != nul1)
input.close();
}
}
如果 new失败了，那么 input的初始状态 nul1将始终保持不变。如果 new成功了，那么
288
289
290
196 第12章 异常与断言
input将会引用表示被打开文件的对象。当执行 finally子句时，只有在input流已经打开的
情况下才会关闭它。不论对流的操作是否产生了异常，finally子句的内容都可以确保文件被
关闭，这样就节省了“可同时打开文件数”这种有限的资源。searchFor方法声明它可以抛出
StreamException异常，这样所有产生的异常在清理之后都会传给调用代码，包括在调用
close 方法时抛出的任何StreamException异常。
正确使用finally有两种主要的编码风格。通常情况下我们有两个动作，称作 pre 和
post,如果pre 发生则post 必定发生——不管在pre和 post 之间会发生什么动作，也不管
这些动作是正常结束还是抛出了异常。有一种编码风格可以确保这一点，其形式如下：
pre();
try /other actions
} finally {
post();
}
如果pre成功，我们就会进入 try块内，不管发生什么我们都可以确保 post得以执行。反之，
如果pre由于某种原因失败了并且抛出了异常，那么 post 就不会得以执行——在这种情况下，
pre 发生在 try块之外这一点非常重要，因为如果pre失败，post一定不会执行。
我们可以在流搜索的例子中看到第二种形式的惯用法，在那个例子中，pre 返回的是一个
可以用来确定它是否成功结束的值。只有在pre成功结束的情况下，才会调用 finally子句中
的post:
Object val = nul1;
try {
val= pre();
// other actions
} finally {
if(val != nul1)
post();
}
在这种情况下，我们仍然可以在try块之外调用pre,于是我们就不需要 finally子句中的 if
语句了。把pre置于try块内的好处是当我们想同时捕获 pre可能抛出的异常和其他动作可
能抛出的异常时——因为 pre在try块内部，所以我们只需要一组 catch 块即可，但是如果
pre在try块之外，我们就需要用一个外层的 try -catch 块来捕获 pre 抛出的异常。如果
pre和其他动作可以抛出同样的异常——这对于VO操作来说十分常见，并且我们希望在以某
种方式使用过这个异常后继续传播它，那么嵌套 try块的使用就会更加复杂一些，因为其他动
作抛出的异常将会被捕获两次，我们必须在编写catch 块的时候特别留心地处理这种情况。
finally子句也可以用来清理 break、continue和 return留下的现场，这就是我们有时
会看到不带 catch子句的try子句的原因。任何控制转移语句执行时，所有相关的 finally
子句都会执行，不可能不执行 finally子句就离开 try块。
前面的例子正是以这种方式依赖 finally来进行清理的，即使在正常返回的情况下。在其
他语言中使用goto的一个最常见的理由就是为了确保在代码块结束时，无论它的执行是否成
功，某些东西都会被清理掉。在我们的例子中，finally子句就可以确保无论是在执行 return
语句之后，还是在流抛出异常之后，文件都会被关闭。
控制总是由于某种原因才进入 finally子句的，这个原因可能是try 代码正常结束，也可
12.5 异 常 链197
能是try代码执行了诸如 return 这样的控制流语句，或者 try块中执行的代码抛出了异常。
当 finally子句执行到底而退出时，这个原因会被记录下来。但是，如果finally块是因为执
行了控制流语句(诸如 break 或 return)或者抛出了异常而产生了新的退出原因，那么这个新
的原因就会替换掉旧的原因，而旧的原因将被遗弃。例如，考虑下面的代码：
try {
// ...do something ...
return 1;
} finally {
return 2;
}
当try块执行它的 return语句时，控制流将进入 finally块，其“原因”是返回了值1。但是
在finally块内部，返回了值2,因此最初的意图就被遗弃了。事实上，如果 try 中的任何其
他代码抛出过异常，其结果仍然是返回2。如果finally块不返回任何值而仅仅是直接执行到
底，那么“返回值1”这个原因将被记住并如实返回。
12.5 异常链
异常有时是由其他异常引起的，在1.4节中，有这样一个例子：
public double[] getDataSet(String setName)
throws BadDataSetException
{
String file = setName+".dset";
FileInputStream in = nul1;
try {
in= new FileInputStream(file);
return readDataSet(in);
} catch(IOException e){
throw new BadDataSetException();
} finally {
try {
if(in != nul1)
in.close();
} catch(IOException e){
;// ignore: we either read the data OK
// or we're throwing BadDataSetException
}
}
}
// ..definition of readDataSet ...
这个方法在任何的IO异常或数据格式错误上都抛出 BadDataSetException异常。问题是任
何关于原来异常的信息都将丢失，但是在订正这个错误时可能需要这些信息。
用其他异常来代替原有异常是很重要的一种提高抽象层次的方式。对于任何调用以上方式
的代码来说，所有的故障都可以以相同的方式来恢复。故障的特殊性对于这个程序的任务来说
也许并不重要，它只需处理数据文件的故障，但是订正这个问题的人可能需要了解确切的故障，
所以他们可能需要得到这些信息——见12.6节“栈轨迹”。
类似情况很常见，以至于异常机制包含了“由另一个异常所触发的异常”这一概念。在
291
292
198 第12章 异常与断言
Throwable中定义的 initcause方法将触发异常的原因设置成了作为参数传递进来的异常对
象。例如，可以将前一个例子中的IOException捕获子句改写为：
} catch(IOException e){
BadDataSetException bdse= new BadDataSetException();
bdse.initCause(e);
throw bdse;
}finally {
// ...
}
这里 initcause被用来记忆使数据出错的异常。这意味着调用代码可以只使用一个异常处理
程序来处理所有的数据错误，同时仍然知道引发底层问题的异常类型。调用代码还可以使用
getCause 方法来得到这个异常。
可以通过将 BadDataSetException编写成可以保存(至少是保存一段时间)的异常来进一
步简化上面的例子，因此我们提供了一个在其原因已知的情况下接受该原因的构造器。定义新
异常类的惯用法是提供至少以下4种形式或其变体形式的构造器，以处理异常特有的数据：
class BadDataSetException extends Exception {
public BadDataSetException(){}
public BadDataSetException(String details){
super(details);
}
public BadDataSetException(Throwable cause){
super(cause);
}
public BadDataSetException(String details,
Throwable cause){
super(details,cause);
}
}
现在前面那个例子中的捕获语句可以简化为以下形式了：
} catch(IOException e){
throw new BadDataSetException(e);
} finally {
// ...
}
并非所有的异常类都提供了可以接受原因的构造器，但是它们都支持initCause方法。为
了使这样的异常类可以更容易地使用initcause方法，该方法将返回被调用了该方法的异常实
例。这是为了使我们可以像下面这样使用它：
throw new BadDataSetException().initcause(e);//Error?
唯一的问题是它几乎总是产生编译期错误：initcause 返回的是一个Throwable实例，而我们
只能在方法的 throws子句中列出了 Throwable的情况下才可以抛出 Throwable实例，即使
这种情况，也应该是极少发生的!所以，我们必须修改上面的代码，把 Throwable强制转换为
我们所创建的实际异常类型：
12.7 什么时候使用异常 199
throw(BadbataSetException)
new BadDataSetExceptionO).initCause(e);
请注意，不论是通过构造器还是调用一次 initCause方法，一个异常只能设置一次它的原
因，任何对重新设置它的尝试都将导致抛出IllegalstateException异常。
12.6 栈轨迹
当异常被创建时，调用的栈轨迹就被保存到了该异常对象中，这是由 Throwable构造器调
用它自己的 fillInStacktrace方法来完成的。我们可以通过使用printStackTrace方法来
打印这个栈轨迹，并且可以通过再次调用fillInStackTrace方法用当前的栈信息来覆盖它。
如果异常是有原因的，那么printstackTrace方法通常会先打印当前异常的栈轨迹，然后紧
接着打印它的原因的栈轨迹，但是所打印的栈轨迹的具体细节将取决于虚拟机的实现。
栈轨迹是用StackTraceElement 对象数组来表示的，我们可以用getstackTrace方法得
到这个数组。我们可以使用这个数组来检查栈或者建立我们自己的信息显示方式。每个
StackTraceElement 对象都表示一个调用栈中的方法调用。我们可以用getFileName、get className、getMethodName、getLineNumber或 isNativeMethod方法来查询它们。
我们也可以用 setStackTrace方法来设置栈轨迹，但是为了让这种做法有益无害，我们必
须编写一个非常与众不同的程序。由于栈轨迹中包含的实际信息非常有价值，所以如果没有不
得已的需求，最好不要丢弃掉这些信息。改变栈轨迹的合理原因总是有的，它们应该是至关重
要不可或缺的，但是这种原因相当少见。
12.7 什么时候使用异常
我们在这一章的开头使用了“非预期的错误情形”来描述什么时候会抛出异常，因为异常不
是指简单的可预料的情况，例如，到达输入流的末尾是可预料的，所以从流中返回下一个输入
的方法把“到达末尾”作为其可预料行为的一部分。用返回标志标示输入末端是合理的，因为它
使调用者可以更容易地检查返回值，这样的惯用法也更易理解。请考虑下面这个典型的使用返
回标志的循环：
while((token = stream.next())!= Stream.END)
process(token);
stream.close();
与下面的循环比较一下，该循环是用异常来标示输入的结束的：
try {
for(;;){
process(stream.next();
}
} catch(StreamEndException e){
stream.close();
}
在第一种情况下，控制流直接而清晰，代码一直循环直至到达流的末端，然后关闭了流。在第
二种情况下，循环看起来似乎永远都不会停止，除非我们知道输入结束是以 StreamEndExcep tion来标示的，否则不会知道循环的正常范围。即使我们了解 StreamEndException异常，
这种结构也很令人迷惑，因为它把循环终止的条件从 for循环的内部移到了外层的 try块中。
在有些情况下，不存在合理的标志值。例如，表示 double值流的类可以包含任何有效的
293
294
200 第12章 异常与断言
double值，所以也就不可能有任何流结束标志。最合理的设计是添加一个显式的eof测试方
法，在任何从流中读入的操作执行之前都应该调用它：
while(!stream.eof()
process(stream.nextDouble());
stream.closeO;
另一方面，越过输入末端继续读取也不是可预料的。这意味着程序没有注意到末端而试图做了
一些它不应该尝试的事情，这是抛出ReadpastEndException异常的一个极好范例。这种行为
不属于我们预料到的流类的使用，抛出异常才是正确的处理方法。
判定什么情况属于预料之中而什么情况属于预料之外是一个很模糊的问题，关键是不要把
异常滥用为报告可预料情况的方式。
练习12.2:判定在下列情况下应该通过什么方式与程序员进行交流：
·有人想把Passengervehicle对象的载客量设为负值。
295 ·在对象用来设置其初始状态的配置文件中发现了一个语法错误。
·在一个字符串数组中搜索程序员所指定的单词的方法没有找到这个单词。
·提供给“open”方法的文件不存在。
·提供给“open”方法的文件存在，但是安全机制阻止用户使用它。
·在试图打开一个通到一台远程服务器的网络连接的过程中，无法联系上远程机器。
·在与远程服务器进程进行对话过程中，网络连接停止了运行。
12.8 断言
断言(assertion)是用来检查不变式(invariant)的，即永远都应该是true的情况。如果发现断
言是false的，那么就会抛出异常。如果我们的代码假设某事物为 true,那么添加一个测试它的
断言，可以为我们提供一种在程序中的错误引发奇怪的后果之前捕获它们的途径。例如，在链
表中，最后一个元素总是拥有一个为nu77的指向下一个元素的引用：
public void append(Object value){
ListNode node= new ListNode(value);
if(tail != nu71)
tail.next = node;
tail= node;
assert tail.next == nul]:
}
当append方法结束它的工作后，assert再次进行检查了最后一个节点的构成的正确性。如果
该节点的构成不正确，将会抛出AssertionError。
默认情况下，断言是不会被计算的。我们可以为包、类和整个类加载器打开或关闭断言计
算功能，正如我们马上就会看到的那样。当断言被关闭时，断言根本不会被计算。这意味着我
们必须当心断言对非断言代码造成的负面影响。例如，下面的代码就非常危险：
assert ++i< max;
当断言代码被计算时，i的值将递增到下一个值。但是当某人把断言关闭时，整个表达式在逻
辑上将从代码中消失，这使得i的值将永远不会发生变化，不要做任何类似于这样的事情。应
296 该把它分开写成这样：
i++;
assert i<max;
12.9 什么时候使用断言201
assert语句
断言的语法如下：
assert eval-expr[:detai7-expr];
其中 eva7-expr可以是boolean 表达式，也可以是Boolean 表达式，而detai7-expr则是一个
可选的表达式，它会被传递给 AssertionError 构造器来帮助描述发生的问题。细节表达式
(detai7-expr)是可选的，如果有的话，它可以为查看该语句或抛出的异常的人提供信息。如果
该细节是一个 Throwable对象，它将成为AssertionError的原因，也就是说，它将会是该错
误的getcause方法的返回值。除此之外，该细节将会被转换成 string类型，从而成为该错误的
细节消息。
当在代码中遇到 assert时，第一个表达式将会被计算。如果返回值是true,则断言通
过；如果是false,则断言失败，此时会构造一个AssertionError并抛出它。
12.9 什么时候使用断言
断言的典型应用是确保在发生了“不能发生的”事情时可以引起人们的注意，这就是为什么
失败的断言会抛出 Error而不是Exception的原因。失败的断言意味着当前的状态基本上是
混乱的。
我们不应该使用断言来测试我们知道事实上有时候会发生的情况(IOException)或者是通常
用其他手段来测试的情况(IllegalArgumentException、Nul7pointerException 、……)。不
管断言会不会被计算，我们都需要处理这些问题。断言应该用来测试从来都不会发生的情况——
在正常工作的程序中，任何断言都不应该失败。下面几节内容将给出一些什么时候使用断言的好
例子。
12.9.1 状态断言
有些断言是用来测试当前的状态是否总是它应该具有的状态的：
public void setEnds(Point p1,Point p2){
this.p1= p1;
this.p2 = p2; 297
distance = calculateDistance(p1,p2);
assert(distance >=0):"Negative distance";
}
在上面的代码中，终点的设置会导致距离域被重新计算。距离的计算结果应该总是产生正值，
给出负值distance 这个缺陷会在这个值将来被使用时产生奇怪的结果。上面所示的断言将在
起源处捕获这个缺陷，这种形式的简单断言在许多场合都可以用来确保我们的状态和算法的正
确性。
术语前置条件(precondition)和后置条件(postcondition)表示的是特定种类的状态断
言。前置条件是指某特定代码块(通常是一个方法)执行前必须为“真”的事物，后置条
件是指执行后必须为“真”的事物。我们可以使用assert来检查前置条件和后置条件，
例如：
298
202 第12章 异常与断言
public boolean remove(Object value){
assert count >=0;
if(value == null)
throw new Nu11PointerException("value");
int orig = count;
boolean foundIt= false;
try {
// remove element from list(if it's there)
return foundIt;
} finally {
assert((!foundIt && count == orig)日
count == orig -1);
}
}
上面的方法强制前置条件为：列表大小在操作前必须为非负数，后置条件为：移除一个元素后
列表大小应该减一，除非该元素不在列表中。
注意，对被移除的元素是否为 nu77的检查并不是通过断言实现的，而是通过抛出
NullPointerException.异常实现的。通常我们应该想到使用我们的类的人会犯错误，所以
在可能出现错误的地方，我们应该总是检查它们，并且定义好当错误真的出现时需要做些什么
工作，例如返回一个标志值或者抛出一个异常。事实上，断言是一种检验代码中有没有缺陷或
意外用法的方式，而不是检查调用它的代码有没有缺陷的方式，所以不要用断言来验证传给非
私有方法的引元。
断言语句可能会被执行，但也有可能不被执行，所以编译器并不认为它们总是可达的。只
在断言声明中初始化的变量被认为是潜在地未初始化的，因为如果断言被禁用，那么该变量就
是未初始化的。就算所有使用到该变量的地方都在其他的断言语句中，情况也是如此。
12.9.2 控制流断言
我们也可以使用断言来检验某些代码的控制流是否总是和我们所期望的一致：
// value must always be present
private void replace(int va1,int nval){
for(int i=0;i< values.1ength;i++){
if(values[i]== val){
values[i]= nval;
return;
}
}
assert false:"replace:can't find"+ val;
}
这个循环应该永远都无法到达方法的末尾，因为循环中的某些索引会引发对 return语句的调用。
如果这种情况没有发生，循环将意外地离开底端，而程序将默默地以其意外的方式继续执行下
去。循环后面的assert false意味着如果控制流到达了那里，我们将会被告知。
在这种情况下，我们完全可以合理地避免使用断言机制，直接用 throw来代替 assert,自
己抛出一个错误：
throw new AssertionError("replace:can't find"+ val);
对于有返回值的方法来说，使用 throw将会特别有用。如果没有 throw,编译器就不会知道该
12.10 打开和关闭断言203
方法无法到达底端，所以会执意要求我们在末尾返回一个数值，其代码就像这样：
return -1;// never happens
注释“never happens”断言某事为真，但是不会去检验或强制要求这一点。只有读到这段代码
的人才会知道这个不变式，因为断言 assert false可能会被关闭，所以编译器还是会要求这
段代码要有一个虚假的 return;而 throw语句则会强制要求我们已经知道的内容。
编译器不允许我们有任何它认为是不可达的 assert语句，就像它不允许我们有任何它认
为是不可达的其他语句一样。如果编译器可以确定某一行代码是不可达的，那么说明不仅我们
在此处不需要任何 assert,而且我们也不能把任何assert放在那里。
12.10 打开和关闭断言
在默认情况下，断言计算功能是关闭的，我们可以打开某一个虚拟机、包、类或者类加载器
上的所有断言计算。因为断言可能是开着的，也可能是关着的，所以我们必须小心以避免它们
给非断言代码带来的副作用。
我们可以通过将命令行选项传递给虚拟机(稍后介绍)或者通过使用类加载器提供的方法
(见16.14节“运行时断言的控制”)来控制断言计算的开关。
12.10.1 为什么要开关断言?
首先要回答的问题是为什么我们想要拥有能够切换断言计算开关的能力。通常的情况是在
开发期间打开断言，在系统封装时关闭它们。有一种论点是，在开发周期中，我们会捕获到所
有不正常的情况，因此，执行所有检查的开销与付出的努力相比有些不值得。
这是个很诱人的逻辑，但是可能会给我们带来严重的问题。断言的意图是在缺陷带来破坏
和导致奇怪的结果之前捕获它。当别人运行我们的代码时，查找问题的原因要更困难一些，所
以及早地捕获和报告这些原因就显得很重要，即使问题可能极少发生。我们应该只在对性能有
显著影响的地方关闭断言，尽管在那些关键的代码段中，我们可能也想要关闭它。
12.10.2 在命令行控制断言
在默认情况下，断言计算是关闭的。为了要改变开关的状态，假设我们使用的是一个命令
行驱动的虚拟机，那么我们可以通过标准的命令行选项来实现：
·-enableassertions/-ea[descriptor]:启用(打开)由descriptor所定义的断言
计算。如果没有任何descriptor,那么除了被系统类加载器加载的类之外，所有其他类的
断言都将被启用，见16.13节“加载类”。
· -disableassertions/-da[descriptor]:禁用(关闭)由 descriptor所定义的断
言计算。如果没有任何 descriptor,那么所有类的断言全都被禁用。
descriptor允许我们指定受这一选项影响的特定的包或类，没有descriptor 意味着该选项
适用于所有非系统类(即除系统类加载器加载的类之外的所有其他类),其中包是用名字后边紧
跟...来定义的，这意味着该选项适用于所有子包。例如，选项
-enableassertions:com.acme...
将会打开com.acme包及其所有子包中的所有类的断言。如果 descriptor 就由...构成、则表示
的是目前工作目录下的未命名包。如果没有..., descriptor就被认为是一个类的全名。
-enableassertions:com.acme.Plotter
将打开类 com.acme.Plotter的断言。因此如果我们想打开com.acme包里除去 com.ac-
299
300
301
204 第12章 异常与断言
me.Evaluator类之外的所有的断言，那么可以使用：
-enableassertions:com.acme...-da:com.acme.Evaluator
这样该选项将应用于Evaluator类和在它内部的所有内嵌类型。
如果我们在代码中使用了断言，我们所应该做的最明显的事情就是总是使用具有足够特征
说明的-ea来描述所有相关的代码。
多个选项是按照它们在命令行中的顺序依次计算的，类相关的选项优先于包相关的选项，
而较细化的包选项优先于较粗化的包选项。例如，假设有
-da:com.acme.Plotter ~ea:com.acme...-da:com.acme.products
-ea:com.acme.products.Rocket
那么除com.acme.Plotter类之外的com.acme包及其子包中的所有类的断言都将被启用，而
除com.acme.products.Rocket类之外的com.acme.products 包及其子包中的所有类的断
言都将被禁用。
系统类是单独控制的，因为我们更有可能是在自己的类里找缺陷，而不是在系统类里找缺
陷。要想影响系统类，应该使用该选项的“system”变体：-enablesystemassertions/-esa
和-disablesystemassertions/-dsa(后一个选项主要是出于对称的考虑)。
类的断言状态是在该类被初始化时确定的(见16.13.2节“为类的使用做准备”),永远都不
会被改变。这个确定是在该类的所有静态初始器被执行之前，超类被初始化之后做出的。如果
某个超类的静态初始器会导致虚拟机去执行它自己的子类中的静态方法，那么这个静态方法有
可能将在它自己的类被初始化之前执行，也就是在该类的断言状态被确定之前执行。在这种情
况下，所有断言语句的执行都必须按照好像启用了该类的断言的情况处理。
12.10.3 彻底移除
即使断言可能永远不会在运行时执行，但是与它们相关的代码仍然存在，它们仍然会占用
虚拟机资源并且给应用的性能增加额外的开销。对大多数应用来讲，这是不需要担心的，有
好的适时编译器会帮我们处理开销问题，但是有时候，在资源紧张的情况下，我们必须考虑它。
唯一能确保彻底移除断言相关的代码的方法是编辑代码并彻底移除断言。但是有一种标准的
Java编码风格可以给源代码编译器一个暗示，说明我们不想让某段代码在某种环境下出现：
private static final boolean doAssert = true;
if(doAssert)
assert(cleared I| size.== origSize);
在上述代码片段中，只有在 doAssert变量为 true的时候才会检查断言。doAssert变量是一
个编译期常量(它是static的、final的，并且被初始化为一个常量值),这个编译期常量的引用会
在编译期被那个常量值所替换。如果doAssert为false,那么断言将永远不会被执行，如果
编译器选择移除断言的话，它可以把if语句彻底地移除，我们也可以使用这项技术去掉用来调
试的打印语句。
12.10.4 使断言成为必需的
有时候(很少)我们可能需要确保某些类的断言从来不会被关闭，那么我们可以使用如下代
码来达到这个目的：
12.10 打开和关闭断言 205
static {
boolean assertsEnabled = false;
assert assertsEnabled = true;
if(!assertsEnabled)
throw new Illega1StateException("Asserts required");
}
在这段代码中，我们有意识地使用了assert语句的副作用，使得这段代码可以确定断言是否
被关闭了，如果被关闭了，这个类就不会被加载。这几乎是唯一的副作用做了好事的情况。
使断言成为必需的会使代码的运行环境变得复杂，因为即使其他类的断言都是关闭的，我
们也必须总是为这个类打开断言，所以应该尽量不要这样做。
最大的错误就是没有意识到错误。
——托马斯·卡莱尔(英国散文家)
302
303
305
第13章 字符串与正则表达式
再好的引语，如果不能修改它，那又有何用呢?
———《The Two Doctors》(BBC科幻节目)中Dr.Who的台词
字符串是具有内建语言支持的标准对象。在前面已经介绍了许多使用字符串字面常量来创
建字符串对象的例子，还介绍了把字符串连接起来以创建新字符串的+和+=运算符，然而，
String类还提供了许多其他的功能。因为 String 对象是不可变(只读)的，所以Java语言还
提供了StringBuilder类来处理可变的字符串。本章将主要介绍String类、StringBuilder
类以及其他一些相关的类，包括用于正则表达式匹配的工具类。
13.1 字符序列
正如本书7.1.1节“字符集”中介绍的那样，Java编程语言将由 Unicode字符组成的文本表
示成一个使用UTF-16编码格式的char型值的序列，而String类定义的对象所表示的就是
这种字符序列。更一般地讲，任何实现了java.1ang.CharSequence接口的类表示的都是这
种字符序列，包括本章将要讲述的String类、StringBuilder类和 StringBuffer类，以及用
于I/O操作的 java.nio.charBuffer类。
CharSequence接口很简单，它只定义了4个方法：
·public char charAt(int index):返回该字符序列中位于给定的 index处的char型
值，而字符序列的索引范围是从0到1engthO)-1(与数组的索引范围相同)。因为该对
象是一个UTF-16编码格式的字符序列，所以返回值既可能是一个真正的字符，也可能
是代理对中的部分值。如果索引值是负数或者不小于字符序列的长度，就会抛出 Index OutofBoundsException。
· public int 1engthO:返回该字符序列的长度。
· public charSequence subSequence(int start,int end):返回一个新的CharSe quence,其中包含该字符序列中从 charAt(start)开始到charAt(end-1)截止的所有
char型值。如果 start的值不小于 end的值，或者这两个值中有一个超出了该序列的
索引范围，那么就会抛出IndexoutofBoundsException。需要注意的是，要确保指定
的范围不会拆分任何代理对。
·public String tostringO:覆盖了Object.tostring方法的契约，限定其返回的是
由该CharSequence所表示的字符序列。
13.2 String类
字符串是不可变(只读)的字符序列：字符串在创建之后，其内容就永远不能再修改了。
String类提供了许多用于处理字符串搜索、比较以及与其他字符序列交互的方法。本节中将会
对该类做全面的描述。
13.2 String类 .207
13.2.1 基本的String 操作
字符串可以隐式地创建：可以通过使用字符串字面常量(如"Gr?ce")或者通过使用+或
+=运算符连接两个String 对象来创建一个新的 String 对象。
也可以使用new来显式地创建字符串。String类支持以下这些简单的构造器(其他的构
造器会在后面的几节中讲述):
· public StringO:创建一个新的String 对象，其内容是空字符串(即"")。
·public String(String value):创建一个新的 String 对象，它是指定的 String 对
象value的一个副本，也就是说，这是一个复制构造器。因为String 对象是不可变的，
所以该方法很少用到。
·public String(StringBuilder value):创建一个新的 String 对象，其内容与指定
的 StringBuilder 对象value的内容一样。
·public String(StringBuffer value):创建一个新的 String 对象，其内容与指定的
StringBuffer对象value的内容一样。
String 对象最基本的两个方法是length 和charAt,它们是由CharSequence接口定义
的。下面这个循环就利用这两个方法计算了字符串中的各种字符的个数：
for(int i=0;i< str.1engthO;i++)
counts[str.charAt(i)]++;
请注意 length是String类的方法，但对于数组来说，它是数组的域，初学者很容易将这两者
混淆。
在String类的大部分方法中，如果访问字符串的索引值小于0或大于lengthO)-1,就
会抛出IndexoutofBoundsException,而另外一些方法的实现会抛出更为具体的 StringIn dexoutofBoundsException,这种异常可以接受非法的索引值作为异常构造器的引元，然后在
详细信息中包含它。对于那些从数组中复制数值或将数值复制到数组中的方法或构造器，如果
它们想要访问超出数组边界的数值，那么也会抛出 IndexoutofBoundsException。
还有一些简单的方法可以用来查找某个特定字符或子字符串在字符串中第一次或最后一次
出现的位置。下面的方法就将返回某个给定字符在字符串中第一次和最后一次出现的两个位置
之间所夹的字符个数：
static int countBetween(String str,char ch){
int begPos = str.index0f(ch);
if(begPos<0) // not there
return -1;
int endPos = str.1astIndex0f(ch);
return endPos - begPos -1;
}
countBetween方法查找了字符ch在字符串 str中第一次和最后一次出现的位置。如果该字
符在字符串中并未出现两次，那么该方法的返回值为-1。否则，这两次出现的位置之差就等于
这两个位置之间所夹的字符个数加1(若这两个位置分别为2和3,则它们之间所夹的字符个数
就是0)。
indexof方法有几个重载的版本，可以用于在字符串中向前搜索；同时 lastIndexof方法
也有几个重载的版本，可以用于在字符串中向后搜索。每一个方法返回的都是它搜索到的字符
或子字符串的索引值，如果没有搜索到就返回-1,如表13-1 所示：
306
307
308
208. 第13章 字符串与正则表达式
表13-1
方 法 返回的索引值
indexof(int ch) ch第一次出现的位置
indexof(int ch,int start)
indexof(String str)
≥start的ch第一次出现的位置
str第一次出现的位置
indexof(String str,int start)
lastIndexof(int ch)
≥start的str第一次出现的位置
ch最后一次出现的位置
1astIndexof(int ch, int start)
lastIndexof(String str)
1astIndexof(String str,int start)
≤start的ch最后一次出现的位置
str最后一次出现的位置
≤start的str最后一次出现的位置
上述这些索引方法中，有些方法是以一个int型值作为参数来表示待查找的字符的，如果该参数
值小于0xFFFF,则查找这个给定的字符；否则，该方法将会查找具有给定值的 Unicode代码
点—见13.5节“使用UTF-16”。
如果并不关心子字符串的确切索引位置，则可以使用contains 方法，如果当前字符串中
含有给定的Charsequence作为字符串的子序列，那么该方法就返回 true。如果需要查找任
意一个charSequence的索引位置，则必须首先调用该 charSequence的 tostring方法，然
后将其返回值作为参数传递给 indexof方法。
练习13.1:编写一个计算给定字符在一个字符串中出现次数的方法。
练习13.2:编写一个计算特定字符串在另一个字符串中出现次数的方法。
13.2.2 字符串比较
String类支持多种比较字符串和子字符串的方法。但是，在讨论这些方法之前，必须明确
一点：关于完全Unicode字符串的国际化和本地化问题在这些比较方法中并没有得到解决。例
如，当比较两个字符串来确定哪个“更大”一些时，字符串中的字符是通过其 Unicode值来在数
字上进行比较的，而不是按照它们在本地化意义上的顺序进行比较。例如，在法语中，c和C指
的是同一个字母，只是在变音符上有一点小小的不同，对法语的字符串集排序时，就应该忽略
它们之间的这个差异，例如"ac b"就应该放在"acz"前面，因为b在z之前。但是在 Unicode字
符集中就大大不同了，Unicode字符c(u0063)排在 Unicode字符C(uO0e7)的前面，所以前面
例子中的两个字符串的排序就是相反的顺序了。国际化和本地化问题将在第24章中讨论。
第一个比较操作是equals方法，其参数是一个对 String 对象的引用。如果传递给它的引
用所指向的 String对象与被调用该方法的对象具有相同的内容，那么该方法就返回 true—
也就是说，这两个字符串具有相同的长度以及完全相同的 Unicode字符序列。如果传递给它的
另一个对象不是String类型的，或者它们的内容不相同，那么 String.equals 就会返回
false。正如本书3.8节曾经介绍过的，该方法覆盖了object.equals方法，以判定等同性而
不是同一性。
如果要在比较字符串时忽略其大小写的差别，可以使用equalsIgnorecase方法。通过
“忽略大小写”的方式，E和e就会被看作是相同的，但它们与E和e还是存在着差异的。对于没
有大小写区别的字符，如标点符号，则只与它们自己等同。Unicode 中有许多有趣的关于大小写
的样式，包括“标题样式”(titlecase)等。String类中对大小写的处理是根据Character类中
13.2 String类 209
与大小写相关的方法而进行的，见8.5节“字符”。
通过使用contentEquals方法，可以将一个String 对象与任意一个CharSequence 对象
进行比较。如果这两个对象所表示的字符序列完全相同，该方法就返回true。
如果想要对字符串进行排序，就必须先确定它们之间的顺序，所以 String类实现了接口
Comparable<String>——Comparable接口在4.1节中描述过。对于compareTo方法来
说，如果被调用该方法的字符串小于、等于或大于另一个字符串，则该方法的返回值分别是一个
小于、等于或大于0的int值，这其中所使用的排序顺序是Unicode字符的排序顺序。String
类还定义了compareTOIgnoreCase方法。
compareTO方法有助于创建字符串的某种内部规范的顺序。例如，二分搜索要求元素列表
必须是已排序的，不过对它来说，是否要按照本地语言的顺序进行排序并不重要。下面的代码
就是为拥有一组已排序字符串的类而编写的二分搜索的查找方法：
private String[] table;
public int position(String key){
int lo=0;
int hi= table.length -1;
while(lo <= hi){
int mid= 1o+(hi - 1o)/2;
int cmp= key.compareTo(table[mid]);
if(cmp ==0) // found it!
return mid;
else if(cmp<0) // search the lower part
hi= mid-1;
else // search the upper part
1o= mid+1;
}
return -1; // not found }
这就是基本的二分搜索算法。它首先检查搜索范围的中点，判断 key 是大于、等于还是小于位
于中点的元素。如果key等于中点元素，那么该元素就是要查找的元素，搜索结束。如果 key
小于中点元素，那么就会继续搜索该范围的前半部分；否则，就继续搜索该范围的后半部分。
最终，要么找到了该元素，要么搜索范围的起点值变得比终点值还要大，说明要搜索的 key 不
在列表中。
除了完整的字符串之外，还可以比较字符串部分内容的等同性，所使用的方法是 region Matches,它有两种形式：
· public boolean regionMatches(int start,String other,int ostart,int
count):如果该 String的指定部分与字符串other 的指定部分具有相同的 Unicode字
符序列，则返回值为 true。这项检查从该字符串的 start 位置和字符串 other的os tart位置开始，只比较从检查位开始向后的count个字符。
·public boolean regionMatches(boolean ignoreCase,int start, string other,
int ostart,int count):该版本的 regionMatches 与前一个版本很相似，只不过使
用了布尔值ignoreCase来控制是否对大小写敏感。
例如：
309
310
311
210 第13章 字符串与正则表达式
class RegionMatch {
public static void main(String[] args){
String str= "Look,look!";
boolean b1,b2,b3;
b1= str.regionMatches(6,"Look",0,4);
b2= str.regionMatches(true,6,"Look",0,4);
b3= str.regionMatches(true,6,"Look",0,5);
System.out.print1n("b1="+ b1);
System.out.println("b2="+ b2);
System.out.println("b3="+ b3);
}
}
其输出如下：
b1= false
b2= true
b3= false
第一个比较产生false是因为位于该字符串中位置6 的字符是'1',而位于另一个字符串
中位置0的字符是'L';第二个比较产生 true是因为忽略了大小写；第三个比较产生
false是因为现在比较的长度是5,而这两个字符串的相同字符没有超过5个，即使忽略
大小写也一样。
在查询方法中，比如 regionMatches方法以及接下来我们要提到的一些方法，任何非法的
索引值只会导致返回值为 false,但不会抛出异常。如果需要用对象作引元，但传入的是null
时，就会抛出Nu17PointerException。
通过使用 startswith方法和 endswith 方法，可以直接检查字符串的起始字符和终止字
符：
·public boolean startswith(String prefix,int start):如果该 String是以给定
的prefix(在start位置处)开始的，就返回 true。
·public boolean startswith(String prefix):等价于 startswith(prefix,0)。
·public boolean endswith(string suffix):如果该 String是以给定的 suffix结
尾的，就返回 true。
13.2.3 字符串字面常量、等同性和内存限定
一般来说，使用 ==来比较字符串会得到错误的结果。考虑如下代码：
if (str ==":Pena?")
answer(str);
这里并没有比较两个字符串的内容，它只是对一个对象引用(str)和另一个对象引用(表示字
面常量":Pena?"的字符串对象)进行了比较。这个==表达式将几乎总是产生 false,即使
str包含字符串":Pena?"也是一样，这是因为这两个字符串存储在不同的对象中。将 ==作
用于对象上时，只是检查这两个引用是否指向了同一个对象，而不是检查它们是否为等同的对
象。
然而，对于两个相同内容的字符串字面常量来说，它们将指向同一个String 对象。例如，
在下面的代码中==的使用就是正确的：
13.2 String类 211
String str="Pena?";
// ...
if(str==":Pena?")
answer(str);
因为 str最初被设置成了一个字符串字面常量，所以当它与另一个字符串字面常量作比较时，
等价于比较这两个字符串是否具有相同的内容。但是需要注意的是，只有当所涉及的所有字符
串引用指向的都是字符串字面常量时才可以这样做。如果 str 又改为引用一个生成的 String
对象，例如当用户打字输入结果时，那么==运算符就会返回 false,即使我们输入的就是字
符串：Pena?也一样。
为解决这个问题，我们可以对不能确切知道是否引用到了字符串字面常量的字符串进行内
存限定(intern)。intern方法将返回一个String 对象，它与被调用该方法的 String 对象具
有同样的内容。然而，任何两个内容相同的字符串在被调用 intern方法后返回的 String对
象都是相同的，这种机制使得我们可以通过比较字符串引用来测试其相同性，从而取代了执行
速度较慢的对字符串内容的测试。例如：
int putIn(String key){
String unique = key.intern();
int i;
// see if it's in the table already
for(i=0;i< tableSize;i++)
if(table[i]== unique)
return i;
// it's not there--add it in
table[i] = unique;
tableSize++;
return i;
}
所有存储在数组 table中的字符串都是调用intern方法后返回的结果。该表被用于搜索一个
字符串，它是在另一个与key 内容相同的字符串上调用 intern方法后返回的结果。如果找到
了要搜索的字符串，则搜索结束。如果没有找到，我们就将这个key的唯一表示对象添加到表
的末尾。对 intern方法的返回结果进行处理，使得对对象引用的比较等价于对字符串内容的
比较，但前者运行的速度更快。
尽管两个不同的字符串可能会具有相同的散列码，但是任何两个内容相同的字符串都应该 312
确保具有相同的散列码——因此 String类覆盖了Object.hashcode方法。散列码主要用于
各种散列表中，比如 java.util包中的HashMap类——见21.8.1节“HashMap”。
13.2.4 创建相关字符串
有一些 String方法将返回新的字符串，它们和原来的字符串相似，但是做了一些特殊的
修改，之所以返回新的字符串是因为 String 对象是不可变的。例如我们可以通过使用如下的
方法从一个字符串中提取出指定界限之内的子字符串：
public static String delimitedString(
String from,char start,char end)
{
int startPos = from.index0f(start);
int endPos = from.1astIndex0f(end);
313
212 第13章 字符串与正则表达式
// no start found if(startPos ==-1)
return nul1;
// no end found else if(endPos == -1)
return from.substring(startPos);
else if(startPos> endPos)// start after end
return nul7;
// both start and end found else
return from.substring(startPos,endPos +1);
}
方法 delimitedstring 返回了一个新的 String 对象，它包含了from字符串中由 start和
end界定的子字符串——也就是说，它以 start字符为开始，以end字符为结尾。如果字符串
中可以找到 start字符但找不到 end字符，那么该方法返回的新 String 对象就将只包含从
start位置开始到该字符串末尾的所有字符。delimitedstring方法使用了substring方法
的两种重载形式，第一种形式只以起始位置作为参数，返回的新字符串包含原字符串中从起始
位置开始的所有字符；第二种形式以起始位置和结尾位置作为参数，返回的新字符串包含原字
符串中从起始位置到结尾位置的所有字符，其中包含起始位置上的字符但不包含结尾位置上的
字符。这种“直到末尾但不包含末尾”的方式使得该方法的 endpos 必须加一，这样返回的字符
串中才能包含用干界定的字符。例如
delimitedstring("I) a dit《Bonjour!》",'《','》');
返回的字符串是：
《Bonjour!》
以下是其他有关“相关字符串”的方法：
·public String replace(char oldchar,char newchar):用来把原字符串中的所有
oldchar字符都替换成newChar字符，以返回一个String。
· public String replace(charSequence oldseq, charSequence newSeq):用来把原
字符串中出现的所有oldseq子序列都替换成 newSeq子序列，以返回一个String。
· public String trimO:用来截去原字符串中开头和结尾的空白分隔符，以返回一个
String。空白分隔符就是指那些可以由 Character.iswhitespace方法标识出来的字
符，包括空格符、制表符和换行符。
有许多方法返回的都是基于对给定的正则表达式进行匹配而得到的相关字符串-—
见13.3节“正则表达式的匹配”。
· public String replaceFirst(String regex,String repstr):用来把原字符串中
第一个与正则表达式 regex匹配的子字符串替换成 repstr,以返回一个String。如果
是在字符串 str上调用该方法，其执行结果等价于执行Pattern.compile(regex).
matcher(str).replaceFirst(repstr)。
· public String replaceA11(String regex,String repstr):用来把原字符串中所
有与正则表达式 regex匹配的子字符串都替换成 repstr,以返回一个string。如果是
在字符串 str上调用该方法，其执行结果等价于执行 Pattern.compile(regex).
matcher(str).replaceAl1(repStr)。
· public String[] split(String regex):等价于 split(regex,0)(见下面的方法)。
· public String[] split(String regex,int limit):返回一个字符串数组，数组中
包含的字符串是由原字符串根据给定的正则表达式进行拆分得来的。原字符串中与给定
13.2 String类 213
的正则表达式的每一处匹配都会引发对原字符串的拆分，其匹配的部分将被移除。参数
limit限制了使用该正则表达式来拆分原字符串的次数。如果该限制n为正数，则实际
应用的次数为n-1,最后一次拆分后剩下的字符串将作为返回数组中的最后一个元素
(所以该数组的长度不会大于n)。如果该限制为负数，则意味着没有使用次数的限制，
而且返回的数组可以为任意长度。如果该限制为0,则与限制为负数时相似，只是结尾
的空字符串会被舍去。如果是在字符串str上调用该方法，其执行结果等价于执行 Pat tern.compile(regex).split(str,limit)。
下面用一个例子来说明就容易理解了。下表表示的是在字符串"w--x--y--"上调用
split("--",n)方法所返回的数组元素，其中n分别取-1、0、1、2、3和4:
0 3 4 Limit: -10
111 111
[3]:
当限制为负数或0时，原字符串中出现的所有"--"都将被移除，但是二者的区别是只有当限
制为负数时才有结尾的空字符串。当限制为1时，该模式没有被应用，所以返回的是作为第0
个元素的整个字符串。当限制为2时，该模式应用了一次，将原字符串拆分成了两个子字符串。
当限制为3时，拆分成三个子字符串。当限制为4时，拆分成4个子字符串，并且第4个子字符
串就是使用该模式拆分原字符串所得到的结尾的空字符串。当限制为任何大于4的数时，返回
的结果等同于限制为4的情况。
在以上的所有方法中，如果正则表达式的语法不正确，就会抛出 PatternsyntaxExcep tion。
上述是所有避免直接使用 Pattern 和Matcher 对象的简便方法，但是这些方法中的正则
表达式每次都需要被编译。如果我们只是想知道给定的字符串是否与给定的正则表达式匹配，
那么可以使用返回值为boolean型的 matches 方法。
大小写问题是语言环境敏感的(locale sensitive),也就是说，它们会随着地域的不同而不同，
随着文化的不同而不同。Java平台允许用户来指定语言环境，包括语言和字符格式问题。这些
语言环境是用Locale对象来表示的，详细内容见第24章。方法 toLowercase和 toupper Case使用的是当前默认的语言环境，也可以使用作为引元传递进来的由用户指定的语言环境：
· public String toLowerCaseO:根据默认的语言环境将原字符串中的所有字符都转换
成等价的小写字符(如果有的话)以返回一个String。
· public String toupperCaseO:根据默认的语言环境将原字符串中的所有字符都转换
成等价的大写字符(如果有的话)以返回一个String。
·public String toLowerCase(Locale loc):根据指定的语言环境将原字符串中的所
有字符都转换成等价的小写字符(如果有的话)以返回一个String。
·public String toupperCase(Locale loc):根据指定的语言环境将原字符串中的所
有字符都转换成等价的大写字符(如果有的话)以返回一个String。
方法 concat将返回一个新的 String,它等价于将 +运算符作用于两个字符串上所返回
的结果，因此下面两条语句是等价的：
newstr=oldstr.concat("not");
newstr = oldstr+"not";
314
315
316
214 第13章 字符串与正则表达式
练习13.3:如文中所示，delimitedstring方法假定每个输入字符串只含有一个要抽取的
子字符串。编写该方法的新版本，使它可以找出所有要抽取的子字符串，并且返回一个数组。
练习13.4:编写一段程序，令它读取的输入字符串的形式为一行行的“类型值”,其中“类
型”是包装器类的名字(如 Boolean、Character等),“值”是一个字符串，它可以被对应类型
的构造器作为参数解码。对每一个输入条目，该方法都将创建一个具有相应类型和相应值的对
象，并把它添加到ArrayList中——见21.6.1节“ArrayList”。当读入所有的条目之后，该
方法显示出最后的结果。假定每一行条目均以换行字符'n'结束。
13.2.5 字符串转换
程序中经常需要在字符串和诸如整型或布尔型之类的其他类型之间进行转换，这种转换要
求想要转换成的类型具有执行这种转换的方法。例如，要想将 String类型转换为 int类型，
就要求 Integer类具有这种静态方法。下面表13-2给出了所有可以转换的类型，以及将它们
与String类型进行相互转换的方法：
表 13-2
类型 转换为String 从String 转换到
boolean String.valueOf(boolean) Boolean.parseBoolean(String)
byte String.valueOf(int) Byte.parseByte(String,int base) char String.valueOf(char) str.charAt(0)
short String.valueOf(int) Short.parseShort(String,int base) int String.valueOf(int) Integer.parseInt(String,int base) long String.valueOf(long) Long.parseLong(String,int base) float String.valueOf(float) Float.parseFloat(String) double String.valueOf(double) Double.parseDouble(String)
要想将一个基本类型转换为 String类型，可以通过调用 String 的静态方法 valueof来
实现，该方法用于生成十进制表示的数值类型。Integer和Long 包装器类(在第8章中描述
过)还提供了用于生成其他表示法的方法：toBinarystring、tooctalstring 和 toHex String。
要想将字符串转换为，或者更准确地说，解析为一个基本类型，可以通过调用该基本类型
对应的包装器类的静态方法parseType来实现。每种解析方法都有其自己的关于所允许的字
符串格式的规则，例如 Float.parseFloat可以接受诸如"3.14f"这样的浮点形式的字面常
量，而Long.parseLong 就不可以接受字符串"25L"。这些数值解析方法有两种重载形式：
种形式是以字符串作为第一个参数，以2~32之间的数值为基数作为第二个参数；另一种形式
是仅以字符串作为参数，并假定基数为10。这些解析方法也会拒绝那些含有表示基数字符的字
符串，例如表示十六进制值的"0x12FE"和表示八进制值的"033"。但是，Integer和 Long包
装器类还提供了一个静态的 decode方法专门用来解析这些带有基数信息的字符串。对于这些
数值类型来说，如果要转换的字符串表示的并非该类型的合法值，那么就会抛出 NumberForma tException。
要想将 String类型转换为char类型，只需直接从该 String 中提取第一个char 即可。
对于我们自己定义的类，如果提供了合适的 tostring方法以及通过给定的字符串描述就
可以创建新对象的构造器，那么它就可以支持字符串的编码和解码。方法 String.valueof
(Object obj)被定义为返回"null"(当obj为nul1时)或返回obj.tostring 的结果，
13.2 String类 215
String类提供了足够多的 valueof方法的重载形式，我们可以通过调用该方法将任何类型的
值转换为String。
13.2.6 字符串和char数组
String 对象可以映射为char数组，反之亦然。我们经常需要将一个字符串构建到一个
char数组中，然后根据该数组的内容创建一个String 对象。假设只有可写类 StringBuild er(后面会介绍)还不够，那么 String类的多个方法和构造器将会帮助我们将一个String 对
象转换为一个char数组，或将一个char数组转换为一个String 对象。
以下便是两个用于从 char数组中创建 String 对象的构造器：
·public String(char[]chars, int start,int count):创建一个新的 String,其
内容与chars 数组中从下标 start开始多达 count个字符的内容相同。
·public String(char[]chars):等价于 String(chars,0,chars.1ength)。
这两个构造器都创建了数组的副本，所以当从数组中创建了 string 对象之后，可以改变数组
的内容而不会影响 String 对象的内容。
例如，下面的简单算法可以将字符串中某个字符的所有出现都除去：
public static String squeezeOut(String from,char toss){
char[] chars = from.toCharArrayO;
int len = chars.1ength;
int put =0;
for(int i=0;i< len;i++)
if(chars[i] != toss)
chars[put++]= chars[i];
return new String(chars,0,put);
}
方法 squeezeout首先通过使用方法 tocharArray将输入的字符串 from转换成了字符数组，
然后又设置了put的值，用于指定下一个放置字符的位置，接着程序开始执行循环，将所有不
是toss的字符复制到数组中，当循环结束后，该方法返回一个新的 String 对象，其内容即为
去除 toss字符后的字符串。
当然，如果愿意，我们还可以用两个静态的 String.copyvalueof方法来代替构造器。例
如，squeezeOut方法也可以改写为以如下语句结尾：
return String.copyvalueof(chars,0,put);
copyvalueof方法也有单引元的形式，用于复制整个数组，这主要是出于完整性的考虑，
这两个静态的 valueof方法也等价于 String 的两个构造器。
对于大部分情况来说，使用方法 tocharArray 都是既简单又有效的。如果在将字符串的
一部分复制到字符数组中时需要更多的控制，那么可以使用方法 getchars:
· public void getchars(int srcBegin,int srcEnd,char[] dst.int dstBeain)
将该 String对象的字符复制到指定的数组中，其中指定的子字符串的字符将被复制到
字符数组中从dst[dstBegin]开始的位置。指定的子字符串是原字符串从 srcBegin处
开始到srcEnd处结尾(但不包括srcEnd 处的字符)的部分。
13.2.7 字符串和byte 数组
字符串所表示的是采用UTF-16 编码方式的编码为 char 型值的字符，将这种char型值
转换为原始字节值需要使用另一种编码方式。同样地，将那些单独的“字符”或原始的8位“字
317
318
216 第13章 字符串与正则表达式
符”数组转换为char型值也需要知道原始字节的编码方式。例如，如果要将ASCII或Latin-1
编码的数组转换为Unicode字符，只需要直接将高位置为0即可；但是如果是要对其他的8位字
符集编码方式进行转换，如 Hebrew,就不能采用这种方式。稍后我们会讨论不同字符集的问
题。在下面的构造器和方法中，我们可以指定一个编码字符集编码方式，或者使用用户的或平
台的默认编码方式：
·public String(byte[]bytes,int start,int count):构建一个新的 String,它
是通过使用默认语言环境下的默认编码方式对 bytes 数组中从下标 start开始的
count个字节进行转换来的。
· public String(byte[] bytes):等价于 String(bytes,0,bytes.length)。
·public String(byte[] bytes, int start,int count, String enc)
throws UnsupportedEncodingException:它是通过使用enc 指定的编码方式对
bytes 数组中从下标 start开始的 count个字节进行转换来构建新 String的。
·public String(byte[] bytes,String enc)
throws UnsupportedEncodingException:等价于 String(bytes,0,bytes.
length,enc)。
·public byte[] getBytesO:返回一个字节数组，该数组是通过使用默认语言环境下的
默认编码方式对字符串的内容进行编码而得来的。
· public byte[] getBytes(String enc)
throws UnsupportedEncodingException:返回一个字节数组，该数组是通过使用
enc指定的编码方式对字符串的内容进行编码而得来的。
String类的这些从 byte数组中构建字符串的构造器对数据进行了复制，所以将来对数组
319 所做的进一步修改并不会影响 String的内容。
13.2.8 字符集编码方式
字符集编码方式指定了原始的8位“字符”和与它们等价的16位 Unicode字符之间相互转换
的方式。字符集是根据它们的标准和常用名来命名的。本地平台定义了哪些字符集编码方式是
可理解的，但是下面列出的字符集编码方式是每一种平台实现都必须支持的：
7位ASCII,也被称为ISO646-US,是Unicode字符集中的基本Latin块 US-ASCII
ISO-8859-1 ISO的第一个Latin字母表，也被成为ISO-LATIN-1
8位Unicode转换格式 UTF-8
16位Unicode 转换格式，遵从高位在前(big-endian)的字节顺序 UTF-16BE
16位Unicode转换格式，遵从低位在前(little-endian)的字节顺序 UTF-16LE
UTF-16 16位Unicode转换格式，字节顺序由强制的初始字节顺序掩码指定(输入
时两种顺序都可以，输出时使用高位在前的顺序)
查看所用平台实现的发布文档便可以找出它是否支持其他的字符集编码方式。
字符集和它们的编码机制是通过java.nio.charset包中下列这些特定的类来表示的：
·Charset:它是一个位于16位 Unicode 编码单元序列和字节序列之间的具名映射(如 US
-ASCII或 UTF-8)。它包含了关于编码序列的基本信息、编码和解码的简单机制，以及
创建具有更多功能的 charsetEncoder和CharsetDecoder对象的方法。
·CharsetEncoder:它的对象可以将16位 Unicode 编码单元序列转换成指定字符集的字
节序列。该编码器对象还具有描述其编码方式的方法。
13.3 正则表达式的匹配 217
·CharsetDecoder:它的对象可以将指定字符集的字节序列转换成16位Unicode编码单
元序列。该解码器对象还提供描述其解码方式的方法。
我们可以通过 charset自带的静态 forName方法来获取 charset,但是通常我们只需要
在其他某些方法(如 String构造器或I/O操作)中指定字符集名称即可，并不需要直接操作
charset 对象。为了测试是否支持指定的字符集，可以使用 forName方法，如果抛出了Un supportedcharsetException,则说明不支持。
如果想查找可用字符集的列表，可以使用静态的avalilablecharsets方法，它会返回一
个由所有已知字符集的名称和 Charset实例构成的 SortedMap。例如，可以使用如下代码打
印出所有已知字符集的名称：
for (String name:Charset.availablecharsets().keySetO)
System.out.println(name);
每个Java 虚拟机的实例都有一个默认的字符集，它是在虚拟机启动期间确定的，并且主要
取决于底层操作系统所用的语言环境和编码方式。可以通过调用静态的 defaultcharset方法
来获得当前默认的Charset。
13.3 正则表达式的匹配
java.uti1.regex包提供了一种可以检验某字符串与称作正则表达式(regular expression)
的关于某一类字符串的通用描述是否匹配的方法。正则表达式是这样来描述某一类字符串的：
用通配符表示需要匹配或排除的一组字符，用标记符表示需要在特定位置进行匹配，还有其他
一些诸如此类的方式。这个包使用的是一种通用的正则表达式，它与流行的 perl编程语言所
使用的正则表达式十分相似，而per1所用的正则表达式本身也是从一些 Unix 工具所使用的正
则表达式中演变过来的。
我们可以用正则表达式来检验字符串是否与某种模式相匹配，还可以用基于正则表达式的
一种丰富的表达式语言来挑选出字符串中的各个部分。现在我们首先要学习的是什么是正则表
达式，然后再学习如何编译和使用它们。
13.3.1 正则表达式
关于正则表达式的完整描述十分复杂，并且涉及很多其他内容，因此我们并不想给出完整
的指南，而只是想给出有关正则表达式的一些最常用特性的示例。(完整的参考资料目录就有
好几页纸。)“进阶读物”中列出了有助于理解正则表达式的资料清单。
正则表达式是在字符序列中进行搜索的，而字符序列是由java.1ang.CharSequence接
口定义，由String类和 StringBuilder类实现的。如果我们需要新的搜索源，也可以提供自
己的对该接口的实现。
每个正则表达式都定义了一种模式，它可以应用到一个字符序列上去搜索与之匹配的部
分。其中最简单的形式是精确匹配，例如，模式 xyz与字符串 xyzzy匹配，但是与字符串
plugh 就不匹配。通配符可以使模式更泛化，例如，.(圆点)表示与任何一个字符匹配，所以模
式.op与hop和pop都匹配，*表示与0到多个该星号前的字符匹配，所以xyz*与xy、xyz和
xyzzy都匹配。
其他有用的通配符包括：简单集(p[aeiou]p与pop和pup匹配，但是与 pgp 不匹配，而
[a-z]则表示与任何一个小写字母都匹配);取反([^aeiou]表示与任何一个不是小写元音字
母的字符匹配);预定义集(d与任何数字匹配；\s与任何空白字符匹配);边界(Atwisty只
320
321
218 第13章 字符串与正则表达式
与位于一行起始处的单词“twisty”匹配；Vbalike只与位于单词边界之后的“alike”匹配，也就是
说，只与位于单词起始处的“alike”匹配)。
还有一些表示特定字符的特殊符号，包括表示制表符的\t、表示换行符的\n、表示警报(响
铃)字符的a、表示退出的\e,以及表示反斜线符号本身的\。任何具有其他特殊意义的字符均
可以通过在其前面加上符号来移除其特殊意义；换句话说，\c总是表示字符C。例如，如果想
要在表达式中匹配*,可以使用\*来表示。
特殊符号均以\字符打头，\字符同时也是用来引入转义字符的字符。这就意味着，例如在
字符串表达式"\balike"中，实际的模式是由退格字符和紧跟它的单词"alike"构成的，然而
"\s"就不是空白分隔符模式，它会引起编译期错误，因为\s并不是一个有效的转义字符。如果
要在字符串表达式中使用这些特殊符号，那么前导的自身必须用\转义，所以上例中的字符串
应该分别改为"\Vbalike"和"\\s"。如果想要在模式中使用一个实际的反斜线符号，那么它必
须被转义两次，也就是使用四个反斜线字符："\1\",其中每一对反斜线字符都表示字符串中
一个单一的反斜线，因而上述的字符串"\1\"在模式中就变成了一对反斜线字符，然后被解释
成一个单一的反斜线字符。
正则表达式还可以捕获字符串的一部分，以备稍后用于正则表达式自身的内部，或是作为
从字符串中取出某个部分的一种方式。我们可以捕获表达式中位于括号内的部分，例如，正则
表达式(.)-(.*)-A-1可以与x-yup-yup-x、n-a-a-n或其他相似的字符串匹配，因
为1与组(.)匹配而与组(.*)匹配'。组是从1开始计数的，并且是按照它们左括号出现的
次序来排序的。 322
13.3.2 正则表达式的编译和匹配
对一个正则表达式进行求值可能会需要大量的计算，而且在许多情况下经常会重复使用同
一个正则表达式，这一点可以通过对正则表达式进行一次编译并重复使用其结果来得到解决。
另外，为了找出多个匹配的字符串，一个字符序列可能会被同一个模式重复检查多次，这可以
通过记录前面执行匹配时得到的某些信息来加快执行的速度。为了能够同时进行这两种优化，
使用正则表达式的完整模型构建如下：
1.首先，将正则表达式字符串转换为模式的编译版本的Pattern 对象。
2.然后，向该 Pattern 对象请求一个Matcher 对象，这个Matcher对象把模式应用到特
定的CharSequence对象上(如 String 对象或 StringBuilder 对象)。
3.最后，请求该 Matcher 对象使用编译过的模式在这个字符序列上执行操作。
也可以用以下代码来表示：
Pattern pat = Pattern.compile(regularExpression);
Matcher matcher=pat.matcher(sequence);
boolean foundMatch = matcher.find();
如果模式只使用一次，或者对每一个字符串都只使用一次来进行匹配，那么就不需要处理
中间对象。接下来我们将会看到，Pattern类提供了许多不需要 Matcher对象的简便方法，这
些方法创建了它们自己的Pattern和Matcher 对象，它们使用起来很容易，但是如果需要多次
使用同一个模式或者重复使用同一个模式来与同一个字符串进行匹配，那么它们的效率就会大
1..*代表“0个或多个字符”,这是因为.代表“任何一个字符”,而*代表“0个或多个它前面的字符”,所以这两
个字符合在一起，就表示“0个或多个任意字符”。
13.3 正则表达式的匹配 219
打折扣。
Pattern类具有下列方法：
· public static Pattern compile(String regex)
throws PatternsyntaxException:用于将给定的正则表达式编译成一个模式。
·public static Pattern compile(String regex, int flags)
throws PatternsyntaxException:用于将给定的正则表达式按照给定的flags 编译成
一个模式，其中flags 控制了某些有趣的表达式的处理方式，稍后我们会进行介绍。
· public String patternO:用于返回通过编译生成该模式的正则表达式。
·public int flagsO:用于返回该模式的匹配标志。
·public Matcher matcher(charSequence input):用于创建一个匹配器，该匹配器会
将给定的输入 input与该模式进行匹配。
· public String[] split(charSequence input,int limit):这是一个根据给定的
input输入序列与该模式的匹配情况对 input 进行拆分的简便方法。当不需要重复使
用匹配器时可以使用该方法。
·public String[] split(CharSequence input):这也是一个根据给定的 input输入
序列与该模式的匹配情况对 input进行拆分的简便方法，等价于 split(input,0)。
·public static Boolean matches(String regex,charsequence input):这是一个
编译给定的正则表达式并尝试将给定的 input输入与其进行匹配的简便方法。当不需
要重复使用解析器或匹配器时可以使用这个方法，如果匹配成功，则返回true。
·public static String quote(String str):用于返回一个字符串，该字符串可以用
来创建与str匹配的模式。
Pattern 对象的 tostring 方法也可以返回通过编译生成该模式的正则表达式。
在创建模式对象时所指定的标志将会对匹配如何进行产生影响，其中某些标志将会影
响到匹配性能，有时甚至会产生严重的影响，不过它们可能具有我们需要的功能。如表
13-3所示：
表 13-3
标 志 含 义
CASE_INSENSITIVE 启用不区分大小写的匹配。在默认情况下，仅处理ASCII字符的大小写。
UNICODE_CASE 与CASE_INSENSITIVE组合使用，表示启用对 Unicode字符大小写折叠的识别。
CANON_EQ 启用规范等价。如果一个字符可有多种表示方式，则认为它们等价，例如a与a\
u030A规范等价。
启用dot-all 模式。在dot-all模式中，.可以与行结束符匹配，而在其他情况下 DOTALL 它们并不匹配。
启用多行模式。在多行模式中，^和$不仅可以与整个字符序列的开始和结尾匹 MULTILINE 配，还可以与嵌人在序列中的行进行匹配。
UNIX_LINES 启用Unix行模式。在Unix行模式中，只有\n被当作是行结束符。
COMMENTS 模式中允许出现注释和空白分隔符。其中空白分隔符和以#字符开始直到下一个
行结束符为止的注释都将被忽略。
LITERAL 启用模式的字面常量解析。
323
324
325
220 第13章 字符串与正则表达式
Matcher类也具有与字符序列进行匹配的方法，这些方法的返回值均为表示匹配成功或失
败的布尔值。如果匹配成功，则与该匹配相关的位置和其他状态都可以通过 start、end和
group方法从Matcher对象中获得。这些匹配查询方法如下：
· public boolean matchesO:用于尝试将整个输入序列与该模式进行匹配。
·public boolean 1ookingAtO:用于尝试将从头开始的输入序列与该模式进行匹配。
该方法与matches 方法相似，都是始终从输入序列的开头开始匹配；与之不同的是，该
方法不要求匹配整个输入序列。
·public boolean findO:用于尝试查找输入序列中与该模式匹配的下一个子序列。该
方法从输入序列的开头开始匹配，不过如果前一次调用find方法是成功的并且匹配器
自那时起还未被重置，则本次匹配将从上次匹配中还未进行匹配的第一个字符开始。
·public boolean find(int start):用于重置该匹配器，然后尝试查找输入序列中从
指定索引位置开始的与该模式匹配的下一个子序列。如果可以找到一个成功匹配，则下
一次对 find方法的调用将从本次匹配中还未进行匹配的第一个字符开始。
一旦开始进行匹配，就可以使用下列方法来改变匹配器的状态：
·public Matcher resetO:用于重置该匹配器。该方法将丢弃该匹配器的所有状态信
息，并将其追加位置(见下面的内容)重置为0。该方法返回的Matcher 对象就是被调用
了该方法的Matcher 对象。
·public Matcher reset(charSequence input):用于将该匹配器重置为使用新的输入
序列。该方法返回的Matcher对象就是被调用了该方法的Matcher 对象。
· public Matcher usePattern(Pattern pattern):用于将该匹配器使用的模式改为传
递进来的pattern模式。该方法将导致匹配器丢弃所有的组信息，但是匹配器的输入和
追加位置不会受到影响。
一旦找到一个成功匹配，则可以使用下列方法来返回有关匹配的更多信息：
·public int startO:用于返回上次匹配的开始索引值。
· public int endO:用于返回匹配的序列中最后一个字符的索引值加一的值。
·public String groupO:用于返回上次匹配成功的输入子序列；换句话说，就是由
start和end定义的子字符串。
·public int groupCountO:用于返回该匹配器模式中的捕获组数。组号范围从0开
始，直到这个组数减1的值。
·public String group(int group):用于返回上次匹配中与给定组匹配的输入子序列。
第0组表示整个匹配模式，所以group(0)等价于groupO。
·public int start(int group):用于返回上次匹配中给定组的开始索引值。
·public int end(int group):用于返回与给定组匹配的序列中最后一个字符的索引值
加1的值。
这些方法合在一起就构成了MatchResult接口，该接口只允许查找匹配结果但不允许修
改它。我们也可以通过调用 toMatchResult方法将当前的匹配器状态转换成一个MatchRe sult实例，这样，接下来对匹配器的状态做任何修改都不会影响到现有的MatchResult对象。
13.3.3 替换
我们可能经常需要将查找匹配与将这些匹配的字符串替换为新字符串进行配对使用。例
13.3 正则表达式的匹配221
如，如果我们想要将所有出现的 sun都替换为moon,则可以编写如下的代码':
Pattern pat = Pattern.compile("sun");
Matcher matcher= pat.matcher(input);
StringBuffer result = new StringBuffer();
boolean found;
while((found = matcher.find())
matcher.appendReplacement(result,"moon");
matcher.appendTail(result);
只要存在与 sun匹配的字符序列，这段代码中的循环就会继续进行。在循环的每次迭代中，从
追加位置(即前一个匹配之后的位置；初始值为0)开始到当前匹配的开始位置结束的所有字符
都会被复制到字符串缓冲区中，然后复制用于替换的字符串moon。当再也没有匹配的字符序
列时，appendTail方法会将剩余的所有字符都复制到缓冲区中。
Matcher类的替换方法有：
·public String replaceFirst(String replacement):用于将与该匹配器的模式匹配
的第一个字符序列替换成 replacement字符串，并返回结果。该方法首先重置匹配器，但
在操作完成后并不重置匹配器。
· public String replaceA11(String replacement):用于将所有与该匹配器的模式匹
配的字符序列都替换成 replacement字符串，并返回结果。该方法首先重置匹配器，但在
操作完成后并不重置匹配器。
·public Matcher appendReplacement(StringBuffer buf, String replacement):
该方法首先将当前追加位置和匹配位置之间的字符添加到字符串缓冲区中，紧接着添加
replacement 字符串，最后将匹配器的追加位置改为匹配字符序列之后的位置。正如前面
的代码所示，该方法可以用于实现替换循环，它最后返回的是该匹配器对象。
·public stringBuffer appendTail(StringBuffer buf):用于将从当前追加位置开始直到
字符序列结尾为止的所有字符添加到字符串缓冲区中。该方法最后将返回该缓冲区对象。
现在前面的示例可以通过使用 replaceA71方法改写为更简单的形式：
Pattern pat = Pattern.compile("sun");
Matcher matcher= pat.matcher(input);
String result = matcher.replaceA11("moon");
下面给出了一个比较复杂的使用正则表达式的例子，该程序用来将所有数字都替换为在数
值上比它大1的数字：
Pattern pat = Pattern.compile("[-+]?[0-9]+");
Matcher matcher = pat.matcher(input):
StringBuffer result = new StringBufferO;
boolean found;
while((found = matcher.findO)){
String numStr= matcher.qroupO;
int num = Integer.parseInt(numStr);
String plusOne = Integer.toString(num+1);
matcher.appendReplacement(result,plusOne);
}
matcher.appendTail(result);
1.StringBuffer类(见13.4.4节)是一个可追加的字符序列(即可以修改其内容),而Matcher类则需要升级到
5.0版本才可以处理可追加的字符序列类型，如 StringBuilder类，不过此处忽略了这一点。
326
327
222 第13章 字符串与正则表达式
在该程序中，我们首先解码匹配所找到的数字，然后在其基础上加1,最后用得到的新值替换了
原来的数值。
替换字符串中也可以使用$g符号，该符号会被表达式中第g个捕获组的值替换。下面的
方法就利用该特性互换了所有指定的两个相邻单词：
public static String
swapWords(String w1,String w2,String input) {
String regex ="\\b("+w1+")(\\W+)("+w2+")\\b";
Pattern pat= Pattern.compile(regex);
Matcher matcher = pat.matcher(input);
return matcher.replaceA11("$352S1");
}
在该程序中，我们首先根据两个指定的单词构建了匹配模式，在该模式中使用了括号来捕获字
符组。该模式中的b表示与一个单词边界匹配(否则单词“crow”就可以与“crown”的一部分匹
配了),W表示与任何一个非单词字符匹配。初始模式的匹配形式为第一组(第一个单词)、第
二组(分隔符)和第三组(第二个单词),而"$3$2$1"则是匹配序列反转后的替换字符串。
例如，以下对方法的调用：
swapwords("up","down",
"The yo-yo goes up, down,up, down,...");
328 将会返回如下字符串：
The yo-yo goes down,up, down,up,...
如果只想互换首次出现的这两个单词，则可以使用 replaceFirst方法：
public static String
swapFirstWords(String w1,String w2,String input){
String regex ="\\b("+w1+")(\\W+)("+w2+")\\b";
Pattern pat = Pattern.compile(regex);
Matcher matcher = pat.matcher(input);
return matcher.replaceFirst("$352$1");
}
13.3.4 区域
Matcher类可以在作为输入给定的字符序列中查找匹配的字符串。在默认情况下，查找匹
配需要考虑整个字符序列，当然我们也可以通过使用 region方法，并提供该方法所需的用来
定义输入字符序列的一个子序列的开始索引值和结束索引值，来控制字符序列的查找区域(re gion)。方法 regionStart和 regionEnd分别返回当前开始索引值和当前结束索引值。
我们也可以通过调用 useAnchoringBounds 方法来控制某个区域是否应该被当作真正的
输入开始及结束，如果向该方法提供的引元值为 true(默认值),那么我们就可以针对字符序列
中的某一行的开始或结束进行匹配。如果不想用有行定位符(line anchor)的区域来匹配，那么
可以向该方法提供值为 false的引元。方法 hasAnchoringBounds 将返回当前的设置。
类似地，我们还可以控制区域的边界是否对那些向前、向后或探测边界的匹配方法透明。
在默认情况下，区域的边界是不透明的，也就是说，它们看起来就像是输入序列上的硬边界一
样。不过可以通过 userTransparentBounds 方法来改变边界的透明度。方法 hasTranspar entBounds用于返回当前设置。
13.4 StringBuilder类 223
13.3.5 效率
假定我们需要将一个字符串解析为由逗号分隔的两部分，那么可以使用既清晰又直观的模
式(.*),(.*),但是该模式并不一定是解决这个问题效率最高的方法，因为第一个.*就可
能需要尝试匹配整个输入序列，然后匹配器必须退回到字符序列中最后一个逗号的位置，再将
剩余部分与第二个.*进行匹配。当然，我们也可以通过明确声明逗号不属于捕获组的方式来
提高效率：([^,]*),([^,]*),这样的话显然匹配器只需要找到第一个逗号便可以停下来，
而不需要再回退了。但是另一方面，第二个表达式对于偶尔使用正则表达式的用户来说就显得
有点不清晰了。
我们应该避免这种牺牲模式的清晰度来换取效率的做法，除非我们所编写的程序对性能的
要求很高。正则表达式本身就已经有点神秘莫测了，而那些复杂的技术又使它们变得更加难以
理解，所以只有在确实需要的情况下才应该使用正则表达式。如果我们需要高效的程序，那么
必须确保我们所使用的方法确实是高效率的——就像对待所有的优化一样，我们应该仔细测试
以确定到底哪种方案更快。在我们给出的例子中，设计得足够精巧的模式编译器和匹配器可以
使这两个模式变得同等迅速，这样就不需要牺牲模式的清晰度来换取其他的东西了。甚至有可
能今天这个模式还比另一个模式的效率高，而明天一个更好的实现将抹煞这种差异。在使用正
则表达式时，与使用其他编程技术一样，选择优化而不是清晰度是比较保险的做法。
13.4 StringBuilder类
如果Java中只有不可变的字符串可供使用的话，那么我们就不得不在一组 String 操作中
为每一个中间结果都创建一个新的 String 对象。例如，考虑一下编译器将如何计算下面的表
达式：
public static String guillemete(String quote){
return '《'+ quote+'》';
}
如果编译器仅限于使用String 表达式，那么它只能这样做：
Gucted = String.valueof('《').concat(quote)
.concat(String.valueof('》'));
每次调用 valueof和 concat方法都会创建一个新的 String 对象，所以该操作将会创建4个
String 对象，其中只有一个String对象在以后还会用到，而其他的字符串仍然需要创建、赋
值和垃圾回收等开销。
事实上，编译器要比上述方法有效得多。它使用 StringBuilder 对象从表达式中构造字
符串，只有在必须的时刻才创建最终的 String对象。StringBuilder 对象可以被修改，所以
根本不需要创建新的对象来保存中间结果。通过使用StringBuilder,上例中的表达式可以表
示为：
quoted = new StringBuilder().appendC'《')
.append(quote).append('》').tostringO;
这段代码只创建了一个用来存储构造内容的 StringBuilder 对象，并在其中追加了元素，然后
使用 tostring方法从得到的结果中创建了一个String 对象。
如果要构造并修改一个字符串，很可能需要用到 StringBuilder类。StringBuilder提
供了下列构造器：
·public StringBuilderO:用于构造一个stringBuilder 对象，其初始值为""(空字
329
330
331
224 第13章 字符串与正则表达式
符串),容量为16个字符。
·public StringBuilder(int capacity):用于构造一个StringBuilder 对象，其初始
值为"",容量为给定的数值。
·public StringBuilder(String str):用于构造一个StringBuilder对象，其初始值
是从字符串 str中复制而来的。
·public StringBuilder(charsequence seq):用于构造一个StringBuilder对象，
其初始值是从字符序列 seq 中复制而来的。
StringBuilder类与 String类很相似，它支持的许多方法的名字和契约都和 String方
法中的相同，如indexof、1astIndexof、replace和 substring。但是，StringBuilder类并
非扩展自String类，反之亦然，它们都是对CharSequence的独立实现。
13.4.1 修改缓冲区
有多种方法可以修改 StringBuilder 对象的缓冲区，包括在末尾追加和在中间插入。其
中最简单的方法就是setcharAt,它可以改变指定位置的字符。下面的 replace 方法的行为
与String.replace的行为一样，只是它使用的是StringBuilder 对象。replace方法不需
要创建新的对象来保存结果，所以后继的 replace调用可以操作同一个缓冲区：
public static void
replace(StringBuilder str,char oldChar,char newChar){
for(int i=0;i< str.length(O); i++)
if(str.charAt(i)== oldChar)
str.setCharAt(i, newChar);
}
setLength方法可以截断或者扩展缓冲区中的字符串。如果调用setLength方法时所提
供的长度小于当前字符串的长度，则该字符串会被截断到指定的长度。如果该长度大干当前字
符串的长度，则会用null字符('u0000')扩展该字符串。
也可以用 append和insert方法来将其他任何数据类型转换为String类型，并且将转换
的结果追加到末尾或是插入到指定位置。在需要时，insert方法将移动缓冲区中的字符来为
要插入的字符腾出空位。下列类型均可以通过 append和insert方法进行转换：
Object String CharSequence char[] boolean char int long float double
append和 insert方法还可以将Charsequence或char 数组的一部分用作引元。以下代码使
用各种不同的 append调用创建了一个用于描述某整数的平方根的 StringBuilder:
String sqrtInt(int i){
StringBuilder buf = new StringBuilder(O);
buf.append("sqrt(").append(i).append()');
buf.append("=").append(Math.sqrt(i));
return buf.toString(O); }
append和insert方法将返回 StringBuilder 对象自身，这种机制使得我们可以在前一次追
加的结果上继续追加。
几个 append方法合在一起就构成了java.lang.Appendable接口。这些方法是：
13.4 stringBuilder类 225
public Appendable append(char c)
public Appendable append(CharSequence seq)
public Appendable append(charsequence seq,int start, int end)
Appendable接口用来标记那些可以接收来自java.util.Formatter对象(见22.1节“For matter”)的格式化输出的类。
insert 方法有两个参数，第一个是表示 StringBuilder 中字符插入位置的索引值，第二
个是要插入的值，如果需要的话要将其先转换为String。下面的方法用于将当前日期放入缓
冲区的起始处：
public static StringBuilder addDate(StringBuilder buf){
String now = new java.uti1.Date().toStringO);
buf.insert(0,now).insert(now.1engthO),":");
return buf;
}
addDate方法首先使用 java.util.Date 创建了一个表示当前时间的字符串，其中java.
util.Date的默认构造器所创建的对象表示的是该对象被创建的时间。然后 addDate方法将
这个表示当前时间的字符串插入到缓冲区中，并在其后追加了一个简单的分隔符字符串。最
后.该方法返回了作为参数传入的缓冲区，这样调用该方法的代码就可以与StrinaBuilder类
自己的方法一样使用该方法的串联形式了，这种方法串联形式是很有用的，这点已经在
StringBuilder类自己的方法中证明了。
reverse方法用于反转 StringBuilder 中的字符顺序。例如，如果缓冲区的内容是
"good",那么调用 reverse后其内容就变成了"doog"。
delete方法用于移除缓冲区中的部分字符，我们需要向它提供起始索引和终止索引作为其
参数。在调用该方法后，字符串中从起始索引到终止索引(但不包括终止索引)的那部分将从缓冲
区中移除，同时缓冲区的长度也将变短。我们也可以使用deletecharAt方法来移除单个字符。
我们还可以使用下面的方法替换缓冲区中的字符：
· public StringBuilder replace(int start,int end, string str):用于将缓冲区
中从 start 位置开始到 end位置为止(但不包括 end位置上的字符)的所有字符替换为
str的内容。缓冲区的长度可能会增加也可能会缩短.这取决于str的长度是大干还是
小于被替换的字符范围。
13.4.2 取出数据
如果要从 StringBuilder 对象中取出String 对象，直接调用 tostring方法即可。如果
需要的是缓冲区的某个子字符串，可以使用 substring方法，其功能同 String类中的方法类
似。如果需要的是由缓冲区的某些或全部内容组成的字符数组，可以使用getchars方法，其
功能同String.getchars方法类似：
· public void getchars(int srcBegin,int srCEnd,char[] dst,int dstBeqin):
用于将该 StringBuilder 中的字符复制到指定的数组中。具体操作是将指定的子字符
串中的字符复制到字符数组中从dst[dstBegin]开始的位置，其中指定的子字符串是指
字符串缓冲区中从srcBegin位置开始到srcEnd位置为止(但不包括srcEnd位置上的
字符)的部分。
下面的方法使用了getchars方法来移除缓冲区中的部分字符：
332
333
334
226 第13章 字符串与正则表达式
public static StringBuilder
remove(StringBuilder buf, int pos, int cnt){
if(pos<0|1 cnt<01| pos +cnt > buf.length())
throw new Index0utOfBoundsException(O);
int leftover = buf.1ength()-(pos +cnt);
if(leftover ==0){ // a simple truncation
buf.setLength(pos);
return buf;
}
char[] chrs = new char[leftover];
buf.getChars(pos+cnt,buf.1ength(),chrs,0);
buf.setLength(pos);
buf.append(chrs);
return buf;
}
首先，remove方法要保证对数组的引用没有越界。当然，我们完全可以在后面处理实际的异
常，但是这里先做检查有助于更好地控制程序。然后，remove方法计算了要移除的部分之后还
有多少字符。如果一个也没有，则直接截断缓冲区并返回；否则，remove方法会先通过 get Chars方法获取那些位于移除部分之后的字符，然后再截断缓冲区，将获取到的剩余字符追加
到缓冲区中，最后返回该缓冲区。
13.4.3 容量管理
StringBuilder对象的缓冲区有容量限制，即它限制了缓冲区可以存储的字符串的长度，
如果超出了这个长度就必须为它分配更多的空间。缓冲区的大小会随着字符的增加而自动变
大，但是如果可以一次性地指定缓冲区的大小，则效率会更高。
StringBuilder 对象的初始大小可以通过使用接受单一的 int参数的构造器来设置：
· public StringBuilder(int capacity):用于创建一个StringBuilder 对象，其初始
容量为指定的capacity,其初始值为""。
·public void ensureCapacity(int minimum):用于确保缓冲区的容量至少为指定的
minimum。
· public int capacityO:用于返回缓冲区的当前容量。
· public void trimToSizeO:用于尝试将缓冲区的容量减小到恰好能容纳当前缓冲区
中的字符序列。但是该操作并不保证能确实减小缓冲区的容量，它只不过是提示系统现
在是尝试收回一些存储空间的大好时机。
我们可以使用这些方法来避免重复地增加缓冲区的容量。例如，下面是13.4.1节sqrtInt
方法的改写版本，它可以保证最多只为缓冲区重新分配一次空间：
String sqrtIntFaster(int i){
StringBuilder buf= new StringBuilder(50);
buf.append("sqrt(").append(i).append(')');
buf.append("=").append(Math.sqrt(i));
return buf.toStringO); }
13.5 使用UTF-16 227
与原来的版本相比，其中唯一的变化就是此版本使用构造器创建了一个大得足够容纳结果字符
串的 StringBuilder 对象。值50比需要的空间还要大一点，因此，缓冲区的容量再也不需要
增加了。
13.4.4 StringBuffer类
StringBuffer类基本上等同于 StringBuilder类，它们之间只存在一处差异：String Buffer类为可追加的字符序列提供了线程安全的(thread -safe)实现，有关线程安全的描述见
第14章。正是这个差异把对 StringBuffer的讨论归并到了对线程安全的数据结构的讨论中，
而并不是因为下面这个次要的因素：StringBuffer类要比 StringBuilder类旧一些，而且之
前它所处的角色和 StringBuilder 如今所处的角色一样，都是作为可变字符序列的标准类。
介于这个原因，我们经常会发现，许多方法接受的参数或返回的对象都是StringBuffer,而不
是StringBuilder、charsequence 或者Appendable。这种历史上沿袭下来的StringBuffer
的用法很可能在未来的几年中仍然会出现在现有的API中。
练习13.5:编写一个方法将字符串中的十进制数字转换成用逗号隔开的数字，其中从右边
开始每三个数字用一个逗号隔开。例如，给出字符串"1543729",则该方法返回的字符串应该 335
为"1,543,729"。
练习13.6:修改上述方法，使其可以通过参数来指定所使用的分隔符以及分隔符之间的数
字个数。
13.5 使用UTF-16
在8.5.1节“使用UTF-16字符集”中，我们描述了许多Character类提供的工具方法，它
们可以简化对 Unicode 增补字符的处理(即那些值比0xFFFF大的字符，在CharSequence 对象
中，它们需要被编码成一对 char值)。String类、StringBuilder类和 StringBuffer类也
都提供了这些方法：
·public int codePointAt(int index):用于返回 this 对象中在指定索引处定义的
Unicode代码点，该方法考虑到了该代码点有可能是一个由 this.charAt(index)和
this.charAt(index+1)对来表示的增补字符的情况。
·public int codePointBefore(int index):用于返回 this对象中在指定索引之前定
义的Unicode代码点，该方法考虑到了该代码点有可能是一个由 this.charAt(index-
2)和 this.charAt(index-1)对来表示的增补字符的情况。
· public int codePointcount(int start,int end):用于返回在 this.charAt
(start)和 this.charAt(end)之间定义的Unicode代码点的个数，该方法考虑到了代
理对。任何未配对的代理值均作为一个代码点来计数。
·public int offsetBycodePoints(int index, int numberofcodePoints):用于返
回 this 对象中从指定的 index处偏移 numberofcodePoints个代码点之后的索引，该
方法考虑到了代理对。
此外，StringBuilder和 StringBuffer类还定义了appendcodePoint方法，它接受一
个表示任意 Unicode字符的 int值，如果需要的话还会将其编码成一个代理对，然后将它追加
到缓冲区的末尾。奇怪的是，两个类中并没有与它对应的 insertCodePoint方法。
最后，String类还提供了下列构造器：
·public String(int[] codePoints,int start,int count):用于构造一个新的
336
228 第13章 字符串与正则表达式
String,它的内容是从 Unicode 代码点数组的codepoints[start]处开始的count个
代码点字符，如果需要的话增补字符将被编码成代理对。如果数组中含有任何不是有效
Unicode代码点的数值，则会抛出IllegalArgumentException。
当思想失效时，语言就起作用了。
——约翰·沃尔夫冈·冯·歌德
第14章 线 程
在某个时刻，你必须跳出飞机，前提是你可以将缝在一起的降落伞及时打开。
—杰克·里卡德(因特网先驱)
我们通常编写的程序都是按顺序每次执行一个步骤。如图14-1所示，我们获得银行账户的
余额，在上面加上存款数，然后又把它复制回账户的记录中：
bal = a.getBalance();
bal+=deposit;
a.setBalance(bal);
图 14-1
真正的银行出纳员或计算机程序都会执行类似的操作序列。在计算机中，这种每次执行一步的
操作序列被称作线程(thread),而这种单线程编程模型正是大多数程序员所使用的模型。
然而在真正的银行中，在某一个时刻会发生多个操作，如图14-2所示：
bal =a.getBalance();
bal+=deposit;
a.setBalance(bal);
图 14-2
在计算机中，与现实银行中拥有多个出纳员类似的情形被称作多线程(multithreading)。线
程就像银行出纳员一样，可以独立于其他线程执行一项任务。正如两个银行出纳员可以使用同
一个文件柜一样，线程之间也可以共享访问对象。
这种共享访问既是多线程最有用的特性之一，同时也是其最大的陷阱之一，在这种获取一
修改一设置的序列中存在着被称作竞争危险(race hazard)或竞争条件(race condition)的因素。
当两个线程在修改同一块数据时，如果它们是以会对数据造成破坏的交叉方式去执行的，那么
就会出现竞争危机。在银行业务的例子中，假设有位客户通过一个银行出纳员把钱存到某个账
户里，几乎与此同时，第二个客户也要求另外一个出纳员向同一个账户存钱，那么这两个出纳
员都会去文件柜查询当前账户的余额(假设这是一个仍然使用纸质文件的老式银行),并且会得
bal= b.getBalance();
bal+=deposit;
b.setBalance(bal);
337
338
230 第14章 线 程
到相同的信息，如图14-3所示。接着，他们返回各自的柜台，加上存款，然后再回到文件柜去
记录他们分别独自计算的结果。在这个过程中，只有后一笔存款记录会真正地反映到用户的余
额上，而前一笔修改则会丢失。
bal1= a.getBalance(); bal2-a.getBalanceO;
bal1+=deposit; ba2-dcst:
a.setBalance(bal1);
图 14-3
在实际的业务中，银行解决这个问题的方法是让第一个出纳员在文件上贴个便签，在上面
写上：“我正在使用这个文件，请等我处理完再使用。”实际上，在计算机中同样是这么做的：用
一个锁和对象关联起来，这个锁可以告知该对象是否正在被使用。
许多现实世界的软件问题都可以通过使用多线程控制来很好地解决。例如，以图形界面显
示数据的交互程序经常需要让用户实时地修改显示参数，而这些交互程序通常都通过使用线程
来获得其最佳动态行为。单线程系统经常通过使用中断或轮询来提供多线程的假相，而轮询会
把应用程序的显示和用户输入部分混在一起，特别是显示代码必须编写成可以频繁轮询的形
式，以便对用户的输入作出及时的反应。这样显示代码就必须保证显示操作耗时最小化，或者
必须能够中断它自己的操作来进行轮询。把一个程序的这两个不相关的功能性要求混在一起会
使其代码变得更复杂，而且还经常是不可维护的。
所有这些问题在多线程系统中都能够比较容易地解决。我们可以让一个控制线程用当前的
数据去更新显示，而让另一个线程响应用户的输入。如果用户的输入很复杂，比如填写一个表
格，那么显示代码可以独立地运行直到它收到新数据。在采用轮询的模型中，显示更新必须被
复杂的输入中断，或者必须使用复杂的“握手”机制使得更新显示能够在用户向表格中输入数据
时不停地进行。在多线程系统中可以直接支持这种进程中的共享控制模型，而不必对每一种新
的轮询情况进行手工处理。
本章详细介绍了在Java编程语言中控制多线程的基本结构、类和方法，但是这些内容并不
能教会读者应该如何有效地进行多线程设计。java.util.concurrent包及其子包提供了较
高级别的并发工具，可以用来减轻编写复杂的多线程程序的任务，但是这些工具的详细用法也
超出了本书的范围，我们会在25.9.1节给出一个概述。读者可以参考本系列丛书的《Concurrent
Programming in Java,Second Edition》来获得关于如何创建设计良好的多线程程序的建议。“进
阶读物”给出了其他有用的参考资料，它们可以为读者提供有关线程和同步设计的背景资料。
14.1 创建线程
要想创建控制线程，我们首先得创建一个 Thread 对象：
Thread worker= new ThreadO;
在创建了这个 Thread 对象之后，我们就可以对它进行配置然后运行它了。对线程进行配置时
会涉及到设置它的初始优先级和名字等。当线程准备好可以运行时，我们就调用它的 start方
a.setBalance(ba12);
14.1 创建线程 231
法。之后，start方法根据 Thread 对象中的数据生成一个新的控制线程，然后返回。现在虚
拟机调用新线程中的 run方法，从而激活这个线程。我们只能为每个线程调用一次 start方
法，否则再次调用时将抛出IllegalThreadstateException异常。
当线程的 run方法返回时，线程就已经退出了。我们可以通过调用线程的 interrupt方
法来请求中止线程的运行，这是一个编写良好的线程总是会响应的请求。当然，我们也可以通
过其他方式来和运行的线程进行交互，很快我们就会看到。
Thread.run的标准实现并未做任何事情，要想让线程执行某些工作，必须扩展Thread类
以提供一个新的 run方法，或者创建一个Runnable对象并把它传递给线程的构造器。我们首
先讨论如何通过扩展 Thread类来创建新的线程类型，下一节我们再介绍如何使用Runnable
接口。
下面是一个简单的两线程程序，它以不同的速率打印单词“ping”和“PONG”:
public class PingPong extends Thread {
private String word;// what word to print
private int delay;// how long to pause
public PingPong(String whatToSay,int delayTime){
word = whatToSay;
delay = delayTime;
}
public void run(){
try {
for(;;){
Svstem.out.print(word +""):
Thread.sleep(delay);// wait until next time
}
} catch(InterruptedException e){
return; // end this thread }
}
public static void main(String[] args){
new PingPong("ping",33).startO;// 1/30 second
new PingPong("PONG",100).startO;//1/10 second
}
}
我们定义了一个名为PingPong的线程类型，它的 run方法在不停地循环，在每次循环迭代中
都会打印它的word字段并休眠 delay毫秒。PingPong.run并不会抛出任何异常，因为它所
覆盖的 Thread.run并不抛出任何异常。相应地，我们必须捕获 sleep方法可能会抛出的 In terruptedException异常(有关InterruptedException异常的内容将在稍后介绍)。
现在我们可以创建一些工作线程，PingPong.main方法就是这样做的，它创建了两个
PingPong对象，其中每个对象都有自己的单词和休眠周期，然后它又调用了每个线程对象的
start方法。现在线程会不停地休眠和运行，并输出如下的示例结果：
ping PONG ping ping PONG ping ping ping PONG ping
ping PONG ping ping ping PONG ping ping PONG ping
ping ping PONG ping ping PONG ping ping ping PONG
339
340
341
232 第14章 线 程
ping ping PONG ping ping ping PONG ping ping PONG
ping ping ping PONG ping ping PONG ping ping ping
PONG ping ping PONG ping ping ping PONG ping ping ...
我们可以通过设定构造器的 String参数或者设定 setName方法调用的参数来为线程命
名，并且可以通过调用getName方法获得线程的当前名。为线程命名只是为了方便程序员，运
行时系统并不使用它们，但是每个线程仍然必须得有一个名字，因此如果没有为线程指定名字，
那么运行时系统就会给它取个名字，通常使用的是像 Thread-1、Thread-2这种简单的数字
编号模式。
我们可以通过调用静态方法 Thread.currentThread来得到当前运行线程的 Thread 对
象。即使我们没有显示地创建线程，当前运行的线程也总是存在的，因为main方法本身就是
通过运行时系统创建的线程而执行的。
练习14.1:编写一个程序，用来显示执行 main方法的线程的名字。
14.2 使用Runnable
线程抽象出了工作者(worker)这个概念——工作者就是执行某些操作的实体，因为线程将
所要完成的工作都封装在其 run方法中。但是当我们需要执行某项工作时，不仅需要一个工作
者，还需要这项工作，Runnable接口就抽象出了工作这个概念，并允许把这项工作和一个工作
者(即线程)相关联。Runnable接口只声明了一个方法：
public void run();
Thread类本身就实现了Runnable接口，因为线程也可以定义工作单元。
我们已经看到了，通过扩展 Thread类，我们可以为一个线程提供具体的计算，但是这种方
式在很多情况下显得很笨拙。首先，类的扩展是单重继承的，如果我们扩展了一个类，使其可
以在一个线程中运行，那么我们就无法再扩展其他类了，即使我们确实需要也不行。再者，如
果我们的类仅仅只是需要是可运行的，那么继承 Thread 的所有开销就有点得不偿失了。
在很多情况下，实现Runnable接口要显得更容易一些。通过把 Runnable对象传递给某
个 Thread 构造器，我们可以在该 Runnable对象本身的线程中执行它。如果 Thread 对象是用
Runnable对象构造的，那么 Thread.run方法的实现就会调用这个可运行对象的 run方法。
以下就是PingPong类的 Runnable版本。如果我们比较这两个版本，就会发现它们看上
去几乎是一样的。它们之间的主要差别体现在其超类型(一个实现了Runnable接口，而另一
个扩展了Thread类)和main方法上。
class RunPingPong implements Runnable {
private String word;// what word to print private int delay; // how long to pause
RunPingPong(String whatToSay,int delayTime){
word = whatToSay;
delay = delayTime;
}
public void run(){
try {
for(;;){
System.out.print(word+"");
14.2 使用Runnable 233
Thread.sleep(delay);// wait until next time
}
} catch(InterruptedException e){
return; // end this thread
}
}
public static void main(String[] args){
Runnable ping = new RunPingPong("ping",33);
Runnable pong = new RunPingPong("PONG",100);
new Thread(ping).start();
new Thread(pong).start();
}
}
首先，上面的代码定义了一个实现了Runnable接口的新类，它的 run方法实现和 PingPong类
中的 run方法实现是一样的。然后，在main方法中创建了两个具有不同的定时周期的 RunPing Pong 对象；最后为这两个对象分别创建了一个新的 Thread 对象，并立刻启动了这两个线程。
有5个Thread类的构造器允许我们指定Runnable对象：
· public Thread(Runnable target):用于构造一个新的 Thread,该线程使用了指定 342
target的 run方法。
·public Thread(Runnable target,String name):用于构造一个具有指定名字name
的新的 Thread,该线程使用了指定 target的 run方法。
·public Thread(ThreadGroup group,Runnable target):用于在指定的 Thread Group 中构造一个新的 Thread,该线程使用了指定 target的 run方法。我们将在后面
ThreadGroup 中介绍它。
·public Thread(ThreadGroup group,Runnable target, String name):用于在指定
的 ThreadGroup 中构造一个具有指定名字 name 的新的 Thread,该线程使用了指定
target的 run方法。
· public Thread(ThreadGroup group,Runnable target, String name,long
stacksize):用于在指定的 ThreadGroup 中构造一个具有指定名字name的新的
Thread,该线程使用了指定 target的 run 方法。stackSize 参数是对该线程的栈大
小所提出的建议值。适合于栈大小的值是完全依赖于操作系统的，操作系统并不一定非
要遵循这个建议。绝大多数的应用并不需要这个便利的构造方法，但是就像自然界的大
多数事物一样，当我们需要它的时候，它就是不可或缺的。
只有 run方法的类并没有太多的用处，因为真正的类定义了完整的状态和行为，而在一个
单独的线程中执行某些操作只是其功能的一个部分而已。例如，考虑一个能够缓存打印请求的
打印服务器，客户端是调用print方法来提交打印任务的，但是所有的print方法实际上做的
都是把打印作业置于一个队列中，然后由一个独立的线程把这些作业从队列中取出来发送给打
印机。这就使得用户可以在提交打印作业时不用等待实际的打印动作发生。
class PrintServer implements Runnable {
private final PrintQueue requests = new PrintQueue();
public PrintServer(){
new Thread(this).start();
}
343
344
234 第14章 线 程
public void print(PrintJob job){
requests.add(job);
}
public void run(){
for(;;)
realPrint(requests.removeO);
}
private void realPrint(PrintJob job){
// do the rea1 work of printing }
}
在创建 PrintServer 对象时，该对象创建了一个新的 Thread来完成实际的打印工作并把它自
己作为Runnable实例传递给了该 Thread 对象。如果一个类可以被扩展，那么代码中所示的
方式，即在该类的构造器中启动一个线程，就会有一定的风险。因为一旦该类被扩展，那么在
扩展类的构造器执行之前，那个被启动的线程可能就已经可以访问正在被构建的对象的域了。
requests 队列很小心翼翼地同步访问它的不同线程，即那些调用print方法的线程和我
们自己的内部线程，我们将在后面的小节中讨论同步，并将在14.4节定义 PrintQueue类。
你可能会感到惊奇，为什么我们没有引用我们所创建的线程，这是否意味着这个线程可以
被垃圾回收器回收?答案是否定的。因为虽然我们并没有保持对线程的引用，但是在线程自身
被创建的时候，它将一个对其自身的引用保存到了它所处的 ThreadGroup中，稍后我们会详细
介绍线程组。
在 run方法中定义的工作通常具有明显的私有性，即该工作只能由指定完成该工作的工作
者来执行。
然而，作为接口的一部分，run方法是公共的，因此它可以被任何对该线程的对象拥有访
问权限的代码不受限制地调用，而这可能并非是我们所愿意看到的。例如，我们肯定不希望客
户端去调用Printserver类的 run方法。有一种解决方法是，用 Thread.currentThread方
法来确定调用 run方法的线程的标识，并将它和所期望的工作者线程进行比较。但是，有一种
更简单的方法，那就是不去实现Runnable接口，而是定义一个内部的 Runnable对象。例如，
我们可以将Printserver类改写为如下版本：
class PrintServer2 {
private final PrintQueue requests=new PrintQueue();
public PrintServer2(){
Runnable service = new Runnable(){
public void run(){
for(;;)
realPrint(requests.remove(O); }
};
new Thread(service).start();
}
public void print(PrintJob job){
requests.add(job);
}
private void realPrint(PrintJob job){
// do the real work of printing
}
}
14.3 同 步235
run方法和以前是完全一样的，但现在它是实现了Runnable的匿名内部类的一部分。当
新线程被创建时，我们将 service 传递给它作为要执行的Runnable。现在，该线程所要执行
的工作就完全是私有的了，我们不必再担心它会被滥用。
通过使用Runnable对象，我们可以创建出非常灵活的多线程设计，其中每一个Runnable
对象都变成了一个工作单元，并且它们可以在系统的各个部分之间进行传递。我们可以把 Run nable对象存储到一个队列中，然后维护一个工作者线程池，由它来为队列中的工作请求提供
服务，这是多线程服务器应用中的一种非常常见的设计。
练习14.2:修改第一个版本的Printserver,使只有在构造器中创建的线程才能成功地执
行 run方法，建议使用线程标识来实现。
14.3 同步
回忆一下本章开始部分谈到的银行出纳员例子，当两个出纳员(线程)需要使用同一个文件
(对象)时，存在着由于交叉操作而破坏数据的可能性。这种潜在的干扰动作在术语上被称作临
界区(critical section)或者临界区域(critical region),通过同步(synchronizing)对临界区域的访问
可以避免这种干扰。在银行业务中，出纳员可以在文件中放置便条并达成协议—一旦文件里
有便条就意味着这个文件目前不可以使用，这样，出纳员就可以同步他们的行为。在多线程中
与其等效的动作就是获取待操作对象上的锁，而多线程协作时遵循的协议是：在某些动作操作
对象之前，必须先获取这个对象的锁。获取待操作对象上的锁可以阻止其他对象获取这个锁，
直至这个锁的持有者释放它为止。这样，如果操作正确，多线程就不会同时执行那些会互相干
扰的动作。
每个对象都有与之关联的锁，并且可以通过使用synchronized方法和语句来获取或者释放
这个锁。术语同步代码(synchronized code)指的是包含在synchronized方法或语句中的代码。
14.3.1 synchronized方法
对于类来说，如果其对象必须为防止在多线程环境中遭受干扰而受到保护，那么这样的类
通常都会有恰当的被声明为 synchronized 的方法(何为“恰当”将在下文中定义)。如果一个
线程要在某个对象上调用 synchronized方法，那么它首先要获取这个对象的锁，然后执行方
法体，最后释放这个对象上的锁。而与此同时，在同一个对象上调用 synchronized方法的其
他线程将被阻塞，直到这个对象的锁被释放为止，如图144所示：
获取锁
synchronized 方法 等待获取锁
释放锁
获取锁
释放锁
345
synchronized
方法
图 14-4
346
236 第14章 线 程
同步会强制两个线程的执行及时互斥，而非同步的访问则无需等待任何锁，它们将直接执行，
而不去理会是否可以持有对象上的锁。
锁归整个线程所有，因此在一个同步方法中调用同一个对象上的另一个同步方法时，被调
用的方法将会直接执行而不会阻塞，但只有当最外层的同步方法返回时才会释放所持有的锁。
这种锁归整个线程所有的行为可以防止线程在自己已持有的锁上发生阻塞，从而允许递归地调
用方法或调用继承而来的方法，而这些方法本身可能就是同步的。
只要同步方法执行结束，就会立即释放锁，不论它是(通过 return语句或者到达方法体的
末尾)正常结束的，还是(通过抛出异常)非正常终止的。与那些必须显式地获取和释放锁的系
统不同，这种同步模式可以从根本上解决忘记释放锁的情况。
同步可以让那个交叉执行的例子得以正常运行：如果执行的是同步方法中的代码，那么在
第一个线程执行的时候，第二个线程如果试图访问第一个线程正在使用的对象，那么它将被阻
塞，直到第一个线程完成操作。
例如，如果在多线程环境下运行的 BankACcount类，那么它的代码可能会是这样的：
public class BankAccount {
private long number;// account number
private long balance;// current balance(in cents)
public BankAccount(long initialDeposit){
balance = initialDeposit;
}
public synchronized long getBalance(){
return balance;
}
public synchronized void deposit(long amount){
balance += amount;
}
// ... rest of methods ...
子
现在我们可以解释在同步方法中，什么是所谓的“恰当”(appropriate)了。
构造器并不需要被声明为 synchronized的，因为它只在创建对象的时候执行，而对于任
何给定的新对象来说，它只能在一个线程中被创建。事实上，构造器也不能够被声明为 syn chronized的。
balance字段受到了 synchronized存取器方法的保护，防止了被非同步地修改。如果某
个字段的值可以被修改，那么当有另一个线程在写入它的值时候，其他线程就不应该读取它的
值，因为如果一个线程读取的是其他线程正在进行设置的值，那么这种读取可能会返回无效值。
即使这个值是有效的，“获取一修改一设置”序列也会要求这个值在被读取和设置的时候不可以
被修改，否则所设置的值就是错误的，因此必须同步地访问字段。这也是为什么最好使用存取
器方法来访问字段而不是将字段声明为public或者 protectd的另外一个原因：通过使用方
法，我们可以同步地访问数据；但是，如果字段可以被外部的类直接访问，那么我们就无法做到
这一点了。
有了 synchronized 的声明，我们就可以确保两个或者两个以上的运行线程不会互相干扰
了，因为每一个方法都将互斥地执行，即一旦某个方法的一个调用开始执行，那么对任何方法
的其他任何调用在第一个方法结束之前都将无法进行。但是，这并不能保证方法的执行顺序。
如果在查询余额的同时要存款，那么它们当中有一个会先结束，但是我们无法知道是哪一个。如
果想让动作按确定的顺序执行，那么线程之间就必须以某种与应用相关的方式去协调其行为。
14.3 同步 237
我们可以询问当前的线程是否持有给定对象上的锁，所采用的方式是将这个对象传递给
Thread类的静态方法holdsLock,该方法在当前线程持有这个对象的锁时返回 true。这种方
式的典型用法是用来断言持有所需的锁。例如，要求只能被 synchronized的公共方法调用的
私有方法可能会这样断言：
assert Thread.holdsLock(this);
偶尔，我们也会发现在方法中不持有某个特定的锁也是很重要的。因为，在某些罕见的情况下，
我们可能想根据是否持有某个其他的锁来决定是否要获取指定的锁。
如果扩展类覆盖了synchronized的方法，那么新的方法可以是synchronized的，也可
以不是，而当超类的方法被调用时仍然是synchronized的。如果非同步的方法使用 super来
调用超类的方法，那么对象的锁会在调用的那一刻被获取并在超类方法返回时被释放。同步要
求是类的实现的一部分。扩展类可能能够修改数据结构，使得方法的并发调用不会互相影响，
这样方法就不需要进行同步了；相反地，扩展类也可能会在提升方法的行为时采用会使方法互
相干扰的方式，这时就必须对方法进行同步。
14.3.2 静态synchronized方法
静态方法也可以被声明为 synchronized的。每个类都有与其相关联的Class 对象(见
16.1节“Class类”),而静态同步方法获取的就是它所属的类的Class 对象上的锁。两个线程
不可以同时执行同一个类的静态同步方法，这就像两个线程不能同时在同一个对象上执行同步
方法一样。如果静态数据是在线程之间共享的，那么对它的访问就必须利用静态同步方法来进
行保护。
在静态同步方法中获取 Class 对象上的锁并不会对这个类的任何对象产生影响，所以当另
一个线程在静态同步方法中持有Class 对象上的锁时，我们仍然可以在这个类的对象上调用同
步方法，而只有其他的静态同步方法才会被阻塞。
14.3.3 synchronized语句
synchronized语句可以使我们能够执行获取任何对象锁而不仅仅是当前对象锁的同步代
码，也能够执行那些同步时间比整个方法调用时间要短的同步代码。synchronized 语句包括
两部分：要在其上获取锁的对象和获取锁之后要执行的语句。synchronized 语句的一般形式
是：
synchronized(expr){
statements
}
表达式 expr的值必须是某个对象引用，在获取该对象上的锁之后，就会执行语句块中的
statements。在语句块的结尾这个锁会被释放，即使在语句块中出现了未捕获的异常，这个锁
也会被释放。synchronized方法只是方法体被包装在针对 this引用的 synchronized语句
中的方法在语法上的便捷声明方式。
下面是一个把数组中的每个元素都用其绝对值来替代的方法，它是依靠 synchronized 语
句来控制对数组的访问的：
/** make al1 elements in the array non-negative */
public static void abs(int[] values){
347
348
349
238 第14章 线 程
synchronized(values){
for(int i= 0;i< values.1ength;i++){
if(values[i]<0)
values[i]=-values[i];
}
}
}
values 数组包含了要被修改的元素，我们通过把 values 命名为synchronized语句的对象来
对其进行了同步。现在循环可以开始进行了，并且可以保证在执行的过程中 values 数组不会
被同样在该数组上进行同步的其他代码所修改。这是通常被称作客户端同步的一个范例，即所
有使用共享对象(在本例中指的是values 数组)的客户端在处理对象之前都要对该对象的同步
达成一致。对于像数组这样的对象，当它们被直接共享时这是对其进行保护的唯一方式，因为
它们没有任何可以同步的方法。
synchronized 语句拥有多种用法，并且拥有 synchronized方法不具备的优势。首先，
它可以定义比方法还要小的同步代码区。同步会影响性能，因为当一个线程持有锁时其他的线
程便得不到这个锁，所以同步编程的一般规则是让持有锁的时间尽可能地短。通过使用 syn chronized 语句，我们就可以在绝对必要的时候才持有锁，例如，对于执行复杂算法并把结果
赋给某个字段的方法，通常只需保护实际被赋值的字段即可，而无需保护整个计算过程。
其次，synchronized语句允许对其他对象而不仅仅是this 进行同步，这使得我们可以做
出多种不同的同步设计。有时我们希望通过使用更细粒度的加锁机制来提高类的并发级别，因
为类中不同的方法组操作的可能是类中不同的数据，所以尽管方法组内需要互斥，但是不同的
方法组之间就不需要互斥了。在这种情况下，我们并不需要同步所有的方法，我们可以为每一
个这样的组都定义一个单独的用作锁的对象，并且让这些方法使用具有恰当的锁对象的 syn chronized 语句。例如：
class SeparateGroups {
private double aVal =0.0;
private double bVal = 1.1;
protected final Object lockA = new Object();
protected final Object lockB= new ObjectO;
public double getA(){
synchronized(lockA){
return aVal;
}
}
public void setA(double val){
synchronized(lockA){
aVal= val;
}
}
public double getB(){
synchronized(lockB){
return bVal;
子
}
public void setB(double val){
synchronized (lockB){
I
14.3 同 步 239
bVal= val;
}
}
public void reset(){
synchronized(lockA){
synchronized (lockB){
aVal= bVal=0.0;
}
}
}
}
上面代码中的两个锁引用都受到了保护，使得扩展类可以正确地同步它们自己的方法，例如将
aval和bva1设置成同一个值的方法。此外要注意 reset方法在修改这两个值之前是如何同
时获取两个锁的。
synchronized语句的另一种常见的用法是在内部类对象中用来对其包围对象进行同步：
public class Outer {
private int data;
// ...
private class Inner {
void setOuterData(){
synchronized(Outer.this){
data =12;
}
}
}
}
和其他所有对象一样，内部类对象也是单独同步的，即获取内部类对象上的锁对于其包围对象
上的锁并不会有任何影响，而获取包围对象上的锁对于它所包围的所有内部类对象也不会有任
何影响。如果内部类需要和它的包围对象同步，那么这种同步必须显式地进行，而 synchro nized语句则是实现这一目的的理想工具，另外一种方法是在包围类中声明仅有内部类使用的
synchronized方法。
如果 synchronized 语句需要与静态 synchronized方法使用相同的锁，那么我们可以使
用声明这些 synchronized语句和方法的类所相应的类字面常量(见下面的例子)。如果需要
在非静态代码中对静态数据的访问进行保护，也可以使用这种方法。例如，考虑一下 Body类，
它维护的静态字段 nextID保存着下一个新的 Body 对象可用的标识，这个字段被 Body类的无
参数构造器所访问。如果并发地创建 Body 对象，那么在更新 nextID字段的时候就可能产生干
扰。要防止发生这种干扰，我们可以在 Body 的构造器中使用 synchronized 语句，并在该语
句中使用Body.class对象的锁：
BodyO){
synchronized(Body.class){
idNum = nextID++;
}
}
这个构造器中的 synchronized 语句获取 Body.class 对象上的锁的方式与该类中的 syn chronized 静态方法获取这个锁的方式是一样的。如果对 this 进行同步，那么对于每一个调
350
351
352
240 第14章 线 程
用来说，使用的就都将是不同的对象，因此不能防止线程并发地访问 nextID。而使用Object
的方法getclass来获取当前实例的Class 对象也是错误的：在扩展类中，比如 Attributed Body,返回的是AttributedBody而不是Body的Class 对象。因此，虽然使用的是不同的锁，
但它们之间的互相干扰仍然无法避免。要想保护对静态数据的访问，最简单的规则就是使用声
明这些静态数据的类的Class 对象上的锁。
在很多情况下，我们可以不使用 synchronized 语句，而是把类中要保护的代码分解到该
类自己的 synchronized方法中。我们需要根据自己的经验和判断来决定哪种方法更适合。例
如，在Body类中，我们可以把对 nextID的访问封装到静态 synchronized方法 getNextID
中。
最后，由于 synchronized语句具有获取任意对象上的锁的能力，使得我们可以执行客户
端同步，就像在数组例子中看到的那样。这种能力很重要，它不仅可以保护对没有同步方法的
对象所进行的访问，而且可以同步对同一个对象的一系列访问，我们在下一节会看到更多与此
有关的内容。
14.3.4 同步设计
为类设计恰当的同步策略可能会很复杂，深入研究这些设计问题也超出了本节的讨论范
围，因此我们只是简单地来看一下某些涉及到的问题。
客户端同步可以这样实现：让共享对象的所有客户端在访问该对象之前使用 synchro nized语句对其加锁。当然，这种协议很脆弱，因为它要求所有的客户端操作都准确无误。通
常更好的方法是通过把共享对象的方法声明为 synchronized的(或者在这些方法中使用恰当
的 synchronized语句),让共享对象自己来保护对它们的访问，这可以使得客户端能够非同步
地使用共享对象。这种方法有时也被称作服务器端同步，但它只是“对象对其行为进行了封装”
这种面向对象观点的一种扩展，只不过这里对象封装的是同步。
有时设计者在设计类时没有考虑多线程环境，因此没有对类中的任何方法进行同步。要想
在多线程环境中使用这样的类，就必须决定是通过 synchronized 语句来进行客户端同步，还
是创建扩展类来覆盖其恰当的方法，把这些覆盖方法声明为 synchronized的，并通过 super
引用来转发方法调用。
如果使用的是接口而不是类，那么就还可以使用另一种实现方法，即把接口中的方法包装
到同步方法中，这些同步方法把调用转发给实现了同一个接口的另一个非同步对象。这种方法
对接口的任何实现都很有效，因此与扩展每一个类并在同步方法中使用super相比，这是一个
更好的方案。这种灵活性也是应该使用接口来设计系统的另一个原因。我们可以在集合类中看
到这种同步包装技术的例子，见21.11.1节“同步包装器”。
迄今为止我们所学习的同步都是“线程安全”中最简单的概念，即多个线程可以并发调用对
象上的方法，并且在每个线程中被调用的方法都在执行所期望的作业。但是，同步必须扩展到
涉及一个对象上的多个方法调用，甚或是涉及多个对象上的多个方法调用这种更复杂的情况。
如果这一系列的调用必须是原子操作，那么我们就需要使用同步。在多个方法调用的情况中，
可以把这个调用系列封装到另一个方法中，并对这个方法进行同步，但这样做通常不太现实，
因为我们不能把所有基本方法的组合都定义为方法，也不可能在类的设计阶段就知道需要哪些
方法组合。而在多个对象上操作的情况中，又有哪里能够放置同步方法呢?
在这些情况中，通过 synchronized语句进行客户端同步经常是唯一可行的方式。对象可
以要求上锁，这样除了执行调用系列的锁持有者之外，其他线程都无法调用该对象的任何同步
14.4 wait、notifyA17和notify 241
方法。类似地，我们可以获取调用系列涉及的每一个对象上的锁，然后在这些对象上调用方法
系列，但是必须小心死锁(见14.7节)。只要对象的方法已经在当前对象的锁上被同步了，那么
该对象的其他客户端就不需要使用客户端同步。
在类中强制同步的方式是一种实现细节，这种强制方式也是类契约的重要部分，必须要进
行明确的文档说明，因为方法前面的 synchronized修饰符只是类的实现细节而不是绑定契约
的一部分。此外.在类中使用的同步机制也需要进行文档说明，并且应该让该类及其扩展类的
使用者可以访问到这些文档说明，因为扩展类需要与超类强制的同步策略保持一致，而只有当
程序员了解这种策略并具有访问这种强制机制的权限时，才能够做到这一点。例如，用私有域
作为锁对象的类可以防止扩展类使用相同的同步机制，因为这种方式使得扩展类必须定义它自
己的锁对象(可能是this)并覆盖超类的每个方法才能使用这种新的同步机制。类的使用者可
能需要了解所使用的同步机制才能安全地应用客户端同步来在同一个对象上调用多个方法，但
这并不要求该对象的所有使用者都必须使用客户端同步。
练习14.3:编写一个类，在它的对象中存储一个当前值，并提供一个方法对这个值进行累
加并打印出新值。编写一个程序，创建一个这样的对象和多个线程，并在每一个线程中重复地
调用这个累加的方法。要求编写的类不会丢失任何累加的结果。
练习14.4:使用静态数据和静态方法来修改练习14.3的代码。
练习14.5:修改练习14.4中的代码，使线程能够在不使用静态同步方法的情况下安全地递
减这个值。
14.4 wait、notifyA11和 notify
虽然 synchronized加锁机制足以避免线程之间的互相干扰，但是我们还需要一种能够在
线程间进行通信的方式。为此，wait方法会让一个线程等待，直到某个条件出现，而通知方法
notifyAl1和notify会通知正在等待的线程已经发生了某个可能会满足条件的事件。wait
方法和通知方法都是在Object类中定义的，所有的类都会继承它们，并且它们可以像锁那样
应用于特定的对象。
对 wait和通知方法的使用有一种非常重要的标准模式，在这种模式中，等待某条件出现
的线程应该总是执行类似如下所示的操作：
synchronized void dowhenconditionO{
while(! condition)
waitO);
..Do what must be done when the condition is true...
}
在此要说明几点：
●所有的操作都是在同步代码内执行的。如果不是这样，对象的状态就会不稳定。例如，
如果方法没有被声明为 synchronized的，那么在执行完 while语句后，就无法保证判
定条件仍然为 true,因为另一个线程可能已经修改了该条件所测试的状态。
·wait定义有一个重要的方面，就是当它暂停线程时，它会原子性地释放掉对象上的锁，
“线程挂起和锁的释放是原子性的”这一说法是指它们是以不可分割的方式一起发生的。
否则，就会产生竞争危机：通知可能会在锁释放之后线程挂起之前发生，也就是说，这个
通知实际上可能会丢失而不会对线程产生任何影响。当线程在被通知后又重新启动时，
将原子性地再次获取锁。
353
354
355
242 第14章 线 程
●条件测试应该始终在循环中进行。决不要假设被唤醒就意味着条件已经满足了，因为该
条件有可能在得到满足之后又被改变了。换句话说，不要把while改成 if。
另一方面，通知方法是由同步代码调用的，而这些同步代码会改变一个或多个其他线程正
在等待的条件。典型的通知代码如下：
synchronized void changeconditionO{
.. change some value used in a condition test...
notifyAl10;// or notify()
}
notifyAl1方法会唤醒所有等待的线程，而notify方法只会唤醒一个线程。
多个线程可能会等待同一个对象，但是等待的条件可能会不同。如果它们等待的条件不
同，那么我们就应该始终使用notifyAl1而不是notify来唤醒所有的等待线程。否则，我们
可能会唤醒等待条件不同于当前已满足条件的线程，这个线程将会因为发现它的条件并未被满
足而继续等待，而等待当前已满足条件的线程将永远不会被唤醒。使用notify是一种优化，
但只能应用于下列情况：
·所有线程等待的是同一个条件。
·至少有一个线程可以从被满足的条件中获益。
·使用notify对于所有可能的子类来说都确实是一种优化。
对于其他情况，我们必须使用notifyA11。如果子类违反了前两种情况中的任意一种，超类中
使用 notify的代码就会被破坏。最后要说明的是，对等待和通知策略，包括对所用引用(this
或其他字段)的识别，都应该进行文档说明，以供扩展类使用，这一点非常重要。
下面的例子实现了14.2节我们将其与PrintServer一起使用的 PrintQueue类。为了保
存打印作业，我们重用了在第11章中定义的SingleLinkQueue类，并在其中添加了必要的同
步：
class PrintQueue {
private SingleLinkQueue<PrintJob> queue=
new SingleLinkQueue<PrintJob>();
public synchronized void add(PrintJob j){
queue.add(j);
notifyA110;// Tel1 waiters:print job added }
public synchronized PrintJob remove()
throws InterruptedException
{
while(queue.size()==0)
wait(); // Wait for a print job
return queue.remove();
}
}
与SingleLinkQueue自身形成对照的是，PrintQueue类的方法为了避免互相干扰都被同步
了。当向队列中添加作业时，等待者就会被通知；当队列为空时，remove方法就会等待其他线
程添加作业而不是返回nu11,因此它将被阻塞直到可获得某个作业为止。许多线程(并非只有
一个线程)会向队列中添加作业，并且也有许多线程(再次强调并非只有一个线程)会从队列中
14.5 等待和通知的详细介绍 243
移除作业。因为wait可能会抛出 InterruptedException异常，所以我们在throws子句声
明了它，稍后我们将会学习InterruptedException异常。
回过头来再看Printserver示例，我们就会发现虽然内部线程看起来是在无穷循环中不
断地尝试把打印作业从队列中移除，但是由于使用了wait,所以这意味着无论何时，只要不存
在任何需要该线程完成的工作，该线程就会被挂起。相反，如果我们使用的是在其为空时返回
nul1的队列，那么打印线程会不断地调用 remove,从而占用整个CPU,这种情况我们称之为
忙等待(busy-waiting)。在多线程系统中应该尽量避免忙等待，因此我们应该始终挂起线程，
直到它们被告知所等待的事件可能已经发生。这是使用wait、notifyAl1/notify机制来进行
线程通信的精髓所在。
14.5 等待和通知的详细介绍
Java有三种形式的wait和两种形式的通知，它们都是Object类中的方法，并且是final
的，因此它们的行为是不可以被改变的：
·public final void wait(long timeout)throws InterruptedException:让当前线
程一直等待，直到发生以下四个事件之一：在当前对象上调用notify,并且该线程被选
择时是可运行的；在当前对象上调用notifyAl1;指定的 timeout 超时；该线程的 in terrupt方法被调用。其中 timeout 以毫秒为单位，如果timeout是0,那么等待将不
会超时，而会无限时地等待通知。在等待过程中，当前对象将释放对象锁；在wait结束
前，不管wait是如何或者为什么结束的，当前对象都将自动地再次获取对象锁。如果
因为线程被中断而造成等待结束，那么将抛出 InterruptedException异常。
·public final void wait(long timeout, int nanos)
throws InterruptedException:是更细粒度的wait方法，其超时的时间间隔是两个
参数的和：timeout 以毫秒为单位，nanos 以纳秒为单位，后者的取值范围0~999999。
·public final void waitOthrows InterruptedException:与wait(0)等价。
·public final void notifyA11O:可以通知所有等待条件发生变化的线程。一旦线程
重新获取对象锁，就会从 wait调用返回。
·public final void notifyO:用来通知至多一个正在等待条件发生变化的线程。我
们无法选择通知哪个线程，因此只有当我们确信了解哪些线程在何时正在等待什么条件
的情况下，才可以使用这种形式的 notify。如果对这些因素不是很有把握，那就应该用
notifyAl1。
如果在调用notifyAl1或者notify时没有任何线程处于等待状态，那么该通知将被忽
略。如果某个线程随后决定等待，那么先前的通知对它不会产生任何影响。只有在wait开始
之后产生的通知才会对正在等待的线程产生影响。
这些方法只能在同步代码中调用，调用时会用到被调用这些方法的对象上的锁。我们可以
直接在同步代码中调用这些方法，也可以间接地在同步代码调用的方法中调用。如果未能持有
某个对象的锁就试图调用该对象的这些方法，则会得到IllegalMonitorstateException异
常。
当wait因为超时而结束时，并不会有任何表示发生了这种情况的提示，因而也就不会有
线程被通知。如果线程需要知道它是否超时，就必须自己跟踪运行时间。使用超时是一种预防
性编程措施，如果某些条件应该满足，但是由于某些原因(也许是其他线程的失败)没有满足，
那么可以使用这种措施来恢复。由于必须重新获取对象锁，因此使用超时并不能保证 wait会
356
357
358
244 第14章 线 程
在有限的时间内返回。
某些虚拟机的实现还允许在线程未接收到通知、中断或者超时提示的情况下发生所谓的“伪
唤醒”(spurious wakeup)。这也是为什么 wait应该始终在测试所等待条件的循环中执行实现的
另外一个原因。
练习14.6:编写一个程序，每秒钟打印一次从执行开始到目前为止所运行的时间，再用另
一个线程每隔15秒钟打印一条消息。每过一秒钟时间打印线程就会通知消息打印线程进行打
印。在不改变时间打印线程的前提下，再增加一个每隔7秒钟打印另一个消息的线程。
14.6 线程调度
线程可以在程序中执行不同的任务，而这些任务的重要级别也可以不同。为了反映正在执
行的任务的重要性，每个线程都有优先级，运行时系统将用这个优先级来协助确定在任意给定
的时间应该调用哪个线程。Java程序既可以在单处理器机器上运行，也可以在多处理器机器上
运行，并且我们可以使用单线程或多线程来运行程序，因此对线程调度进行保障就显得相当普
遍了。在具有N个可用处理器的系统中，通常会看到有N个最高优先级的可运行线程在同时执
行，而低优先级的线程一般只能在高优先级的线程被阻塞(不可运行)时才能运行。但事实上，
为了防止“饿死”,低优先级线程可能会在其他时刻运行，这就是被称为优先级老化(priority ag ing)的特性，但是我们不能依赖于它。
正在运行的线程将持续运行到执行阻塞操作(诸如 wait、sleep或者某些类型的I/O操作)
或者被抢占时为止。线程在以下情形下可能会被抢占：具有更高优先级的线程处于可运行状
态，或者因为线程调度器决定该轮到另一个线程运行若干个CPU时钟周期了，例如时间片(time
slicing)限制了单个线程在被抢占之前可以运行的时间量。
抢占到底何时发生取决于用户的虚拟机，对此并不会有任何保证，只有一个普遍的原则，
即虚拟机优选的线程通常是具有更高优先级的线程。使用优先级只能影响调度策略以提高运行
效率，不能依靠线程优先级来保证算法的正确性。为了编写正确的跨平台的多线程代码，我们
必须假设线程可以在任何时刻被抢占，因此我们始终要保护对共享资源的访问。如果希望抢占
发生在某个指定的时刻，那么必须使用诸如 wait和notify等显式的线程通信机制。我们不能
对将锁授予线程的顺序进行假设，也不能对等待线程收到通知的顺序进行假设，因为它们都是
与系统相关的。
线程的初始优先级与创建该线程的线程的优先级相同，我们可以使用setPriority方法
将线程的优先级改变成 Thread类中的常量MIN_PRIORITY和MAX_PRIORITY之间的值。默认
线程的标准优先级为 NORM_PRIORITY,运行线程的优先级可以在任何时刻改变。如果线程被赋
予的优先级比当前的优先级低，那么系统可能会让另一个线程运行，因为原先的线程不再是具
有最高优先级的线程之一了。getPriority方法将返回线程的优先级。
通常，如果对线程优先级不是很确定，那么就应该让运行应用中连续运行部分的线程比处
理诸如用户输入这类较少发生事件的线程具有更高的优先级。例如，当用户点击“取消”按钮
时，他们的目的是想让应用程序取消某个正在执行的操作。如果显示更新和用户输入具有相同
的优先级，并且正在更新显示，那么在用户输入线程对按钮做出反应之前可能要经过相当长的
一段时间。如果将显示线程置于较低的优先级，它仍然会占用大部分的运行时间，因为用户界
面线程会因等待用户输入而阻塞。当有用户输入时，用户界面线程通常会抢占显示线程所占有
的运行权，以响应用户的请求，从而使更新显示线程阻塞。正是因为这个原因、执行连续更新
的线程的优先级经常会被设置为NORMLPRIORITY-1以使得它不会占用所有的可用周期，而用
14.6 线程调度 245
户界面线程的优先级经常会被设置为NORM_PRIORITY+1。
通常使用由正常优先级加上一个小的“增量”而形成的优先级比直接使用MIN_PRIORITY
或 MAX_PRIORITY要好得多。实际上优先级具有什么样的效果完全取决于所运行的系统。在某
些系统中，线程的优先级不仅赋予了与程序相关的某种重要性，而且赋予了与运行在系统中的
其他应用相关的某种重要性'。极端的优先权设置可能会导致意想不到的行为，因此除非确切
了解它们的效果并且确实需要它们，否则应该尽量避免使用它们。
某些算法对在其上运行线程的虚拟机可用的处理器数量是敏感的。例如，某个算法可能把
工作分为几个更小的块来更好地利用并行处理能力。Runtime类(见第23章)的 avail ableprocessors方法将返回当前可用的处理器数量，请注意，处理器数量在任何时刻都可能
发生变化，因此当该数量显得很重要时，应该通过调用这个方法来进行检查，而不是记住上次
检查时所得到的数量。
主动重调度
Thread类中有几个方法允许线程放弃对CPU的占用。按惯例，Thread类的静态方法总是
可应用于当前运行的线程，并且由于我们无法从另一个线程处占有CPU,所以这些主动重调度
方法都是静态的：
·public static void sleep(long millis)throws InterruptedException:用于将
当前运行的线程置于休眠状态，休眠的时间至少是所指定的毫秒数。“至少”意味着并不
能保证线程恰好会在指定的时间到达时被唤醒，其他线程的调度、系统时钟的粒度和精
确性，以及其他的因素都可能会对此造成干扰。如果一个线程在睡眠时被中断，则会抛
出InterruptedException。
·public static void sleep(long millis,int nanos)
throws InterruptedException:用于将当前运行的线程置于休眠状态，休眠的时间至
少是所指定的毫秒数和纳秒数之和。纳秒数的取值范围是0~999999。
·public static void yieldO:用于给调度器提供提示：当前线程现在并不需要运行，
这样调度器就可以选择另一个线程来运行。调度器将视情况来决定是接受这个建议还是
忽略这个建议，虽然没有任何规范说明究竟怎样做才是正确的，但是通常我们可以信赖
调度器能“执行正确的操作”。
下面的程序演示了yield方法是如何影响线程调度的。这个应用接受了一个单词列表，然
后为每个单词都创建了一个用于打印该单词的线程。该应用的第一个参数表示是否每个线程在
运行print1n之后都将让步，第二个参数表示每个线程应该重复打印其单词的次数，剩下的参
数是要进行重复打印的单词：
class Babble extends Thread {
static boolean doYield;// yield to other threads?
static int howOften; // how many times to print
private String word; // my word
Babble(String whatToSay){
word = whatToSay;
}
1.请检查所用的虚拟机实现的版本说明；某些实现会把优先级的取值范围当作是相同的进行处理，从而减少不同
调度类的数量。
359
360
361
246 第14章 线 程
public void run(){
for(int i=0;i< howOften; i++){
System.out.println(word);
if(doYield)
Thread.yield();// let other threads run
}
}
public static void main(String[] args){
doYield= new Boolean(args[0]).booleanValue();
howOften = Integer.parseInt(args[1]);
// create a thread for each word
for(int i=2;i<args.1ength; i++)
new Babble(args[i]).start();
}
}
当线程不让步时，每个线程都会获得大块的时间，通常足够完成所有的打印任务，而不会让其
他任何线程获得任何运行时间。例如，假设在运行程序的时候，我们以下面的方式把 doYield
设置为 false:
Babble false 2 Did DidNot
那么其输出结果可能会是这样的：
Did
Did
DidNot
DidNot
如果每个线程执行完println之后都进行让步，那么其他的打印线程就将有机会得以运行。假
设我们通过如下的调用把 doYield设置成了 true:
Babble true 2 Did DidNot
那么让步将使得其他线程有机会得以运行，并且其他线程会依次让步，从而产生像下面这样的
输出：
Did
DidNot
DidNot
Did
上面显示的输出只是近似的结果——也许你认为单词会交替显示?因为不同的线程实现会
产生不同的输出结果，即使是同样的实现，在应用的不同运行过程中也可能会产生不同的输出
结果。但是在所有实现中，调用yield都会给其他线程以更均等的机会去获得运行周期。
还有另外两个因素会影响这个程序(以及许多像该程序这样试图演示调度行为的程序)的
行为。其中第一个因素是print1n使用了同步机制，因此不同的线程必须共同竞争同一个对象
锁。
第二个因素是在该程序中有三个线程而不是两个。主线程必须创建并启动两个 Babble线
程，这意味着它也要和这两个线程一起竞争调度，因此，第一个Babble线程甚至完全有可能在
主线程获得创建第二个Babble线程的机会之前就结束了。
练习14.7:多次运行 Babble并查看其输出：输出是否总是一样的?如果有可能的话，在
14.7 死锁 247
不同的系统上运行它，并比较它们的输出。
14.7 死锁
在任何存在两个线程和两个带锁的对象的情况下，都有可能产生死锁，即每个线程都拥有
其中的一个对象锁，并且在等待另一个对象锁。如果对象X的某个 synchronized方法在对象
Y上调用了一个 synchronized方法，而反过来对象Y的某个 synchronized方法也在对象X
上调用了一个 synchronized方法，那么这两个线程就可能会彼此等待对方结束以获取对方持
有的对象锁，这样这两个线程就都将无法运行。这种情况也被称为致命拥抱(deadly embrace)。
下面有一个 Friendly类，其中一个朋友被拥抱之后一定要拥抱对方：
class Friendly {
private Friendly partner;
private String name;
public Friendly(String name){
this.name= name;
}
public synchronized void hug(){
System.out.print7n(Thread.currentThread().getName()+
" in "+ name +".hug()trying to invoke"+
partner.name+".hugBack()");
partner.hugBackO;
}
private synchronized void hugBack(){
System.out.print1n(Thread.currentThread().getName()+
" in"+ name+".hugBackO)");
}
public void becomeFriend(Friendly partner){ this.partner= partner;
}
}
现在考虑这样的场景，jareth 和cory是两个已经成为朋友的 Friendly 对象：
1.线程1调用 synchronized方法jareth.hug,于是线程1拥有了jareth 上的锁。
2.线程2调用 synchronized方法 cory.hug,于是线程2拥有了cory上的锁。
3.现在jareth.hug调用 synchronized方法cory.hugBack,于是线程1被阻塞以等待
cory上的锁(当前正由线程2持有)变为可获取的。
4.最后，cory.hug 也调用 synchronized方法 jareth.hugBack,于是线程2也被阻塞以
等待 jareth上的锁(当前正由线程1持有)变为可获取的。
这样就出现了死锁：cory在jareth上的锁被释放之前将不会继续运行，反之亦然，因此两个
线程就陷入了永久的拥抱状态。
我们可以像下面这样建立上述场景：
public static void main(String[] args){
final Friendly jareth= new Friendly("jareth");
final Friendly cory = new Friendly("cory");
362
363
248 第14章 线 程
jareth.becomeFriend(cory);
cory.becomeFriend(jareth);
new Thread(new Runnable(){
public void run(){ jareth.hug();}
},"Thread1").start();
new Thread(new Runnable(){
public void run(){ cory.hug();}
},"Thread2").start();
}
并且当程序运行时，在程序“挂起”之前我们可能会得到如下的输出：
Thread1 in jareth.hugO)trying to invoke cory.hugBack()
Thread2 in cory.hug()trying to invoke jareth.hugBackO)
当然，如果够幸运的话，可能其中一个线程在另一个线程启动之前就已经完成了整个 hug
操作。如果第2步和第3步以相反的顺序发生，jareth 将在cory需要jareth 上的锁之前完
成 hug和 hugBack。但是同样的应用在将来的运行中，有可能会因为线程调度器的不同选择而
造成死锁。有多种对设计的修改都可以解决这个问题。最简单的就是不让 hug和 hugBack 成
为 synchronized方法，但是让它们在某个所有 Friendly对象都共享的单一对象上进行同步。
这种技术意味着在单一应用的所有线程中在某一时刻只能发生一个拥抱动作，但它可以消除发
生死锁的可能性。其他更复杂的技术将允许同时发生多个拥抱动作而不会产生死锁。
我们有责任去避免死锁，因为运行时系统既不会发现死锁也不会防止死锁。调试死锁问题
可能会令人沮丧，因此在设计阶段就应该尽量避免死锁的可能性，最常见的方法是使用资源排
序(resource ordering)。利用资源排序，我们可以对所有必须获取其锁的对象指定顺序，这样就
可以保证我们总是以这个顺序来获取锁。采用这种技术后，两个线程就不可能分别持有一个对
象锁并试图获取另一个线程持有的对象锁，因为它们必须以相同的顺序来请求对象锁，所以一
旦某个线程获取了第一个对象锁，第二个线程将在试图获取该锁时阻塞，这样第一个线程就可
以安全地获取第二个对象锁。
练习14.8:用 Friendly程序做试验。在你的系统中这个程序实际发生死锁的频率是多
364 少?如果增加了yield调用，是否可以改变死锁的可能性?如果可以，试着在更多的系统上做
这个试验。然后在不取消同步的情况下，移除潜在的死锁。
14.8 结束线程的执行
已经启动的线程是活跃的，对该线程调用 isAlive方法将返回true。线程在终止之前将
一直是活跃的，有三种情况可使线程终止：
· run方法正常返回。
· run方法意外结束。
●应用程序终止。
让线程从 run返回是终止线程的常规方式，因为每个线程的存在都是为了执行一项任务，
当这项任务执行完成之后，线程就应该被终止。但是如果在执行过程中出现了错误，并抛出了
未被捕获的异常，那么也会导致线程被终止，我们将在14.12节进一步讨论这个话题。线程终
止时就不再持有任何锁了，因为 run结束时，必定会退出所有的同步代码。
线程也可以在其应用程序终止时被终止，我们将在14.9节“结束应用程序的执行”中介绍
14.8 结束线程的执行 249
这种情况。
14.8.1 取消线程
经常会碰到这样的情况，我们创建了一个执行某项工作的线程，然后在它完成之前需要取
消这个工作，最明显的例子就是用户点击了用户界面上的取消按钮。要想使线程是可取消的
(cancellable),程序员就必须采取一定的措施，但必须是某种使线程终止的清晰而安全的机制。
我们可以通过中断线程来请求取消，并且可以编写一个线程来监视并响应中断。如图14-5所
示：
线程1
thread2.interrupt(O;
图14-5
中断线程请求在提醒线程：用户希望线程注意自己的行为，通常是希望线程能够终止运行。中
断并不会强制终止线程，虽然它将中断休眠或等待线程的睡眠状态。
线程2
如果我们想要对运行线程在处理某个事件时施加一些控制，那么中断也会很有用。例如，
更新显示的循环可能需要使用事务来访问某些数据库信息，并且要求等到事务正常结束之后再
去处理用户的“取消”请求，那么用户界面线程就可以通过中断显示线程来实现“取消”按钮，以
此赋予显示线程这种控制权。这种方法很有效，我们只需让显示线程正常地工作，并在每个事
务结束时检测它自己是否已经被中断，如果被中断了就终止线程。
和中断线程相关的方法有：interrupt,向线程发送中断；isInterrupted,测试线程是否
已经被中断；interrupted,测试当前线程是否已经被中断，随后清除线程“中断”状态的静态
方法。线程的中断状态只能由线程自己来清除，因为无法“清除”另一个线程的中断。查询另一
个线程的中断状态通常并没有什么意义，因此这些方法被设计为仅供当前线程在其自身上使
用。当线程侦测到自己已经被中断时，它经常需要在实际响应中断之前执行某些清除工作。这
些清除工作可能涉及那些在线程仍然保持中断状态时会受到影响的操作，因此线程将使用 in terrupted方法来测试并清除自己的中断状态。
中断一个线程通常不会影响它正在执行的操作，但是像 sleep 和wait 这样会抛出 Inter ruptedException异常的方法除外。如果线程被中断的时候正在执行这些方法，那么线程将
会抛出 InterruptedException异常。这种抛出异常的中断会清除线程的中断状态，因此 In terruptedException异常的处理代码通常是这样的：
}
void tick(int count,long pauseTime){
try {
for(int i=0;i<count;i++)f
System.out.println('.'
System.out.flush(O);
Thread.s]eep(pauseTime)
}
} catch(InterruptedException e){
Thread.currentThreadO.interruptO:
}·
tick方法每隔 pauseTime微秒就打印一个句点，总共打印 count次——更好的实现方式见
22.7节“Timer和TimerTask”。如果正在运行tick 的线程被中断，sleep将抛出Interrupt-
365
366
367
250 第14章 线 程
edException异常，滴嗒操作将随后终止，catch子句将再次中断线程。我们也可以把 tick
声明成可抛出InterruptedException异常的，并且直接把异常向上传播，但这样会使 tick
的每个调用者都必须处理相同的可能发生的情况。再次中断线程允许tick 清除自己的行为，
然后让其他代码按照其通常的方式来处理中断。
大体上，任何执行阻塞操作的方法(不管是直接的还是间接的)都应该允许通过interrupt
来取消阻塞操作，并且应该在出现这种情况时抛出相应的异常，这就是sleep和wait所做的
事情。在某些系统中，阻塞的I/O操作将抛出InterruptedIOException异常来响应中断，该
异常是大多数I/O方法将抛出的IOException异常的子类，更多的关于I/O的内容见第20章。
即使中断在VO操作期间无法被响应，系统也可能会在操作开始时检测中断并抛出异常，因此，
如果被中断的线程需要在清除过程中执行VO操作，那么它必须清除自己的中断状态。但是一
般而言，我们不能假设interrupt 将解除一个正在执行VO操作的线程的阻塞状态。
在某个线程中运行的所有类的所有方法，除了这些方法定义的行为之外，通常关心的是所
属对象的状态，而不是正在执行方法的线程的状态。既然如此，我们怎样来编写允许线程响应
中断并且可被取消的方法呢?如果我们的方法可以阻塞，那么它应该像刚才讨论的那样来响应
中断。否则，我们必须决定什么样的中断或者取消对我们的方法来说是有意义的，并使这部分
行为成为该方法契约的一部分——在绝大多数情况下，方法自身根本不需要关心中断。然而，
最重要的规则是不要通过显式地清除中断或者捕获 InterruptedException异常并继续执行
代码来隐藏中断，因为这些做法在执行代码时将阻止任何线程被取消。
中断机制是协作代码可以加以利用以使得多线程更加有效的工具。但是，它和其他任何机
制都不能处理含有敌意或者恶意的代码。
14.8.2 等待线程结束
一个线程可以使用某种形式的 join方法来等待另一个线程终止，其中最简单的形式是一
直等待某个特定线程结束：
class CalcThread extends Thread {
private double result;
public void run(){
result = calculate(); }
public double getResult(){
return result;
}
public double calculateO{
// ...calculate a value for "result"
}
}
class ShowJoin {
public static void main(String[] args){
CalcThread calc = new CalcThreadO:
calc.start();
doSomethingElse();
try {
14.9 结束应用程序的执行 251
ca1c.joinO);
System.out.print1n("result is "
+ ca1c.getResultO);
} catch(InterruptedException e){
System.out.println("No answer:interrupted");
}
}
// ... definition of doSomethingE1se ...
}
上面的程序首先定义了一个新的线程类型CalcThread,用来计算结果。我们先启动了一个
calcThread,然后执行了一些其他操作，接着加入(join)到这个线程中。当join返回时，我
们可以肯定calcThread.run 已经完成并且 result已经被设置。如果CalcThread在do SomethingElse结束时已经完成，join就立刻返回，这是因为当线程消亡时，它的 Thread 对
象并不会随之消亡，因此我们仍然可以访问它的状态，所以并不要求我们必须在线程可终止之
前加入它。
join的另外两种形式可以接受与wait类似的超时，下面是join的所有三种形式：
·public final void join(long millis)
throws InterruptedException:等待这个线程结束或者等待指定的毫秒数，这两个事 368
件哪个先发生都可以。超时设为0毫秒意味着要一直等待。如果线程在等待过程中被中
断，我们将得到InterruptedException异常。
· public final void join(long millis,int nanos)
throws InterruptedException:用更精确的计时时间来等待这个线程结束。总的超
时时间为0纳秒还是意味着一直等待。纳秒的范围是0~999999。
· public final void joinOthrows InterruptedException:等价于join(0)。
在内部，join是根据 isAlive来定义的，它的行为使得在逻辑上可以认为它被编写成了下面
这样的形式：
while(isAlive())
waitO;
其中我们要理解的是，当线程实际终止时，运行时系统将调用 notifyA11。
14.9 结束应用程序的执行
每个应用都是从执行 main的线程开始的。如果应用程序没有创建任何其他的线程，那么
当main返回时应用程序就结束了。但是如果应用程序创建了其他线程，那么在main返回时会
发生什么呢?
线程分为两种：用户线程和守护线程。用户线程的存在可以使应用程序保持运行状态，而
守护线程则不会。当最后一个用户线程结束时，所有守护线程都会被终止，应用程序也随之结
束。守护线程的终止很像调用 destroy所产生的终止，即事发突然而且没有机会做任何清除，
因此守护线程仅限于执行它们可以执行的操作。使用 setDaemon(true)方法可以把线程标记
为守护线程，可以使用isDaemon来测试这个标志。在默认情况下，线程的守护状态继承自创
建它的线程，并且不能在线程启动之后被改变；否则，就会抛出IllegalThreadstateExcep tion。
如果main方法创建了一个线程，那么该线程就继承了初始线程的用户线程状态。当main
结束时，应用程序将继续运行直到main创建出来的这个线程结束。初始线程并没有什么特殊
369
370
252 第14章 线 程
之处，它只是应用程序在某次运行中第一个启动的线程而已，对它的处理和对其他用户线程的
处理是一样的，应用程序将一直运行到所有用户线程结束。运行时系统所了解的仅仅是，初始
线程被设计用来创建另一个线程，让其执行实际的工作，之后初始线程就消亡了。如果我们希
望应用程序在初始线程消亡后就退出，那么可以把所有创建出来的线程都标记为守护线程。
我们可以通过调用 System或者Runtime的exit方法来强制应用程序结束，这个方法将
终止Java 虚拟机的当前执行过程，也就像对每个线程调用了destroy一样。然而，应用程序可
以安装在其关闭之前运行的特殊线程，用于这个目的的方法将在23.3节“关闭”中详细介绍。
许多类会隐式地在应用程序中创建线程。例如，将要在第25章中简要介绍的抽象窗口工
具集(Abstract Window Toolkit,AWT)提供了基于事件的图形化用户界面，并创建了特殊线程来
处理所有相关的事件。类似地，也是在第25章中提到的远程方法调用(Remote Method Invoca tion)也创建了用来响应远程方法调用的线程。这些线程中有些是守护线程，而另一些则不是，
因此使用这些类可能会使我们的应用程序比预期的运行时间要长。在这些情况下，如果没有其
他方法可以终止线程，使用exit方法就显得很必要了。
14.10 内存模型：同步和 volatile
任何被不同线程所共享的可变的(即可修改的)值都应该总是被同步地访问以防止发生干
扰。然而，同步是需要代价的，并且并非总是需要使用同步来防止干扰。Java语言可以保证对
任何变量(long或 double类型的除外)的读写都是原子性的，这样变量就只会持有某个线程
写入的值，而决不会持有两个不同线程写入的部分交叉混合的值。这意味着，原子变量只能由
一个线程来写，多个线程来读，因此不需要对它的访问进行同步以防止数据被损坏，因为这些
访问之间不存在互相干扰的可能性。但这对获取一修改—设置序列(比如++操作)没有任何
帮助，这种操作始终需要同步。
原子访问并不能保证线程总是会读取变量最近的写入值。事实上，如果没有同步，一个线
程写入的值对另一个线程来说可能永远都不会是可见的，有很多因素都会影响一个线程写入的
变量何时会对另一个线程变为可见的。现代的多进程硬件可以执行某些非常奇怪的操作，在这
些操作中共享内存将得到更新，与运行时动态编译环境所作的操作类似。此外，当缺乏同步机
制时，不同的线程发现被更新变量的顺序也可以完全不同。对程序员来说，这些事情不仅奇怪，
而且经常看起来毫无道理，同时又总是程序员所不期望的。在确定内存访问如何排序以及何时
可以确保它们可见时所使用的规则被称为Java编程语言的内存模型。
线程的动作是由它所执行的方法中的语句的语义来决定的。在逻辑上，这些语句都是按语
句书写的顺序即程序顺序来执行的，然而，线程读取的所有变量的值都是由内存模型来决定的，
因为内存模型定义了变量被读取时允许返回的值集合。在这种上下文中，变量只包含字段(包
括静态的和非静态的)和数组元素。从程序员的角度看，这个值集合应该只包含单一的值：由某
线程最近写入的值。然而，正如我们所看到的，在缺乏正确的同步时，实际获得的值集合可能
包含许多不同的值。
例如，假设有一个字段currentvalue,可以被图形线程不断地显示，并且可以由其他线程
使用非同步的方法对其进行修改：
public void updateCurrent(){
currentValue =(int)Math.random();
}
14.10 内存模型：同步和 volatile 253
显示代码可能与下面的代码类似：
currentValue=5;
for(;;){
display.showValue(currentValue);
Thread.sleep(1000);// wait 1 second
}
当第一次进入循环时(假设没有其他线程调用过updatecurrent),currentvalue唯一可能的
值是5。然而，由于没有使用任何同步，所以每当有线程调用 updateCurrent时，都会有新值
被添加到所要读取的可能值集合中。当在循环中读取 currentvalue时，可能值也许已经包括
了5、25、42和326,其中任何一个值都可以通过读取操作返回，因为根据内存模型的规则，任何
被某个线程写入的值(但不是一些“无中生有”的值)都可以通过读取操作返回。实际上，如果
showValue无法改变 currentvalue的值，那么编译器就会假设它可以认为currentvalue在
循环体内并未发生改变、从而在每次调用 showvalue时直接使用常量5来表示 currentval ue。这种策略和内存模型是一致的，因为5是其中的可用值之一、而且内存模型并没有控制要
返回哪个值。为了让程序能像我们所描述的那样运行，我们必须作些事情，以使得在写入 cur rentvalue时，写入的值可以成为内存模型唯一允许读取的值。要做到这一点，就必须对写入
和读取变量的操作进行同步。
14.10.1 同步动作
线程执行的某些动作被定义为同步动作(synchronization action),这些动作被执行的顺序在
术语上被称为程序的同步顺序(synchronization order),它与程序的执行顺序是一致的。这些同
步动作会对变量的读取和写入进行同步。
最常见的同步动作就是使用同步方法和阻塞来保证独占地访问共享变量，其中监视器锁的
释放会与随后所有该监视器锁的获取和释放进行同步。如果所有读写变量的操作都只在持有特
定的监视器锁时才会发生。那么内存模型将保证每个读取变量的操作所返回的值都是最近写入
的值。
还有第二种同步机制，它并不提供对监视器的独占访问、但它同样可以确保对变量的每一
个读取操作都能返回最近写人的值、这种机制就是使用 volatile 变量。字段(但不是数组元素)
可以用修饰符 volatile来声明，volatile变量的写入操作将与随后所有这个变量的读取操作进
行同步。如果 currentvalue 被声明为 volatile,那么我们所给出的示例代码就会被正确地同
步，并且总是会显示最新的值。使用 volatile变量很少能够替代在这个变量上使用同步方法或者
同步语句的做法、因为 volatile变量并没有提供可以跨多个动作的原子性。更恰当地说.volatile
变量经常被用作简单的标记以表示发生了某个事件，或者被用来编写无锁(lock -free)算法，这
种算法将25.9.1节中提到的原子变量的用法合并到了一起。
将变量设置为 volatile所产生的另一个效果就是可以确保读写操作都是原子性的，这就把基
本的原子性保障扩展到了可以覆盖long 和 double类型变量的程度。
还有一些其他的同步动作也有助于使多线程工作得很好：
·在执行线程时，将线程的启动与该线程要执行的第一个动作进行同步，这样可以确保新
启动的线程可以看到由创建它的线程初始化的所有数据，包括该线程自己的域。
·将线程最后执行的动作与所有侦测该线程是否已经终止的动作(诸如调用isAlive 或在
该线程上调用 join这类动作)进行同步，这样可以确保类似这样的情况：在加入线程时
可以看到该线程在终止之前所写入的全部数据，诸如该线程运算的结果。
371
372
373
254 第14章 线 程
·将中断线程的操作与其他所有判断该线程是否已经被中断的动作进行同步，例如与线程
抛出InterruptedException异常或另一个线程在该线程上调用 isInterrupted 这类
动作进行同步。
·将对任何字段写入默认值(0、null 或者false)的操作与所有线程的第一个动作进行同步。
这样可以确保即使在未能正确同步的程序中，线程也不会看到字段中(未写入默认值之
前)的随机值，它只会看到某线程写入的特定值或字段的默认值。
14.10.2 final字段和安全
2.2.3节介绍了如何使用final字段来定义不可变的值；我们也确实可以使用final字段来定
义不可变的对象，但是在我们的脑子中很容易产生一种常见的误解，那就是对不可变对象的共
享访问并不需要任何同步，因为这种对象的状态永远都不会改变。之所以有这种误解是因为我
们做了这样的假设：我们总是能够保证线程看到的是不可变对象初始化之后的状态，但事实并
非如此。问题在于虽然共享对象是不可变的，但是用来访问共享对象的引用自身是共享的，并
且经常是可变的，因此，正确同步的程序必须同步对这个共享引用的访问，但是程序经常无法
做到这一点，因为程序员并没有意识到需要这么做。例如，假设一个线程创建了一个 String
对象，并在一个静态域中存储了对它的引用，而第二个线程随后用这个引用来访问该字符串。
基于迄今为止我们所讨论的内容可知，我们无法保证在第一个线程构造该字符串时写入的值会
被第二个线程在访问该字符串时看到。
内存模型定义了针对多线程程序的语义，并告知程序员需要怎么做才能正确地同步编写出
来的程序。但是，我们还需要某些措施来确保未能正确同步的程序也不会违反 Java语言的完整
性、虚拟机的实现或者防止敏感的 API被误用的安全架构(见23.5节“安全”)。这些措施以附
加规则的形式添加到了内存模型中，从而使内存模型覆盖了对final 字段的使用。
有关 final字段的第一项规则覆盖了我们所描述的共享字符串的情况。基本上，这项规则规
定如果在对象被构造之后保存对这个对象的引用，那么必须确保任何读取这个引用的线程所看
到的该对象的 final字段都是初始化之后的值。请注意，对于对象的非 final字段，无法保证它们
在没有同步的情况下被读到的是初始化之后的值。
第二个规则将第一个规则扩展为可以传递性地应用到通过 final字段可达的对象上。如果
不能保证对象的final字段一定能被看到，那么保证能看到存储在final字段中的引用就没有什
么实际意义了。概括起来，第二个规则所规定的就是如果从 final 字段读取引用，那么被引用对
象的任何非 final字段所具有的值至少是在该引用被写入时所具有的值。例如，这意味着如果一
个线程构造了一个对象，并使用这个对象上的方法设置了它的状态，如果用于访问这个对象的
引用是在该对象的状态被修改之后写入到 final字段中的，那么随后第二个线程将看到这个由第
一个线程所设置的状态。
为了保持系统的完整性，类必须在没有正确的同步可依赖的情况下使用 final 字段来适当地
保护敏感数据。正是由于这个原因，String类在内部使用的是final字段，因此 String值不仅
是不可变的，而且保证一定是可见的。
14.10.3“之前发生”关系
上面所介绍的同步动作是对内存模型运行的一种简化。使用同步语句块、同步方法以及
volatile变量可以为 volatile变量自身和在同步语句块中被访问的变量之外的变量提供读写保证。
这些同步动作建立了所谓的“之前发生(happens-before)”关系，正是这种关系确定了读取
14.11 线程管理、线程安全和 ThreadGroup 255
变量时应该返回何值。“之前发生”关系是传递性的，如果按程序顺序一条语句在另一条语句之
前发生，那么这条语句与第二个语句之间就存在着“之前发生”关系，这样就使得除同步动作之
外的动作在线程之间也变成了同步的。例如，如果某个非 volatile变量是在某个 volatile变量之
前被写入的，而在另一个线程中，这个 volatile变量是在读取那个非 volatile变量之前被读取的，
那么对非 volatile变量的写操作就发生在读取该变量之前，因此可以确保读操作返回的是写入的
值。请考虑如图14-6所示的情形：
static Data data; static volatile boolean dataReady;
线程1
data = new DataO;
dataReady = true; 线程2
图 14-6
if(dataReady){
Data d= data;
// process new data }
如果线程2读到的 dataReady的值为 true,那么线程1对dataReady 的写操作就发生在读操
作之前。因为线程1写 data的操作发生在线程1写dataReady 之前，所以由此可知它也发生
在线程2读dataReady 之前，因此也就发生在线程2读data 之前。简言之，如果线程2发现
dataReady为真，那么就可以确保它看到的是线程1创建的新的 Data 对象。之所以这样是因
为dataReady 是 volatile变量',但即使data本身不是 volatile变量，这也是成立的。
最后请注意，指令和内存访问的实际执行顺序可以是任意的，只要线程的动作使得该线程
看起来就像是遵循了程序顺序，并且内存模型已经考虑了所有要读取的值。这就使得程序员可
以完全理解他们所编写的程序的语义，并且使得编译器的编写者和虚拟机的实现者可以去执行
简单的内存模型做不到的综合优化。
本节让我们对内存模型是如何与多线程进行交互的有了一个概念。关于内存模型的完整介
绍已经超出了本书的范围，幸运的是，如果我们使用本书中的工具来实现简单的加锁策略.那
么精妙的内存模型就可以为我们提供帮助，使我们的代码运行良好。
14.11 线程管理、线程安全和 ThreadGroup
在编写多线程程序的时候——其中有些线程是由库类创建的——如果把这些线程组织成相
关的线程组，然后将线程组作为单元来管理，并且在必要时对不同线程组的线程能够执行的操
作加以限制，那无疑是很有用的。
出于管理和安全方面的考虑，线程被组织成线程组。一个线程组可以包含在另一个线程组
中，从而形成一个源自顶级或系统线程组的层次结构。线程组中的线程可以作为单元来管理，
例如，立刻中断线程组中的所有线程，或者对线程组中的线程所具有的优先级设置上限。线程
组还可以用来定义安全域，线程组内的线程通常可以修改组内的其他线程，包括该线程组下层
的任何线程。“修改”在这里是指调用任何可能影响线程行为的方法.比如改变线程的优先级或
1.如果 dataReady不是 volatile变量而其对应的get和set方法是同步的，那么上述的结论也是成立的。
374
|375
376
256 第14章 线 程
者中断线程。但是，应用可以定义某种安全策略来防止线程被它所属的组外的线程所修改。不
同线程组中的线程也可以被授予不同的在应用中执行动作的权限，例如执行VO操作的权限。
一般来说，对安全敏感的方法在执行前总是要检查所有已经安装的安全管理器，如果安全
策略禁止执行这个动作，那么这个方法就会抛出 SecurityException异常。在默认情况下，
应用程序启动时是不安装任何安全管理器的。但是，如果我们的代码是在另一个应用程序上下
文中执行的，例如在浏览器中执行 applet,那么我们就可以十分肯定该应用程序已经安装了安全
管理器。诸如创建线程、控制线程、执行I/O操作或者终止应用程序这类动作都是安全敏感的。
更多的详细内容见23.5节的“安全”。
每一个线程都属于一个线程组，而每一个线程组又都是由一个 ThreadGroup 对象来表示
的，这个对象描述了对组内线程的限制并允许以组为单位与组内线程进行交互。通过将线程组
传递给线程的构造器，我们可以为新线程指定线程组。在默认情况下，每个新线程都会被置于
和创建它的线程相同的线程组中，除非安全管理器指定不同的线程组。例如，如果 applet 中的
某个事件处理代码创建了新线程，那么安全管理器就会使新线程成为applet 线程组的一部分，
而不会把它置于事件处理线程所在的系统线程组中。当线程终止时，它所对应的 Thread 对象
会被移出所在的线程组，因此如果不存在对该对象的其他引用，那么它将被当作垃圾回收。
有四种 Thread构造器可以指定线程的ThreadGroup。在14.2节Runnable中已经介绍了
其中的三种，第四种是：
·public Thread(ThreadGroup group,String name):在指定的线程组中用给定的名
字构造一个新线程。
为了防止可以在任意的线程组中创建线程(这将违反安全策略),当不允许当前线程在指定
的线程组中放置线程时，这些构造器自身将抛出 SecurityException异常。
线程在创建后就不可以再改变与之相关联的 ThreadGroup 对象。我们可以调用线程的
getThreadGroup方法来获得与其相关联的线程组，当然，我们也可以调用 Thread的check Access方法来检查我们是否可以对 Thread 进行修改，如果不可以，则会抛出 SecurityEx ception异常；如果可以，则会直接返回(这是一个 void方法)。
线程组可以是守护组(daemon group),它与守护线程的概念没有任何联系。当守护 Thre adGroup变为空时，它会自动销毁。把 ThreadGroup 设置为守护组并不会对包含在这个组中
的线程或子组是否是守护的产生影响，它只会对组为空时发生的事情产生影响。
线程组也可以用来对其所包含的线程的优先级设置上限。在调用 setMaxPriority为线程
组设置完优先级上限之后，任何试图把线程的优先级设置得高于它所在线程组的优先级上限的
操作，都会自动地把线程的优先级降至这个上限。这个方法调用不会影响已有的线程，因此.
为了确保线程组内没有任何其他的线程高于某个特殊线程的优先级，可以在设置完该特定线程
的优先级之后，把线程组的优先级设置得比它低。这种限制也适用于线程组本身，任何试图把
线程组新的优先级上限设置为高于当前的优先级上限的操作，都会自动地将其降至当前的优先
级上限。
static synchronized void
maxThread(Thread thr,int priority)
{
ThreadGroup grp = thr.getThreadGroupO);
thr.setPriority(priority);
grp.setMaxPriority(thr.getPriority()-1);
}
14.11 线程管理、线程安全和 ThreadGroup 257
上面的方法首先把某个线程的优先级设置成了所期望的值，然后又设置了比该线程的优先
级低的线程组的优先级上限。线程组新的优先级上限被设置成比该线程的实际优先级低一级，
注意，不是priority-1,因为现有的线程组上限可能会限制我们将线程优先级设置成这种级
别的能力。当然，该方法是在这里假设线程组中没有任何其优先级比它更高的线程。
ThreadGroup 支持下列构造器和方法：
·public ThreadGroup(String name):用于创建新的 ThreadGroup。它的父线程组是
当前线程所在的ThreadGroup。与Thread的名字一样，线程组的名字并不会被运行时
系统所使用，但是它可以为 nul1。
·public ThreadGroup(ThreadGroup parent,String name):用于在名为parent的
ThreadGroup内创建具有指定name 的新的 ThreadGroup。如果parent为nul1将抛
出 Nu11PointerException异常。
· public final String getNameO:用于返回 ThreadGroup的名字。
·public final ThreadGroup getParentO:用于返回父线程组的 ThreadGroup 对象，
或者如果线程组无父线程组，则返回 null(只有在顶级线程组上调用该方法时才会发生
这种情况)。
·public final void setDaemon(boolean daemon):用于设置线程组的守护状态。
· public final boolean isDaemonO:用于返回线程组的守护状态。
·public final void setMaxPriority(int maxPri):用于设置线程组的优先级上限。
·public final int getMaxPriorityO:用于获取线程组当前的优先级上限。
· public final boolean parentof(ThreadGroup g):用于检查线程组是否是g线程组
的父线程组或线程组g本身。把本身理解为“部分”可能会更好一些，因为线程组就是它
自身的一部分。
·public final void checkAccessO:如果不允许当前线程修改该线程组，将抛出Se curityException异常，否则直接返回。
· public final void destroy():用于销毁线程组。要销毁的线程组不能包含任何线
程，否则该方法将抛出IllegalThreadstateException异常。如果该线程组包括其他
线程组，那么它们也必须为空。这个方法不会销毁线程组中的线程。
我们可以使用两个并列的方法集来检查线程组的内容：其中一个方法集用于获取包
含在线程组中的线程，而另一个方法集用于获得包含在线程组中的线程组。
· publicint activeCountO):用于返回该组内活动线程的估计数量，包括子线程组含有
的线程。之所以称为估计数量是因为在方法调用者获得这个值的同时它可能已经过期
了。在调用 activecount的期间或之后，有的线程可能已经消亡，而新的线程可能已经
被创建了。活动线程是指 isAlive方法返回为 true的线程。
·public int enumerate(Thread[] threadsInGroup,boolean recurse):用对线程
组中每个活动线程的引用填充 threadsInGroup数组，直到填满为止，并返回所存储的
线程数。如果 recurse为false,则只有直接属于该线程组的线程包含在内，否则会把线
程组层次结构中的所有线程都包含在内。ThreadGroup.enumerate可以让我们去控制是
否进行递归，而ThreadGroup.activeCount 则不可以。我们可以对要存储递归枚举结果
的数组的长度做出合理的估计，但对非递归的 enumerate,我们的估计值则往往会过大。
· public int enumerate(Thread [] threadsInGroup):等价于 enumerate(threadsIn Group, true)。
377
378
379
258 第14章 线 程
·public int activeGroupcountO:该方法与activeCount类似，但是返回的是所有
子线程组中的活动线程组数目而不是活动线程的数量。这里的“活动”表示“存在”,并没
有与之对应的“非活动”组的概念；使用术语“活动”是为了和activecount 保存一致。
· public int enumerate(ThreadGroup[] groupsInGroup,boolean recurse):该方
法与枚举线程的 enumerate方法类似，但是它向数组中填充的是对 ThreadGroup的引
用，而不是对 Thread的引用。
· public int enumerate(ThreadGroup [] groupsInGroup):等价于enumerate
(groupsInGroup,true)。
我们还可以用ThreadGroup来管理线程组中的线程。在线程组上调用interrupt
将会导致在该线程组的每一个线程上调用 interrupt方法，包括所有子线程组中的线
程。这是使用 ThreadGroup来直接影响线程的唯一方式，曾经还有过其他方式，但是现
在它们都被弃用了。
在 Thread类中还有两个静态方法可以作用于当前的线程组，它们是先调用cur rentThread,再在得到的线程上调用getThreadGroup 方法，然后在得到的线程组上
调用方法的快捷方式。
·public static int activeCountO:用于返回当前线程的 ThreadGroup 中活动线程
的数量。
·public static int enumerate(Thread[] threadsInGroup):等价于在当前线程的
ThreadGroup上调用enumerate(threadsInGroup)方法。
ThreadGroup类还有一个在因未捕获异常而导致线程消亡时调用的方法：
·public void uncaughtException(Thread thr, Throwable exc):我们将在下一节中
详细介绍这个方法。
练习14.9:编写一个方法，用于接受一个线程组并启动一个线程，这个线程使用上述的方
法周期性地打印该线程组中的线程和线程组的层次结构。编写一个在不同的线程组中创建数个
短暂存活线程的程序，用它来测试这个方法。
14.12 线程和异常
异常总是因线程的动作而发生在特定的线程中，例如，试图执行除0操作，或者显式地抛
出异常。这类异常是同步异常，并且始终保留在线程中。如果“父”线程想知道“子”线程为何终
止，那么子线程就必须把相关的信息存储到“父”进程能够获取的某个地方。把对线程的 start
方法的调用放置在 try-catch 块中并不能捕获新线程可能抛出的异常，这样只能直接捕获
start抛出的所有异常。
抛出异常会导致语句的执行突然结束，并会沿调用栈向上传播，使得其中的所有方法都突
然结束。如果异常不能在run方法突然结束时被捕获，那么根据定义，它就是未捕获异常(un caught exception)。在这种情况下，因为发生异常的线程已经被终止，所以异常也就不复存在了。
但是由于未捕获异常通常是严重错误的标志，所以我们需要以某种方式来对它们进行跟踪。为
了实现这个目的，每个线程都可以与一个 UncaughtExceptionHandler实例关联起来。Un caughtExceptionHandler接口是Thread类的嵌套接口，它只声明了一个方法：
·public void uncaughtException(Thread thr, Throwable exc):在 thr线程因抛
出 exc而终止时，会调用该方法。
如果安全许可允许，那么我们可以使用线程的 setUncaughtExceptionHandler方法来设
14.12 线程和异常 259
置其未捕获异常处理器。
当线程因为未捕获异常而要被终止时，运行时系统会将该线程和异常作为参数传递，用来
在该线程上调用getuncaughtExceptionHandler方法，目的是向线程查询其未捕获异常处理
器，并在返回的处理器上调用uncaughtException方法。
getuncaughtExceptionHandler方法将返回由线程的 setuncaughtExceptionHandler
方法显式设置的处理器，或者在没有设置任何处理器的情况下返回线程的 ThreadGroup 对象。
由于线程一旦被终止，就不属于任何线程组了，因此 getuncaughtExceptionHandler 也可能
会返回nul1。
ThreadGroup的 uncaughtException方法的默认实现是：如果该线程组有父线程组，那
么就调用其父线程组上的uncaughtException。如果该线程组中没有父线程组，那么就用
Thread类的静态方法 getDefaultuncaughtExceptionHandler向系统查询默认的未捕获线
程处理器。如果存在这样的默认处理器，那么就会用抛出异常的线程和抛出的异常来调用其
uncaughtException方法。如果没有任何默认的处理器，那么 ThreadGroup的uncaughtEx ception方法将直接调用异常的printStackTrace方法来显示有关所发生异常的信息(如果
该异常是ThreadDeath的实例，那么就不会发生更多的事情)。
对于由应用程序创建的线程和由应用程序所使用的库创建的线程，应用程序都可以按三个
级别来控制未捕获异常的处理：
·按系统级别，通过使用 Thread类的静态方法 setDefaultuncaughtException
Handler设置默认处理器来控制。对这项操作要进行安全性检测，以确保应用程序允许
执行这个的控制。
·按线程组级别，通过扩展ThreadGroup并覆盖其中的 uncaughtException的定义来控
制。
·按线程级别，通过在线程上调用 setuncaughtExceptionHandler来控制。
例如，如果我们正在编写基于图形环境的程序，那么可能会希望在窗口中显示栈轨迹而不
是直接把它输出到System.err,其中 system.err 就是printStackTrace方法打印输出其结
果的地方。我们可以定义自己的 UncaughtExceptionHandler来实现uncaughtException,
以创建所需要的窗口，并把栈轨迹重定向到这个窗口中。
14.12.1 不要使用stop
我们在第12章中提到了两种形式的异步异常，它们被定义为Java 虚拟机中的内部错误，还
提到了因调用被弃用的 Thread.stop方法而产生的异常。
一般来说，我们不在本书中讨论被弃用的方法，但是stop是个例外，部分是因为它的功
能，但主要还是因为它如大家所说的，是“外在的”,我们很可能会碰到使用它的代码(或试图使
用它的代码)。
stop方法会导致在其上调用它的线程抛出异步的 ThreadDeath异常。这个异常没有任何
特殊之处，和其他任何异常一样都可以被捕获，并且在没有被捕获时将一直向上传播直到线程
终止。该异常可以在线程运行过程中的几乎任何时刻发生，但是不包括尝试着获取对象锁的时
刻。
stop的目的是强制线程以受控的方式终止，它通过抛出不可能被捕获的异常，使得使用
finally子句的正常清除过程可以随着线程调用栈的展开而执行清除。但是在以下两种情况
中，stop做不到这一点：首先，它不能强制终止任何线程，因为线程可能会捕获抛出的异
380
260 第14章 线 程
常然后忽略它，因此 stop无力对付恶意代码。其次，与其说它允许受控的清除，不如说
实际上它允许破坏对象。如果在线程处于临界区时调用 stop,同步锁将随着异常的传递
而被释放，但由于在临界区上的操作只是部分完成了，所以此时对象可能已经处于被破坏
的状态了。基于上述这些严重的缺陷，应该弃用 stop方法，转而使用 interrupt来实现
381 线程动作的协作取消。
stop的第二种形式可以接受任何 Throwable对象作为其引元，并将其作为目标线程抛出
的异常，这将会隐藏更加严重的缺陷，因为它使得“不可能出现”的受检查异常从未声明它们的
代码中抛出。
14.12.2 栈轨迹
我们可以查询任何活动线程当前执行过程的栈轨迹。getStackTrace方法将返回一个在
12.6节“栈轨迹”中详细介绍的 StackTraceElement 对象的数组，其中第0个元素表示线程当
前正在执行的方法。如果线程不是活动的，那么将返回长度为0的数组。
我们可以使用 Thread类的静态方法getA11StackTraces来访问系统中所有线程的栈轨
迹，这个方法将返回一个映射表，把线程及其相应的 StackTraceElement数组匹配起来。
栈轨迹信息通常被用于调试和监控目的，例如，如果应用程序被“挂起”了，那么监控线程
可能会显示所有的栈轨迹，以展示每个线程正在做什么。当然，如果应用程序是因为代码中
的错误而挂起的，那么任何这样的监控线程自身可能都没有机会执行。我们并不要求虚拟
机为任何给定的线程都提供长度不为0的栈轨迹，我们同样也允许在栈轨迹信息中剔除某
些方法。
14.13 ThreadLocal变量
ThreadLocal类使得我们可以拥有这样一个单一的逻辑变量：它在每个单独的线程中都具
有独立的值。每个 ThreadLocal对象都有set方法，可以用它来设置当前线程中该变量的值；
它们还有get方法，可以返回当前线程中该局部变量的值。这就像是在每个线程类中都定义了
一个新域，但是却不需要实际改变任何线程类一样。这是一种我们可能并不会用到的特性，但
是如果我们确实需要使用它，那么 ThreadLocal也确实可以简化我们的工作。
例如，我们可能希望用户对象在每个线程的基础上与所有操作相关联，这时我们可以创建
ThreadLocal 对象来保存每个线程当前的用户对象： 382
public class Operations {
private static ThreadLoca1<User> users =
new ThreadLocal<User>(){
/** Initially start as the "unknown user".*/
protected User initialValue(){
return User.UNKNOWN_USER;
}
};
private static User currentUser(){
return users.get();
}
14.14 调试线程 261
public static void setUser(User newUser){
users.set(newUser);
}
public void setValue(int newValue){
User user= currentUser();
if(!canChange(user))
throw new SecurityException();
// ...modify the value ...
}
// ...
}
静态字段 users 保存了一个 ThreadLocal变量，它在每个线程中的初始值都是User.UN KNOWN_USER。这个初始值是通过覆盖initialvalue方法来定义的，其中该方法的默认行为
是返回nul1。程序员通过调用 setuser方法可以为给定的线程设置 user,一旦经过设置，当
在该线程中调用currentuser方法时就会返回所设置的值。正如在 setValue方法中所展示
的那样，当前用户可用于确定其待遇。
调用 remove方法可以清除 ThreadLocal中的值，如果清除后再次调用get方法，ini tialvalue方法将会再次被用来确定要返回什么值。
当线程消亡时，ThreadLocal变量中为该线程所设置的值就不可达了，并且如果没有对这
个值的其他引用，那么这个值将被当作垃圾回收。
当我们创建新线程时，这个线程所对应的 ThreadLocal变量的值就是它的 initialvalue
方法返回的值。如果我们希望新线程中的这个值是从创建它的线程中继承而来，那么我们可以
使用InheritableThreadLocal类，它是ThreadLocal的子类。该类有一个受保护的方法
childvalue,调用它可以获得其子线程(被创建线程)的初始值，传递给这个方法的是父线程
中该变量的值，而该方法返回的是要传递给子线程的值。childvalue的默认实现返回的是父
线程的值，但是我们可以通过子类化来实现其他的操作，例如把父线程的值克隆给子线程。
使用 ThreadLocal 对象是一种本质上存在风险的工具。因此，应该在完全理解将要使用
的线程模型之后，再去使用 ThreadLocal对象。这引出了线程池(thread pooling)问题，线程池
是一种线程重用技术，有了线程池就不必为每个任务都创建新的线程。在线程池系统中，一个
线程可能会多次使用。用于这种环境的任何ThreadLocal对象包含的都是最后使用该线程的
代码所设置的状态，而不是在开始执行新线程时所具有的未被初始化的状态。因此，如果我们
编写了一个使用 ThreadLocal对象的通用类，而别人又在线程池中使用了这个类，那么其行为
就可能会产生致命的错误。
例如，在上面的Operations 例子中，如果在多线程中使用Operations 对象，或者在同一
个线程中使用不同的operations 对象，那么 users变量就具有这个问题，“当前用户”这个概
念就很容易出错。使用Operations 对象的程序员必须明白这一点，并且只有在符合该类代码
所假设的线程环境中才可以使用该对象。
14.14 调试线程
设计用来帮助我们调试多线程应用的 Thread方法很少，这些具有打印风格的辅助调试方
法可以打印出应用程序的状态。在Thread 对象上调用下列方法可以帮助我们调试所编写的线
383
384
385
262 第14章 线 程
程：
· public String tostringO:用于返回线程的字符串表示，包括其名字、优先级和所属
线程组的名字。
· public long getIdO:用于返回一个正值，它在该线程处于活动状态时唯一地标识该
线程。
·public Thread.State getStateO:用于返回该线程的当前状态。Thread.state是
一个嵌套的枚举类，它定义了如下的常量：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_
WAITING和TERMINATED。新创建的线程在被启动之前所具有的状态是NEW,在被启动
之后会变成RUNNABLE,直到被终止时才变为TERMINATED。尽管线程是可运行的，但是
在它被终止之前，其状态可以在 RUNNABLE和 BLOCKED(例如在等待获取监控锁时)、
WAITING(已经被调用了 wait方法)或者TIMED_WAITING(已经被调用了wait的计时
版本)之间进行切换。
·public static void dumpStackO:用于在System.err上打印当前线程的栈轨迹。
还有一些可以跟踪线程组状态的辅助调试方法，我们可以在 ThreadGroup 对象上调用下列方
法来打印它们的状态：
·public string tostringO:用于返回 ThreadGroup的字符串表示，包括其名字和优
先级。
·public void listO):在System.out 上递归地列出这个 ThreadGroup。它将打印这
个组内每个线程和线程组的 tostring方法的返回值。
我先演奏一遍，然后再告诉你们我演奏的是什么。
——迈尔斯·戴维斯(美国爵士乐大师)
第 15章 注 解
我不喜欢菠菜，并且很庆幸我并不喜欢，
因为如果我喜欢菠菜我就会去吃它，但我就是讨厌它。
——克拉伦斯·达罗(美国名律师)
程序的源代码通常带有大量非正式的文档，它们包含在源代码文件的注释中。例如，很多
组织都会在类的源文件顶端放置一个标准序言，其中包含版权信息、程序员名字、类的创建日
期、类的最近修改日期和当前修订版本号等内容。其他一些注释可能还可以反映出类或方法的
用途，或者使用限制，例如说明类的实例是非线程安全的，不能在并发执行的情况下使用。还
有一些注释可能是提供给外部工具进行处理的，用来辅助应用程序的管理和部署，例如源代码
管理系统中的版本控制，或者说明类该如何被应用服务器管理的部署描述符。这些基于注释的
注解都服务于某种实用的目的，但是它们都是非正式的和非正规的。还有一种更好的用来说明
这些内容的方式，那就是直接使用注解类型(annotation type)来描述注解形式，以此来为程序元
素进行注解。注解类型是以标准而结构化的方式来展现信息的，这种方式可以由工具自动地处
理。
虽然本章说明了使用注解和定义注解类型的语法和语义，但并未说明何时应该使用何种注
解，因为Java语言只有非常少量的注解。我们所使用的注解是主流的开发和部署环境中的工具
都支持的那些注解。注解的类型主要集中在java.1ang.annotation包中，本章介绍的标准
类型都出自这个包。
15.1 一个简单的注解实例
考虑下面这个非正式的、基于注解的类序言：
/*---------
Created: Jan 31 2005
Created By: James Gosling
Last Modified: Feb 9 2005
Last Modified By:Ken Arnold
3 Revision:
-*/
public class Foo {
//...
}
我们可以定义注解类型，用来保存所有需要的信息：
@interface ClassInfo {
String created();
String createdBy();
String lastModified();
String lastModifiedBy();
int revision();
}
387
388
389
264 第15章 注 解
注解类型是一种特殊的接口，是用@加上interface关键字来表示的'。注解是作用于程序元
素(program element)的，例如类和域的声明。在注解类型中看起来像是方法的东西实际上是特
殊的注解元素(annotation element)声明，注解元素与域十分相似，对于所有拥有其注解类型的程
序元素，它都有一个对应的值。因此，classInfo注解中包含了四个字符串元素和一个int元
素，当我们用它来注解(将该注解应用于)程序元素时，我们需要为其中所有的注解元素提供相
应的值。注解也是修饰符，可以出现在任何允许放置修饰符的地方。下面是一个在类 F00中使
用ClassInfo的实例：
@ClassInfo(
created ="Jan 31 2005",
createdBy ="James Gosling", 1astModified ="Feb 9 2005", lastModifiedBy="Ken Arnold",
revision= 3
)
public class Foo {
// ...
}
再次强调一下，注解是用@后面加上注解的类型名来表示的。注解元素的值是由括号内的由逗
号分隔的 name=value语句列表提供的。正如我们所看到的那样，注解可能包含很多文字信
息，很容易使实际的程序变得晦涩难懂，所以强烈推荐大家遵从这样一种固定的模式：总是在
指定其他所有修饰符之前首先指定注解，并总是将其书写在单独的行上。
要想使用ClassInfo 注解，程序员就必须在每次编辑 Foo源代码的时候，都去更新该注解
中所有发生变化的元素。这类更新可以由能够识别注解的开发工具自动实现。
15.2 注解类型
注解类型是一种特殊的接口，正如我们所看到的，它们是用关键字 interface和前缀@来
声明的。任何可以声明接口的地方都可以声明注解类型(也就是说，可以声明为顶层注解类型
或嵌套在其他类型中的注解类型),并且注解类型可以拥有的修饰符与接口相同。然而，把注解
类型刻画成接口有一点误导的意味，因为它除了沿用了一些语法和相关的使用规则之外，在正
常使用中与接口鲜有相似之处。2
在注解类型中声明的方法被称为注解类型的元素，这些元素受严格的规则约束：
·元素的类型只能是基本类型、String、枚举类型、其他注解类型、Class(或Class的某个
特定的泛型调用)和前面几种类型的数组。
·元素不能声明任何参数。
·元素不能有 throws子句。
·元素不能定义类型参数(也就是说，不能是泛型方法)。
实质上，注解类型的元素就像对象的域一样，为所有应用该注解类型的程序元素都进行了
实例化。这些域的值是由在应用注解时所给定的初始化器决定的，或者是由元素的默认值决定
的-—-如果有默认值的话。
1.先用@字符是因为它的发音是“at”:A-T,Annotation Type的缩写。
2.在运行时利用反射进行访问的情况除外，见16.2节“注解查询”。
15.2 注解类型265
我们可以通过在空参数列表后面加上关键字 default和一个合适的值来为元素指定默认
值。例如，假设我们想用主版本号和次版本号构成的对来表示修订版本号，那么可以定义如下
的注解类型，它的默认修订版本号是1.0:
@interface Revision {
int major()default 1;
int minor()default 0;
}
这些值本身必须是表达式或者字面常量(例如类字面常量),但绝不能为 nul1。
Revision注解类型可以用来注解类和接口——我们稍后会演示如何做出这种强制规定，
也可以供其他的注解类型使用，例如，我们可以用它来重新定义ClassInfo 注解类型：
@interface ClassInfo {
String created();
String createdByO;
String lastModified();
String lastModifiedBy();
Revision revision();
}
在我们首次创建 Foo类时，我们可能会使用下面这样的ClassInfo:
@ClassInfo(
created="Jan 31 2005",
createdBy ="James Gosling",
lastModified ="Jan 31 2005",
lastModifiedBy = "James Gosling",
revision = @Revision
)
public class Foo {
// ...
}
请注意注解元素的初始化表达式是如何使用注解语法的。在本例中，@ Revision用major 和
minor的默认值对 revision元素进行了初始化。当以后再次编辑 Foo时，revision元素将会被做
以相应的修改，例如：
@ClassInfo(
created = "Jan 31 2005",
createdBy ="James Gosling",
lastModified = "Feb 9 2005",
lastModifiedBy = "Ken Arnold",
revision = @Revision(major=3)
)
public class Foo {
// ...
}
上面的注解通过指定主版本号并让次版本号仍然保持默认值0,使得 revision 被更新成了3.0。
注解类型可以没有元素，在这种情况下，它被称为标记注解(marker annotation)——与标记
接口类似。例如，注解类型java.1ang.Deprecated就是一个标记注解，用来标记不应该继续
使用的程序元素。当我们使用被注解为@ Deprecated的程序元素时，编译器会发出一个警告，
在能够理解注解的开发环境中也会如此。
如果注解类型只有一个元素，那么这个元素应该命名为 value。这使得我们可以使用某些
390
391
392
266 第15章 注 解
符合语法的缩略形式，有关缩略形式的内容将会在下一节中介绍。
对于注解类型的形式还有更一步的约束，包括：注解类型可以不显式地声明它扩展自另一
个接口，但是所有注解类型都隐式地扩展自Annotation接口；注解类型也不允许是泛型；注
解类型不允许直接或间接地拥有其自身类型的元素'。
即使一个接口显式地扩展了Annotation,它也不是注解类型，而且Annotation本身就不
是注解类型。类似地，如果一个接口声明它扩展了某个注解类型，它本身也并非注解类型。扩
展或实现注解类型是毫无意义的，但是如果我们这么做了，那么该注解类型的作用也只是一个
声明了方法集合(包含继承自Annotation的方法)的普通接口。
最后，就像其他接口一样，注解类型可以声明常量和(隐式地为static的)嵌套类型。
15.3 注解元素
可以被注解的程序元素就是那些可以用修饰符来修饰的元素，包括：类型声明(类、接口、枚
举类型和注解类型)、字段声明、方法和构造器声明、本地变量声明，甚至还包括参数声明。包也
具有特殊的注解机制，我们将会在18.5节介绍。
正如所看到的那样，为了注解元素，我们需要提供所使用的注解类型的名字，并在其前面
加上@,后面加上用括号括起来的初始化器列表，该列表对应于所用注解类型的所有元素。对
于给定的程序元素，每个注解类型只能对其注解一次。
如果注解类型是一个标记注解类型，或者所有的元素都具有默认值，那么初始化器列表可
以省略。例如，我们可以把某个方法标记为已被弃用：
@ Deprecated
public void badMethodO){/* ...*/}
与此等价的是，我们也可以只指定一个空的初始化器列表：
@ Deprecated()
public void badMethodO){/* ...*/}
如果不属于上述情形，那么对于每一个没有默认值的元素，我们都必须以 name= value的
形式列出其初始化器，就像在ClassInfo的例子中看到的那样。初始化器的顺序并不重要，但
是每个元素只能出现一次。如果一个元素有默认值，那么就不需要把它列出来，但是如果我们
想用一个特定值来覆盖默认值，那么就需要把它列出来，就像在ClassInfo 中的修改注解类型
Revision的元素时所做的那样。
如果元素含有数组类型，那么它就需要用数组初始化器表达式来进行初始化。例如，用来
追踪类的缺陷订正信息的注解类型可以表示如下：
@interface BugsFixed {
String[] bugIDs();
}
这么做的意图是每当有缺陷被订正时，它的标识符就会追加到 bugIDS 初始化器列表之后。下
面是它的使用示例：
@ BugsFixed(bugIDs ={"457605","532456"})
class FoO {/* ...*/}
1.这项约束主要是为了防止出现无限递归，如果注解类型具有其自身类型的元素，且该元素具有默认值，那么这种
无限递归就有可能发生，奇怪的是，并没有类似的约束防止类的无限递归。
15.4 限制注解的适用性 267
如果数组中只有一个元素，我们就可以用缩略形式来初始化数组，即省略数组元素外面的
大括号。例如，对 Foo中修正的第一个缺陷可以注解如下：
@ BugsFixed(bugIDS ="457605")
对于像BugsFixed那样只有一个元素的注解类型，将其元素命名为 value可以使我们能
够使用额外的缩略形式：
@interface BugsFixed {
String[] value();
}
上面使用的第一个BugsFixed就可以直接写成：
@ BugsFixed({ "457605","532456"})
如果只有一个单一的初始化器表达式，那么它就会被认为是用来初始化名为value的元素的。
如果这样的元素不存在，那么我们会得到一个编译期错误。将这种缩略形式与单元素数组组合
起来，我们就可以将使用的第二个BugsFixed 改写为：
@ BugsFixed("457605")
在注解类型中，我们也可以在拥有多个元素的情况下，仍然把其中一个命名为value。如
果我们这么做了，并且其他所有元素都拥有默认值，那么我们仍然可以使用上述缩略形式来初
始化 value元素的值。然而，一旦有了多个初始化器表达式，我们就必须为每个元素显式地命
名。
最后，我们可以用注解类型来注解其本身。例如，标记注解 Documented表示的是，被其
注解的程序元素必须使它的文档注释得到处理(见第19章)。因为Documented本身也应该被
归档，所以它对自身进行了注解：
@ Documented
@ interface Documented{}
自我注解与注解类型中含有注解类型的元素完全不同——正如我们所知，后者是不允许的。
15.4 限制注解的适用性
注解类型可以出现在任何允许出现修饰符的地方，但是正如我们可以想象到的，并非每个
注解对任何程序元素都有意义—考虑一下将ClassInfo应用到方法参数的情况!通过为注
解类型添加@ Target 注解，我们可以限制它的适用性。作用于注解类型的注解称为元注解 393
(meta-annotation)。
Target 注解类型是java.1ang.annotation包中定义的为数不多的几个注解类型之一，
除非特殊指明，否则此处提到的所有注解类型都出自这个包。Target是作用于注解类型的，并
用来控制这些类型本身何时适用。它只有一个元素——枚举类型数组 ElementType,该元素遵
循前面提到的惯用法，被命名为value。ElementType描述了注解类型可以应用的不同的程序
元素，并定义了ANNOTATION_TYPE(注解类型)、CONSTRUCTOR(构造器)、METHOD(方法),
FIELD(字段)、LOCAL_VARIABLE(本地变量)、PARAMETER(参数)、PACKAGE(包)和TYPE(类型)
等常量。编译器将会检查任何作用于程序元素的注解类型，以校验其是否可以应用于这种程序
元素。
classInfo注解类型应该只应用于类型声明(类、接口、枚举类型或者注解类型),所以它应
声明为：
394
268 第15章 注 解
@Target(ElementType.TYPE)
@interface ClassInfo {
String created();
String createdBy();
String lastModified();
String lastModifiedByO;
Revision revision();
}
现在，如果我们试图将ClassInfo 注解应用于参数声明，将会得到编译期错误。
可以使用Target注解来指定多种元素类型。例如，只应用于域或本地变量的注解类型可
以注解如下：
@ Target({ ElementType.FIELD,ElementType.LOCAL_VARIABLE })
我们的Revision 注解类型也可以注解为如下形式：
@ Target(ElementType.TYPE)
以此来限定可应用它的类型声明。如果注解类型没有任何@ Targer元注解，那么它就可以应
用于任何地方。
不要将注解类型的适用性与其可访问性混为一谈。如果注解是public的，它就可以随处使
用，但是注解的适用性可能会限制它究竟能够应用于哪些程序元素。反过来，如果无法访问某
个注解，我们就无法应用它，即使我们试图将其应用于正确类型的元素也是枉然。限制注解的
适用性并不会影响在其他注解类型内部对它的使用。例如，即使 Revision 被限定为只能应用
于本地变量(这样做不是为了使其具有真正的意义，而仅仅是为了举例),也并不妨碍ClassIn fo拥有Revision类型的元素。
15.5 保存策略
注解可以服务于多种不同的目的，并且可能会针对不同的读者。我们所看到的大多数注解
都是专门供程序员阅读的，或者是针对开发工具的。其他注解，例如@ Deprecated,则是专门
供编译器读取的。在有些情况中，开发工具可能需要从类的二进制表示中抽取出注解，以确定
应用程序该如何部署。而且，有时候注解还需要在运行时进行检查。
保存策略(retention policy)与每一个注解类型都相关，它决定了注解何时能够被访问。保存
策略是由 Retentionpolicy枚举类型定义的，它使用了Retention元注解来控制。保存策略
的值有三种：
· SOURCE:注解仅存在于源文件中，在生成二进制表示时，由编译器丢弃。
· CLASS:注解保存在类的二进制表示中，但是在运行时不可用。
· RUNTIME:注解保存在类的二进制表示中，但在运行时必须通过反射机制来获取。
默认的保存策略是CLASS。无论使用何种保存策略，本地变量上的注解在二进制表示中或
在运行时都不可用，因为在二进制表示中没有存储这些信息的位置。
在运行时用来访问注解的反射方法将在16.2节讨论。实际上，对于每个被注解的元素，运
行时系统都会创建一个对象，通过它实现由注解类型定义的接口。通过调用该对象的相应方
法，我们就可以获得被注解的程序元素所对应的注解元素的值。
15.6 使用注解
注解很强大，但是它们很容易被误用。当注解的数量及冗余度已经完全淹没代码本身的时
15.6 使用注解269
候，就很容易造成注解过载(annotation-overload)。因此，应当谨慎而明智地使用注解。
注解的第二个问题在于任何人都可以定义他们自己的注解。注解的一个关键益处就是它适
于用注解处理工具或APT来进行自动分析，但是只有当我们使用的注解是通用的、标准的时，
这种自动分析才会发挥最大的功效。因此，尽管我们已经了解了可以如何定义注解，但是在实
践中，程序员很少需要定义自己的注解类型。目前只有很少的已定义的注解类型：
·元注解@ Target和@ Retention,前面已经介绍过了。
·@ Deprecated和@ Document 注解，前面也已经介绍过了。
·@ Inherited元注解，用来表示注解应该被继承。例如，如果要在 F00类中查询某个在
F00中并未出现的特定注解类型，而该注解类型具有@ Inherited元注解，那么该查询
就会继续在 Fo0的超类中查找，依此类推。
·@ override 注解，用来通知编译器该方法将要覆盖一个继承自超类的方法。如果我们
错误地对某个方法进行了重载而不是覆盖(这是个很常见的错误),该注解类型将使编译
器给出一个警告。
·@ Suppresswarnings 注解用来告知编译器忽略指定类型的警告，具体的警告类型可以
用初始化该注解的字符串来定义。遗憾的是，它并没有预定义的警告字符串集合，这意
味着不同的编译器之间的互操作会存在一些问题。
如果在这一领域中没有标准，注解的有效使用将会受到遏制。
最后，注解还有一个潜在的问题，就是注解可能会被误用，从而改变它们所作用的代码的
语义。按照《Java语言规范》的规定，“在Java 编程语言中，注解不得以任何方式影响程序的语
义。”事实上，编译器、虚拟机和所有其他注解处理工具应该忽略所有无法识别的注解。尽管注
解存在着这些问题，但是只要有适合的处理工具，注解就可以用来实现“元编程”(metaprogram ming)风格，这种风格使得人们可以创建Java 编程语言的特殊方言，以满足自己的特定需求。如
果程序开始依赖于特化注解所提供的支持，那么Java平台的可移植性所带来的好处将会丧失。
只要能当选，我不在乎是谁投的票。
——威廉·特威德(美国政客)
395
396
1.Java 社区组织的JSR 250正在定义供将来使用的通用注解类型。
397
第 16章 反 射
如果一个人的幽默感敏锐到了可以向别人显示自己的荒谬的程度，那么这种幽默感
就可以使他避免去犯所有的或者几乎所有的错误，除非那些错误值得去犯。
———塞缪尔·巴特勒(英国作家)
java.lang.reflect包中包含了用于反射(reflection)的相关类，我们可以用这些类来检
查类型的详细信息。通过使用这些类，我们可以编写出完整的类型浏览器，或者编写出可以用
来解释用户代码的应用程序，该程序会将用户代码转化为类的实际使用、对象的创建、方法的调
用，等等。几乎所有在本章中提及的类型都包含在了java.1ang.reflect包中，只有Class
和 Package类包含在java.1ang中，Annotation类包含在java.1ang.annotation中。
反射是由Class类对象开始的，从Class对象中，我们可以获得有关该类的全部成员的完
整列表；可以找出该类的所有类型(它实现的接口和扩展的类);并可以发现关于类自身的信
息，诸如它所应用的修饰符(public、abstract、fina1,等等)或它所在的包。反射有时也被称
为内省(introspection),这两个词汇都隐喻了“让类型自我审视并提供自身的描述信息”。这种内
省能力可以被类型浏览器用来展示应用程序的结构，同时也筑就了动态创建和操作对象的第一
步。
下面有一个简单的“类型浏览器”的例子，对于给定的类名，这个程序可以给出该类的直接
超类并列出它所声明的public方法：
import java.1ang.reflect.*;
import static java.1ang.System.out;
import static java.1ang.System.err;
public class SimpleClassDesc {
public static void main(String[] args){
Class type= nu77;
try {
type = Class.forName(args[0]);
} catch(ClassNotFoundException e){
err.println(e);
return;
}
out.print("class"+ type.getSimpleNameO);
Class superclass = type.getSuperclassO);
if(superclass != nul1)
out.print1n(" extends "+
superclass.getCanonica1Name(O));
else
out.print1n(O);
Method[] methods = type.getDeclaredMethods(O);
for(Method m:methods)
if(Modifier.isPublic(m.getModifiers(O)))
第16章 反 射 271
out.print1n(""+m);
}
}
假设我们给出了某个类的全限定类名(例如 java.1ang.String),那么该程序将首先尝试使用
静态方法Class.forName来获得该类所对应的Class 对象。如果无法找到该类，就会抛出一
个该程序将捕获并报告的异常；否则，会打印出该类的名字，例如，对 String类会打印出
String。接下来，程序会向这个class 对象查询所给类的超类的Class 对象，只要指定的类
不是Object,并且是类而不是接口，那么 getSuperclass方法就会返回该类超类的Class 对
象。使用getCanonica1Name方法可以将超类的名字完整地打印出来(我们将会在16.1.4节中
看到有多种命名类的方法)。然后，程序会向所给类的Class 对象查询它所声明的所有方法，
其中包括所有在该类中实际声明的方法，但是该类继承而来的方法并不包括在内。因为我们只
对public方法感兴趣，所以我们向Method 对象查询方法的修饰符，并向Modifier类对象查询
这些 Method 对象是否包含 public修饰符。如果答案是肯定的，则打印该方法，否则忽略该方
法。以下是将3.1节的Attr类的名字传递给该类时，程序的输出结果：
class Attr extends java.1ang.Object
public java.1ang.String Attr.getName()
public java.1ang.String Attr.toString()
public java.1ang.Object Attr.getValue()
public java.lang.Object Attr.setValue(java.1ang.Object)
在接下来的几页中，我们将会看到如何对该类的超类及其成员进行更详细的检查。
反射还允许我们编写执行如下动作的代码：如果我们了解所要做的操作，就可以在代码中
以更简单的方式直接去执行的动作。给定一个类名(这个类可能在程序编写时还不存在).我们
就可以获取其对应的class 对象，然后可以使用这个Class 对象来创建这个类的新实例。我们
可以与这些创建出来的对象进行交互，就像它们是通过 new创建的一样。例如，我们可以通过
使用反射来调用它们的方 类型 法，我们马上就会看到这
种用法，但是这比直接的 ParameterizedType 方法调用更难理解。我们 GenericArrayType 应该仅在所有其他面向对
TypeVariable<D> 象的设计机制都不奏效的
WildcardType 时候再使用反射。例如， AnnotatedElement 我们不应该使用Method
对象作为“方法指针”,因
AccessibleObject 为接口和抽象类是更好的 GenericDeclaration
工具。在某些时刻我们必
需使用反射——通常是我 成员 们在解释或显示其他代码
时，但是无论如何我们应
该尽可能地使用更直接的 :类 方式。 构造器 字段 方法 图16-1展示了支持
………………-1--11.句
图16-1 内省层次结构 反射的类和接口。顶端的
398
272 第16章 反 射
Type 表示可以在Java程序中存在的所有类型，它是一个不包含任何方法的标记接口。所有的
具体类型都是用Class类的实例来表示的，而其他类型则都属于泛型：参数化类型、类型变量、
通配符和泛型数组。constructor、Method和 Field类分别表示构造器、方法和域，它们都是
Member类的实例，并且也是Accessibleobject(它属于访问控制)的子类。类Class、Con structor和Method 都是GenericDeclaration的实例，这是因为它们都可以以泛型的方式
声明。最后，Class类、Accessibleobject的子类以及Package类都是AnnotatedElement
的实例，因为它们可以拥有应用于自身的注解。
16.1 Class类
每种类型都有其Class对象，包括每个类、枚举、接口、注解、数组和基本类型，还有一个特
殊的用来表示关键字 void的Class 对象。这些对象可以用来进行基本的查询，表示对类型的
399 引用以及创建该类型的新对象。
class类是反射的起点，它也提供了操纵类的工具，主要用于创建某种类型的对象(其中类
型名由字符串指定)和使用特殊技术实现的类的加载(例如跨网络)。我们将在16.13节中详细
介绍类的加载。
我们可以通过以下4种方式来获得Class 对象：通过使用对象的 getclass方法来获得它
的Class 对象；使用类字面常量(类的名字后面跟.class,例如 String.class);使用静态方
法Class.forName 查找类的完全限定名(包含所在包的路径的名字);从某种能够返回嵌套类
和嵌套接口的Class 对象的反射方法中获得(例如 Class.getclasses)。
16.1.1 类型符号
class是一个被声明为Class<T>的泛型类。每一个引用类型的Class 对象都有一个与
400所表示的类相对应的参数化类型，例如，String.class 的类型是Class<String>,Inte ger.class的类型是Class<Integer>,依此类推。基本类型的Class 对象和与它对应的包
装器类具有相同的类型，例如，int.class的类型是Class<Integer>,但是要注意，int.
class和Integer.class是同一个类的类型的两个不同实例。参数化类型共享的是其原始类
型的Class 对象，例如，List<Integer>的Class 对象与List<String>和 List.class
的Class 对象相同，其类型为Class<List>。
参数化的Class类型被称为给定类的类型符号(type token)。获得类型符号的最简单的方
法是使用类字面常量，例如 String.class,因为它为我们提供了确切的类型符号。与之相反，
所声明的Class.forName 返回的则是一个通配符Class<?>,它表示的是“不明”(unidenti fied)类型符号，因此为了有效地使用这个类型符号，我们需要确定它的确切类型，我们很快就
会看到有关它的例子。Object的getclass方法将返回被调用该方法的对象的类型符号，它的
返回类型也是Class<?>。然而 getclass受到了编译器的特殊对待：如果getclass是在具
有静态类型T的引用上被调用的，那么编译器会将 getclass的返回类型处理为Class<?ex tends T>',因此下面的代码可以执行：
1.实际上它是被当作 Class<?extends s>处理的，其中S是T的擦除。由于参数化类型共享相同的 Class对
象，所以擦除被用来从通配符边界中移除所有的参数化类型。例如，对于List<String>1,1.getclassO返
回的Class 对象就具有class<?extends List>类型。
16.1 class类273
String str="Hello";
Class<String> c1= String.class;// exact type token
Class<? extends String> c2=
// compiler magic str.getClass();
但是下面这段代码不能通过编译：
Class<? extends String> c3=
Class.forName("java.1ang.String");// INVALID
在使用反射时，接受未知的类型符号Class<?>,并将其转换为已知类型的类型符号是一
种很常见的动作。我们需要的是某种类似于强制转型的操作，但是我们知道，我们不能进行涉
及参数化类型的强制转型，解决之道是使用“神奇”的Class类的 asSubclass方法：
·public<T> Class<?extends T> asSubclass(Class<T> subType):返回在其
上调用该方法的Class 对象，但是返回之前要将其强制转换为表示给定的Class 对象的
子类。如果当前的Class对象无法表示为 subType类型的子类(或者 subType本身),401
就会抛出ClassCastException异常。
asSubclass方法并不改变Class 对象；它改变的仅仅是所调用的表达式的类型，因此我们可
以在强制转型时使用额外的类型信息。例如，我们可以使用带有 forName 参数的 assubclass
来订正前面的问题：
Class<? extends String> c3=
Class.forName("java.1ang.String").
asSubclass(String.class); // OK
注意，我们不能将未知的类型符号转换成确切的Class<String>,但是有Class<?ex tends String>就足够了。当然，String不是使用反射的实际例子，更典型的例子是我们正
在加载某个实现了已知接口的未知类，并且想创建该类的实例，我们将会在16.13节的 Game类
中看到这样的例子。
16.1.2 类检查
class类提供了许多用于获取特定类信息的方法，其中一些方法可以提供该类的类型信息
(该类实现的接口和扩展的类),而另一些方法则可以返回有关该类成员的其他信息，包括嵌套
类和嵌套接口的信息。我们可以查询某个类表示的是接口还是数组，或者查询某个特定对象是
否是该类的实例，我们将在接下来的几页中看到这些方法。
class类最基本的方法是那些遍历类型层次结构的方法，它们将显示实现的接口以及扩展
的类的信息。例如，在下面这个程序中，对于由作为引元而传入的字符串所表示的类型，该程
序将打印出有关它的完整的类型层次结构：
import java.1ang.reflect.*;
public class TypeDesc {
public static void main(String[] args){
TypeDesc desc = new TypeDesc();
for(String name :args){
try {
Class<?> startClass = Class.forName(name);
desc.printType(startClass,0,basic);
}catch(ClassNotFoundException e){
System.err.println(e);// report the error 402
403
274 第16章 反 射
}
}
}
// by default print on standard output
private java.io.PrintStream out = System.out;
// used in printType() for 1abeling type names
private static String[]
basic ={"class","interface", "enum“,"annotation" },
supercl={"extends","implements"},
iFace={ nul7, "extends" };
private void printType(
Type type,int depth,String[] 1abels)
{
if(type == null)// stop recursion -- no supertype
return;
// turn the Type into a Class object
Class<?> cls = nu11;
if(type instanceof Class<?>)
cls=(Class<?>)type;
else if(type instanceof ParameterizedType)
cls =(Class<?>)
((ParameterizedType)type).getRawTypeO);
else
throw new Error("Unexpected non-class type");
// print this type
for(int i=0;i<depth;i++)
out.print("");
int kind=cls.isAnnotation()?3;
cls.isEnum()?2:
c1s.isInterface()?1:0;
out.print(labels[kind]+"");
out.print(cls.getCanonica7NameO);
// print generic type parameters if present
TypeVariable<?>[] params= cls.getTypeParametersO);
if(params.)ength>0){
out.print('<');
for(TypeVariable<?> param :params){
out.print(param.getNameO);
out.print(","); }
out.println("\b\b>");
}
else
out.println();
// print out all interfaces this class implements
Type[] interfaces = cls.getGenericInterfacesO;
16.1 Class类 275
for(Type iface :interfaces){
printType(iface,depth+1,
cls.isInterface()?iFace :supercl);
}
// recurse on the superclass
printType(cls.getGenericSuperclass(),
depth+1, supercl);
}
}
这个程序将循环遍历通过命令行提供的类名，获取每一个具名类型的Class 对象，并在其上调
用printType方法。我们必须在try语句块中执行上述操作，以防止没有任何类具有指定的
类名。下面是在工具类java.util.HashMap上调用该程序时产生的输出结果：
class java.uti1.HashMap<K,V>
implements java.util.Map<K,V>
implements java.1ang.Cloneable
implements java.io.Serializable
extends java.util.AbstractMap<K,V>
implements java.uti1.Map<K,V>
extends java.1ang.Object
在上述代码中，位于 main方法之后的是对所用输出流的声明，默认使用的是System.
out。紧接其后的是字符串数组声明。
再后面是printType方法，它可以打印有关它自己的 type 参数的描述，然后递归地调用
自己，以打印有关 type的超类的描述。因为我们最初拥有的是泛化的Type 对象，所以我们必
须首先将它们转换为Class对象。参数 depth用于跟踪该方法在类型层次结构树中已经遍历
的深度，据此来控制描述信息行的缩进。在每一个递归层上，depth 的值都会递增。labels数 404
组指定了标记类的方式：如果某类型是一个类，则用1abels[0]对其进行标记；label[1]用来
标记接口类型；1abels[2]用来标记枚举类型；labels[3]用来标记注解类型。请注意我们在
检查这些类型的种类时所采用的顺序，由于枚举类型是类，注解类型是接口，所以我们必须先
检查更为具体的类型。
我们为这些标记定义了三个数组：basic用于顶层类，supercl用于超类，iFace用于接
口的超接口，它们彼此之间是扩展而非实现关系。我们先打印了恰当的类型前缀，然后调用
getCanonica1Name方法打印了类型的全名。虽然Class类提供了 tostring方法，但是我们
需要在它的前面添加“class”或“interface”,正是因为我们希望对前缀进行控制，所以必须创建
自己的实现。稍后我们将更详细地介绍类名。
接下来，我们检查type是否是一个泛型。所有类都实现了GenericDeclaration,通过它
定义了单一的getTypeParameters方法，该方法将返回一个Typevariable对象的数组。如
果有一个或多个类型参数，那么我们就在尖括号中打印它们的名字，就像它们在源代码中书写
的那样。
在打印了类型描述之后，printType 递归地调用自己，先是在源类型实现的所有接口上调
用，接着是在源类型扩展的超类(如果有的话)上调用，在调用的过程中传递恰当的标记数组。
最终，该方法会到达Object类的Class 对象，而这个class 对象没有实现任何接口，所以它
的getGenericSuperclass方法返回的是nul1,于是递归终止。
有一些简单的查询方法可以用来检查我们要处理的Class 对象的类别，其中许多方法在上
面的例子中已经用到了：
405
406
276 第16章 反 射
·public boolean isEnumO:如果Class对象表示枚举类，则该方法返回true。
·public boolean isInterfaceO:如果Class 对象表示接口(包括注解类型),则该方
法返回 true。
·public boolean isAnnotation():如果Class 对象表示注解类型，则该方法返回
true。
· public boolean isArrayO:如果Class 对象表示数组，则该方法返回true。
·public boolean isPrimitive():如果Class 对象表示的是八个基本类型之一或
void,则该方法返回 true。
· public boolean issyntheticO):如果Class 对象表示的是由编译器引入的合成类
型，则该方法返回 true。合成程序元素是指那些在源代码中没有对应结构的元素。
·public int getModifiersO:该方法返回编码为整数的类型修饰符。应该使用类Mod ifier的常量和方法对这个整数值进行解码，见16.3节。类型修饰符包括访问权限修饰
符(public、protected、private)以及abstract、final和static。为方便起见，某
个类型是否是接口也被编码为修饰符。基本类型的修饰符总是public和 final;而数
组类型的修饰符总是final,并且拥有和它所包含的元素相同的访问权限修饰符。在这
种上下文中，注解类不会被当作是修饰符，因为此编码机制的制订发生在将注解类添加
到Java 中之前。
我们还可以查询某个类型是顶级类型还是嵌套类型；如果是嵌套类型，我们还可以获得该嵌套
是何种类型的信息：
· public boolean isMemberclassO:如果该 Class 对象表示的类型是另一个类型的成
员(也就是说，它是一个嵌套类),则该方法返回 true;如果返回false,则说明它是一
个顶层类型。不管它的名字是什么,该方法都可以应用于嵌套接口和嵌套类。
·public boolean isLocalclass():如果该类表示的是局部内部类，则该方法返回
true。
· public boolean isAnonymousclassO:如果该类表示的是匿名内部类，则该方法返回
true。
注意，并没有任何方法可以用来确定某个成员类是静态嵌套类还是内部类。
上面的例子展示了两个方法，我们可以使用它们来确定某个类型在类型层次结构树中的位
置：
·public Type[] getGenericInterfacesO:该方法返回由该类型实现的所有接口对应
的Type 对象构成的数组。如果该类型没有实现任何接口，我们将得到一个长度为0的
数组。如果某个实现的接口是参数化类型，那么它对应的 Type 对象就是一个Parame terizedType的实例，否则其Type 对象就是一个Class 对象。
·public Type getGenericSuperclassO:该方法返回该类型的超类所对应的Type 对
象。如果Class对象表示的是Object类、接口、void或者基本类型，则该方法返回
nul1,因为它们没有超类。如果Class 对象表示的是数组，则该方法返回Object的
class 对象。通过递归调用该方法，我们可以确定某个类的所有超类。如果其超类是参
数化类型，所对应的Type对象就是ParameterizedType的一个实例；否则其Type对
象就是一个Class 对象。
早期Java版本遗留下来的方法 getInterfaces和getSuperclass与上述方法类似，不同之处
在于它们只返回class 对象而不返回Type对象。对于所有参数化类型，返回的都是其相应的
16.1 Class类277
原始类型的Class 对象。
对于所有不同种类的类型，有些方法只能应用于它们的某个特定子集：
·public Class<?> getComponentType():该方法返回的Class 对象用于表示由该
Class 对象表示的数组的构件类型。如果该Class 对象表示的不是数组，则返回null。
例如，给定一个 int型数组，通过getclass方法会得到一个Class对象，在该对象上
调用 isArray方法会返回true,而getcomponentType方法会返回 int.class对象。
· public T[] getEnumconstantsO:该方法返回该枚举类的元素，如果该Class 对象表
示的不是枚举类，则返回null。
·public Class<?> getDeclaringclass():该方法返回声明该嵌套类为成员的类的
class 对象。如果该 Class 对象表示的不是嵌套类，则返回nul1。例如，当在一个局部
内部类或者匿名内部类上调用该方法时，将返回nul1。
·public Class<?> getEnclosingclassO:该方法返回声明该类的包围类的Class
对象。如果该Class 对象表示的不是顶层类，则返回null。
·public Constructor<?> getEnclosingconstructorO:该方法返回声明该局部内
部类或匿名内部类的构造器的Constructor 对象(稍后就会介绍)。如果该 Class 对象
表示的不是在某个构造器中声明的局部内部类或匿名内部类，则返回null。
·public Method getEnclosingMethodO:该方法返回声明该局部内部类或匿名内部类
的方法的 Method对象(稍后就会介绍)。如果该 Class 对象表示的不是在某个方法中声
明的局部内部类或匿名内部类，则返回nul7。
练习16.1:修改TypeDesc,使其不打印 Object类。因为每一个类都继承自Object类，
所以打印 Object类这一步是多余的。可以使用Object类型的Class 对象的引用来完成此练
习。
练习16.2:修改TypeDesc,使其显示指定类是否是一个嵌套类。如果是嵌套类，则显示其
中其余的类是否是嵌套类。
16.1.3 检查类成员
class类包含一组方法，我们可以使用它们来检查类的各个构成元素，包括字段、方法、构
造器和嵌套类型。对于每一种构成元素，都有专门为表示它们而定义的类型，在后面的小节中
我们会看到有关这些类型的详细介绍：Field对象用来表示字段；Method 对象用来表示方法；
Constructor对象用来表示构造器；而嵌套类型则由已经介绍过的Class类来表示。
这些方法有4种变体，使用哪一种取决于我们想要得到的是所有成员，还是某个特定成员；
是只想得到公共成员，还是任何成员；是只想得到在当前类中声明的成员，还是要包括继承而
来的成员。
使用下面的方法，我们可以请求特定种类的所有公共成员，无论它是在类(接口)中声明
的，还是继承而来的：
public Constructor[] getconstructorsO
public Field[] getFieldsO
public Method[] getMethodsO
1.其中许多方法返回的都是原始类型数组，例如 Class[]或 Constructour[]。这些方法应该被泛化以返回通配
符类型：class<?>[]或 Constructor<?>[]。
407
408
278 第16章 反 射
public Class[] getclassesO
因为构造器不能被继承，所以 getconstructors方法只能返回当前类中声明的公共构造器所
对应的Constructor对象。
我们还可以请求特定种类的类成员，它们是在当前类(接口)中实际声明的，不是继承而来
的，这种成员不需要是公共的：
public Constructor[] getbeclaredconstructorsO
public Field[] getDeclaredFieldsO
public Method[] getbeclaredethodsO
public Class[] getDeclaredclassesO
不管是哪种情况，如果没有对应类型的成员，我们得到的就将是一个空数组。getclasses 和
getDeclaredclasses方法都会返回嵌套类和嵌套接口。
在请求某些特定的成员时，我们需要提供额外的信息。对于嵌套类型，我们只需提供嵌套
类型的名字，实际上并没有任何用于实现此目的的特殊方法，因为Class.forName 就可以实
现。对于特定域的请求，需要用到它们的名字：
public Field getField(String name)
public Field getDeclaredField(String name)
第一种形式用于查找公共字段，无论它们是在当前类中声明的还是继承而来的，而第二种形式
只查找声明的字段，它们不必是公共的。如果不存在以指定名字命名的字段，就会抛出
NoSuchFieldException异常。注意，在数组类型上调用这些方法时，不会返回其隐式的长度
字段。
一些特殊的方法可以通过它们的签名来加以辨别，签名即方法名和表示方法参数的数量及
类型的Class对象序列。请记住，对于可变引元方法，最后一个参数实际上是一个数组。
public Method
getMethod(String name, class...parameterTypes)
public Method
getDeclaredMethod(String name, class...parameterTypes)
类似地，构造器也可以通过其参数的数量和类型来辨别：
public constructor<T>
getConstructor(Class... parametertypes)
public Constructor<T>
getDeclaredconstructor(Class...parametertypes)
在上述两组方法中，如果指定的方法或构造器不存在，就会抛出 NoSuchMethodException异常。
注意，当我们请求一个单一的构造器时，可以得到参数化的构造器类型
Constructor<T>,它与Class 对象的类型是匹配的，但是当我们请求一组构造器时，返回的
数组却并不是以T参数化的，这是因为我们不能创建泛型数组。任何从该数组中提取出来的构
造器本质上都具有未知类型，但是这仅会对使用 invoke方法调用构造器造成影响，稍后我们
将对此进行讨论。
上述所有方法在执行前都需要进行安全检查，因此它们将与任何已安装的安全管理器(见
23.5节“安全”)进行交互。如果没有安装任何安全管理器，则以上的所有方法都可以执行。在
典型情况下，安全管理器将允许任何代码调用查询类型公共成员信息的方法——这符合正常的
语言级访问规则。但是，对非公共成员信息的访问通常仅限于系统中的特权代码。请注意，这
16.1 class类 279
里唯一的差别就在于公共成员和非公共成员——安全管理器并没有足够的信息约束proctect 或
package级别的访问。如果安全管理器不允许某项访问，就会抛出 SecurityException。
下面的程序列出了给定类的公共字段、方法和构造器：
import java.1ang.reflect.*;
public class ClassContents {
public static void main(String[] args){
try {
Class<?>c= Class.forName(args[0]);
System.out.print1n(c);
printMembers(c.getFields());
printMembers(c.getConstructorsO);
printMembers(c.getMethods(O));
} catch(ClassNotFoundException e){
System.out.print1n("unknown class:"+ args[0]);
}
}
private static void printMembers(Member[] mems){
for(Member m:mems){
if(m.getDeclaringClass()== Object.class)
continue;
String decl =m.toString(
System.out.print("");
System.out.println(strip(decl,"java.1ang."));
}
}
//... definition of strip ...
}
首先我们获取具名类的Class 对象，接着我们获取并打印由所有表示公共字段、构造器和方法
的成员对象构成的数组。printMembers方法使用 Member 对象的 tostring方法得到了描述
成员的字符串，其中略过了所有从 Object 继承而来的成员(用getDeclaringclass方法来检
查成员属于哪一个类),因为它们在每个类中都出现，所以每次都重复操作就没多少意义了
(strip方法移除了名字中的前缀"java.1ang.")。以下是该程序在3.1节 Attr类上运行时
输出的结果：
class Attr
public Attr(String)
public Attr(String,Object)
public String Attr.toString()
public String Attr.getName()
public Object Attr.getValue()
public Object Attr.setValue(Object)
练习16.3:修改 Classcontents类，使其显示所有声明的成员和所有继承而来的公共成
员。你必须确保不会有成员被重复列举两次。
16.1.4 命名类
在TypeDesc程序中使用的Class 对象是通过静态方法 Class.forName得到的，该方法
409
410
411
280 第16章 反 射
接受一个字符串引元，并返回表示具有该名字的类型的Class 对象。其中，所使用的名字必须
是类或接口的二进制名(binary name),或者是特殊的具名数组类型，这些概念将在下面详细
介绍。
每一个类型都可以用许多不同的名字表示。实际的类或接口名是该类型的简单名(simple
name),这是我们在程序中表示给定类型时可书写的最短名字。例如，java.1ang.Object的
简单名是Object,java.util.Map 中的嵌套接口 Entry的简单名是Entry, object实例数组
的简单名是Object[],而 int数组的简单名是int[]。除了匿名内部类，所有的类型都有简
单名，我们可以通过Class的getsimpleName方法得到某种类型的简单名。
类型的规范名(canonical name)是它的全名。就像你在代码里写的那样，它包括包名和封装
类名(如果存在的话)。例如，Object的规范名是java.1ang.Object,嵌套接口 Entry的规
范名是java.util.Map.Entry, object实例数组的规范名是java.lang.object[],int数
组的规范名是int[]。更具体地说，顶层类或接口的规范名就是所在包路径后面依次紧跟圆点
和简单名，嵌套类的规范名由其声明类的规范名后加点"."后接该嵌套类的名字组成。数组的
规范名是其所含元素的规范名后接[],局部内部类和匿名类没有规范名。我们可以通过Class
的getCanonica1Name 方法得到某种类型的规范名。
规范名就是完全限定名(full qualified name)的一个例子，完全限定名就是用包和包围类型
限定的简单名。简单名在给定的上下文中可能会产生混淆，而完全限定名却可以唯一地确定类
型。每种类型都只有一个规范名，但是嵌套类型(以及嵌套类型数组)可以有多个完全限定名。
例如，java.uti1.SortedMap接口扩展了java.util.Map并继承了嵌套的 Entry接口，因
此，我们也可以用完全限定名 java.util.SortedMap.Entry来标识 Entry类型。
类或接口(不是数组)的二进制名是用来和虚拟机通信的名字，我们可以通过将它传入
class.forName方法来向虚拟机请求特定的Class 对象。顶层类或接口的二进制名就是它的
规范名，而嵌套类有特殊的命名惯例，我们已经在5.7节“嵌套类型的实现”中学习过这些命名
惯例了。静态嵌套类型和内部类(除了局部内部类和匿名内部类)的二进制名是由它们的直接
包围类后接$和嵌套类或内部类的简单名构成的。例如，接口 Entry的二进制名是java.
util.Map $ Entry。局部内部类的二进制名是由其封装类的二进制名后接$、数字和它的简单
名组成的。匿名内部类的二进制名是由其封装类二进制名后接$和数字组成的'。我们可以通
过Class的getName方法获得某个类型的二进制名，这个二进制名是 forName方法所期望的
类名或接口名。
对于类名，数组类型具有其特殊的符号，被称为内部格式(internal format),因为它是虚拟
机内部使用的格式。但是出于某种原因，这种符号并不被认为是二进制名，它是由代表数组的
元素类型的编码与前导字符[构成的，其中元素类型是按以下方式编码的：
B byte
C char
D double
F float
I int
J long
1.因为二进制名不能唯一地指定局部类和匿名类，所以我们不能以一种轻便的方式使用反射来实例化这些类。幸
运的是，我们很少需要这样做。
16.1 class类281
Lclassname;
S
Z
class 或 interface
short
boolean
例如，int型数组的名字是[工，而Object数组的名字是[Ljava.1ang.Object;(注意名字后
面的分号)。多维数组只是元素类型为数组的数组，所以 int[][]型数组的名字是[[I,而该数
组中的元素的类型名是[I。这些内部格式名可以传递给 forName方法以获得数组类型的
Class 对象，这也是getName 返回的数组类型名。
对于基本类型和 void,其简单名、规范名以及二进制名都是相同的(即表示这些类型的关键
字，例如 int、float或 void),所有的名字方法都会返回相同的名字。从 forName方法中无法
获得这些类型的Class 对象。我们必须使用类字面常量，如 int.class 或对应的包装器类的
TYPE字段，如 Void.TYPE。如果将表示这些类型的名字用于 forName 方法，那么该方法会认
为这个名字是用户定义的类或接口，而且未必能被虚拟机找到。
16.1.5 通过名字获取 Class 对象
我们在前面使用的 forName方法是一般的 forName方法的简单形式：
·public static Class<?> forName(String name,boolean initialize,class Loader loader)throws ClassNotFoundException:该方法使用给定的类加载器返回
与指定类名或接口名相关联的Class 对象。假定类或接口的二进制名(与getName方法
返回的名字格式相同)或数组名都已采用了内部格式，那么该方法就会尝试着定位、加载
并链接该类或接口。指定的类加载器被用来加载类或接口。如果 loader为nul],那么
该类将由系统类加载器加载。该类仅在intialize为true时进行初始化，并且之前并
未被初始化过。对于数组类，将加载数组中的元素类型，但并不对其进行初始化。
就像该方法的描述所表明的那样，获取类的Class 对象将涉及类的加载、链接和初始化——这
是一个相当复杂的过程，该过程将会在16.13节详细介绍。简单的Class.forName方法使用
的是当前类的加载器，也就是加载在 forName 调用中出现的当前类的加载器，并且在必要时会
初始化加载的类。如果无法找到要加载的类，就会抛出检查型异常 ClassNotFoundExcep
tion。该异常能包含一个嵌套的描述问题的异常，我们可以通过在异常对象上调用getcause
获得该嵌套异常。这个调用返回的可能是嵌套异常，但也可能是nul1,因为类的加载、链接和
初始化过程存在着很高的复杂性，使得这些方法也可能会抛出非检查型的异常 LinkageError
和 ExceptionInInitializerError。
16.1.6 运行时类型查询
在编写程序时，我们可以使用instanceof来检查对象的类型或者用强制转换来改变表达
式的类型。在这两种情况中，我们都需要知道所涉及的类型名，这样才能在代码中把它写出来，
在使用反射时，我们只有Class 对象，因此无法使用像 instanceof、强制转换这样的操作。
class类提供了几种方法，用来在功能上模拟语言级的操作符：
·public boolean isInstance(Object obj):该方法可以确定 obj对象与该类是否是
赋值兼容的，它动态等价于instanceof操作符。如果obj可赋值给该 Class 对象所表
示的类型的变量，则该方法返回true;否则返回 false。
·public T cast(Object obj):该方法将obj强制转换为该Class 对象所表示的类，如
果强制转换失败，就会抛出ClassCastException。在少数情况下，当我们想将一个类
412
413
414
282 第16章 反 射
强制转换为由类型参数所表示的类时，由于我们不能使用实际的语言级强制转换，所以
就需要使用cast方法。
· public boolean isASsignableFrom(Class<?> type):如果该Class 对象表示的
是type 的超类或者 type自身，则该方法返回 true;否则返回 false。
16.2 注解查询
我们可以查询应用到某个类或接口上的注解，使用的方法与那些用来查询成员的方法类
似，但是它们在实现细节上稍微有所不同。用于查询注解类的所有方法是AnnotatedElement
接口的一部分。所有表示程序元素的反射类(Class、Field、Method、Constructor 以及Pack age)都实现了AnnotatedElement。本节讨论的内容可以应用于所有这些AnnotatedElement
实例。
注解查询只能提供有关在运行时可获取的注解的信息，也就是说，这些注解的保存策略必
须是RetentionPolicy.RUNTIME(见15.5节“保存策略”)。
我们可以使用getAnnotations方法(该方法将返回一个Annotation实例数组)查询某
个元素上应用的所有注解，不管这些注解是直接声明的还是继承的。我们也可以使用getDe claredAnnotations只查询直接声明的注解，该方法也会返回一个Annotation实例数组。
我们还可以使用getAnnotation方法查询指定的注解，该方法接受注解类型作为参数，并返回
Annotation对象；如果该注解不存在，则返回nul1。我们可以使用 boolean 的 isAnnota tionPresent方法询问在某个元素上是否使用了指定的注解。与类似的查询成员的方法有所
不同，这些方法没有公共注解和非公共注解之分，也没有任何安全检查。
返回的注解实例是代理对象，它们实现了由给定注解类型所定义的接口。我们可以调用注
解类型的方法来获取每一个注解元素的注解值，例如，假设我们的 BugsFixed 注解类型(见
15.3节)拥有运行时的保存策略，然后给出下面的注解：
@ BugsFixed({"457605","532456"})
class F0o {/* ...*/}
那么以下代码
Class<Foo> cls = Foo.class;
BugsFixed bugsFixed =
(BugsFixed)cls.getAnnotation(BugsFixed.class);
String[]bugIds = bugsFixed.value();
for(String id :bugIds)
System.out.print7n(id);
将会打印：
457605
532456
如果某个注解方法表示的是具有Class类型的注解元素，并且该类无法在运行时找到，那
么我们就会得到TypeNotPresentException(这是一个非检查型的异常，该异常与ClassNot FoundException类似)。
因为在运行时可获取的注解类型与用来注解被检查类的注解类型有所不同，所以有可能会
出现对这两种类型的使用不兼容的情况。如果出现这种情况，那么在试图访问注解的某个元素
时就会抛出AnnotationTypeMismatchException或 IncompleteAnnotationException异
16.4 成 员 类283
常。如果被访问的元素类型是枚举类型，并且注解中的枚举常量从该枚举类型中移除了，那么
就会抛出 EnumconstantNotPresentException异常。
练习16.4:编写一个程序，打印出适用于指定类的所有可获取的注解。(只有使用了RUNT IME 保存策略的注解才是可获取的)。
练习16.5:扩充ClassContents,使其包含所有成员的可获取的注解信息。
16.3 Modifier类
Modifier类为所有非注解修饰符(ABSTRACT、FINAL、INTERFACE、NATIVE、PRIVATE、
PROTECTED、PUBLIC、STATIC、STRICT、SYNCHRONIZED、TRANSIENT和VOLATILE)都定义了int
型常量。每一个常量都有与其对应的查询方法 isMod(int modifiers),如果修饰符 mod具有
指定值，则该方法返回 true。例如，如果某个域的声明如下：
public static final int OAK=0;
那么它对应的 Field对象的getModifiers方法将返回
Modifier.PUBLIC |Modifier.STATIC |Modifier.FINAL
strictfp修饰符是通过常量STRICT反射的。如果代码或类是以严格浮点(见9.1.3节
“严格浮点运算和非严格浮点运算”)方式计算的，那么该方法、类或接口的修饰符将包含
STRICT标志。
查询方法可以以更符号化的方式来询问问题。例如，表达式
Modifier.isprivate(field.getModifiers(O)
等价于更模糊的查询表达式
(field.getModifiers()& Modifier.PRIVATE)!=0
16.4 成员类
类 Field、constructor以及Method都实现了Member接口，该接口有4个方法可以用来
获取所有成员都共享的属性：
·class getDeclaringclassO:该方法返回声明该成员的类的Class 对象。
·String getNameO:该方法返回该成员的名字。
·int getModifiersO:该方法返回以整数编码的该成员的语言修饰符，这个整数值应该
用Modifier类来解码。
·boolean issynthetic():如果该成员是由编译器创建的合成成员，则该方法返回
true。例如在内部类中创建的用来保存对包围实例的引用的合成域，以及生成的用来支
持泛型的合成“桥接”方法，见附录A.3.1。
虽然类或接口可以成为另一个类的成员，但是由于历史原因，Class类并没有实现Member
接口，尽管它支持具有相同的名字和契约的方法。
所有Member类的 tostring方法都包含成员的完整声明，与其在源代码中出现的形式相
似，都包含修饰符、类型以及参数类型(参数的可应用类型)。出于历史原因，tostring方法没
有包含泛型信息。toGenericstring方法提供了成员声明的更完整的表示，它包括类型参数
以及所有用到的参数化类型和类型变量。对于方法和构造器，throws 列表也包含在该字符
串中。
415
416
417
284 第16章 反 射
16.5 访问检查和 Accessibleobject
类 Field、Constructor和Method 也是Accessibleobject类的子类，该类使得我们可
以启用或禁止语言级的访问权限修饰符，例如 public和private。通常，通过使用反射来访
问成员的操作所受到的访问权限检查，与通过常规的、显示的代码进行访问时受到的检查相同，
例如，如果我们不能直接访问代码中的某个字段，那么我们也就不能通过反射间接地访问它。
我们可以通过在对象上调用 setAccessible,并将 true 传递给该方法，来禁止访问权限检查，
这样，我们就可以访问到这个对象，而不用理会语言级的访问控制。这是必需的，例如，在我们
编写调试器时就需要它。这些有关访问权限检查的方法有：
·public void setAccessible(boolean flag):这个方法可以将该对象的可访问标志
设置为指定的布尔值。true表示该对象应该抑制语言级的访问权限控制(这样就始终是
可访问的);false表示该对象应该接受语言级的访问权限控制。如果不允许我们改变
对象的可访问性，则会抛出SecurityException。
· public static void setAccessible(Accessibleobject [] array, boolean
flag):这是一个设置对象数组的可访问标志的简便方法。如果在设置数组中某个对象
的标志时抛出了SecurityException异常，那么只有数组中先前已经设置过的对象会
具有给定值的访问权限，而其他对象则保持不变。
·public boolean isAccessibleO:该方法返回了对象当前的访问标志。
16.6 Field类
Field类中定义了一些方法，可以用来查询字段的类型以及设置或读取字段的值。将这些
方法与继承而来的Member方法结合在一起，就可以使我们能够找出有关字段声明的全部信息，
并且能够操纵某个特定对象或类的字段。
getGenericType方法返回表示字段的声明类型的 Type实例。对于像 String 或 int 这
样的平凡类型，该方法将返回与其相关联的class 对象，例如 String.class和int.class。
对于像 List<String>这样的参数化类型，该方法将返回ParameterizedType的实例，例
如，对像T这样的类型，该方法将返回Typevariable实例。
遗留下来的getType方法将返回字段的类型的class 对象。对于平凡类型，该方法
的行为与getGenericType方法的相同。如果字段的声明类型是参数化类型，那么 get Type方法将返回参数化类型的擦除所对应的Class 对象，即原始类型的Class 对象。例
如，对于声明为List<String>的对象，getType将返回List.class的。如果字段的
声明类型是类型变量，那么 getType方法将返回类型变量的擦除所对应的Class 对象。
例如，假设有一个类 F00<T>,对于其声明为T类型的字段，getType将返回Object.
class 对象。如果F00被声明为 F00<T extends Number>,那么 getType将返回 Num ber.class。
我们可以使用isEnumconstant方法查询一个字段是否是枚举常量，也可以使用get和
set方法来获取和设置字段的值。这些接受Object引元并返回Object 值的方法都有一种通
用形式，以及一些可以直接处理基本类型的更加特化的形式。所有这些方法都要接受一个引
元，用来指定所要操作的对象。对于静态字段，将忽略这个对象引元，所以此时也可以将其设
置为nu77。下面的方法将打印一个对象的 short型字段的值：
16.6 Field类 285
public static void printShortField(Object o,String name)
throws NoSuchFieldException,IllegalAccessException
{
Field field = 0.getC1ass().getField(name);
short value =(Short)field.get(o);
System.out.println(value);
}
get方法的返回值可以是这个字段所引用的任何对象，如果该字段是基本类型，那么该方法将
返回恰当类型的包装器类对象。对于我们的 short型字段，get方法将返回包含该字段值的
Short类型的对象，而在将它赋值给本地变量 value时，该对象值会自动进行拆箱转换。
set方法的使用也是类似的。将short型字段设置为所提供的值的方法看起来可能像下面
这样：
public static void
setShortField(Object o,String name,short nv)
throws NoSuchFieldException,Illega1AccessException
{
Field field=0.getClass().getField(name);
field.set(o,nv);
}
虽然 set 接受的是Object类型的参数，但是我们可以直接传递一个 short型的值，并用包装
转换将其包装为 Short类型的对象。
在上面的方法中，如果指定对象的域是不可访问的，并且这种访问权限控制是强制执行的，
那么就会抛出IllegalAccessException异常；如果传递的对象与该域的类型不同，就会抛出
IllegalArgumentException异常；如果该域是非静态的且传递的对象引用是nul1,就会抛
出NullpointerException异常；访问静态域可能会要求对类进行初始化，所以该方法也会抛
出 ExceptionInInitializerError异常。
Field类还有特定的用来获取和设置基本类型的方法，例如，我们可以在 Field 对象上调
用getPrimitiveType和 setPrimitiveType,其中 PrimitiveType是(首字母大写的)基本
类型名。get方法可用于下面的语句：
short value = field.getshort(o);
而 set方法可用于下面的语句：
field.setshort(o,nv);
用以上两种方式声明的语句中可以避免使用包装器类对象。
Field类实现了AnnotatedElement接口，所以我们也可以像16.2节那样查询应用于域
上的注解。
凭借上面介绍的方法，我们可以将 Field对象用作操纵任意值的一种方式，但是我们应该
尽量避免使用它。因为Java语言会在程序的编译期尽可能多地捕获编程错误，所以在我们编写
代码时，使用的诸如 Field对象这样的间接方法越少，那么在将它们编译成代码之前、就可以
防止更多的错误。而且，我们可以看到，在前面的代码中，要想知道到底会发生什么,与在普通
的语法中直接使用域名的情况相比，我们花费在阅读代码上的精力显然大了许多。
Final字段
在通常情况下，对声明为 final的字段进行设置将会导致抛出IllegalAccessException
418
419
420
286 第16章 反 射
异常，这是我们所能预期的，因为 final字段的值是永远不会改变的。但是有些特殊情况——例
如在定制的反序列化(见20.8.4节)中，改变 final字段的值就是有意义的，我们只有在实例字
段上才能通过反射实现这一点，并且前提是在该 Field对象上已经调用过了setAccessible
(true)。注意，可以成功调用 setAccessible(true)是不够的，必须确实调用过它。
这种能力是为高度特化的上下文提供的，并非用于通用目的，我们介绍它仅仅是为了保持
内容的完整性。如果脱离了特定的上下文，例如定制的反序列化，那么改变final字段的值可能
会导致意外的甚至是灾难性的后果。在这些上下文之外，不能保证对 final字段的改变是可见
的。即便是在这样的上下文中，在使用这项技术编码时也必须保证安全机制不会阻碍代码的执
行。改变值为常量变量(见2.2.3节)的final字段将会导致此改变不可见，除非通过使用反射来
实现这种修改。
练习16.6:编写名为Interpret的程序，用来创建所请求类型的对象，同时允许用户检查
并修改该对象的字段。
16.7 Method类
Method类和它从 Member类继承而来的方法使得我们可以获得方法声明的完整信息：
·public Type getGenericReturnType():该方法返回的是目标方法的返回类型的
Type 对象。如果目标方法被声明为返回 void,则该方法返回void.class。
· public Type[] getGenericParametertypesO):该方法返回目标方法所有参数类型的
Type 对象数组，这些 Type 对象将按照参数的声明顺序存储于在数组中。如果目标方法
没有任何参数，则该方法返回一个空数组。
·public Type[] getGenericExceptionTypesO:该方法返回在 throws子句中列出的
所有异常类型的Type 对象数组，这些Type 对象将按照异常的声明顺序存储在数组中。
如果目标方法没有声明任何异常，则该方法返回一个空数组。
Java还提供了getReturnType、getParameterTypes和getExceptionTypes 方法，用来返回
Class对象而不是Type对象。就像在使用 Field.getType时，参数化类型和类型变量是由它
们的擦除所对应的Class 对象表示的。
Method类实现了AnnotatedElement,并且我们可以像16.2节所讨论的那样去查询应用
于方法上的注解。另外，Method类还提供了getParameterAnnotations,用来提供对应用于
方法参数上的注解进行访问。getparameterAnnotations 方法可以返回Annotation 数组，
其中最外层数组的每一个元素都与方法的参数相对应；如果某个参数没有任何注解，则该方法
为这个参数返回一个长度为0的Annotation数组。如果Method 对象所表示的方法自身就是
一个注解元素，那么 getDefaultvalue方法将返回一个表示该元素默认值的Object 对象；如
果Method对象本身不是注解元素或者它没有默认值，则该方法将返回 nul1。
Method类也实现了GenericDeclaration,因此定义了getTypeParameters方法，该方
法将返回一个Typevariable对象数组。如果给定的 Method 对象表示的不是泛型方法，该方
法将返回一个空数组。
我们可以使用 isvarArgs方法来检查某个Method 对象是否是一个可变引元方法，而is Bridge方法可以用来检查它是否是一个桥接方法(见附录A.3.1)。
Method 对象最有趣的用法就是反射地调用它自己：
·public Object invoke(Object onThis,object...args)throws IlleaalAccess
Exception,IllegalArgumentException,InvocationTargetException:该方法在
16.7 Method类287
onThis对象上调用Method 对象定义的方法，并用 args 的值来设置被调用方法的参
数。对于非静态方法，onThis的实际类型就确定了将要调用方法的哪种实现，而对于静
态方法，onThis会被忽略，并且通常会设置为 nul1。args值的数量必须和被调用方法
的实际参数数量相同，并且这些值的类型必须全部都可赋值给那些被调用方法的参数；
否则，我们将会得到IllegalArgumentException异常。请注意，可变引元方法的最后
一个参数是一个数组，所以我们必须用实际想要传递的“可变”引元来填充该数组。如果
我们想调用我们没有访问权限的方法，该方法就会抛出IllegalAccessException异
常。如果被调用方法不是onThis对象的方法，该方法会抛出IllegalArgumentExcep tion异常。如果onThis为nul1并且是非静态的，该方法就会抛出 NullPointerEx ception异常。如果这个Method 对象表示的是静态方法，并且声明这个静态方法的类
仍处于待初始化状态，该方法就会抛出 ExceptionInInitializerError异常。如果被
调用方法抛出异常，该方法就会抛出InvocationTargetException异常。
当我们使用invoke方法时，可以直接传递基本类型，也可以使用合适的包装器类。包装
器类表示的类型必须可赋值给方法所声明的参数类型。我们可以使用Long、Float或 Double
来包装double类型的引元，但是不能用 Double来包装 long或 float类型的引元，因为
double不是可赋值给 long 或 float的。对 invoke方法返回的Object 的处理方法和
Field.get一样，都是返回对应于它们的包装器类的基本类型。如果方法声明为 void,in
voke方法将返回nul1。
简单地说，就是我们在用 invoke来调用方法时，只能使用在Java 语言中合法的与其参数
具有相同类型和值的引元。例如，下面的调用
return str.indexof(".",8);
可以用反射写成如下形式：
Throwable failure;
try {
Method indexM = String.class.
getMethod("indexOf",String.class,int.class);
return(Integer)indexM.invoke(str,".",8);
}catch(NoSuchMethodException e){
failure =e;
} catch(InvocationTargetException e){
failure= e.getCause();
} catch(I1legalAccessException e){
failure =e; throw failure;
虽然编译器对于直接调用所做的安全性检查，在使用反射的情况下，只能在运行时使用 invoke
时进行，但是基于反射的代码确实拥有与直接调用的代码在语义上等效的安全性检查。访问权
限检查可能会以略为不同的方式执行——安全管理器可能会拒绝访问我们的包中的某个方法，
即使我们可以直接调用该方法。
当我们可以使用这种形式的调用时，我们有充分的理由去避免它。但是如果我们在编写调
试器或其他需要将用户输入解释为对对象操作的泛型应用时使用 invoke或 get/ set方法，就
会显得很合理。Method对象在某种程度上可以当作类似其他语言中的方法指针来使用，但是
我们有更好的工具，尤其是接口、抽象类和嵌套类，可以用来处理那些通常在其他语言中用方法
指针解决的问题。
421
422
423
288 第16章 反 射
练习16.7:修改你的Interpret程序，使其可以调用对象上的方法。你应该正确显示方法
返回的所有值或抛出的所有异常。
16.8 创建新对象和 Constructor类
我们可以使用Class对象的 newInstance 方法来创建它所表示的类型的新实例(对象),
该方法将调用类的无参构造器，并返回对新创建对象的引用。对于Class<T>类型的类对象，
返回的是具有T类型的对象。
当我们想编写通用的创建新对象的代码并让用户指定新对象所属的类时，这种方式就显得
很有用了。例如，我们可以修改3.11节“设计一个扩展的类”中通用的排序算法测试器，以便让
用户可以输入被测试类的类名，并用它作为 forName查找方法的参数。假设给定的类名是有效
的，那么 newInstance将被调用以创建该类型的对象。以下是通用的 Testsort类的新的
main方法：
static double[] testData ={0.3,1.3e-2,7.9,3.17 };
public static void main(String[] args){
try {
for(String name :args){
Class<?> classFor= Class.forName(name);
SortDouble sorter
=(SortDouble)classFor.newInstance();
SortMetrics metrics
= sorter.sort(testData);
System.out.println(name+ ":"+ metrics);
for(double data :testData)
System.out.println("\t"+ data);
}
} catch(Exception e){
System.err.println(e); // report the error
}
}
这和 Testsort.main(见3.11.1节)几乎是完全一样的，但是我们已经移除了所有的类型名。
这个main方法可以用来测试具有无参构造器的 SortDouble的任何子类。我们不必为每一种
类型的排序算法都编写一个main方法，这个泛型main方法可以处理所有类型，我们所要做的
就是执行下面的语句：
java TestSort Testclass…
来检测所有的排序类(像 SimplesortDouble),这样就可以加载并运行这个类了。
请注意，虽然 newInstance 将返回T类型的对象，但是Class.forName 将返回Class
<?>类型的对象。这意味着 newInstance所返回的对象的实际类型是未知的，所以需要强制
转型。我们也可以用asSubclass来得到所需的确切类型的类对象，这样在调用 newInstance
时就无需强制转型。
Class<?extends SortDouble> classFor=
Class.forName(name).asSubclass(SortDouble.class);
SortDouble sorter = classFor.newInstance();
在这两种情形中，如果指定的类不是SortDouble的子类，就都会抛出ClassCastException
16.8 创建新对象和 Constructor类289
异常。
如果使用不当，newInstance方法会抛出许多不同的异常。如果类没有无参构造器，或者
是抽象类和接口，或者是如果由于某种原因对象创建失败，我们都会得到InstantiationEx ception异常；如果类或无参构造器是不可访问的，就会抛出IllegalAccessException异
常；如果当前的安全策略不允许创建新对象，就会抛出 SecurityException异常；最后，创建
新对象可能要求实例化某个类，所以可能会抛出 ExceptionInInitializerError异常。
Class的 newInstance方法只会调用无参构造器。如果我们想调用任何其他的构造器，
那么必须使用Class 对象得到相关的Constructor 对象，并通过传递合适的参数去调用该
Constructor上的 newInstance方法。
Constructor类与它从 Member 继承而来的方法使得我们可以获得关于构造器声明的完整
信息，同时也使得我们可以通过调用构造器来获得该类的新实例。
·public Type[] getGenericParameterTypesO:该方法返回一个 Type 对象数组，数
组中的元素是该构造器接受的所有参数类型，它们是以声明顺序存储的。如果该构造器
没有声明任何参数，该方法将返回一个空数组。
·public Type[] getGenericExceptionTypesO:该方法返回一个 Type 对象数组，数
组中的元素是该构造器的 throws子句中列举的所有异常类型，它们是以声明顺序存储
的。如果该构造器没有声明任何异常，则该方法将返回一个空数组。
像 Method对象一样，以上方法也有与其相对应的遗留方法 getParameterTypes 和getEx ceptionTypes。
Constructor类与Method类相似，实现了相同的接口(AnnotatedElement和Generic Declaration),并且定义了相似的方法(getParameterAnnotations和isvarArgs)。
为了从 Constructor对象创建类的新实例，我们可以调用它的 newInstance方法。
·public T newInstance(Object...args)throws InstantiationException,Ille galAccesSException,IllegalArgumentException,InvocationTargetExcep tion:该方法首先使用由这个Constructor 对象表示的构造器和指定的初始化引元，
创建和初始化声明这个构造器的类的新实例，然后返回刚刚被初始化的新对象的引用。
Constructor.newInstance与Method.invoke非常相似，args值的数量必须与构造
器的参数数量相同，否则我们将会得到IllegalArgumentException异常。再次提请
注意，可变引元构造器的最后一个参数是一个数组，我们必须用想要传递的实际的“可
变”引元来填充该数组。如果声明该构造器的类是抽象类，我们将会得到 Instantia tionException异常；如果我们没有权限访问该构造器，将会得到IllegalAccesSEx ception异常；如果构造器本身抛出了异常，我们将会得到由该异常所导致的 Invoca tionTargetException异常。
如果构造器对象是通过通配符引用来引用的，那么我们必须将 newInstance方法返回的
对象强制转型为正确的类型。
练习16.8:进一步修改你的Interpret程序，让用户能够调用任何类的构造器，并显示所
有异常。如果构造成功，允许用户调用返回对象上的方法。
内部类构造器
对于所有的内部类构造器，编译器都会将其改造为接受的第一个参数是指向包围类对象的
引用，所以内部类(不包括局部内部类和匿名内部类)从来没有无参构造器。这意味着我们不能
424
290 第16章 反 射
使用class.newInstance来创建内部类对象，所以必须使用Constructor 对象。内部类的
Constructor对象反映了改造后的代码，而不是程序员编写的代码。例如，考虑 BankAccount
类和与其关联的内部类Action(见5.2节),其中Action类有一个单独的构造器，该构造器接
受一个表示行为动作(提款、存款等)的 String参数和一个表示该动作所涉及数量的 long型
值。如果我们使用getDeclaredconstructors来获得Constructor 对象，并使用 tostring
方法打印它的签名，那么我们将得到以下结果：
425 BankAccount $Action(BankACcount,java.1ang.String,long)
在这里，我们可以看到使用$的内部类的命名惯例和隐式添加的引用包围类对象的构造器引
元。我们可以按下面的方法来获取这个构造器：
Class<Action> actionClass = Action.class;
Constructor<Action> con =
actionClass.getDeclaredConstructor(BankAccount.class,
String.class,long.class);
如果我们想构造一个Action 对象，就必须提供合适的包围类对象的引用：
BankAccount acct = new BankAccount();
// ...
Action a = con.newInstance(acct,"Embezzle",10000L);
16.9 泛型类型检查
正如我们在16.1节的图16-1中所看到的那样，有大量的接口可以用来表示在代码中出现
的不同种类的类型。到目前为止，我们将注意力都集中在了Class 对象和Member 对象上，这
是因为这些对象在反射中使用得更加普遍，并且我们提到过的其他种类也只有 Type对象。本
节将详细介绍其他那些 Type接口。
16.9.1 类型变量
在Class、Method和 Constructor中实现的 GenericDeclaration 接口只有一个get Typeparameters方法，该方法会返回一个Typevariable对象数组。Typevariable接口本
身是一个泛型接口，其声明如下：
interface Typevariable<D extends GenericDeclaration>
例如，Method.getTypeParameters 返回的 Typevariable 对象的类型是Typevariable
<Method>。
每一个类型变量都有可以通过getName 返回的名字，它有一个或多个上界，这些上界可以
作为Type[]从 getBounds方法中获得。回顾可知，如果没有任何显示的上界，那么它的上界
就是Object。
getGenericDeclaration方法返回GenericDeclaration的Type 对象，而Typevari able就是在GenericDeclaration 中声明的。例如，表达式 Typevariable.class.get TypeparametersO[0]将会产生一个表示上面声明中的D类型的 Typevariable对象。如果 426
我们在这个对象上调用getGenericDeclaration,该方法将返回Typevariable接口对应的
class对象。更一般地，对于任何至少具有一个类型参数的 GenericDeclaration 对象g,下
面的判断
9.getTypeParametersO[i].getGenericDeclarationO==9
16.9 泛型类型检查 291
将总是为 true(当然要假设i是一个有效的索引值)。
类型变量对象是由返回它们的反射方法按需创建的，Java并不要求我们每次请求相同的类
型变量时，都要得到相同的 Typevariable对象。然而，对于给定的类型变量，每次返回的对
象必须按照 eauals方法进行判断都是等同的。类型变量的边界要直到调用getBounds 时才会
创建.所以如果没有找到在该边界内使用的类型，getBounds 就会抛出TypeNotPresentEx ception异常。对于任何边界，只要其所引用的 ParameterizedType实例由于某些原因而未
能创建，那么 getBounds 就会抛出 MalformedParameterizedTypeException。
16.9.2 参数化类型
诸如 List<String>这样的参数化类型是由实现了ParameterizedType接口的对象表
示的。我们可以从 getActualTypeArguments 中得到参数化类型对应的实际类型参数，
getActualTypeArquments方法返回的是一个 Type 对象数组。例如，在参数化类型 List
<Strina>上调用 aetActualTypeArquments 将会产生一个长度为1的数组，该数组包含唯
一的元素 String.class。
getOwnerType方法(也许称其为getDeclaringType更好些)将返回一个Type对象，该
ParameterizedType对象是这个 Type对象所对应的类型的成员。如果这个Parameterized Type对象不是某个类的成员，则该方法返回 nu11。这是一个类似于Class.getDeclaring class 的方法，只是该方法返回的是一个 Type 对象。
与Typevariable对象相似，ParameterizedType 对象也是按需创建的，并且它们并总不
是相同的对象，所以我们应该使用equals而不是==来检查参数化类型的等同性。在创建参
数化类型时，同时也将创建它的所有类型引元，并且该过程将递归执行。以上两个方法有时会
抛出 TypeNotFoundException或MalformedParameterizedTypeException异常。
最后，ParameterizedType 对象也有getRawType方法，该方法返回参数化类型的原始类
的Class 对象。例如，如果在参数化类型 List<String>上调用getRawType,我们将得到
List.class 对象。就像我们在 TypeDesc程序中看到的那样，即使原始类型是由非泛型类或
接口定义的，getRawType方法返回的也将是Type实例而不是Class<?>,所以必须执行强
制转型。
16.9.3 通配符
通配符类型参数是由实现了wildcardType接口的实例表示的。例如，给定List<? ex tends Number>的参数化类型，getActualTypeArguments方法将返回一个长度为1的数组，
该数组包含一个表示"? extends Number"的WildcardType 对象。
wildcardType有两个方法：getupperBounds 和getLowerBounds,它们分别返回表示通
配符的上界和下界的Type 数组。如果没有指定任何上界，那么其上界就是Obiect类。如果没
有指定下界，getLOwerBounds 就将返回一个空数组。
与Typevariable一样，边界的类型对象是按需创建的，因此可能会抛出TypeNotPre sentException或MalformedparameterizedTypeException异常。
16.9.4 泛型数组
最后一个类型相关的接口是GenericArrayType,它表示数组类型，这些数组类型包含的
427
428
292 第16章 反 射
元素类型是参数化类型或类型变量'。GenericArrayType只有一个getGenericcomponent Type方法，该方法返回数组中元素类型的Type 对象，而这个对象是一个ParameterizedType
对象或Typevariable对象。例如，对于List<String>[]域，getGenericType方法将返
回一个GenericArrayType 对象，该对象的getcomponentType方法将返回List<String>
对应的Parameterizedrype 对象。
当调用getGenericcomponentType方法时，元素的类型对象会创建，此时你可能会如期望
那样得到一个TypeNotPresentException或MalformedparameterizedTypeException异常。
16.9.5 Type 对象的字符串表示
上面描述的所有接口都没有定义 tostring方法或是其他任何通用的获取类型的字符串表
示的方法，只有Typevariable是个例外，它有一个getName方法。然而，所有的类型对象都
有已定义的 tostring方法，但是由于没有任何规范用来说明 tostring方法应该为Type 对象
返回些什么,所以我们不能依靠 tostring方法来给出类型的合理表示。如果我们想要得到类
型的字符串表示，就需要根据可获得的信息自己去组装它。例如，如果某个wildcardType 对
象没有任何X类型的上界和下界，那么它所对应的通配符就是"? extends x"。对于 Parame terizedType,我们可以使用原始类型和实际的参数类型来构造其字符串表示。
练习16.9:使用反射编写一个程序，该程序将打印某个具名类的完整声明，包括除了 import
语句、注释，以及初始器、构造器和方法中的代码之外的所有信息。成员声明应该像你编写代码时
那样显示，你将需要使用所有已经学习过的反射类。同时请注意，许多反射对象的 tostring 方
法提供的信息并非是你想要的正确格式，所以你需要将一条条独立的信息拼接到一起。
16.10 数组
数组是没有成员的对象——数组中隐式的 length“字段”并不是实际的字段。向数组的
Class 对象查询域、方法或构造器将会产生空数组。为了创建数组并获取(get)或设置(set)
存储在数组里的元素的值，我们可以使用Array类的静态方法。我们可以使用以下两个ne WInstance 方法中的任意一个来创建数组：
·public static object newInstance(Class <?> componentType,int length):
该方法返回一个指定长度的新数组，该数组的元素类型是componentType。
·public static Object newInstance(Class <?> componentType,int[] dimen sions):该方法返回一个多维数组的引用，其维数是由dimensions 数组中的元素指定
的，其元素类型是由componentType指定的。如果 dimensions 数组为空或者数组的
维数超过了数组实现所允许的上限(通常为255),该方法就会抛出IllegalArgumen tException异常。
对于基本数据类型，要使用类字面常量来获取 Class 对象。例如，要使用 byte.class来
创建byte数组。语句
1.你可能还记得我们不能创建这样一个数组，但是我们可以声明这种类型的变量。实际的数组创建可以只使用无
界的通配符类型，例如 new List<?>[1]。当我们首次将这个新数组赋值给更具体的变量时，例如List<
String>[],由于编译器不能保证数组当前或将来的内容确实提List<String>对象，所以我们将会得到“不
受检查”的警告。这样的数组原本就是不安全的，因此在使用时应格外当心—通常我们不应该创建返回这种
数组或将这种数组作为参数的方法。
16.10 数 组 293
byte[] ba =(byte[])Array.newInstance(byte.class,13);
等价于
byte[] ba = new byte[13];
第二个 newInstance方法接受的是一个多维数组。语句
int[] dims ={4,4};
double[][] matrix=
(double[][])Array.newInstance(double.class,dims);
等价于
double[][]matrix= new double[4][4];
由于元素类型本身也可以是数组类型，所以所创建数组的实际维数可能会大于传递给ne WInstance方法的引元所指示的参数。例如，如果 intArray是int[]类型对应的Class 对
象，那么Array.newInstance(intArray,13)调用就会创建一个 int[][]类型的二维数组。
当 componentType是数组类型时，所创建数组的元素类型就是componentType的元素类型。
因此，在前面的int[][]例子中，其结果元素类型为int。
Array 的静态getLength 方法将返回给定数组的长度。
Array类还拥有用来获取和设置指定数组中的单个元素的静态方法，它们与 Field类的
get和 set方法类似。通用的get和 set方法可以操作Object,例如，给定一个int 数组xa,
xa[i]的值可以像下面这样以较费力但较不清晰的方式来获得：
Array.get(xa,i)
该方法返回一个Integer 对象，我们必须解包该对象才能抽取其中的int值。我们可以用类似
的方式来设置数组元素的值：xa[i]=23与下面这种看起来比较笨拙的语句是等效的：
Array.set(xa,i,23);
如果作为数组传入的对象实际上不是数组，我们将会得到IllegalArgumentException异常。
如果要设置的值(在需要时解包后)不可赋值给数组的元素类型、那么我们也会得到Illeaal.
ArgumentException异常。
Array类还为所有基本类型提供了一组完整的 get Type和 set Type方法，例如下面语句
所用到的方法：
Array.setInt(xa,i,23);
这些方法可以避免使用中间的包装器对象。
泛型数组和动态数组
让我们回忆一下第11章的 SingleLinkQueue类的 toArray方法，当时我们承诺将展示怎
样通过传入队列的实际类型引元所对应的类型符号来直接创建数组(而并非传入数组)。下面
是我们给出的第一个版本：
public E[] toArray_v1(Class<E> type){
int size= size();
E[] arr=(E[])Array.newInstance(type,size);
int i=0;
for(Cell<E> C= head;
C!= nu11 &&i<size;
C= C.getNext(O)
arr[i++]=C.getElement();
return arr;
429
430
}
431
294 第16章 反 射
这段代码能够工作，但是它没有接受待填充数组的泛型版本那么令人满意，主要问题是上述代
码将导致编译器发出“非检查型”警告。就像我们所注意到的那样，转型到E[]的强制转换涉及
到了类型参数，并且这种强制转换在运行时具有不同的意义——实际的强制转换将转换为Ob ject,它是E的擦除。尽管这样，上述代码仍然明显是类型安全的：我们请求一个元素类型为
E的数组，并尝试着将返回对象作为这样的数组来使用。出现的“非检查型”警告是由Array
API的局限性所导致的，并且无法避免。
上述代码的第二个问题是它具有与最初的非泛型版本 toArray 方法相同的限制—它只
允许创建具有精确的指定元素类型的数组，而不能创建任何超类型的数组。我们可以通过把当
前的版本转化为泛型方法来解决这个问题，如前所做的：
public <T> T[] toArray(Class<T> type){
int size = sizeO);
T[] arr=(T[])Array.newInstance(type, size);
int i=0;
Object[] tmp= arr;
for(Cel1<E> C= head;
C != nu11 && i< size;
c= c.getNext()
tmp[i++]= Cc.getElement();
return arr;
}
这个版本仍然有不可避免的“非检查型”警告，但是它允许传入任何Class 对象并返回具有指
定元素类型的数组。与接受数组作为引元的泛型版本一样，这个版本依赖运行时的数组存储检
查来保证传入的元素类型确实与当前队列的元素类型兼容。
于是，现在有了两个方式来处理 toArray 需求：让调用方传入数组，这样可以避免警告，
但是必须处理具有错误大小的数组；或者让调用方传入元素类型的类型符号，这样可以创建具
有正确大小的数组，但是不得不面对“非检查型”的警告。或者，我们也可以像集合类那样将两
者结合使用：接受一个数组，如果数组的大小不对，就动态地创建另一个数组，同时得到警告信
息。但是我们一般建议应该尽一切代价避免“非检查型”的警告，而Array.newInstance是一
个例外。
练习16.10:进一步修改Interpret,使得用户可以指定待创建数组的类型和大小；可以设
置和获取数组元素的值；可以在指定的数据元素上访问域并调用方法。
16.11 包
如果我们在Class 对象上调用getPackage方法，就可以得到描述该类所在包的Package
对象(Package类是在java.1ang 中定义的)。我们也可以用包名通过调用静态方法 getPack age 或者调用静态方法getPackages(该方法返回由系统中所有已知包构成的数组)来获得
Package 对象。getName方法可以返回包的全名。
Package 对象的使用与其他反射类型完全不同，即我们不能在运行时创建或操纵包。我们
可以使用Package对象来获取有关包的信息，诸如包的用途、谁创建了包、包的版本等。我们将
把这些内容延后到第18章详细介绍包时再讨论。
1.对于那些支持“非检查型”的警告类型的编译器，这种情形正是在15.6节介绍的@ suppress warnings 注解的
理想的用武之地。
16.12 Proxy类 295
16.12 Proxy类
Proxy类允许我们在运行时创建实现了一个或多个接口的类。这是一个高级特性，尽管很
少会用到它，但是在需要时它就显得非常有用。
例如，假设我们想要记录调用对象的日志，以便在发生故障时可以打印最后几个在该对象
上调用过的方法。我们可以为特定的类手工编写这样的代码，并对某特定对象打开这一功能，
但是这需要我们对想要监视的每一种对象类型都手工地编写代码，同时每一个对象都需要对每
一个方法调用进行检查，以查看这些调用是否有必要记录日志。
我们应该编写一个通用工具，让它使用Proxy创建的类去记录调用历史。由该类创建的对
象将实现相关接口，并在调用方对方法的调用和该对象对方法的执行之间插入我们提供的代
码。
Proxy模型是这样的：调用Proxy.getProxyclass方法，调用时传入一个类装载器和一
个接口数组，这样就可以得到对应于代理类的Class 对象。代理对象拥有一个构造器，我们需
要将一个InvocationHandler 对象传递给它。我们可以从代理类的Class 对象中得到这个构
造器对应的 Constructor 对象，并且可以在该 class 对象上调用newInstance方法(传入一
个调用处理器)来创建代理对象。所创建的代理对象实现了所有传给 getProxyclass方法的接
口以及Object类中的方法。作为一条捷径，我们也可以调用Proxy.newProxyInstance来直
接得到代理对象，该方法将接受三个参数：类加载器、接口数组和调用处理器。当在代理对象上
调用方法时，这些方法的调用会转变成对调用处理器的 invoke方法的调用。
现在让我们来看看通用的调试日志类的代码：
public class DebugProxy implements InvocationHandler {
private final Object obj; // underlying object
private final List<Method> methods;// methods invoked
private final List<Method> history;// viewable history
private DebugProxy(Object obj){
this.obj= obj;
methods = new ArrayList<Method>();
history = Collections.unmodifiableList(methods);
}
public static synchronized Object proxyFor(Object obj){
Class<?> objClass = obj.getClassO);
return Proxy.newProxyInstance(
objClass.getClassLoader(),
objClass.getInterfaces(),
new DebugProxy(obj));
}
public Object
invoke(Object proxy,Method method,Object[] args)
throws Throwable
{
methods.add(method);// log the call
try {
// invoke the real method
return method.invoke(obi,args):
}catch(InvocationTargetException e){
432
433
434
296 第16章 反 射
throw e.getCauseO);
}
}
public List<Method> getHistoryO{ return history;} }
如果我们需要针对给定的对象调试代理类，只需调用proxyFor方法，例如：
object proxyobj= DebugProxy.proxyFor(realobj);
proxyobj对象会实现 realobj对象所实现的全部接口以及object类的方法，它还和所创建
的 DebugProxy实例建立了关联——这个实例是proxy的调用处理器。当我们在 proxyObj对
象上调用方法时，会导致在与其相关的 DebugProxy实例上调用 invoke方法，同时传递给该
方法的有作为proxy 对象的proxyobj。表示被调用方法的 Method对象，以及传递给被调用方
法的所有引元。在我们的例子中，invoke方法首先通过将被调用方法添加到被调用方法列表
中来记录日志，然后又在底层的 realobj对象上调用该方法，其中 realobj对象存储在 obj
字段中。
这个proxy 对象上的方法调用的(只读)记录可以从该对象的DebugProxy实例中获得，而
这个 DebugProxy实例又可以通过将proxy 对象传入 Proxy类的静态方法 getInvocationHan dler而得到：
DebugProxy h=
(DebugProxy)Proxy.getInvocationHandler(proxyObj);
List<Method> history = h.getHistoryO;
如果我们不使用newProxyInstance 这条捷径，我们就需要在ProxyFor中编写以下代码：
Class<?> objClass = obj.getClass();
Class<?> proxyClass = Proxy.getProxyClass(
objClass.getClassLoader(),
objClass.getInterfaces());
Constructor ctor = proxyClass.getConstructor(
InvocationHandler.class);
return ctor.newInstance(new DebugProxy(obj));
调用处理器的 invoke方法可能会抛出 Throwable异常。然而，如果 invoke方法抛出了
原方法不能抛出的异常，那么方法调用者就会得到 UndeclaredThrowableException异常，
通过该异常的getCause方法可以得到引发该异常的异常。
如果我们用相同的参数(相同顺序的相同的类加载器和接口)调用两次 getProxyclass方
法，会得到相同的Class对象。如果接口的顺序不同，或者类加载器有所区别，那么我们将得
到不同的Class 对象，之所以与接口顺序相关是因为列表中的两个接口有可能具有相同的名字
和签名的方法。如果发生了这种情况，那么对于传递给 invoke的Method 对象，其声明类就是
所列出的声明了该方法的第一个接口(这是由接口和超接口的深度优先搜索所定义的)。
对于Object类的公共非final方法——equals、hashcode 和 tostring,其声明类总是
object.class,而Object的其他方法没有被“代理”,这些方法直接由代理对象自己来处理，
没有通过调用 invoke方法。最重要的是，这意味着代理对象的锁仅仅只是作用于代理的锁，
无论代理使用了什么对象来完成其操作(例如，在我们的例子中，代理对底层对象的方法调用
进行了跟踪)都不会涉及到加锁、解锁，包括wait、notifyAl1和notify。
我们可以使用静态方法Proxy.isProxyClass来判断一个Class对象表示的是否是动态
16.13 加 载 类297
创建的proxy 对象。
16.13 加载类
Java运行时系统会根据需要加载类，而加载类的细节会因Java虚拟机实现的不同而有所不
同，但是大多数实现都使用类路径(class path)机制来搜索在代码中引用的尚未加载到运行时系
统中的类。类路径是系统用来寻找类文件的位置列表，这种默认机制在大多数情况下能很好地
发挥作用，但Java虚拟机的强大之处是它能够从对应用程序有意义的地方加载类。为了让应用
程序以非默认的方式加载类，我们必须提供可以获取类的字节码并把它加载到Java 运行时系统
中的ClassLoader 对象。
例如，我们可能建立了一个游戏，任何玩家都可以用他们选择的策略来编写类进行游戏，
该游戏的设计如图16-2所示：
/
玩家 玩家
服务器
游戏程序
SneakyPlayer
DumbPlayer Bo1dPlayer 类文件 ShyPlayer
图 16-2
为了达到这个目的，我们将提供一个抽象类Player,让玩家扩展它以实现自己的策略。当
玩家准备使用自己的策略时，他们会将编译过的类字节码发送给我们的系统。这些字节码需要
被加载到游戏中，然后通过与其他玩家对战来进行计算，并将得分返回给玩家。
在服务器端，游戏程序将加载所有正在等待的 Player类，创建新类型的对象，再根据游戏
算法运行其策略。当结果被计算出来时，它们就会被报告给提交策略的玩家。
我们并未指定通信机制，但是它跟电子邮件系统一样简单，玩家通过邮件发送自己的类，
并接收回复邮件中的结果。
本例中有趣的部分是，游戏程序是如何将编译过的类文件加载到运行时系统中的。这正是
类加载器(class loader)的职责，它必须扩展抽象类ClassLoader,并覆盖其 findclass方法：
·protected class<?> findclass(String name)throws ClassNotFoundExcep tion:该方法定位表示 name类的字节码，并将其加载到虚拟机中，最后返回所创建的
表示这个类的Class 对象。
在这个例子中，我们将提供一个PlayerLoader类，用来从玩家的类中读入字节码，并将
它们安装为可用类，实现这一目的的基本循环如下：
public class Game {
public static void main(String[] args){
435
436
437
298 第16章 反射
String name;// the class name
while((name= getNextPlayer())!= nu11){
try {
PlayerLoader loader= new PlayerLoader();
Class<? extends Player> classof =
loader.loadClass(name).
asSubclass(Player.class);
Player player= classOf.newInstance();
Game game = new Game();
player.play(game);
game.reportScore(name);
}catch(Exception e){
reportException(name,e);
}
}
}
// ...definition of other methods ...
}
每个新游戏都会创建一个新的PlaverLoader 对象，用来为游戏的本次运行加载类。新的类加
载器使用loadclass方法加载类，并返回表示该类的Class 对象。这个 Class 对象是用来创
建Player类的新对象的，接着我们又创建了新的 game 对象，并开始游戏。当游戏结束后，会
向玩家报告得分。如果每次运行游戏时没有使用新的类加载器，那么试图加载与某个已加载类
同名的类就只能返回这个已加载类的Class 对象，这使得玩家无法提交他自己的同名类的升级
版本。
对于给定的Class 对象，通过它的getclassLoader方法，我们可以得到加载它的类加载
器。系统类不需要类加载器，所以对该方法的调用可能会返回 nul1。
类加载器定义了命名空间(namespace),能将应用程序中的类从中分离出来。如果两个类
有不同的类加载器，那么它们就是有差异的类，即使它们都是从同一个类文件中读取的类的二
进制数据。每个有差异的类都维护着它自己的静态变量集，对其中一个类的静态变量的修改不
会影响到其他从同一个类文件中加载的类。
每个线程都有一个相关联的ClassLoader 对象，在默认情况下将使用它来加载类。这个
上下文类加载器(context class loader)可以在创建线程时指定；如果没有指定，则使用父线程的
上下文类加载器。第一个线程的上下文类加载器通常就是加载应用程序的那个类加载器，即系
统类加载器(system class loader)。Thread 类的 getcontextclassLoader 和 setContext ClassLoader方法可以让我们获取和设置线程的上下文类加载器。
16.13.1 classLoader类
类加载器可以将加载类的职责委托给它的父类加载器(parent class loader),这个父类加载
器可以通过构造器引元来指定：
·protected ClassLoaderO:该方法将创建一个类加载器对象，该类加载器对象将系统
类加载器作为其隐式的父类加载器，而系统类加载器是通过getSystemclassLoader方
法得到的。
· protected ClassLoader(ClassLoader parent):该方法将创建一个类加载器对象，
该类加载器具有指定的父类加载器。
16.13 加 载 类 299
用于其他类的泛化的类加载器应该同时提供这两种形式的构造器，使我们可以显式地设置它的
父类加载器。
系统类加载器通常就是虚拟机用来加载应用程序的初始类的加载器，我们可以从静态方法
getsystemclassLoader中得到对它的引用。
引导(bootstrap)类加载器用来载入那些属于虚拟机的类(像Object、String、List等这些
类),这些类通常被引用为系统类(system class),这个术语可能会引起一定程度的混淆，因为系
统类是由引导类加载器加载的，而应用类是由系统类加载器加载的。引导类加载器可以由实际
的ClassLoader对象来表示，但也可以没有实际的ClassLoader 对象，因此在一个系统类的
实例上调用getclassLoader方法通常会返回nul1,用来表示它是由引导加载器加载的。
我们可以在类加载器上调用getParent方法来查询其父类加载器，如果该类加载器的父类
加载器是引导类加载器，那么 getParent方法可能会返回nul1。
类加载器机制是安全架构的组成部分之一(见23.5节“安全”),所以创建类加载器及查询
父类加载器都要受到安全检查，因此有可能会抛出 SecurityException异常。
ClassLoader类的主要方法就是loadclass:
· public class<?> loadclass(String name)throws ClassNotFoundException:
该方法返回具有指定二进制名的类的Class 对象，必要时会加载该类。如果该类不能加
载，就会抛出ClassNotFoundException。
loadclass的默认实现通常不会被覆盖，它将按照下面的步骤来加载类：
1.调用findLoadedclass来检查指定的类是否已经被加载。ClassLoader维护着一张
class对象表，用来记录当前类加载器已经加载的所有类。如果该类已经加载，findLoaded Class就会返回已有的Class 对象。
2.如果指定的类没有被加载，就调用父类记载器的 loadclass方法：如果当前类加载器没
有父类加载器，那么就使用引导类加载器。
3.如果指定的类仍没有被加载，则调用 findclass方法来定位和加载该类。
请注意，Java 虚拟机总是将加载给定类的机会先赋予父类加载器；并且只有在引导加载器
和系统类加载器加载给定类失败的情况下，我们自定义的类加载器才会有机会去执行。这意味
着我们编写的类加载器必须在与系统或引导类加载器不同的搜索路径下寻找类。
PlayerLoader类扩展了ClassLoader类，并覆盖了findclass方法：
class PlayerLoader extends ClassLoader {
public Class<?> findClass(String name)
throws ClassNotFoundException
{
try {
byte[] buf = bytesForClass(name);
return defineClass(name,buf,0,buf.1ength);
} catch(IOException e){
throw new ClassNotFoundException(e.toString(O);
}
}
// ... bytesForClass,and any other methods ...
}
findclass方法一般要执行两个动作：首先，它要定位指定类的字节码，并将它们加载到
438
300 第16章 反 射
一个字节数组中———在我们的例子中这是bytesForclass方法的任务；其次，它要使用defi-
439 neclass 工具方法将这些字节所定义的类实际加载到虚拟机中，然后返回该类的Class 对象。
· protected final class<?> defineclass(String name,byte[] data,int off set, int length)throws ClassFormatError:该方法返回指定的具名类的Class对
象，该类的二进制表示存放在data数组中。在data数组中，只有从offset到offset
+length-1这个范围内的字节被用来定义该类。如果这个子数组中的数据不能构成合
法的类文件格式，就会抛出ClassFormatError异常。defineclass方法负责将Class
对象存入 findLoadedclass方法要用来进行查找的已加载类列表中。
defineclass的另一种重载形式需要一个额外的ProtectionDomain引元，而上面的形
式使用的是默认的保护域。保护域定义了该域中的对象的安全许可权限，见23.5节“安全”。
defineclass 方法的两种形式都可能会抛出 SecurityException异常。
在定义类之前，我们必须先读入该类的字节码，这就是bytesForclass方法的目的：
protected byte[] bytesForClass(String name)
throws IOException,ClassNotFoundException
{
FileInputStream in= null;
try {
in= streamFor(name +".class");
int length= in.availableO;// get byte count
if(length==0)
throw new ClasSNotFoundException(name);
byte[] buf= new byte[length];
in.read(buf); // read the bytes
return buf;
} finally {
if(in != null)
in.close();
}
}
该方法假定存放类的字节码的文件名称为类名加上“.class”后缀，然后使用 streamFor方法
(在上面未展示)得到了一个用于读取类的字节码的 FileInputStream 对象——StreamFor知
道应该在哪里搜索要加载的类文件。我们接着创建了一个字节缓冲区，将数据读入该缓冲区，
并返回这个缓冲区。
440
当类成功加载之后，findclass方法返回由 defineclass方法返回的新的Class 对象。
当不再需要某个类时，我们无法显式地卸载它，我们只需停止对它的使用，这会使得该类在它
的ClassLoader不可达时，能够被当作垃圾回收。
练习16.11:在Game和Player类的基础上实现一个简单的游戏，如填字游戏(tic-tac toe)。多次运行这个游戏，并对各种player实现进行打分。
16.13.2 为类的使用做准备
在让类可用的过程中，类加载器只实现了第一步，而完整的过程总共有3步：
1.加载：得到实现了类的字节码，并创建Class 对象。
2.链接：验证类的字节码是否遵循语言规范，通过为静态字段分配空间来准备虚拟机，并
(可选地)解析类中的所有引用，必要时会加载被引用的类。
3.初始化：首先初始化超类(必要时还要加载和链接它),然后执行类中所有的静态初始化
16.13 加 载 类301
器和静态初始化块。
defineclass 方法返回的Class 对象仅表示被加载的类——它还没有被链接。我们可以
通过调用 resolveclass(这个名字起得很糟糕)方法来显式地链接：
·protected final void resolveclass(Class<?> C):如果指定类尚未链接就链接
该类。
我们前面讲到的loadclass方法不能解析已加载的类。loadclass方法还有一个受保护
的重载形式，它需要一个额外的boolean标志来标明是否要在返回前解析类。虚拟机可以保证
类在初始化之前已经完成解析(链接)。
类必须在第一次发生下列任何情况之前立即执行初始化：创建类的实例；调用类的静态方
法；访问类的非 final静态字段。这其中包括使用反射方法来实现这些操作的情况。此外，在嵌
套类型内部执行 assert语句之前，顶层包围类(如果有的话)必须被初始化。使用反射直接加
载类也可能会触发初始化——例如使用Class.forName(name),但是请注意，对类字面常量
的简单使用并不会触发初始化。
16.13.3 加载相关资源
类是程序所需的主要资源，但是有些类还需要其他的相关资源，例如文本、图像或声音。类
加载器可以用多种方式来查找类资源，它们可以使用相同的机制来得到与类一起存储的其他任
何资源。在我们的游戏例子中，特定的游戏策略可能包含一本相关的“书”,这本书将告诉程序
应该如何对各种场景做出响应。下面这段代码出现在 Boldplayer类中，它可以得到一个用来
获取这本书的InputStream 对象：
String book ="BoldPlayer.book";
InputStream in;
ClassLoader loader = this.getClass().getClassLoader(O);
if(loader != nul1)
in= loader.getResourceAsStream(book);
else
in= ClassLoader.getSystemResourceAsStream(book);
系统资源与系统类是相关联的(系统类可能没有相关联的类加载器实例),但是ClassLoader
的静态方法 getsystemResourceAsStream可以返回用于指定资源的 Inputstream 对象。上
面这段代码检查当前类是否有对应的类加载器：如果没有，就使用引导类加载器来加载指定的
类；否则，就调用对应的类加载器上的getResourceAsStream方法，将资源名转化为字节输入
流。如果资源没有找到，则加载资源的方法返回nul1。
class类也提供一个getResourceASStream方法，但是它简化成了从类的类加载器获取
资源，因此前面的代码可以改写为下面这种更简单的形式：
String book = "Boldplayer.book";
Inputstream in = Boldplayer.class.getResourceAsStream(book);
资源名必须由一个或多个由斜杠“/”分隔的有效标识符构成，它指定了资源的路径。通常，
类加载器将在与搜索类文件相同的路径下搜索资源。
其他两个资源方法 getResource和getsystemResource将返回用来命名资源的 URL 对
象。java.net.URL类将在25.5节进行简要介绍；它提供的方法可以用统一资源定位符来访问
资源。我们可以在类加载器的方法所返回的 URL对象上调用getcontents方法，来获得表示
这个URL对应内容的对象。
441
442
443
302 第16章 反 射
getResources方法将返回一个java.uti1.Enumeration类型的对象(我们之前看到过
的Iterator类型的一种较老的变体),它可以遍历给定资源名下存储的所有资源的 URL对象。
静态方法getSystemResources 只针对系统资源实现了同样的功能。
这些获取资源的方法首先向父类加载器请求资源，如果没有任何父类加载器，它们就向引
导类加载器请求资源。如果资源无法定位，就调用findResource 或 findResources 方法。
就像 loadclass是构建在我们在子类化ClassLoader 时所提供的findclass方法的基础之
上一样，这些资源获取方法也是构建在两个资源查找方法的基础之上的，我们可以覆盖这两个
方法以实现自己的资源查找逻辑：
· public URL findResource(String name):该方法返回具有指定资源名的URL 对象，
或者在资源无法定位时返回nul1。如果有多个具有相同名字的资源，那么就由该方法
的实现来决定应该返回其中的哪一个。ClassLoader 中的默认实现总是返回nul1。
·public Enumeration<URL> findResources(String name):该方法返回一个包含
所有具有指定名字的资源的 Enumeration对象。ClassLoader中的默认实现是返回一
个包含零个资源的 Enumeration 对象。
下面是PlayerLoader类的 findResource方法：
public java.net.URL findResource(String name){
File f= fileFor(name);
if(!f.exists())
return nul1;
try {
return f.toURL(O);
} catch(java.net.MalformedURLException e){
return nul1; // shouldn't happen
}
}
fileFor方法与PlayerLoader的streamFor方法类似，它返回一个java.io.File对象，该
对象对应于文件系统中的具名资源。如果具有指定名字的文件确实存在，就会从它所在的路径
上创建一个对应于该资源的 URL 对象。(File类表示的是文件系统中的路径名，见20.7.3节
“File类”。)
Boldplayer类可能会与 Boldplayer.book 一同加载，因为Boldplayer.book可以在类
文件的存储位置找到。我们可以将这个版本的“书”替换为我们自己的“书”,要实现这一点，只
需直接将我们的“书”放置到系统类加载器或引导加载器会首先查找的路径下。
练习16.12:修改你所完成的练习16.11的答案，通过实现 findResource 和 findRe sources 方法，允许玩家改变策略以使用附加资源。
16.14 在运行时控制断言
在第12章中我们已经学习了有关断言和怎样通过向虚拟机传递命令行选项来开启和关闭
断言的知识(见12.10节)。我们也可以改变运行代码中断言运算，虽然这种方式很少用到。如
果我们在编写控制运行其他代码的程序，并且必须为用户提供管理断言的各种选项，那么我们
就很可能需要用到这种方式。这样的操作可以通过ClassLoader上的下列方法来完成：
·public void setDefaultAssertionStatus(boolean enabled):该方法设置所有由
该类加载器加载的所有类的默认断言状态，而子加载器无论存在于该方法调用之时还是
16.14 在运行时控制断言 303
之后，都不会受到影响。类加载器初始的默认断言状态值为 false。
·public void setPackageAssertionStatus(String packageName,boolean ena bled):该方法设置指定包及其子包中由该类加载器加载的所有类的默认断言状态。名
字为 nu11的包表示该类加载器的未命名包，见第18章。
·public void setclassAssertionStatus(String className,boolean enabled):
该方法在加载指定类时设置该类及其所有嵌套类的默认断言状态。我们可以只命名顶层
类，因为嵌套类的断言开关是通过其包围类来控制的。
·public void clearAssertionStatusO:该方法清除(关闭)该类加载器的所有断言，
其先前的所有断言设置都将被清除，无论这些设置是通过方法调用来实现的，还是命令
行来实现的。
在所有情况下，这些设置只会作用于将来要加载并初始化的类———旦某个类被加载，我们就
不能改变其断言状态了。更具体地讲，断言状态在类初始化时就建立好了：在其超类初始化后，
但是在执行任何静态初始化器之前。
像命令行选项一样，类相关的声明优先于包相关的声明，而包相关的声明又优先于类加载
器的默认状态。事实上，命令行选项将直接请求虚拟机在类加载器上调用适当的方法。因此以
下命令行选项
-da:com.acme.Evaluator -ea:com.acme...
等价于调用
loader.setclassAssertionStatus("com.acme.Evaluator",false);
loader.setPackageAssertionStatus("com.acme",true);
其中 loader是将要使用的类加载器。(请注意，这些方法没有用命令行所使用的...语法，因
为对于名字来说，它引用的是包还是类这一点是透明的。)
有一说一，不要含混其辞。
——爱默生(美国思想家、文学家)
目录
第1章　快速浏览
 1.1 开始
 1.2　变量
 1.3　代码中的注释
 1.4　具名常量
 1.5　Unicode字符
 1.6　控制流
 1.7　类和对象
 1.7.1　创建对象
 1.7.2　静态字段（类字段）
 1.7.3　垃圾回收器
 1.8　方法和参数
 1.8.1　调用方法
 1.8.2　this引用
 1.8.3　静态方法（类方法）
 1.9　数组
 1.10　字符串对象
 1.11　扩展一个类
 1.11.1 调用超类的方法
 1.11.2　Object类
 1.11.3 类型强制转换
 1.12　接口
 1.13　泛型类型
 1.14　异常
 1.15　注解
 1.16　包
 1.17　Java平台
 1.18　其他主题概述
第2章　类与对象
 2.1　一个简单的类
 2.1.1 类成员
 2.1.2　类修饰符
 2.2　字段
 2.2.1 字段的初始化
 2.2.2　静态字段
 2.2.3　final字段
 2.3　访问控制
 2.4　创建对象
 2.5　构造与初始化
 2.5.1 构造器
 2.5.2　初始化块
 2.5.3　静态初始化
 2.6　方法
 2.6.1　静态方法
 2.6.2 方法调用
 2.6.3 引元数量可变的方法
 2.6.4　方法异常与返回
 2.6.5　参数值
 2.6.6　使用方法来控制访问
 2.7 this
 2.8　重载方法
 2.9　导入静态成员名
 2.10　main方法
 2.11　本地方法
第3章　类的扩展
 3.1 扩展类
前言
目录
第1 章 快速浏览
开始 1 .1
变量 1 .2
3
45 U n i CO d e 字符
6 控制流
7 类和对象
代码中的注释
具名常量
1 创建对象 7 .1 1 . 7 .2 静态字段(类字段) 1 . 7 .3 垃圾回收器 8 1 . 方法和参数
1 . 调用方法 8 . 1
t h i S 引用 1 .8 .2
1 .8 .3 静态方法(类方法)
1 . 9 数组
1 .1 0 字符串对象
1 .1 1 扩展一个类
1 . 1 1 .1
1 .1 1 .2O b j e C t 类 1 .1 1 .3 类型强制转换
调用超类的方法
1 .1 2接口
泛型类型
异常
注解
1.17 J a V a 平台
1 . 1 8 其他主题概述
第2 章 类与对象
.2 .3 11d1于F又
创建对象
 子自甘念 RJNH
m a i n 方法
本地方法 乙.1
第3 章 类的扩展
3 .1 扩展类
 3.2　扩展类的构造器
 3.3　继承与重定义成员
 3.3.1　覆盖
 3.3.2　隐藏字段
 3.3.3　访问继承的成员
 3.3.4　可访问性与覆盖
 3.3.5　隐藏静态成员
 3.3.6　super关键字
 3.4　类型兼容与转换
 3.4.1 兼容性
 3.4.2　显式的类型强制转换
 3.4.3　类型检测
 3.5　protected的真正含义
 3.6　将方法与类标记为final
 3.7　抽象类与抽象方法
 3.8　Object类
 3.9　克隆对象
 3.9.1　克隆的策略
 3.9.2　正确克隆
 3.9.3 浅克隆与深克隆
 3.10　扩展类：如何扩展以及何时扩展
 3.11　设计一个可扩展的类
 3.12　单重继承与多重继承
第4章　接口
 4.1　一个简单的接口示例
 4.2　接口声明
 4.2.1　接口常量
 4.2.2　接口方法
 4.2.3　接口修饰符
 4.3　扩展接口
 4.3.1　继承和隐藏常量
 4.3.2　继承、覆盖和重载方法
 4.4　使用接口
 4.4.1 实现接口
 4.4.2　使用实现
 4.5　标记接口
 4.6　何时使用接口
第5章　嵌套类和接口
 5.1　静态嵌套类型
 5.1.1　静态嵌套类
 5.1.2　嵌套接口
 5.2　内部类
 5.2.1 访问包围对象
 5.2.2　扩展内部类
 5.2.3　继承、作用字段和隐藏
 5.3　局部内部类
 5.4　匿名内部类
 5.5　继承嵌套类型
 5.6　接口中的嵌套
 5.7　嵌套类型的实现
第6章　枚举类型
 6.1　一个简单的枚举类型的例子
 6.2　枚举声明
 6.3　枚举常量的声明
 6.3.1　构造
 6.3.2　常量相关的行为
 6.4　java.lang.Enum
 6.5　是否应该使用枚举
3.2 扩展类的构造器
3.3 继承与重定义成员
3.3.1 覆盖
3 .3 .2 隐藏字段
3 .3.3 访问继承的成员
3 . 4 可访问性与覆盖 3 .
3. 5 隐藏静态成员 3 .
3 .6S u p e r 关键字 3.
4类型兼容与转换 3.
兼容性 3 .4 .1
3 .4 .2 显式的类型强制转换
3.4 .3 类型检测
3 .5 p r o t e c t e d 的真正含义
3 .6将方法与类标记为f i n a 1
3.7 抽象类与抽象方法
3 .8 O b j e c t 类
3 .9克隆对象
3.9 .1 克隆的策略
3 .9 .2 正确克隆
3.9 .3 浅克隆与深克隆
3.1 0 扩展类：如何扩展以及何时扩展
3 .1 1 设计一个可扩展的类
3.1 2单重继承与多重继承
第4 章 接口
4 .1 一个简单的接口示例
4 .2 接口声明
4 .2 .1 接口常量
4 . 2 .2 接口方法
4 .2 .3 接口修饰符
4 .3扩展接口
4 .3.1 继承和隐藏常量
4 .3 .2 继承、覆盖和重载方法
4 .4 使用接口
实现接口 4 . 4 .1
4 .4 . 2 使用实现
4 .5 标记接口
4 .6 何时使用接口
第5 章 嵌套类和接口
5 .1 静态嵌套类型
5 .1 .1 静态嵌套类
5 .1 .2 嵌套接口
5 .2 内部类
访问包围对象 5 .2 .1
5 .2 .2 扩展内部类
继承、作用字段和隐藏 5 .2 .3
5.3 局部内部类
5 .4 匿名内部类
5.5 继承嵌套类型
5 .6 接口中的嵌套
5.7 嵌套类型的实现
第6 章 枚举类型
6 .1 一个简单的枚举类型的例子
6 .2 枚举声明
6 .3 枚举常量的声明
6 .3.1 构造
6 .3.2 常量相关的行为
6 .4 j a v a .1 a n g .E n u m
6.5 是否应该使用枚举
第7章　语言符号、值和变量
 7.1　词法元素
 7.1.1 字符集
 7.1.2　注释
 7.1.3　语言符号
 7.1.4　标识符
 7.1.5　关键字
 7.2　类型和字面常量
 7.2.1 引用型字面常量
 7.2.2　布尔型字面常量
 7.2.3　字符型字面常量
 7.2.4　整型字面常量
 7.2.5 浮点型字面常量
 7.2.6　字符串型字面常量
 7.2.7　类字面常量
 7.3　变量
 7.3.1 字段和局部变量的声明
 7.3.2　参数变量
 7.3.3　final变量
 7.4　数组变量
 7.4.1　数组修饰符
 7.4.2　数组的数组
 7.4.3　数组初始化
 7.4.4　数组和类型
 7.5　名字的意义
第8章　包装器类
 8.1　通用字段和方法
 8.1.1　构造
 8.1.2　常量
 8.1.3　公共方法
 8.2　Void类
 8.3　Boolean类
 8.4　Number类
 8.4.1　整型包装器
 8.4.2 浮点型包装器类
 8.5　Character类
 8.6　装箱转换
第9章　运算符和表达式
 9.1　算术运算
 9.1.1　整数运算
 9.1.2　浮点运算
 9.1.3　严格浮点运算和非严格浮点运算
 9.2　通用运算符
 9.2.1 递增运算符和递减运算符
 9.2.2 关系运算符和判等运算符
 9.2.3　逻辑运算符
 9.2.4 instanceof
 9.2.5　位操作运算符
 9.2.6　条件运算符？：
 9.2.7　赋值运算符
 9.2.8　字符串连接运算符
 9.2.9　new
 9.3　表达式
 9.3.1　计算顺序
 9.3.2　表达式类型
 9.4　类型转换
 9.4.1 隐式类型转换
 9.4.2　显式类型强制转换
第7 章 语言符号、值和变量
7 .1词法元素
字符集 7 .1 . 1
注释 7 . 1 .2
3 7 语言符号 . 1 .
7 1 .4 标识符 .
7 . 1 .5 关键字
7 . 2 类型和字面常量
7 . 2 .1
7.
222222 2
7 3
···. 7
4 5 77 6
7 7
引用型字面常量
布尔型字面常量
字符型字面常量
整型字面常量
浮点型字面常量
字符串型字面常量
类字面常量
7 .3变量
7 .3 . 1 字段和局部变量的声明
7. 3 .2 参数变量
7 .3 .3 f i n a 1 变量
7 .4 数组变量
741数组修饰符
742数组的数组
7 .4 .3 数组初始化
7 .4 .4 数组和类型
.5 名字的意义 7
第8 章 包装器类
8 .1 通用字段和方法
8 . 1 1 构造
8 .1 .2 常量
8.1 .3 公共方法
8.2 V o i d 类
8.3 B o o 1 e a n 类
8.4 N u m b e r 类
8 .4 .1 整型包装器
8.4 .2浮点型包装器类
8 . 5C h a r a C t e r 类
8 .6 装箱转换
第9 章 运算符和表达式
9 . 1 算术运算
9 .1 .1 整数运算
浮点运算 9 .1 .2
9 .1 . 3 严格浮点运算和非严格浮点运算
9 .2 通用运算符
9 .2 . 1
9 .2 .2
9 .2 .3
9 .2 .4
递增运算符和递减运算符
关系运算符和判等运算符
逻辑运算符
i n S t a n c e O f
9. 2 .5 位操作运算符
9. 2 .6 条件运算符?:
9. 2 .7 赋值运算符
928 字符串连接运算符
 ～1TJ×1 9 . 2 .9 n e w
9 .3 表达式
9 .3 . 1
9 .3.2
9 .4 类型转换
9 .4 . 1
9 .4 .2
计算顺序
表达式类型
隐式类型转换
显式类型强制转换
 9.4.3　字符串转换
 9.5　运算符优先级和结合性
 9.6　成员访问
第10章　控制流
 10.1　语句和块
 10.2 if-else
 10.3　switch
 10.4　while和do-while
 10.5　for
 10.5.1　基本的for语句
 10.5.2　增强的for语句
 10.6　标号
 10.7　break
 10.8　continue
 10.9 return
 10.10　什么？没有goto？
第11章　泛型类型
 11.1　泛型类型声明
 11.1.1　有界类型参数
 11.1.2　嵌套泛型类型
 11.2　使用泛型类型
 11.3　泛型方法和泛型构造器
 11.4　通配符捕获
 11.5　揭秘：擦除与原始类型
 11.5.1　运行时擦除
 11.5.2　重载与覆盖
 11.6　再谈寻找正确的方法
 11.7　类的扩展与泛型类型
第12章　异常与断言
 12.1　创建异常类型
 12.2　throw
 12.2.1　控制的转移
 12.2.2　异步异常
 12.3　throws子句
 12.3.1　throws子句和方法覆盖
 12.3.2　throws子句和本地方法
 12.4　try、catch和finally
 12.5　异常链
 12.6　栈轨迹
 12.7　什么时候使用异常
 12.8　断言
 12.9　什么时候使用断言
 12.9.1 状态断言
 12.9.2　控制流断言
 12.10　打开和关闭断言
 12.10.1 为什么要开关断言？
 12.10.2　在命令行控制断言
 12.10.3　彻底移除
 12.10.4　使断言成为必需的
第13章　字符串与正则表达式
 13.1　字符序列
 13.2　String类
 13.2.1　基本的String操作
 13.2.2　字符串比较
 13.2.3　字符串字面常量、等同性和内存限定
 13.2.4　创建相关字符串
 13.2.5　字符串转换
 13.2.6　字符串和char数组
9 .4 .3 字符串转换
9 .5 运算符优先级和结合性
9 .6 成员访问
第1 0 章 控制流
1 O .1 语句和块
i 2 1 O f .
3 1 .O S
hi1e和d o-w hi 1 e 4 1 O W
r 5 f 1O. O
5 1 基本的f o r 语句 1O .
5 增强的f o r 语句 1O 2
1 O . 6 标号
1 O 7 br
1 8 O
· 7 O
C
9
O
1 O . 1 O 1十么?没有g O
第1 1 章 泛型类型
1 1 .1 泛型类型声明
1 1 .1 .1 有界类型参数
1 1 .1 .2 嵌套泛型类型
11.2使用泛型类型
泛型方法和泛型构造器 3 11.
4 通配符捕获 11 .
5揭秘：擦除与原始类型 11 .
1 1 . 5 .1 运行时擦除
1 1 . 5 .2 重载与覆盖
再谈寻找正确的方法 11 6.
1 1 .7 类的扩展与泛型类型
第1 2 章 异常与断言
1 2 .1 创建异常类型
1 2 .2 t h r O w
1 2 .1 控制的转移 2 .
1 2 . 2 .2 异步异常
1 3 t h r O w S 子句 2 .
1 2 . 3.1 t h ro ws 子句和方法覆盖 1 2 . 3.2 t hro w s 子句和本地方法 12 .4 c h 和f i n a 1 1 y tr
异常链 12 .5
6 栈轨迹 1 2 .
12 . 什么时候使用异常 7
断言 1 2 8 ·
1 2 . 9 什么时候使用断言
状态断言 1 2 .9 .1
1 2 .9 .2 控制流断言
1 2 .1 O 打开和关闭断言
1 2 .1 O .1 为什么要开关断言?
1 2 .1 O .2 在命令行控制断言
1 2 .1 O .3 彻底移除
1 2 .1 O . 4 使断言成为必需的
第1 3 章 字符串与正则表达式
1 3.1 字符序列
13 .2 S t r i n g 类
13 2 .1 基本的S t r i n g 操作
1 3. 1 3.2 .3 字符串字面常量、等同性和内存限定 13 创建相关字符串 2 4。 1O·1 2 字符串转换 3 5
字符串和c h a r 数组 1 3 2 .6
字符串比较 2 .2
 13.2.7　字符串和byte数组
 13.2.8　字符集编码方式
 13.3　正则表达式的匹配
 13.3.1 正则表达式
 13.3.2　正则表达式的编译和匹配
 13.3.3　替换
 13.3.4　区域
 13.3.5　效率
 13.4　StringBuilder类
 13.4.1　修改缓冲区
 13.4.2　取出数据
 13.4.3　容量管理
 13.4.4　StringBuffer类
 13.5　使用UTF-16
第14章　线程
 14.1　创建线程
 14.2　使用Runnable
 14.3　同步
 14.3.1 synchronized方法
 14.3.2　静态synchronized方法
 14.3.3 synchronized语句
 14.3.4　同步设计
 14.4　wait、notifyAll和notify
 14.5　等待和通知的详细介绍
 14.6　线程调度
 14.7　死锁
 14.8　结束线程的执行
 14.8.1　取消线程
 14.8.2　等待线程结束
 14.9　结束应用程序的执行
 14.10　内存模型：同步和volatile
 14.10.1 同步动作
 14.10.2　final字段和安全
 14.10.3　“之前发生”关系
 14.11 线程管理、线程安全和ThreadGroup
 14.12　线程和异常
 14.12.1　不要使用stop
 14.12.2　栈轨迹
 14.13　ThreadLocal变量
 14.14　调试线程
第15章　注解
 15.1　一个简单的注解实例
 15.2　注解类型
 15.3　注解元素
 15.4　限制注解的适用性
 15.5　保存策略
 15.6　使用注解
第16章　反射
 16.1　Class类
 16.1.1 类型符号
 16.1.2　类检查
 16.1.3　检查类成员
 16.1.4　命名类
 16.1.5　通过名字获取Class对象
 16.1.6　运行时类型查询
 16.2　注解查询
 16.3　Modifier类
 16.4　成员类
1 3.2 .7 字符串和b y t e 数组
1 3.2 .8 字符集编码方式
1 3.3 正则表达式的匹配
1 3.3.1 正则表达式
1 3.3. 2 正则表达式的编译和匹配
1 3. 3. 3 替换
1 3. 3. 4 区域
13. 3. 5 效率
1 3 . r i n g
修改缓冲区 1 13 4 . ·
取出数据 2 3 4 1 .
·
3 1 4 容量管理 3 .
4 S t
13 4 4 S t r i n g B u f f e r 类
1 3 . 5 使用U T F - 1 6
第1 4 章 线程
1 4 .1 创建线程
使用R u n n a b1 e 1 4 . 2
3 同步 1 4.
3.1 1 4 S y n C h r O n i Z e d 方法
静态syyn"hh'。°n1z2ed语方法 1 4 3 . 2 。
1 4 3 3 .
1 同步设计 4 4 3 .
4 y A 1 1 和n o t i f y 14 . W a i t 、nO t
5 等待和通知的详细介绍 1 4 .
线程调度 1 4 . 6
1 4 . 7死锁
1 4 . 8 结束线程的执行
1 4 .8 .1 取消线程
1 4 .8 .2 等待线程结束
1 4 .9 结束应用程序的执行
1 4 .1 O 内存模型：同步和v o 1 a t i 1 e
1 4 .1 O .1 同步动作
1 4 .1 O .2 f i n a 1 字段和安全
1 4 .1 O .3“之前发生”关系
1 4 .11 线程管理、线程安全和T hr e a d Gro u p
1 4 . 1 2 线程和异常
1 4 . 1 4 .1 2 .1不要使用s t o p
12 .2 栈轨迹
3 T h r e a d L o c a 1 变量 1 4 .1
1 4 .14 调试线程
第1 5 章 注解
1 5 .1 一个简单的注解实例
注解类型 15 .2
注解元素 15 . 3
1 4 限制注解的适用性 5 .
5 保存策略 1 5.
5 使用注解 1 6
第1 6 章 反射
B u i 1 d e r 类
1 a s s 类 6 C1 1
1 1 类型符号 16 . .
1 1 2 类检查 6.
16 3 检查类成员 1 . .
1 命名类 1 4 6. 。
1 1 5 通过名字获取C 1 a s s 对象 6 . .
1 6 运行时类型查询 6. 1 .
16 . 2 注解查询
1 6 3 Mo d i f i e r 类
16 . 4 成员类
 16.5　访问检查和AccessibleObject
 16.6　Field类
 16.7　Method类
16.8　创建新对象和Constructor类
 16.9　泛型类型检查
 16.9.1 类型变量
 16.9.2　参数化类型
 16.9.3　通配符
 16.9.4　泛型数组
 16.9.5　Type对象的字符串表示
 16.10　数组
 16.11　包
 16.12　Proxy类
 16.13　加载类
 16.13.1　ClassLoader类
 16.13.2　为类的使用做准备
 16.13.3　加载相关资源
 16.14　在运行时控制断言