目 录
引言 ……………………………………………………………………………………………………………1
习题 ………………………………………………………………………………………………………8
注释 ………………………………………………………………………………………9
第一部分 信 息 论
第1章 熵和互信息量……………………………………………………………………13
1.1 离散随机变量……………………………………………………………………………13
1.2 离散随机矢量…………………………………………………………………………24
1.3 非离散随机变量和矢量……………………………………………………………………27
习题…………………………………………………………………………………32
注释 ………………………………………………………………………………………36
第2章 商散无记忆信道及其容量-代价函数………………………………………………38
2.1 容量-代价函数 ………………………………………………………………………………38
2.2 信道编码定理………………………………………………………………………………44
习题……………………………………………………………………………………51
注释 …………………………………………………………………………………55
第3章 离散无记忆信源及其率失真函数 ……………………………………………………57
3.1 率失真函数……………………………………………………………………………57
3.2 信源编码定理…………………………………………………………………………63
习题 ……………………………………………………………………………………68
注释 ………………………………………………………………………………………………………70
第4章 高斯信道和信源 ………………………………………………………………………72
4.1 高斯信道………………………………………………………………………………72
4.2 高斯信源………………………………………………………………………………75
习题……………………………………………………………………………………80
注释 ………………………………………………………………………………………84
第5章 信源-信道编码定理………………………………………………………………………86
习题……………………………………………………………………………………92
注释 ……………………………………………………………………………………………93
·9·
M ;3,上；
第6章 第一部分前沿课题综述 ………………………………………………………………94
6.1 引言……………………………………………………………………………94
6.2 信道编码定理……………………………………………………………………………94
6.3 信源编码定理…………………………………………………………………………99
第二部分 编码理论
第7章 线性码…………………………………………………………………………107
7.1 引官：生成和一致校验矩阵……………………………………………………………107
7.2 g进制对称信道上的伴随式译码……………………………………………………110
7.3 汉明几何和码的性能 …………………………………………………………………112
7.4 汉明码 ……………………………………………………………………………113
7.5 一般q进制信道上的伴随式译码……………………………………………………114
7.6 重量枚举多项式和MacWillians 恒等式………………………………………………117
习题……………………………………………………………………………………121
注释………………………………………………………………………………………127
第8章 循环码……………………………………………………………………………128
8.1 引言 ……………………………………………………………………………………128
8.2 循环码的移位寄存编码器 ………………………………………………………………138
8.3 循环汉明码 …………………………………………………………………………146
8.4 纠正突发错误 …………………………………………………………………………149
8.5 纠正突发错误循环码的译码 ………………………………………………………159
习题………………………………………………………………………163
注释………………………………………………………………………………………171
第9章 BCH、Reed-Solomon 码及其同类码…………………………………………………172
9.1 引言 …………………………………………………………………………172
9.2 具有循环码特性的 BCH码…………………………………………………………175
9.3 BCH码的译码，第一部分：关键方程 …………………………………………………177
9.4 多项式的欧几里得算法 …………………………………………………182
9.5 BCH码的译码，第二部分：算法 …………………………………………………………185
9.6 Reed-Solomon码……………………………………………………………189
9.7 出现删除时的译码 …………………………………………………………………197
9.8(23,12)Golay码…………………………………………………………………204
习题…………………………………………………………………………208
注释………………………………………………………………………………………217
第10章 卷积码 ………………………………………………………………………218
10.1 引言………………………………………………………………………………218
10.2 状态图、网格图及 Viterbi译码 …………………………………………………………223
·10·
10.3 路径枚举多项式和错误概率的界……………………………………………………228
10.4 序列译码………………………………………………………………………………232
习题………………………………………………………………………………………238
注释………………………………………………………………………………………244
第11章 变长信源编码 …………………………………………………………………245
11.1 引言……………………………………………………………………………245
11.2 惟一可译的变长编码………………………………………………………246
11.3 信源的匹配编码 ………………………………………………………………………248
11.4 最佳惟一可译码的构造(Huffman算法)……………………………………………249
习题………………………………………………………………………………………254
注释………………………………………………………………………………………256
第12章 第二部分前沿课题综述 ……………………………………………………………258
12.1 引言……………………………………………………………………………258
12.2 分组码…………………………………………………………………………258
12.3 卷积码……………………………………………………………………………265
12.4 分组码和卷积码的比较…………………………………………………………………266
12.5 信源编码………………………………………………………………………………268
附录A 概率理论…………………………………………………………………………271
附录B 凸函数和 Jensen 不等式 ……………………………………………………………274
附录C 有限城……………………………………………………………………………278
附录D 利用方向图求解路径枚举多项式……………………………………………………281
参考文献……………………………………………………………………………284
定理家引…………………………………………………………………………………………288
·11·
引 言
1948年，Claude Shannon'(克劳德·香农)在他的经典论文“A Mathematical Theory of Commu nication"(通信中的数学理论)的引言部分中写道：
“通信中的基本问题就是在某一点精确或近似地再生另一点选择的信息。”
为解决这一问题，他在该论文中提出了应用数学的一个全新分支，现在称之为信息理论和/
或编码理论、本书的目的就是介绍这一理论提出后30年来的主要成果。
在引言这一章，将通过一对特殊的数学模型，二进制对称信源和二进制对称信道，来介绍
信息理论的核心思想。
二进制对称信源(简称信源)是一个可以发出定义为“0”和“1”的两种特定符号的实体，速
率为单位时间内R个符号。我们称这些符号为比特(bis)[bits是binary digits(二进制数据)的
缩写]。信源随机地发出这些比特，“0”和“1”的发出概率相同。假设信源速率R是连续变化
的，即R可以是任何非负的数值。
二进制对称信道(简称 BSC2)是一个在单位时间内可以传输1比特数据的实体。但是该
信道并不是完全可靠的：存在一个固定的概率p(称为原始误比特率),满足0≤p≤2,使输
出比特与输入比特不相同。
现在设想有两个人，一个是发送者，另一个是接收者。发送者必须使接收者尽可能准确地
接收信源的输出，而他们之间惟一的通信链路就是前面描述过的BSC(但是在启动信源之前，
允许发送者和接收者在一起了解彼此将采用的数据处理策略)。这里还假设发送者和接收者
都可以无任何限制地利用计算能力、存储容量、政府经费和其他资源。
现在要问，对于给定的一个信源速率R,发送者和接收者之间通过BSC的通信可以达到
多高的可靠度?我们最终将给出此问题的一个非常精确的通用结论，但现在先考虑一些特例。
假设R=1/3,这意味着信道传输数据的速率是信源产生数据速率的三倍，因此在传输之
前，可以对信源输出的每一比特重复编码兰次。例如，如果信源输出的前五个比特是10100,
编码流将是111000111000000。对应每个信源比特，接收者将收到三个比特，但是由于存在信
道“噪声”,这三个比特可能不完全相同。如果信道干扰了传输的第2、第5、第6、第12和第13
比特，接收者将收到101011111001100。稍微思考一下你就会认为，此时接收者对信源比特进
行译码的最佳策略是对接收的三个比特多票判决。在我们的例子中，这样译出的接收信息是
11100,第二比特出现了一个错误。一般情况下，如果一个信源比特的三个重复编码比特中有
两个或三个被信道干扰了，接收就会出错。因此，如果用P,表示误比特率，
P=P{2个信道情误}+P{3个信道错误}
=3p2(L-p)+p3
=3p2-2p3
(0.1)
2 信息论与编码理论(第二版)
P≤2,,这个值一般比原始误比特率p小；这种简单的编码策略提高了信道的可靠 由于
度，并且p值越小，提高就越显著。
现在很容易看出，通过对每个比特重复编码更多次可以得到更高的可靠度。因此如果
R=1/(2n+1),其中n为正整数，则在传输之前就可以对每个比特重复编码2n+1次(见习
题0.2),并且采用前面提到的多票判决准则译码。现在很容易得出最终误比特率 p!2a+1)的
公式：
n+=ZP{2n+1个传输比特中有k个宿道错误：
-(2"t1)-p?)- (0.2)
-(2+1)*+D的商次项
如果n>1,该值随着p→0而趋近于0的速度要比前面考虑的n=1的特殊情况快[4]。因此就
很容易理解，为什么长重复序列比短重复序列更有效。这里需要进一步强调的是，对于原始误
比特率p<÷的固定 BSC,当n→时，p(?*3→0,即通过这些重复编码方式，可以使信道达到
理想的可靠度。研究pzn+)的公式(0.2)最终可以得出这样的结论。但也可以换一种方式，
采用弱大数定理①来进行分析，如果在信道中传输N个比特，则对于任意e>0,有：
血{带议的数日->e}=0 (0.3)
也就是说，只要N的取值足够大，接收比特中出错的比例就不可能与p相差很多。因此可以
对p(2n+)做如下估计：
p?a+-P{ 接收的传输比特中出错的比例
2n+1=2+4n+2}
≤P{比例>f}
≤P{|比例-p>2-p}
根据式(0.3),当n→的时，p(2n+)确实趋近于0。我们由此得出结论：如果R的值很小，即使
信道本身的噪声很大，也可以使最终的错误概率很小。这个结论当然并不奇怪。
以上讨论的都是速率小于1的情况。当速率大于1时情况会怎么样呢?在这种条件下，
通信的可靠度又如何?
如果R>1,不妨只传输信源比特的1/R部分，并让接收者以抛硬币的方式猜测其余的部
分。很容易计算出这种简单方式的最终误比特率为：
① 在附录A中讨论。
引言 3
P=k×p+RR1x!
=2-(-p)/R
(0.4)
现在以R=3为例，来介绍另外一种当R>1时可以采用的略有创意的方式。如果R=3,
信道只能传输信源所产生比特的三分之一。因此发送者将信源输出分为三比特一组，并且只
传输这三比特中占多数的比特。例如，如果信源输出101110101000101,发送者将在信道中传
输11101。接收者只需将收到的每个比特重复三次。此时如果信道干扰了传输的第二个比
特，接收者将收到10101,并扩展为111000111000111,于是就产生了五比特的错误。一般情况
下，最终的误比特率为：
Pe=4×(1-p)+3×p
=4+p/2 (0.5)
3+p/3要小。当R取其他 注意这个结果比我们前面取R=3时，通过“抛硬币”方式得出的-
的整数值时，采用该方式的通用结论作为习题(见习题0.4)留给读者推导。
到目前为止我们所考虑的方式都是微不足道的，当然也并非毫无意义。现在介绍一个更
重要的例子，事实上在1948年以前人们对这种方式还毫无了解。
这里假设R=4/7,即对于信源产生的每四个比特，信道都有时间再传输三个附加比特。
我们仔细地选择这些附加比特：如果四个信源比特表示为xo,x?,x?,xg,则附加或者冗余(或
者奇偶校验)比特表示为x,x;·x?,它们由下列等式确定：
x4xI+x2+x3(mod2)
xs三xa+xz+3(mod2)
6=xo+xi+x3(mod2)
(0.6)
举例说明，如果(xo,x?,x?,x?)=(0110),则(4a,xs,x?)=(011),而信道将传输的全部七比
特码宇为0110011。
为了说明接收者如何通过被干扰了的七比特码字估计四个信源比特，即描述他的译码算
法，我们按照下面的方式重写奇偶校验式(0.6):
=
(0.7)
[式(0.7)中采用的也是模2运算。]换一种略微不同的描述方式，如果定义二进制矩阵H为：
"=1:
则我们看到16个可能的码字x=(x,xj,x?,xg,x?,xs,x?)都满足矩阵-矢量方程：
-
(0.8)
[式(0.B)中上角标T表示“转置”。]
搭
4 信息论与编码理论(第二版)
可以设想BSC对传输的每一比特加(模2)0或者1,加0表示这一比特接收时没有错误，加
1则表示有错误。因此如果传输的是x=(x,x?,…,x?),则接收矢量是y=(x+知，x?+
不，…,x?+z?),其中如果信道在传输的第i比特产生了一个错误，则z=1,否则z=0。因
此，若将z=(z?,,…,z。)定义为错误图案，则y=x+za
接收者接收到y时希望确定x,为此他将计算下面的矢量s=(so,s?,s?):
s?=Hy?
=H(x+z)'
=Hx?+Hz?
= Hz [见式(0.8)]
(0.9)
这里s称为y的伴随式S(syndryme)。伴随式中的一个0分量表示y满足相应的奇偶校验方
程，面1分量则表示不满足。根据式(0.9),伴随式不依赖于发送的码字，而只与错误图案z有
关。但是由于x=y+z,如果接收者找到了z,也就知道了x,因此译码问题的重点是寻找z。
等式s'=Hz表明，s'是与z中1分量相对应的H矩阵中列矢量的《二进制)和，而z中1分
量对应的比特是被信道干扰的：
2=+18…+ (0.10)
接收者的任务是，一旦计算出s,就通过方程式s?=Hz'“求解”z。遗憾的是，这里只有三个方
程却有七个未知量，因此对应任一s,总有16个可能的z。这显然已经是一个进步了，因为z本
来有128种可能的取值，但是接收者如何在剩下的16个值中进行选择呢?例如，假设接收到
y=(0111001),则s=(101),z的16个候选值为：
91 。9118!9
1 0 I 0000 00100 0 I01 I1 1 1
1000 010 0 1 1 1 1 I
1 110{ 1 00 0 t 1 1 0
0 1 11 0 00 1 上
P<2,,错误图案包含的1 面对这样一组可能的错误图案，显而易见的是：由于原始的误比特率
的个数(错误)越少，就越有可能是实际的错误图案。在这个例子中，幸运的是，重量最小的错
误图案(0100000)只有一个，这里的重量代表错误图案中1的个数。此时接收者对z的最佳估
计(同时依据伴随式和信道统计特性)是z=(010000);对传输码字的估计是x=y+z=
(001100L);面最终对四个信源比特的估计是(0011)。
当然在上面的例子中也并不是真正的幸运，因为可以看到对于任意伴随式s,方程Hz2=
s'总是存在重量为0或1的惟一解。比如，如果s=(000),则期望的结果是z=(000000)。但
是如果s+(000),则s"必然作为H的某一列出现；如果s2=H的第；列，则第；位为1、其余位
都为0的错误图案 z是Hz=s'的惟一最小重量解。
引言 5
现在可以总结一下称之为(7,4)汉明码的译码算法。给定接收矢量y,接收者将执行下列
步骤：
1.计算伴随式s"=Hy?。
2.如果s=0,设置2=0;到第4步。
3.寻找H巾惟一与s相同的列，称它为第i列，并设置2的第i位等于1,其余位都为0。
4.设置余=y+2。(这是接收者对传输码字的估计。)
5.输出盒的前四个分量(x,t?,&?,e?)。(这是降码器对原始信源比特的估计。)
按照这种算法产生的矢量之有可能与实际的错误图案z不同。但是如果信道最多只产生一个
错误，即如果z的重量是0或者1,则根据上面的讨论有会=z。因此汉明码是纠正单个错误
码。事实上很容易看到，当且仅当信道产生两个或更多错误时，按照上面的译码算法才不能正
确译出原始码字x。因此，如果P表示误组半P≠x}.
P=2(2)pu-p2?
=21p2-70p3+etc
当然误组率P?并不能说明全部情况，因为即使众≠x,中的某些分量也有可能是正确的。如
果用P!"表示误比特率PR≠x,1,则对于所有的0≤i≤6,可以证明：
P=9p2(1-p?+19p3(L-p?+16p?(1-p)3
+12p?(1-p2+7p?(1-p)+p? (0.11)
=9p2-26p3+ete
将该式与式(0.1)比较，会发现对于原始错误概率很小的 BSC,汉明码在速率为4/7=0.571时
的性能，与简单重复编码方式在速率为1/3=0.333时的性能近似。
也可以通过互换(7,4)汉明码中发送者和接收者的规则来进行R=7/4的通信。这时发送
者将信源序列分为七比特一组，通过前面的译码算法(在此变为“编码算法”)将每组七比特减
少到每组四比特，并在信道中传输这四比特。接收者译码时利用接收到的四比特，通过运算奇
偶校验式(0.6)产生附加的三比特。这种方式最终的误比特率P!l=P&,≠x:F与i有关，但
是平均的P,=(∑°。P()7为：
P=0-p2+-pp+301-p22+2(1-pp+3
=g+8D+ete (0.12)
对于无噪声(p=0)BSC,这个结果的性能更为优越，例如R=7/4时，由式(0.4)给出的“抛硬
币"方式的P,=4=0.214。
现在通过一个特定的 BSC总结一下所了解的知识。给定p=0.1,设x=R表示速率，
y=P,表示最终误比特率，对前面讨论的每一种通信模式在(x,y)平面上画出一个点，如
图0.1所示。如果有足够的耐心和智慧，可以继续提出一些特殊的方式，并在图0.1中用点标
黄1
6 信息论与编码理论(第二版)
明。当然我们的最终目标是希望了解哪些点能够达到而哪些点不能达到。令人难以置信的
是，香农已经实现了这个目标。但在给出香农的结论之前，先进一步明确一下速率为R的编
码方式以及相应误比特率P的概念。
0.5
0.4
0.3 R-3.
多票判决
P ·R=7/4汉明 0.2
0.1
·R+47汉明
重复编码方式 0
1/3 1 2 3
-1/7 1/5 R
图0.1 对应 BSC(p=0.1)的一些可达到的(R,P.)点
如图0.2所示，一个(n,k)码的方案是首先将信源序列划分为k比特一组，而每个k比特
的信源分组u再变换(编码)为一个n比特的码字x,并通过信道传输，则接收到的可能是受了
干扰的y。译码器将这个n比特带噪声的码宇变换为一个k比特的分组v,作为对原始信源序
列u的估计。这个通信系统的速率为R=k/n;误比特率定义为：
R-起吧
其中，
plf=P{u?≠暗}.i=1,2,…,k
u
x.xz…,x) 编码 信避 信源
V
() (Px) 信宿 译码 信道
图0.2 对应二进制对称信源和BSC的一个(n,k)码
(可以立即看出，可能除了R≥l的“抛硬币”方式，前面介绍的每一种方式都符合这一描述；见
习题0.5。)如果存在一个(n,k)码满足k/n≥x,P≤y,就称图0.1中的点(x,y)是“可达到”
的。对应特殊的 BSC(p=0.1),图0.3中显示了所有能够达到的点的集合。当然问题的关键
引言 7
是要了解图0.3中可达到与不可达到区域之间界线的描述。为了给出这个描述，需要介绍重
要的二进制熵函数：
H?(x)=-xlog?x-(1-x)log?(1-x),
H?(0)= H?(1)=0
0.5
0<x<1
(0.13)
0.4 P-0.5(渐近逼近)
P
0.3 可达到区城
0.Z
不可达到区城 0.1
0
2 3 4 S
R-—一
图0.3 对应二进制对称信源和 BSC(p=0.1)的可达到的(R,P.)点
y=H?(x)的曲线由图0.4给出(在习题0.10中介绍了H?(x)的一些重要性质)。现在可以描
述图0.3中可达到与不可达到区域之间的界线了。界线中的曲线部分是满足下式的
点(R,P.)的集合：
R={-Hh?FJ D≤P<1 (0.14)
剩余的界线是R轴的一部分，从R=0到R=1-H?(0.1)=0.531。对于一般的 RSC,结论是
相同的，只是式(0.14)被下式代替：
R=i-H?P) (0.15)
并且相应的R轴部分是从R=0到R=1-H?(p),如图0.5所示。
lL(x)
|0 1/2 I
图0.4 二进制熵函数
从图0.3和图0.5中可以得出许多重要结论。但最重要的是，如果R<1-H?(p),则任
何正值的P,,不论取值多么小，都是可达到的!例如，如果p=0.1,根据图0.3,应该存在一个
速率≥0.5的码，其最终的误码率<10-0!这个重要的数值1-H?(p)称为信道的容重；图0.5
的特别含义称为信道编码定理。这个定理表明当速率低于信道容量时，任意可靠的通信都是可
能的。(与我们前面的结论做比较，这证明了通过重复编码，随着R→0,P,可以同样趋近于0.)
4 糖
8 信息论与编码理论(第二版)
0.5
0.4 R=(1-H?p))(I-HKP,y
可达到区城
0.3
P.0.2
R-1-H?(D) 不可达列区城
0.1
2 3 4 5
R—
图0.5 对应二进制对称信源和一般BSC的可达到的(R,P)点
不夸张地讲，本书的全部内容就是研究图0.5及其推广形式。第一部分将通过证明来描
述一大类“信源-信道”对的可达到区城(相关内容见第5章，建议读者尽快浏览一下)。但是
这些证明从某种程度上来讲并不完善，因为它们只断言存在，并没有精确描述具体的码。这个
问题将会在第二部分中得到部分解决，那时将详细介绍一些重要的实用码。
习题
0≤p≤2的假设实质上是不失一般性的。 0.1 解释一下为什么关于BSC原始误比特率
0.2 设R=1/2n,n为某个整数。为了在BSC中通信，考虑一个“每比特重复2n次”的方案。
(a)设计一个合适的译码方法，并计算出最终的误比特率P。
(b)证明在(a)中得到的结果与式(0.2)中R=1/(2n-1)时采用重复编码方案的结果完
全相同。
0.3 证明式(0.5)。
0.4 设R=2n+1,n为某个整数。类似于文中所述的R=3的方案，考虑一个“发送2n+1
个相邻信源比特的多票判决结果”的方案。
(a)证明P.=(I-p)Q+p(1-Q),其中，
e=2-(2n)2--+
(b)证明R=2n时采用类似的方案将得到完全相同的P.值。
0.5 假设R≥1且R是有理数。说明如何将文中含糊的“抛硬币”方案转换为图0.2中的(n,k)
码形式。然后证明最终的误比特率P,为式(0.4)。
0.6 将下列矢量译码，假设它们是R=4/7汉明码的“噪声”样本：1100000,1010103,0111100。
0.7 将下列矢量译码，假设它们是R=7/4汉明码的“噪声”样本：1010,0001,0111。
0.8 证明式(0.11)。
0.9 证明式(0.12)。
引言 9
0.10 证明式(0.13)中定义的二进制熵函数H?(x)具有如下性质：
(a)H?(x)=log?(1-x)/x。
(b)H?(x)=-[x(1-x)log2]-'。
x=2 (c)H?(x)≤1,等式成立当且仅当
(d)H?(x)≥0,lim?.1H?(x)=0。
(e)H?(x)=H?(1-x)。
0.11将可达到与不可达到区域的边界记为B(R),对所有R≥0,它存在连续的导数吗?计算
lim一。R(R),并用通信术语解释你的结果。
注释
[1] 香农于1916年4月30日生于美国密歌根州佩托斯基。曾就读于密歌根大学电子
工程和数学系，于1936年获得理学学七学位。1940年在麻省理工学院获博上学位，
后又在普林斯顿大学进修了一年。之后，加入了新泽西州普林斯顿的贝尔电话实验
室技术部。
1941年，在某种程度上出于战事的需要，香农对通倍问题开始了深入的研究，并汇
集他的研究成果，于1948年发表了名为“A Mathernatical Theory of Cocpmunication”(通
信中的数学理论)的论文：(这篇论文在文献[25]中被全部重新收录)
伴随着许多深奥的科学发现(例如1905年爱因斯坦提出狭义相对论),现在看来当
时产生科学突破的时机已经成熟了。但在通信理论领域却并非如此。虽然在20世
纪40年代香农的工作并非与世隔绝，但是他的理论却非常独树--帜，以至于当时的
通信专家都无法立即接受。但是随着他的定理逐渐被数学/工程界认可，他的研究
也逐渐分立为一门崭新的学科，并有更多的人开始跻身这一领域：起初发展得较缓
慢，但后来这个学科发展得越来越快，育到现在每年都有上百篇信息理论的论文
发表。
香农凭借1948年发表的论文，被认为是独一无二的信息论之父。除此之外，他还被
评为1948年以后对此领域做出最大贡献的人!自从发表“A Mathemalical Theory of
Cummunication”论文以来，他的每篇论文儿乎都可以构成其他人科研思想的无价源
泉。[例如，在1973年信息论方面的重要论文集中(参见文献[25}),引用的49篇论
文里，有12篇的作者或合作者是香农。而其他作者出现的次数均不超过三次。]
[2] 在加利福尼亚洛杉矶，地区信道52(KBSC)是二进制对称信道。
[3] 有时p也称为BSC的转移概率或交叉概率。
K)(N中选K)表示不重复地从N [4] P,公式的推导需要进一步说明。二项式系数
个物体的集合中选出K个物体的方法数。它的数值等于N(N-1)(N-2)…(N K+1)/K(K-1)…2-1。(要了解二项式系数的更多性质，参见Knuh[7],第1卷。)
(2a+1)种。 所以在传输的2n+1个比特中，信道刚好产生k个错误的不同方式有
公铺 。
10 信息论与编码理论(第二版)
+p(1-p)2*等于信源比特 每种方式发生的概率为p*(1-p)2+1-*,因此
的2n+1个重复编码中恰好有k个发生接收错误的概率。
[5] 在英文的医学用语中syndrure(症状)一词是指synplcm(病症)的表现形式，可以用
来帮助医生诊断 disease(疾病)。在这里“disease”是指错误图案，“symptom”是指奇偶
校验失败。这个恰当的名称是由Hagelbarger首先使用的。
1…………………………………7………………………41……………e……………………
第一部分 信 息 论
第1章 熵和互信息量
第2章 离散无记忆信道及其容量-代价函数
第3章 离散无记忆信源及其率失真函数
第4章 高斯信道和信源
第5章 信源-信道编码定理
第6章 第一部分前沿课题综述
4
83…名;花。…集作不 ………………………,
………………
澍 , 缝；
l
第1章 熵和互信息量
1.1 离散随机变量
假设X是一个离散随机变量，即它的取值范围R={x?,x?,…}是有限或可数的。设
p,=PiX=x,I(关于概率论术语请参考附录A)。X的熵定义为：
Hx)=∑nlo8! (1.1)
对该定义需要给予进一步的说明。首先，对数运算的基底有意未做明确规定。但是如果有必要，
可以将以b为基底的熵表示为H(X),并称X的熵的单位以b为基底。例如，以2为基底的单
位称为 bits(binary digis),而以e为基底的单位称为 nats(natural digits)。其次，如果pi=0,
式(1.1)中p.logp'项的值是不确定的；但是我们规定它为0。(这个规定并不是随意给出的.见
习题1.1。)最后，如果R是无限的，和式(1.1)有可能不收敛，在这种情况下设定H(X)=+的。
例1.1 设X表示一个质地均匀的骰子单次掷出的数字。则R=11,2,3,4,5,6,并且对应所
有的i,p=6。因此H(X)=log6=2.58 bits =1.79 nats。
例1.2 设R=|0,1,并定义X满足P{X=01=p,PIX=1F=1-p。则H(X)=-plogp-
(1-p)log(1-p),并且H?(X)作为0≤p≤1的一个函数，与式(0.13)中定义的二进制熵
函数H?(p)相同。后面会经常用H(p)表示函数-plogp-(1-p)log(I-p)(其中时数运
算的基底未做明确规定),并称它为熵画数。图1.1绘出了它的曲线(比较困0.4)。更一
般地，如果p=(pi,…,p,)是任意概率失量，即p,≥0并且∑pi=1,则定义H(p)=
H(p,P?,…,p.)=∑p.logpi'。这种表示方法有时并不兼容，因为对于r=2,我们有
H(p,1-p)=H(p)。(因此用符号H表示三个不完全相同的概念：H(X)表示随机变量X
的熵；H(p)=-plogp-(1-p)log(1-p),其中0≤p≤1;而如果p是一个概率矢量，则H(p?,
P?,…,p.)=∑p:logp:')
log 2
0 1/2 I
图1.1 熵函数H(p)
:
14 信息论与编码理论(第二版)
例1.3 如果和式Z(nlog?n)?'表示为A,而定义随机变量 X满足PiX=n!=
(Anlog' n)-1,其中n=2,3,…,则有H(X)=+的(见习题1.2)。
因此可以认为H(X)是关于X的下列量的一种度量：
(a)通过观测X所获得的“信息”的数量。
(b)关于X的“不确定度”:
(c)X的“随机度”。
在后面的几章里，并没有很严格地去证明这些性质，但是读者现在就应该了解，事实上H(X)
确实也是这些量在严格的数学意义上的度量。当然可能有许多关于随机变量X的函数.同样
具有下面讨论的这些性质，但是只有H(X)将用于研究通信可题。
对于任意x∈R.定义I(x)=-lngPHX=x|。则I是一个新的随机变量，并且H(X)是它
的平均值。函数(x)(见图1.2)可以理解为由事件|X=x)所提供的信息的数量。由这个解
释可知，事件发生的可能性越小，它发生时获得的信息就会越多。确定事件(发生的概率为1)
不提供信息，而不可能事件提供非常大的信息量。例如，假设你拜访一位预言家，他对任何问
题只回答“是”或者“否”。如果你问“我会活到125岁吗”而得到一个“否”的回答，则将获得非
常少的信息，因为如此长寿是不太可能的。相反，如果你得到一个“是”的回答，则将获得很多
的信息。如果现在有数百万人拜访这位预言家，同相同的问题，那么大多数人将得到“否”的回
答，而极少数人会得到“是”的回答，并且获得的信息量的平均值将是H(p),其中p=P|死亡年
龄≥125。此外，在得到这位预言家的回答之前，你可能并不很好奇；这反映了这样一个事实，
即这个回答只有少许的不确定性。H(p)是该不确定性的一个度量"。最后，如果让一个毫无
偏见的人口普查人员来记录这位预言家的回答，他会觉得非常无聊，并可能开始怀疑这位预盲
家是一个只会回答“否”的机器。这反映了代表预言家答案的随机变量X并不是很随机。而
H(p)是X随机性的度量。
Lx)
i
PFX-x}
田1.2 函数(x)
现在考虑一个不太抽象的例子，定义X满足PIX=0|=P|X=11=。则(0)=F(1)=
H(X)=log2=1 bi,即通过观察“比特”X获得了I“比特”的信息量。
我们的第一个定理讨论的是在定义域R上H(X)可能的最大值。
定理1.1 设X在定义城R=lx?,x?,…,x内取值，则0≤H(X)≤logr。当且仅当对于
某个i,p.=1时，H(X)=0;当且仅当对于所有i,p,=1/r时，H(X)=logr。
证明：因为所有的p.都≤1,式(1.1)中的每一项p,logp'都0,所以H(X)0。并且由
麻这.·
i■
第1章 熵和互信忽量 15
于当且仅当p=0或1时，plogp-1=0,所以当且仅当p=0或I时，也就是当且仅当一个
p;=1,而其余的都为0时，H(X)=0.
现在根据Jensen 不等式(見附录B),因为logx是严格上凸∩的，故
H(x)=Znlo'≤108=log
当且仅当p为独立于i的常数，即对于所有的i,p=1/r时，等式成立。
不严格地讲，定理1.1说明均匀分布的随机变量为最“随机”的一类随机变量。而严格地
讲，它证明了如果p=(p?,…,p)是取值满足p,≥0.∑p=1|的r-1维变量，则只有当p=
(1/r,I/r,…,1/r)时，函数I(p,P?,…,p.)达到最大值 logr。
下面要定义的是，对于一对随机变量X和Y,H(XIY)称为给定Y时X的条件城2]。为了
表达得更简洁，我们引人一些简明表示方法。设x是X定义域中的一个值，y是Y定义域中的
…个值，定义：
p(x)=P{X=x}
p(y)=P{Y=y}
p(x,y)=P{X=x,Y=y} (1.2)
p(x|y)=P{X=x|Y=y}=p(x. y)/p(y)
p(y|x)=P{Y=y|X=x}=p(x,y)/p(x)
(这种表示方法偶尔会有歧义性，因此如果必要可以加上适当的下角标，例如，px(x),pyx(ylx)。
但是只有当字母x,y被赋予实际数值时，才需要这样做；见例1.6.)我们的定义是：
Hxin)=E|lo例]
=∑nx,yloBp (1.3)
[在式(1.3)中遵循了和式(1.1)中的相关规定：0logo?1=0;如果该和式不收敛，就意味着
H(XIY)=+。]现在通过一个称为离散无记忆信道(DMC)的筒单通信信道模型，来进一步
了解这个定义。
DMC(见图1.3)在单位时间内接收，个可能输人符号中的某一个符号，并相应地输出s个
可能输出符号中的某一个符号(信道“离散”是指输人和输出符号的个数都是有限的3,“无记
忆”是因为输出只与当时的输人有关，而与任何以前的输人都无关)。输人和输出符号的精确
描述并不是很重要，但一般习惯于用10,1,…、r-1|和10,1,…,s-1|表示输人和输出符
号集。
0 0
1
s-1
图1.3一个离散无记忆信道
.:镳：
16 信息论与编码理论(第二版)
信道的输出并不是输人的确定函数，信道的特性取决于一个rxs阶转移概率分布[p(ylx)]
矩阵。p(ylx)表示给定输人x,输出y的概率。显然p(ylx)的值必须满足：
P(v|x)0 对于所有的x,y
∑Pulx)=1 对于所有的x
当r和s的数值不是很大时，DMC可以用图1.4中的图示法描述。在这种图示中，通过标以
p(ylx)值的一条直线连接每一对满足p(ylx)>0的(x,y)。
输入 输山
x putì ··
图1.4 DMC的另外一种描述
例1.4(二进制对称信道，已在引言中讨论过。)这里r=s=2,围示如下：
0
Lp ·0
p
e
1
I-p
例1.5(二进制删除信道。)这里r=2,8=3,输入用“0”和“1”标志，输出用“0”,"1"和“?”
标志。
0
P
0
1
?
1 4
这科的信道，在实际中可能出现，例如如果物理信道的输入是两个方波：
和
“(1” #1”
则徐出端检测器将收到这些方波加入噪声后的信号r(t):
或 我
“0” “1” ?"
:
第1章 填和互信息童 17
[r(t)da=1判断发送的到底是“0”还是“1”。如果了是正值，检测器就判决 并根据积分值
发送的是“0”,相反就是“]"。但是如果|l的值非常小，可能最好是对传输的比特不做“硬
判决”,而是输出一个特定的删除符号“?”。如果信道的噪声相对较小，则0→1和1→0的
可能性要远小于0→?和1→?的可能性，因此假设P|Y=11X=0=PIY=01X=1|=0
是合理的。(习题4.15将进一步解释“硬判决”。)
现在假设DMC的输入是根据概率分布p(x)在10,1,…,r-1中选择，即假设信道输入
X的特性为：
P{X=x}= p(x) x∈{0,1,…,P-1}
定义了X,现在可以定义一个随机变量Y代表信道的输出。X和Y的联合分布由下式给出：
P(x,y)=P{X=x,Y=y}
=P{X=x}P{Y=y|X=x}
=p(x)p(vlx)
而Y的边缘分布为：
p(p)=P{Y=y}
=∑P{Y=ylX=x}P{X=x}
=∑ovls)p)
类似地，
p(x|y)=p(x,y)/p(y)
=plp(x)/∑n)px)
因此对应每一个DMC和输人分布，存在一对随机变量：“输人”X和经过信道的“输出”Y。
相反，给定任意一对离散随机变量(X,Y),存在一个DMC和输入分布，使得X是输入，Y是输
出：只需定义信道的转移概率分布为p(ylx)=PlY=ylX=xl。换一种说法，给定任意一对
随机变量(X,Y),可以认为Y是X的“噪声”样本，即通过特定 DMC传输X的结果。
例1.6 假设X取值±1,±2,相应的概率都为1/4,并且令Y=X2。对应的DMC如下所示：
+2
p,(±2)=14 4 p{4)=1:2 1
-2·
+1
P?(±1)=1A Ipt山= 1
-1
y x
在这个例子中X和Y是不相关的，但显然Y提供了相当数量的关于X的“信息”(见
习题1.10)。
3?
18 信息论与编码理论(第二版)
假设Y是X的噪声样本，并且H(X)是最初关于X的不确定性的度量，那么如何度量观
测Y后关于X的不确定性呢?首先假设我们观测到Y=y。然后由于对于固定的y,p(xlγ)=
PIX=xlY=y}表示给定Y=y时X的条件分布，故定义给定Y=y时X的条件熵为：
H(XIY=)=∑pA1ploB
这个值本身是Y定义域上的一个随机变量，我们定义它的期望为条件熵H(XIY):
H(XIr)=∑p)HXIr=)
=∑nW∑naiplopi
=pex, ylopD
与式(1.3)相一致。因此，对于给定的一对随机变量X,Y,H(XIY)表示观测Y后，仍然保留
的关于X的不确定量。
例1.7 考虑下面的 DMC,它是例1.5中二进制删除信道的一个特例：
0
3/4 0
1/4
?
1/2
1/2
这里pr(0)=3·pz(1)=3。 通过简单的计算可以得到：
H?(X)=0.9183 bits
H?(X|Y=0)=0
H?(X|Y=1)=0
H?(X|Y=?)=1
可见如果Y=0或者1,关于X不存在任何不确定性，但是如果Y=?,在接收到Y后，反
而会对X更加不确定!但是，
H?(X|Y)=0.3333 bits
因此总体来讲，通过观测Y至少减少了对于X的不确定度。
现在介绍一个下文中将会用到的关于H(XIY)的引理。
定理1.2 设X,Y,Z是海散随机变量。利用简明符号[见式(1.2)],对于每个z,定义
A(x)=∑.,p(y)p(zlx,y),则
H(X|Y)≤H(Z)+E(logA)
证明：
a
第1章 熵和互信息量 19
Hxin=Elos)
-∑nKy,2)l08
=∑n)B1
对于固定的z,p(x,y,z)/p(z)=p(x,ylz)是一个概率分布，因此可以在内部求和时利
用Jensen 不等式。结果是：
Rxin-Znauloea
-∑na)l+∑e3lo1
而P(x,y,z)/p(xly)=p(x,y,z)p(y)/p(x,y)=p(y)p(zlx,y),定理得证。
推论(Fano 不等式)设X和Y是离散随机变量，都取值于集合x,x?,…,x,|。设
P=PIX≠Y|。则
H(X|r)≤H(P)+Pelog(r-1)
证明：在定理1.2中，定义Z=0,如果X=Y;定义Z=1,如果X≠Y。则A(0)=1,而
A(1)=r-1.
注意 利用简明符号证明的定理1.2包含了一些细节，见习题1.11。
Fano 不等式有一个有趣而富有启发性的解释。H(XIY)是已知Y后，仍需要通过检测X才
能获得的信息量。检测X的一种方法是先确定是否X=Y。如果X=Y,就知道了X;但是如果
X≠Y,X就还有r-1种可能的取值。检测是否X=Y等价于检测证明中定义的随机变量Z;由
于H(Z)=H(P.),为此需要H(P,)比特。如果X≠Y(发生的概率为P,),根据定理1.1,在剩余
的r-1个取值中确定X所需要的信息量最多为log(r-1)。
例1.8 将Fam不等式应用于例1.7中的信道。这里r=3,而PiX=Yl=3,P=3。。因此
Famo界为H(XIY)≤H(号)+÷log2=号bog+310g3+3log2=log3-号loe2=1.2520
bits(有关Fano不等式更好的例子见习题1.11):
由于H(X)表示知道Y之前关于X的不确定量，而H(XIP)表示知道Y以后关于X的不
确定量，H(X)-H(XIY)的差值必然表示由Y所提供的关于X的信息量。这个重要的量称
为X和Y之间的互信息重，并表示为7(X;Y):
(X;Y)= H(X)-H(X|Y) (1.4)
[在例1.7巾，A?(X;Y)=0.9183-0.3333=0.5850;因此平均来讲，对信道输出的观测至少
提供了关于信道输入的0.5850比特的信息量。]利用式(1.2)中的符号，我们得到关于I(X;Y)的
几种重要变换形式：
:t
行高…日、常;
20 信息论与编码理论(第二版)
x:Y)=∑px,ylos
=∑px,yloePp
-∑PC,ylo
(1.5)
(1.6)
(1.7)
(细节见习题1.14)
因此我们看到(X;Y)是下面的随机变量/(x;y)在X,Y取值空间上的平均值：
lux;y=log)=losx)y=1o8w
而I(x;y)可以是正值，也可以是负值例如，在例1.7中，/(0;0)=log2而I(0;?)=log?];
但是现在要证明的重要事实是I(X;Y)不能是负值。这当然是合理的，理由是：平均来讲，我
们不希望因观测信道的输出而被误导。
定理1.3 对于任意离散随机变量X和Y,有【(X;Y)≥0。并且I(X;Y)=0当且仅当X
和Y是相互独立的：
证明：我们对式(1.6)利用Jensen不等式：
-1x:r=pl, wlos
≤ ogZPn)p)
= logl=0
此外，鉴于logx是严格上凸∩的，对于所有的x和y,当且仅当p(x)p(y)=p(x,y),即
当且仅当X和Y相互独立时，等式成立。
[尽管也许不应该强调这一点，但是定理1.3表明K(X;Y)可以很好地度量X和Y之间的
相关度，比如，要比协方差Cov(X;Y)更好。回忆一下例1.6就很容易证明这一点，Cor(X;Y)=0,
但是I?(X;Y)=1 bit。]
利用式(1.4)至式(1.7),可以立即证明互信息量的几个重要性质：
I(X;Y)=I(Y;X)
I(X;Y)=H(Y)-H(Y|X)
[(X;Y)= H(X)+H(Y)-H(X,Y)
(1.8)
(1.9)
(1.10)
在式(1.10)中，我们定义了X和Y的联合熵为：
HX,Y)=∑nx,ybospD (1.11)
这些关系式的证明留做习题1.14。通过图1.5中的维恩(Venn)图很容易记忆这些公式。给出
图1.5中每个关系式的通俗解释是一个很有益的练习。例如，式(1.8)表明互信息量的“互易
第1章 熵和互信息量 21
性”;H(X,Y)=H(X)+H(YIX)成为“对于X和Y的不确定量，等价于对于X的不确定量以
及已知X后对干Y的不确定量的和”,等等。
MX,Y
Hujn AXn
HX7- H(Y)
图1.5 式(1.4)和式(1.8)至式(1.10)的维愿记忆图
现在如果给出三个随机变量X,Y,Z,类似于式(1.7),可以定义互信息量(X.Y;Z)(由
X和Y所提供的关于Z的信息量)为：
ux,Y;z)=E[loek
-∑Px, y:1loe”
我们不希望由X和Y共同提供的关于Z的信息量，少于由Y单独提供的关于Z的信息量，而
下面的定理正说明了这一点。
定理1.4 I(x,Y;Z)≈I(Y;Z),等式成立的条件是，当且仅当对于所有满足
p(x,y,z)>0的(x,y,z),有p(zlx,y)=p(zly)。
证明：
Y;Z)-A(x,Y;Z)=E|ogP-loeA”
=EloBk]
-nx,y,z)》
利用Jensen不等式，我们有：
ruY;Z)-(X,Y;z)≤loeZpx..2)k,
=108∑pC,y·P1)
= log1=0
等式成立的条件参考附录B中对Jensen不等式的讨论。
22 信息论与编码理论(第二版)
定理1.4中等式成立的条件非常有趣；它说明序列(X,Y,Z)是一个Markov 链，我们有意将
x,Y和Z之间的关系简单地表示为如图1.6中所示。这里DMC1由转移概率分布p(ylx)
确定，而DMC2由转移概率分布p(zly)=p(zlx,y)确定。我们已经观察到，给定任意一对
随机变量(X,Y),可以设计一个以X为输人、Y为输出的DMC。但是如果(X,Y,Z)是任意
三个随机变量，并不一定存在一对 DMC,使得X,Y,Z之间具有图1,6中所示的关系。显然必
要和充分条件是(X,Y,Z)构成一个Markov链，即p(zly)=p(zlx,y)(也就是说，Z只通过
Y才依赖于X)。
x- DMC1 P DMC2 Z
图1.6一个信息理论学家眼中的Martov链
现在假设(X,Y,Z)是一个如图1.6中所示的Markov 链。则根据定理1.4,有I(X;Z)≤
(X,Y;Z),由于(X,Y,Z)是一个 Markov链，有I(X,Y;Z)=I(Y;Z)。因此T(X;Z)≤
(Y;Z)。如果(X,Y,Z)是一个Markow链，则(Z,Y,X)也是(见习题1.15),因此I(X;Z)≤
(X;Y)。由于这是Markov 链的一个非常重要的信息理论性质，故用一个定理来描述它。
定理 1.5 如果(X,Y,Z)是一个Markov链，则有：
(X;Z){(Y;2
重新观察图1.6,会发现 DMC似乎“削弱”了信息量。如果 DMC是确定的(也就是说，如果
Y是X的确定函数，而2是Y的确定函数),我们可以将图1.6中的级联看做一种数据处理过
程。看似荒谬的是，定理1.5说明数据处理只能破坏信息![由此得出的一个重要结论见
式(1.15)。]
例1.9 设X,.X?,X?是相互独立的随机变量，则(X?,X?+X?,X?+X?+X?)是一个 Makov
链，所以I(X?;x?+X?+X?)≤I(X?;X?+X?)(见习题1.16和习题1.39)。
例1.10 在图1.6中假设X的概率分布为PIX=0}=P\X=1l=立,并且两个 DMC都是错
误概率为p的二进制对称信道。则：
(X;Y)=1-H?(p)
I(x;Z)=1-H?[2p(I-p)} bits
bits
这两个函数的曲线如下图所示(本例的一个推广见习题1.18和习题1.20):
1-H?{D)
1-H?(2p(1-p)
P
i :描三
第1章 熵和互信息量 23
本节的最后，将介绍当T(X;Y)看做是输人概率分布p(x)或者转移概率分布p(ylx)的
函数时，有关(X;Y)凸凹性的两个结论。
定理1.6 I(X;Y)是输入概率分布p(x)的上凸∩函数。
证明：我们假设转移概率分布p(ylx)是固定的，并且考虑两个输入随机变量X和X?,相
应的概率分布分别为p(x)和p?(x)。如果X的概率分布是一个凸组合p(x)=
p?(x)+βp?(x),则必须证明：
aI(X;Y)+βI(X?;Y?)≤I(X;Y)
式中Y?,Y?和Y分别是与X?,X?和X对应的信道输出。为此进行下面的处理，其中采用
了筒明符号：
al(X?;Yi)+β(X?;Y?)-(X;Y)
=∑an(s,ylo+ZBm(x, ylos 【见式(1.7)}
-LIanix,D+Bpx,yJlog
=a∑n(,Dloe+BZnax,Dyloe
(1.12)
现在对上面的求和式分别采用Jensen不等式：例如，
mx,yl≤logZp,》
而
p.》-熙Znx》
-prO)
=1
因此式(1.12)中的第一项求和式≤0.第二项求和式亦如此。
推论 熵函数H(p?,pz,…,p.)是上凸∩的。
证明：设X是一个随机变量，其分布为P\X=il=A。则I(X;X)=H(X)=H(p?,p,…,p,)。
这里利用定理1.6可得出结论。
定理1.7 I(X;Y)是转移概率分布p(ylx)的下凹U函数。
证明：这里考虑输入概率分布p(x)是固定的，但是给出了两组转移概率分布p?(y1x)和
P?(ylx),以及一个凸组合p(ylx)= ap,(ylx)+βp?(ylx),需要证明的是，
(X;Y)al(X;Y)+βI(X;Y?) (1.13)
式中Y,Y?,Y?分别是与转移概率分布p(ylx),p,(ylx)和p?(ylx)对应的信道输出。再
一次采用简明符号，式(1.13)中左右两边的差为[见式(1.5)]:
·!:usi :
24 信息论与编码理论(第二版)
rap(x,D+BpC,ylo
-∑apcr,ylo-Zp(x,ylogp)
=aZP(x,yloePxl)+B≥pCx,ploe
(1.14)
根据Jensen 不等式，式(1.14)中的第一项和式
ale La
-alo ZPuiao]
=alogP)=0
同样，第二项和式也≤0。
1.2 离散随机矢量
在上一节中定义了一对随机变量的熵H(X,Y),并且还定义了一对随机变量和第三个随
机变量之间的互信息量(X,Y;Z)。本节将推广这些定义，并且定义H(X),H(XIY)和
I(X;Y),其中X和Y是任意随机矢量。
以我们的观点来看，随机矢量X=(X?,X?,….Xn)只是有限个随机变量X的一个排列。
X的分布(即X?,X2,…,X。的联合分布)是函数p(x?,x?,…,x)=PlX?=x,X?=x?,…,
X=第，其中每个 x、都在X,的定义域内。回顾一下1.1节中的定义，读者就可以确信
H(X),H(XIY)和I(X;Y)只依赖于p(x)和p(ylx)等分布函数，而与X和Y的实际取值无任
何关系。因此可以立即将这些定义推广到随机矢承；例如X=(X?,X?,…,X)的熵定义为：
H(X)=ZpAsJo8
其中的求和扩展到X定义域上的所有矢量x。显然定理1.1至定理1.7仍然成立。
定理1.5推广到任意随机矢量后有一个非常重要的应用，我们现在就讨论一下。考虑
图1.7中的一个通信系统模型(比较图0.2和图5.1)。在图1.7中，随机矢量U表示信源的连
续k位输出；编码器将U变换为n位一组的X,并送到信道中传输；Y是X通过信道的噪声输
出；而译码器将Y变换为k位一组的V,并作为U的再生信号(至少是近似的)送到信宿。
问题的关键是，对于任何实际通信系统，随机矢量的序列(U,X,Y,V)构成Markov链(见
图1.6)。通俗地讲，图1.7中每个方块的输出只依赖于它的输人，而与前面的任何随机矢量都
无关。规范的说法是，它给出了许多有关条件概率的等式约束，例如p(ylx,u)=p(ylx),
p(vly,x)=p(vly)(对此不应该存在任何疑问；这是我们对于通信系统的一个基本假设)。将
定理1.5应用于子Markov 链(U,X,V),得到7(U;V)≤I(X;V)。类似地，I(X;V)≤I(X;Y)。
!:城小：
d
第1章 熵和互信息量 25
因此对于图1.7中的随机变量，有：
(U;V)≤/(X;Y) (1.15)
这个结论称为数据处理定理。该定理说明信息处理(由图1.7中编码器和译码器完成的工作)
只能破坏信息!例如它说明图1.7中噪声信道的输出Y,比译码器的估计V包含更多有关信
源序列U的信息。(虽然这在理论上是正确的，但为了还原有用信息，仍需要译码器的数据处
理过程。)
衔源一C….L)→缩码姆一(pX:…X)
X U
深码弱(起.R) 信送→(Y.Y?·Y)
Y Y
图1.7 个通用的通信系统
现在讨论两个关于I(X;Y)和∑",I(X?;Y?)的不等式，这里X=(X?,X2,…,X?)和
Y=(Y,Y?,…,Y)是一对n维随机矢量。
定理1.日 如果X中的分量(X?.X?,…,X)是相互独立的，则，
x;Y≥x:Y)
证明：设E表示对X和Y联合样本空间的期望运算。因为假设X,,X?,…,X,是相互独
立的，故有：
X;Y=E|logP [见式(1.5)]
=E lo8x)C2))Px)
另一方面，
Ix。r)=Eog
=e(ogr)
因此，
x,x)-1(x;Y)
=E[o]
≤log [xyle]=0
上式利用了Jensen不等式，其中最后一项期望为：
诺， ·: .5
26 信息论与编码理论(第二版)
p(x,y)…1=p(x?Iy?)…p(xaIyn)p(y)
=∑p(y)(∑p(x?Iy?))…(∑p(。Iy.)) 0
例1.11 设X?,X?,…,X,是独立同分布的离散随机变量，它们的熵都为H。另外设x是菜
合{1,2,…,n|的一个置换，并且令Y;=Xce则I(X;Y)=nH,而∑(X,;Y)=kH,
这里石是π中固定点的数目，即满足π(i)=i的整数i的数目。特别是，如果π没有固定
点，例如如果π(i)=i+I(mod n),则∑I(X;;Y,)=0(见习题1.23)。
假设将(X?,X?,…,X,)看做一个噪声信道的输人，(Y,Y?,…,Y,)看做其输出，定理1.8
告诉我们，如果输人是相互独立的，Y所提供的关于X的信息量，比每个Y,所提供的关于相应
X,的信息量的总和要多。下一个定理将告诉我们，如果不再假设X:是相互独立的，而假设
(X.Y)信道是无记忆的，即，
DCn…nin…,=1uu) (1.16)
情况会完全不同。
定理1.9 如果X=(X,Xz,…,X)和Y=(Y?,Y?,…,Y)是随机矢重，并且信道是无
记忆的，即如果式(1.16)成立，则
x:n<x,x)
证明：再一次设E表示对X和Y联合样本空间的期望运算，根据式(1.16)有
I×;Y)=E|lo[见式(1.7]
=E|logI)k]
另一方面，
x?x)=E[o?
=E log)…P)
因此，
/x;n-x;Y)
..
A
第1章 墒和互信息量 27
=e[logW]
≤log[]
=0
上式利用了Jensen不等式，并由于最后一项期望为：
D…1=∑rw)Pw)
=1
例1.12 假设 X是熵为H的随机变量，令X?=X?=…=X=Y?=…=Y。=X。则该假设满
足定理1.9,并有j(X;Y)=H,∑I(X;;Y)=nH(见习题1.23)。
推论 如果X=(X?,X?,…,x,),则
HX)≤Hx)
证明：定义Y=X,,并且利用定理1.9。
注意 因为当且仅当F(X;Y)= ∑(x;Y?)时，定理1.8和定理1.9的结论可以同时成立，故意味着
这两个定理中任一定理等式成立的充分条件就是另一定理的假设。有趣的是，这些条件也是必
要的(见习题1.24和习题1.25)、
1.3 非离散随机变量和矢量
这一节里我们的目标是将1.1节和1.2节中的结论推广到取值个数不可数的随机变量和
矢量。要想完全严格地论述这个问题是十分困难的，因此只介绍一些基本结论，并建议有兴趣
的读者阅读其他参考文献进一步了解细节s。
我们将看到熵H(X)的定义可以应用于非离散随机变量，但它的值却总是无限的!而在
…对离敞随机变量(或矢量)X和Y之间定义的互信息量，却可以按照一种更有趣和更实用的
方式推广到非离散的情形：其中的关键是对一个随机变量X进行的离散量化的概念。
如果X是一个具有分布函数F(x)=PX≤xi的随机变量，并且如果{S,,i=1,2,…}=P是
将实数轴R划分为有限或可数个Lcbesgue 测度子集的一种分割6,则X被P量化后表示为[X]。
或简单表示为[x],它是由下式定义的一个离散随机变量：
P{[X]=i}=P{X∈S}
=(dFu)
如果 X和Y是一对随机变量，我们定义它们的互信息量I(X;Y)为：
lx:n=(1n;[Ye (1.17)
:d:i:
28 信息论与编码理论(第二版)
这里“sup”取值于实数轴所有可能的P和Q分割。同样，如果X=(X,…,X,)和Y=(Y,,…,Y,)
是…对随机矢量，则
X;Y)= supI[X];[Y]) (1.17')
这里的上确界取值于随机矢量中各组成分量的所有分割[X]=([X?],…、[ X,])和[Y]=
([Y,],…,[Y.])。
如果分割P,中的每个集合都是分割P?中某些集合的子集，则称分割P,为P?的细化。
注意如果分割P?是P?的一个细化，则[X]p就是[X]p,的确定函数，因此根据定理1.5(也见
习题1.22),对于任意随机变量Y,有T([x]e;Y)≤I([X]p,;Y)。这表明随着分割P和Q
的不断细化，定义(1.17)式中的“sup”实际上是一种限定。这一点很容易证明，如果[ X],,
x]?.[Y],和[Y]?分别表示与分割P?,P?,Q?和Q?相对应的离散随机变量，必然存在分割
P和Q,其对应的随机变量[X]和[ Y]满足：
F([X];[Y])=([X];[Y].)i=1,2 (1.18)
现在假设X和Y已经是取值于1x?,x?,…和{y,y?,…的离散随机变量，通过选择X的一
种分割，使每个集合所包含的x,数目不超过一个，同时选择Y的一种分割，使每个集合所包含
的y,数目也不超过一个，显然有I([X]:[Y])=F(X;Y)。并且进一步的细化不能增加
I[LXJ;iY]),因此定义(1.17)式等同于我们前面的定义。
(X,Y)的定义(1.17)式虽然相当简单，但是对于给定的一对随机变量，计算I(X,Y)实
际上并不方便。我们希望有类似于式(1.5)、式(1.6)或式(1.7)的，通过积分而不是求和来计
算I(X,Y)的公式，可是一般情况下这样的公式并不存在7。但如果X和Y足够平滑，就可以
找到这样的公式，现在让我们来看一下。
假设X和Y具有连续的联合密度函数，即对于实数对(x,y),存在一个连续非负值的函
数p(x,y),如果A和B是实数轴上的区间，有：
PX∈A,YEB}=(Jpx,y)dy
这种情况下X和Y的独立密度函数为：
)=pa,)的. 4U)=Jpx,y由
而条件密度函数为：
rx)=g PU)=P)
现在假设积分：
Mx)=pu)lo8*
xir)=Jpx, yloe)dkd
(1.19)
(1.20)
都存在。
第1章 熵和互信息量 29
定理1.10 根据前面的假设条件
I(X;Y)=h(X)-h(XIr)
证明：任意选择0<Ei<E?,并且设…<x-1<xn<x<…是一组可数的点，对于任意的言，
△x,=x?-x?-1满足e<△x?<E?。同样选择(y;),满足e?<△y;<E?。设[X]表示由半开
放区间[x.,x;]组成的实数轴分割对X的量化，而[Y]表示由区间(],-1,y,)组成的分
割对Y的量化。现在临时引入符号：
p(0=P[X]=1F= pw)a
q()=PIY-n-J"q(vybp
DiN=P{X]=6.门=A=puyddp
p(i|/)=P{LX]=i[Y]=j}=p(i,j)/q0)
因为假设所有相关的密度函数都是连续的，根据积分中值定理测，存在s?∈[x,-1,x],
t,∈fy;1,y;],满足：
p(I)=△x;P(S) (1.21) q(i)=△yg()
同样，通过利用二维中值定理[8],在[x?-1,x,]×[y;-1,y,]区间内存在点(,t,),满足：
pti.)=paxlygu)dkdy
Pstquydaedy
=p(sgly)△x?△yq()
(1.22)
因此，
p(il)=△xp(syl4) (1.23)
现在根据式(1.4),I([x];[Y])=H[X])-H([X]1[Y])=∑p(i)bogp(i)1-
∑.p(i,j)logp(ilj)'。根据式(1.21)有：
H(X)=ZApCs)toe)+ZAxp(s)loBK) (1.24)
式(1.24)中的第一个求和项近似于h(X)中的积分[见式(1.19)],因此只要e?值足够小，
它就会收敛。第二个求和项收敛(和式的值小于loge?1)是因为△x?>E?c类似地，
HXlr)=∑AxAypeloatyJOe
+ZAsloBAyeosolae5) (1.25)
30 信息论与编码理论(第二版)
式(1.25)中的第一个求和项是p(x,y)logp(xly)-1的近似阶梯函数的积分，因此只要s?
的值足够小，它将逼近于h(XIY).而根据式(1.22),第二个求和项与式(1.24)中的第二
个求和项相同，
∑ApsltonaC)=-,pu, yday
=云·AxnSs)
因此最后得到：
[X];[IYD)=ZAxpPs]loBpS
-ZAsApISslygs)IO8P) (1.26)
但是正如我们所观察到的，式(1.26)中的第一个求和项近似于h(X),第二个求和项近似
于h(XIY)。因此通过进一步细化X和Y的分割，即随着E?→0,可以肯定I([X];[Y])
将趋近于h(X)-h(XIY)(定理1.10的一个重要应用见习题1.27和习题1.28)。
表面上h(X)的定义非常类似于随机变量的熵的定义[见式(1.1)],似乎应该称h(X)为
X的熵，但这却是用词不当，因为一般应该定义H(X)为H([X])对应X不同离散量化的上确
界。而从定理1.10的证明过程中可以看到[见式(1.24)].H([X])是由两项组成的；其中一项
是近似于h(X)的求和项，而另一项∑p(i)log(△x,)?1却是量化间隔的一种度量，并且显然随
着△x;的减小而趋近于+0。实际上很容易证明H([X])本身总是趋近于+w(见习题1.31),
即使积分h(X)收敛于-!因此尽管五(X)是一个非常有用的量，但它却不是X随机性的一
种度量。事实上h(X)甚至在坐标变换中也不能保持不变(见习题1.33)。因此，h(X)通常称
为X的微分熵，以区别于普通或绝对熵。
类似于离散情况，我们可以很容易地将I(X;Y)和h(X)的定义推广到随机矢量。为定
义通用的I(X;Y),只需分别对每个分量进行离散量化。而对于h(X),假设存在一个n维连
续密度函数p(x),并定义h(X)=-[p(x)logp(z)dx。
例1.13 设X=(X,,X?.…,X),其中X,是相互独立的高斯(正态)随机变量，均值为μ:方
差为a2。则X的密度是函数：
8x)=Tczo)-u2e-20 (1.27)
很容易计算出X的微分熵为：
MX)=]g(x)lo8g(ax
-J8a loe{27y2}
-2Jeusp toac2m3+20
第1章 熵和互信息量 31
(其中g(x,)=(1!√2πa2)exp[-(x?-A)2/2a?)
={[10g(2πo})+1]
(由于J8u)而fsALHpPd=c1)
2g2O…n厂
对于n=1的特珠情况，我们有：
h(X)=log2πeo2
一个重要而有趣的事实足，在给定方差的所有n维随机变量中，相互独立的高斯随机变
量具有最大的微分熵、
定理1.11 如果X=(X?,X?,…,X)的密度函数为p(x),并且E[(X-A)2]=o2,
i=1,2,…,n,则h(X)≤(n/2)log2πe(o}a2…2)V,当且仅当p(x)=g(x)[见定义
(1.27)式]时，等式成立(个别情况除外)。
?p(x)d=1.?p(x)(x-m)Pd=0}。 证明：根据假设，X,的边缘密度函数p?(x)满足
因此根据例1.13中的计算，有：
pu)lo8g()x=2log2reko}…2°
因此如果Y表示分布满足高斯密度函数g(x)的n维随机矢量，
h(X)-h(x)=(p(x)log)a
根据Jensen 不等式，上式中最后的积分式
≤og ?gux)cx=0
此外，对于几乎所有的x,当且仅当g(x)=p(x)时等式成立。(习题1.34和习题1.35是
定理1.11的扩展。)
简单地讨论了微分熵的有趣话题后，我们回过来研究主要关心的互信息量。这里是在一
定的可信度下，证明定理1.3、定理1.4,定理1.5、定理1.8和定理1.9在一般情况下仍然成立。
定理1.3、定理1.8和定理1.9的证明并不困难，下面是证明的一些要点。
定理1.3,对于X和Y的任意离散量化，有T[X];[Y])≥0,因而可以立即得出I(X;Y)≥0
的结论。进一步地，如果X和Y是相互独立的，则[X]和[Y]也是相互独立的，因而对于所有的量
化，有I[X];[Y])=0;因此根据式(1.17)有T(X;Y)=0。最后，如果X和Y是相关的，就可以
找到量化的[X]和[Y]也是相关的(见习题1.36),所以I(X;Y)≥1[X];[Y])>0。
定理1.8。将上面的观察进一步推广，我们发现如果 X,,…,X。是相互独立的，则[X?],
[X?],…,[X,]也是相互独立的，因此根据定理1.8,
(X;[XD=Z×1:[Y) (1.28)
,
32 信息论与编码理论(第二版)
但是随着[X,1和[r,]量化的进一步细化，式(1.28)左边趋近于(X;Y),而右边趋近于
L”,I(X,;Y)。
定理1.9。这里的主要问题是适当地推广假设
eux)=Ⅱpexk) (1.29)
[见式(1.16).]为此我们需要深人研究条件概率分布(例如可参考Feler[4],第2卷，V.10节)。
但是通过定义一个无记忆信道可以回避这些问题，假设该信道输人和输出的所有量化满足
式(1.29),这个条件通常很容易证明(见习题4.27),因此可以立即将定理1.9应用于输人和
输出的每一种量化：
(X;Y)=(xJ;[Y) (1.30)
并且随若式(1.30)中量化的细化，得出定理1.9对于任意随机变量都成立的结论。
最后讨论一下定理1.4和定理1.5。首先观察到定理1.5是定理1.4的一个直接推论，因
此我们将重点放在定埋1.4上。一般证明I(X,Y:Z)≥I(Y;Z)成立不存在问题，因为对于
x,Y和Z的每一种量化，我们直接从定理1.4可以得到f([x],[Y];[Z])≥7([Y];[Z])。
但是要证明定理1.4的第二部分并不容易，即当且仅当(X,Y,Z)构成一个Markov链，I(X,
Y;Z)=F(Y;Z)成立：问题是如果(X,Y,Z)是一个Markov 链，而[X]和[ Z]分别是X和Z的
量化，有可能找不到Y的一个量化[Y],使得([X],[Y],[Z])构成一个Markov链(见习题1.37
至习题1.39)。这里不打算提供详细的证明，但是读者可以参考Pinsker[24]的第3章，该书对
我们引用的结论给出了严格的证明⑧
习题
1.1 证明如果以下两个假设中的任何一个成立，则在H(X)的定义(1.1)式中必须规定0logl/0=0:
(a)H(X)是概率分布矢量p=(p?,P?,…)的连续函数。
(b)如果X和Y是定义在同一样本空间上的随机变量，且X=Y几乎处处成立，则
H(X)=H(Y)。
1.2 如果X如例1.3中定义，证明H(X)=+的。
1.3 令X是一个离散随机变量，而f是X定义域上的一个实值函数。证明H(X)≥
H[f(X)],当且仅当f与集合|x:PIX=x}>0l—一对应时等式成立。
1.4 寻找两组不同的分布pI≥P?≥…p>0与q?≥92≥…≥gm>0,使得H(pi,p?,…,p)=
H(q?,qz,…,qm)。
1.5 当p取遍 n维概率分布矢量集时，H(pi,…,pa)=H(p)的最小值是多少?找到能达到
此最小值的所有po
1.6 给定概率分布(p?,p?·…·p)和一个整数m,0≤m≤n,定义qm=1-2,,p。证明
H(p?…,pa)≤H(pi,…,Pa,qm)+gmlog(n-m)。等式何时成立?
1.7 令f(x)是定义域为x≥1的任意函数。如果 X是一个离散随机变量，取值范围R=|x?,…,
第1章 熵和互信息量 33
x,定义X的f熵为H(X)= ∑",pf(1/p.),其中p=PX=x,}(通常在熵的定义
中，f(x)=logx),
(a)如果f(x)是上凸∩函数，则寻找H(X)的只依赖于n的最佳可能上限。举例说明达
到这个最大值的概率分布可能不是惟一的：
(b)如果f(x)=logx/x,证明H,(X)<log(e)/e。[注意：f(x)不是上凸∩的。]
(e)利用(b)中的结论，进…步证明，实际上H(X)≤log(3)/3,当且仅当p.中有三个等于
13,其余的都为0时等号成立。
1.8 令a=(ai,a?,…)为一个非负值实数序列，且能使和式Z(s)=∑,e-??所有足够大
的s收敛。(例如，如果只有有限多个a,这个条件就能满足。)对每个a>0,定义中(a)=
supiH(p):∑Pa=al。证明更(a)能用参数表示为Φ(a)=logZ(s)-SZ'(s)/Z(s),
其中 Z'(s)/Z(s)=~a.[提示：如果∑PaA=a,定义一个新的概率分布为g=
e-?(s),然后对和式∑palog(q?/p.)应用Jensen不等式。]如果a=(ai,a?,…,as)
仅有有限多个分量，证明更(α)对应α的曲线应类似于下图：
8
c s-0 s-+四
Φ(C)
A
s--。
α—
请给出A,B和C点的坐标。
1.9 令p=(p?,P?,…)是--个可数的概率分布，即对于π=1,2,…,有p≥0且∑P=1。证
明如果∑_p.logn收敛，则H(p)是有限的。相反，如果H(p)有限且p是单调的(即
P≥p一),证明≥plogn<。举例说明如果缺少了单调性的假设,后面那个结论将不
成立。
1.10令X和Y是例1.6中定义的随机变景。证明 Cow(X,Y)=0,(X:Y)=I bit。找到这样
的DMC,使X是Y经过该信道受噪声干扰后的输出。
1.11 找到使定理1.2等式成立的联合概率分布p(x,y,z)的充分必要条件。利用这个结论，
对任意r≥2和任意0≤P≤1,构造取值范围为31,2,…,r的随机变量X和Y,使得Famo
不等式(定理1.2的推论)的等式成立：
1.12证明Fam不等式以H(XIY)形式同时暗示了P.的上限和下限。试着解释一下这个
上限。
1.13设X和Y是随机变量，并且都在有限集中取值。定义Z=Y-X。利用定理1.2,证明
H(XIY)≤H(Z)。如果X与Z相互独立，证明H(XIY)=H(Z)。
1.14证明式(1,5)至式(1.10)。
1.15 证明(X,y,Z)是离散Markov链的充分必要条件为(Z,Y,X)是离散Markov 链。
34 信息论与编码理论(第二版)
1.16 证明例1.9。
1.17(a)X是一个随机变量，均匀分布于10,1,21。Y是一个仅取二值10,1的随机变量。在
所有Y中I(X;Y)可取到多大?
(b)现在令X是一个随机变量，均匀分布于10.1,….n-1|:Y是一个取值范围为10,1,…,
m-1|的随机变量。在所有Y中(X;Y)可取到多大?[注意：只有m<n的情况是有意
义的。]
1.18设n个相同的BSC 级联，
BSCAn→x, X→BSC*1一X?—
[1- 每一个BSC的原始错误概率都为p,证明该信道等价于一个BSC,其错误概率为
(1-2p)"],并且lim。I(X?;X)=0,如果p≠0,1。
1.19如果 x,Y和Z是定义在相同样本空间上的三个离散随机变量，条件互信息量/(X;YI Z)
(给定Z,X与Y之间的互信息量)定义为：
x;YZ)=Zou,y,z)l0)
其中的求和采用通常的惯例。证明：
(a)(X;YIZ)=I(Y;XIZ)。
(b)I(X;Y,Z)=I(X;Z)+I(X;YIZ)。
(c)I(X;YIZ)≥0,当且仅当(X,Z,Y)是一个Markov 链时等式成立。
1.20(有限 Markov 链。)令A=(ay)是一个r×r阶随机矩阵，即对于i=0,1,…,r-1,有
ay≥0且∑a,=1。将A看做是一个 DMC的转移概率矩阵，即PIY=jlX=ii=C
考虑这个信道的一个半无限级联：
x一DMC→x一2一一→
现在令(pa,pi…,P,-)=p是一个概率矢量，它对A是稳定的，即p;=Zp.ag,其
中，j=0,1,…,r-1,设上图中X。的概率分布为p。
(a)证明X,x,,X?,…是具有相同分布的随机变量。在什么条件下它们是独立的?《序
列X?,x?,X?,…称为有限Markov链；参见 Feller[4],第1卷，第15章和第16章。)
(b)Markov链X。,X,,…的(每符号)熵定义为：
H=lin(xa,Xi,….X)
证明：
H=∑nayB
(c)给出 Markov 链的转移概率矩阵如下，计算它们的稳定概率分布和熵。
第1章 熵和互信息重 35
8
(在最后的例子中每一行是前一行的向左循环移位。)
1.21 7(X;Y)是p(x)的严格上凸∩函数吗?它关于p(ylx)是严格下凹U的吗?
1.22设X=(X,,…,X。)和Y=(Y?,…,Y)是离散随机矢最，令f和g是分别具有n个和m
个实数自变量的实值函数。证明I[?(X):g(Y)]≤/(X;Y)。
t.23补充例1.11和例1.12中缺少的细节部分。
1.24证明定理1.8中等式成立的充分必要条件是对所有的(x,y),有p(xly)=II"p(x,Iy.)。
1.25 证明定理1.9中等式成立的充分必要条件是Y,,Y?,…,Y,是相互独立的，由此，定理1.9
的推论中等式成立的充分必要条件是X?,…,X。是相互独立的。
1.26 如果X和Y=(Y,,Y?,…,Y。)是离散随机矢量，证明I(X;Y)≤Z",I(X;Y)是否
成立。
1.27设X和Z是相互独立的随机变量，具有连续的概率密度函数，令Y=X+Z。如果h(Y)
和h(Z)存在，证明I(X;Y)=h(Y)-h(Z)。证明如果X和Z是随机矢量，相同的公式
也成立。
1.28(续)设X和Z是相互独立的随机变量，X是离散的，z有连续的概率密度，令Y=X+
z。证明Y有连续的概率密度，并且如果 h(Y)和h(Z)存在，则(X;Y)=h(Y)-
h(Z)。证明如果X和Z是随机矢量，则有相同的结论。
1.29 如果X=(X?,…,X)中各个分量是相互独立的高斯随机变量，均值为μ,方差为c2。
X'=(X,,…,X???质同上，且均值为μ,方差为o2,证明X+X'=(X?+Xi,…,X+
X°)也有相同的性质，且均值为μ,+m,方差为a2+o2。
1.30如果X?,X?,…,X。是相互独立的随机变量，且具有微分熵h(X,)=h,,证明：
x+…+xJ=10()
等式成立的充分必要条件是X:为高斯变量，方差o2=e2.2πe。
1.31 如果 X具有连续概率密度函数，证明supH([X])=+的，其中上确界是取遍X所有可
能的离散量化而得到的：
1.32 构造一个概率密度p(x)对所有实数都连续的随机变量，使得h(X)=-。
1.33 设X是…个n维随机矢最，具有连续的n维概率密度p(x)和微分熵h(X)。令f是一个欧几
里得n维空间E上连续可微的一—映射。证明h[f(X)]=h(X)+?p(x)loglJdx,其中
J=J(x?,…,x)是变换f的雅可比变换式。
1.34设X=(X?,…,Xa)是一个存在概率密度的随机变量，对于所有的i和j,令E[(X?-μ.)(X,-
A,)]=p。证明：
:1
h(X)<2og2nc(c2)/
让
…"相时能作者作地民装起中容
36 信息论与编码理论(第二版)
其中c2是矩阵(p;)所对应的行列式的值。此外，证明等式成立的充分必要条件是X为
n维正态分布的随机变量，其协方差矩阵为(pa)。(参见Feller[4],第2卷，Ⅲ.6节。)
1.35设f(x)是定义在区间了上的一个连续实值函数，本习题的目的是，如果X的概率密度
函数满足当xE/时，p(x)=0,且j,p(x)(x)dx=A,其中inf()<A<sup(f),求出微分
熵h(X)可取到多大值。(例如，如果I=(-0,∞),而f(x)=(x-μ)2,我们将通过一
C(s)=je-)dx。证明存在so,使 条新途径得到一维条件下的定理1.11?)定义
G(s?)/G(sn)=-A,并定义x∈I时g(x)=e-/G(sn),x≠/时q(x)=0。证明
h(X)≤logG(sg)+s4,等式成立的充分必要条件为X的概率密度几乎处处等于q(x)。
[提示：见习题1.8.]将这个通用方法应用于三种情况：
(a)f(x)=logx,J=(1,的)。
(b)f(x)=x,I=(0,≈)。
(e)f(x)=lx1,1=(-的，的)。
1.36 如果X和Y不是相互独立的随机变量，证明存在着离散量化的{X]和[Y].它们也不是
相互独立的。
下面的三道习题需要读者具有一些简单的Markov 链的知识；例如，可参见 Feller[4],
第2卷，班.Ⅱ节。
1.37 设(X,Y,Z)是一个Markov 链，满足对于任意量化[x]和[z]都存在量化[Y],使得([X],
[Yj,(21)构成一个离散 Markov 链。证明I(X;Y,Z)=I(X;Y)。
1.38考虑(X,f(X),Z)或(X,Y,f(Y))形式的Markov链。证明这类链具有习题1.37所述的
性质，定埋1.4也适用于它们。[提示：对于(X,f(X),Z)的情况，如果|S1是X的分割，
令f(S,)是Y的分割：]
1.39设X?,X?和X?是独立同分布的高斯随机变量，均值为0,方差为1。证明序列(X,Y、Z)
构成一个Markov 链，其中X=x?,Y=x?+X?,而Z=X?+X?+X?。(见例1.9。)但是也
要证明，如果[ X]和!z]是X和Z的量化，并假设二者都具有两个以上的取值，那么对于
Y的任何量化[Y],([X],[Y],[Z])都不是Mankov链。
注释
[1] 假设你可以问问题Q:“我能活到n岁吗”。考虑一下随着n的减少，你的不确定
性(焦虑)将会怎样地增加。
[2] H(XIY)有时也称为(Y关于X的)疑义度。
[3] 在正规的数学术语中“离散”的意思是有限或可数。令我们的DMC的输人和输出符
号集可数是没有问题的，但是为了避免与公认的信息论应用相矛盾，通常不这样做。
[4] 这些定义仅当p(x)p(y)≠0时才有意义。如果p(x)p(y)=0,则p(x,y)也等于
0,这样就可以随意定义T(x:y)而不影响I(X;Y)的值。
[5]这方面最全面的介绍由Pinsker[24]的前三章给出。
行心机…的上……………………………
日
第1章 熵和互信息量 37
[6] 实轴R的一个分割是指其有如下性质的子集(S,)的组合：Us,=R且当i≠j时
s,Ns,=卢
[7] 这种说法严格来讲是不正确的。在Pinsker[24]中证明了I(X;Y)或者无穷大，或者
等于联合样本空间(X,Y)上 Redon-Nikodym导数 du/dμ,×A,求对数后的期望值，
其中μn是(X,Y)的联合概率测度，而A×μ是X和Y的边缘概率测度的乘积。因
此形式上，
x;r=[(loa)do
[8] 这里所应用的定理的一般形式是，如果f(x)是连续的，则sf(x)g(x)dx=
f(x?)!sg(x)dx,x?∈S中的某个值。(见Apostol[2],定理14.16:)
[9] 也许应该简要介绍一下 Pinsker的证明。要证明的结论是I(X,Y;Z)=F(Y;Z)当
且仅当(X,Y,Z)是Markov 链时成立。因此，如果定义条件互信息量I(X;ZIY)为
(X;ZIY)=I(X,Y;Z)-1(Y;Z),要证明的结论变为I(X;ZIY)=0当且仅当
(X,Y,Z)是Markov 链时成立。Pirsker书中第3章的全部内容都是有关条件互信息
量性质的。他首先给出了一个I(X;Z2IY)的抽象量度理论的定义(并不是上面给出
的那个),并证明了很多基本性质，如I(X;ZIY)≥0(等价于定理1.4)和I(X;ZIY)=
(Z;XIY)(见习题1.19),并证明了(X;ZIY)=0当且仅当(X,Y,Z)是Markov链
时成立：最后在3.6节中证明了I(X;ZIY)=I(X,Y;Z)-I(Y;Z),并将此结论归
功于KolmogprvW。
淋
第2章 离散无记忆信道及其容量-代价函数
2.1 容量-代价函数
离散无记忆信道(DMC)由两个有限集合(输入符号集Ax,输出符号集Ay),以及一组转移
概率p(ylx)来描述，其中p(ylx)满足对于任意x∈Ax和y∈Ap,有Ap(ylx)≥0,并且对于
所有的x∈Ax,有2,p(ylx)=1。如果Ax有r个元素，而Ar有s个元素，用一个r×8阶随
机矩阵"Q=(qx)来描述转移概率比较方便，它的行由Ax标注，而列由Aγ标注。此外，对应
于每个输人x,存在一个非负的数值b(x),为x的“代价”;2。通常Ar表示为10,1,…,r
1},Aγ表示为10,1,…,s-1!
例2.1 Ax=Ay={0,11,
e=8
其中0≤p≤2,q=1-p(这是一个二进制对称信道),并且b(0)=0,b(1)=1。
例2.2 Ax={0.2.1},Ay=10,1},
-
并且b(0)=b(1)=1,b(2)=0。
例2.3 Ax=Ay=10,1,21,
-
并且b(0)=b(1)=1,b(2)=4。(本章后面我们还会用到这些例题。)
这样定义离散无记忆信道的动机是希望将信道假设为一个设备，它在单位时间内接收一
个x∈Ax的符号，并且相应输出一个y∈A,的符号。信道是不可靠的，即输出不是输人的确
定函数；p(ylx)是给定输人x,输出y的概率。另外，信道的使用并不是免费的，输入x的“代
价"为b(x)。
1.
第2章 离散无记忆信道及其容量-代价函数 39
更一般地，假设在连续n个时刻使用信道，输人为x?.x?,…,x。,而相应的输出为y?,
Y?,…,Ya。无记忆的假设是指i时刻的输出y,只依赖于i时刻的输人x,即给定输人
x1.…,x。,输出y?,…,y。的条件概率是乘积Tp();lx,)。传输x,x?,…,x。的代价
定义为：
x)=) (2.1)
如果这n个输入用联合分布函数为p(x)=p(x?,…,xa)的随机变量X=(X?,X?,…,Xa)来
描述，平均代价定义为：
ELbx=E0m
=∑pPx)bx)
(2.2)
对于n=1,2,….我们定义信道的n阶容量-代价函数C(β)为：
Cn(β)=max{I(X;Y):E[b(X)]≤nβ} (2.3)
式(2.3)是对所有满足下面条件的n维随机矢量对(X,Y)=((X?,…,X),(Y,…,Y))
求极大值：(i)条件概率P{YFXI与给定信道的转移概率相一致，即PIY?=y?,…,Y=yl
X?=x?,…,X,=x= π"p(y.lx?);(i)输人矢量X满足 E[b(X)]≤nβ。我们称输入矢
量X为一个试验信源；如果它满足E[b(X)]≤nβ,我们称它为β-容度。因此式(2.3)是对所
有n维β-容度试验信源求极大值。
下面是关于函数C.(β)的儿点说明。首先，注意在给定转移概率矩阵(p(ylx))的条件
下，(X;Y)是输人分布p(x)的连续函数。而满足∑p(x)b(x)=E[b(X)]≤nβ的分布的集
合是┌维欧几里得空间的一个完备子集，因此函数I(X;Y)实际上能够达到它的极大值3。这
就是式(2.3)中采用了“max"而不是“sup”的原因。第二，注意如果我们定义βm为：
pmin=mibx) (2.4)
则E[b(X)]≥a·βm,因此C(β)只定义在β≥β的范围内。最后，如果R>β?,满足
E[b(X)]≤nB?的试验信源的集合是满足E[b(X)]≤nβ的试验信源的集合的子集，因此
C(β?)≥C(?),即C?(β)在β≥β范围内是上升函数。
现在定义信道的容量-代价函数4为：
CA)=sup CaB) (2.5)
如果单位时间内占用信道的平均代价必须≤β,则C(β)的值表示信道单位时间内能够可靠传
输的最大信息量：这个结论的精确描述，即香农的信道编码定理，将在2.2节中证明。本节中
我们的任务是研究在给定 DMC和代价函数的条件下计算C(β)的方法。
首先证明所有的函数C,(β)是上凸∩的。
、
40 信息论与编码理论(第二版)
定理2.1 C(β)是β≥β的上凸∩函数。
证明：设α,Q≥0,a?+az=1。我们需要证明的是，对于β,β?≥β,有：
Cn(a?β?+αzβ?)≥aiCn(β)+a?Ca(β?)
为此，设X?和X?是n维试验信源，其分布p?(x)和p?(x)分别地达到C(β?)和C(B),
即如果Y?和Y?表示与X,和X?对应的输出，则有：
/M)=CA} i=1.2 (2.6)
(2.7)
进一步定义试验信源X,其分布为p(x)=Q,p?(x)+α?p?(x),并设Y是相应的榆出。则
E[b(X)]=∑,p(x)b(x)=a?∑,p?(x)b(x)+a?∑.p?(x)b(x)=a?E[b(X)]+
a?E[b(X?)]≤n(a?β+a?B?)[见式(2.6)],可见X为(aβ+a?R)-容度。因此I(X;Y)
C(a?R+a?B)。但是由于I(X;Y)是愉入概率分布p(x)的上凸∩函数(定理1.6),因此
I(X;Y)≥a?I(X;Y)+a?I(X?;Y?)=a?C(β?)+a?C?(β2)[见式(2.7)]。
我们下面的结论表明令人望而生畏的定义(2.5)式其实并不可怕S。
定理2.2 对于任意 DMC,C(β)=nC?(β)对所有的n=1,2,…和所有β≥β都成立。
证明：设X=(X?,…,X,)是一个达到C(β)的β-容度试验信源，即
E[b(X)]≤nβ (2.8)
(X;Y)= Cn(β) (2.9)
其中Y=(Y,,…,Y)是相应的信道输出，根据定理1.9有：
x.n=x;t) (2.10)
如果我们定义β,=E[b(X?)],则有：
B=ELbXJ
=E[b(X)I
nβ
(2.11)
进一步根据C?(β)的定义(2.3)式有：
I(X;Y)≤C?(β) (2.12)
由定理2.1知，C?(β)是β的上凸∩函数，根据 Jensen不等式，有：
Cus)=c(台Bb)-c{0bx}}
但是，由于(1/n)E[b(X)]≤β,并且C:(p)是β的上升函数，
CuB)s nCA (2.13)
第2章 商散无记忆信道及其容量-代价函数 41
综合式(2.9)、式(2.10)、式(2.12)和式(2.13),我们得到G(β)≤nC?(β)。关于反向不等
式，设(X,Y)是达到C?(β)的一对随机变量：
E[b(X}]≤β (2.14)
I(X;Y)=C?(β) (2.15)
设X,,X?,…,X,是独立、同分布随机变量，它们的分布函数与X的相同，并设Y?,Y?,…,
Y是相应的信道输出。根据式(2.14),E[b(X)] =∑E[b(X,)]≤nβ,并且1(X;
Y)= ∑"I(X,;Y,)(根据定理1.8和定理1.9)=nC?(β),因此C(3)≥nC?(β),定理成立。
推论 对于无记忆信道，C(g)=C,(β)[见定义(2.5)式]。[注意：这个结论对有记忆信道
不成立；见习题2.10。]
现在让我们讨论一下在给定 DMC和代价函数的条件下，函数C(β)的一般性质。我们知
道如果β≥β,则它是一个上升、上凸∩函数。它的上凸性意味着对于β>βm,它也是连续
的；参见附录B(它在β=β点也连续；见习题2.5)。现在将讨论当β足够大时，C(9)实际上
是一个常数。定义Cmm=maxiC(β):β≥βm!.即
Cmax=max{I(X;Y)} (2.16)
其中的极大值取值于所有的(1维)试验信源，不受E[b(X)]的限制。C称为信道的容量。
如果我们定义：
βmax=min{E[b(X)]:I(X;Y)= Cmax} (2.17)
测显然对于所有β≥p,有C(β)=C;而对于β<β,有C(β)<Cm。由于当β≥f时
C(β)是上升和上凸∩的，并且当≥β时C(β)是一个常数，故可知C(β)在Bm≤β≤β范
围内实际上是严格上升的(见习题2.6)。因此在这个区间内C(3)可以定义为：
C(f)=max{L(X;Y):E[b(X)]=},βmn≤β≤βmax (2.18)
最后，我们来计算 C(β_)=Cmm。一个试验信源为β-容度，当且仅当b(x)>β时它
的p(x)=0,即它只使用代价最小的输入。因此 C是简化信道的容量，它删除了原来信道中
所有b(x)>β的那些输人。
综合所有这些事实，我们看到典型的 C(β)曲线应该如图2.1所示：
(nax
Cmn
βm
例2.1(续)
Pm
图2.1 典型的C(5)曲线
e=[p9]
:l
42 信息论与编码理论(第二版)
b(0)=0,b(1)=1。这里β=0,简化信道只有一个输入0,因此C=C(0)=0。设X
是一个在0≤β≤β范围内达到C(β)的试验信道。则[见式，(2.18)]必然有P{X=1}=
β,PIX=0|=α=1-β,而C(β)=(X;Y)=H(Y)-H(YIX)=H(ag+βp)-H(p)。
由于H(x)在x=2时达到它的极大值log 2(参见图1.1),故可知H(ag+βp)在β=2时
β=2,而C(β)的完整曲线(参见图2.2)由下面的表达 达到它的板大值Log 2。因此
式给出：
={m2-HO+-M1
log2 Hp)
-
1/2
图2.2 例2.1中C(β)的曲线
例2.2{续)
-19
b(0)=b(1)=1,6(2)=0。这里βm=0,因此同上一个例题一样，C(O)=0。设X表示
立,I时，p(x)= 在0≤β≤β范围内达到C(3)的试验信道的一个输入，并且设x=0,
p(0),p(2),p(1)是上凸∩的，并且E[b(X)]=(p(0)+ P|X=x|。现在【(X;Y)相对
p(1))相对p(0)和p(1)是对称的，因此必然有p(0)=p(1)=β/2。则I(X;Y)=H(Y)-
H(YIX)=log2-(1-β)log2=βlog 2。因此β=1.C(β)的曲线(参见图2.3)由下式
给出：
Ce)-{80g2b≥11
这表明在β_≤β≤β_范围内，C(β)并不一定是严格上凸∩的。
log2
1
图2.3 例2.2中C(β)的曲线
例2.3|续) =
.心：
:i
第2章 离散无记忆信道及其容量-代价函数 43
b(0)=b(1)=1.b(2)=4,设X是达到C(β)的试验信道的一个输入，并设a?=P{X=1,
i=0,1,2.则C(β)=H(Y)-H(YIX)=H(Y)=H(X)=H(ao,a,α),并且对于
β≤β≤β,F[b(X)]=an+a?+4a?=β。显然3=1,简化信道的输入只有0和1,
相应的转移概率为：
g=[69]
这个信道的容量(见例2.1)是log2,因此C(1)=log2.同理C=max(H(ag,a,a?)=log3,
其中an=a?=a?=号(定理1.1),因此β=3+s+4=2,Cm=Jog3。对于I≤f≤2,必须
在满足ao+a?+4a?=β的条件下求H(co,a?,a?)的极大值。其中a。和a,是对称的，因此
我们设a=a?=a,a=1-2a,从而得出a=213-β/6,因而对于1≤β≤2.有C(β)=
H(2/3-β/6,2/3-8/6,3/3-1/3)。C(β)的曲线见图2.4。习题2.3是例2.1和例2.3的一个
扩展、
log3
◆一· lop 2
上 2
图2.4 例2.3中Cβ)的曲线
本节的最后，将介绍一个计算容量(即C)的定理，该定理要求信道的转移概率矩阵具
有高度的对称性。如果随机矩阵Q的每一行都是其他行的-一个置换，同时每一列都是其他列
的一个置换，我们就称Q是对称的。如果一个DMC的转移概率矩阵是对称的，则DMC就是对
称的。
例如，
e-
是对称的，而
c=
却不是(见习题2.2)。
定理2.3 如果一个对称 DMC有r个输入、3个输出，则输入等概，即p(x)=1/r,x∈10,
1,…,r-1时，DMC达到它的信道容量，容量是：
Cnux= logs-H(qn,…,g)
其中(o,q,…,q.-1)是转移概率矩阵的任意一行。
证明6:I(X;Y)=H(Y)-H(YIX),H(YIX)=∑p(x)H(YIX=x)。但是由于矩
、,地： .
1…4…11…7……11…………4……17…7…1………………5…4754 44 信息论与编码理论(第二版)
阵的每一行都是其他行的一个置换，
uyIx=n=∑nustom=R(gmgi…9-)
是独立于x的。另外根据定理1.1,H(Y)≤logs,等式成立当且仅当p(y)=1/s,其中y∈
10,1.…,s-1.但是，转移概率矩阵的列的性质确保，如果对于所有的x,有p(x)=L/r,
则对于所有的y,有p(y)=1/s。
例如，前面给出的具有对称转移矩阵Q的信道有C=log4-H(青，方6)=
log(233-1)=0.0817 bit。…个更普遍的例子是r进制对称信道，它的转移概率矩阵是一个
r×r阶矩阵，满足q=E(如果x≠y),q=1-(r-1)e(如果 x=y),其中0≤6≤1/(r-1)。
r=2时就是我们熟悉的BSC;r=4时的转移概率矩阵如下：
-
根据定理2.3,r进制对称信道的容量是logr-H1-(r-1)e,e,…,c]=logr+(r-1)eloge +
(1-7E+e)log(1-rE+e)。[习题2.3中给出了一种计算r进制对称信道容量-代价函数
Cβ)的方法。]
2.2 信道编码定理
根据2.1节的结论，如果X=(X,X?,…,X?)表示给定DMC的连续 n个输入，而Y=
(Y?,Y?,…,Y)是对应的输出，则n-1(X;Y)≤C。根据第1章中给出的I(X;Y)的通俗
解释，这就表示，信道在单位时间内至多能传输C比特的信息7。另一方面，如果X表示一
个达到C(β)=C的试验信源，则7(X;Y)=C,这意味着如果应用合理，信道在单位时
间内至少能传输Cm比特的信息。因此 C应该代表在信道中传输信息的最大速率。更一般
地讲，对于任意β≥β,如果平均输人代价必须≤β,C(β)应该代表在信道中传输信息的最大
速率。我们本节的目标就是明确这些直观的推断。
设想一个实验。构造信息源序列U=(U?,U?,…,UA),序列的各个分量由独立、同分布
的随机变量组成，具有相同的概率分布函数PIU=0|=PIU=1=2。。我们的目的是在信道
中传输这k“比特”信息，共利用信道n次，平均每次的代价≤β。设X=(X?,X?,…,X。)是
相应的信道输入，Y=(Y,Y?,…,Y)是信道的输出，而C=(0,…,0k)表示接收者对U的
估计，我们假设它只依赖于Y(见图2.5)。
业 —X
—
倘道 Y
图2.5 一个设想的通信系统
假设这是一个相当可靠的系统，即对于所有的i,有P10;≠0I<e,其中；是某个很小
l
第2章 离散无记忆信道及其容量-代价函数 45
的值。则根据定理1.8,1(U;U)≥Z..,(U;0,),井且根据 Fam不等式(定理1.2的推论),
(U.;0)=H(U?)-H(UIU)=log 2-H(U10.)≥log 2-H(e)。因此有I(U;O)≥
k[1-H?(e)]。再根据数据处理定理[式(1.15)],1(U;V)≤I(X;Y)。最后根据式(2.3),
I(X;Y)≤C(β)=nC(β):综合这三个不等式，我们有(其中对数运算的基底是2):
se (2.19)
比率k/n称为系统的速率，根据设想的通信系统实验，它表示每次利用信道所传输的比
特数。边界(2.19)式是误比特半e的上升函数。这个结论并不奇怪：它只说明我们越希望通
信可靠，就越应该降低传输速率。从数量上来讲，式(2.19)说明，如果使用信道的平均输入代
价≤β,并且希望设计一个速率r>C(β)的系统，则最终错误概率ε的下界为e≥H-1[1-
C(β)/r]>0。即使没有代价约束，如果r>Cm,则E≥H?'(1-C/r)>0。简单地讲，当迷
率高于信道容量时不能实现可靠通信。
速率低于C(β)时会怎样呢?式(2.19)不能提供任何有意义的帮助，因为如果k/n<C(β),
所有的e≥0都能使式(2.19)成立：但这并不是问题，因为我们现在将证明，如果R<C(β)
并且ε>0,可以成功地设计出上述类型的通信系统，满足平均代价≤β,k/n≥R,并且
Pl?≠U,I<e对于任意的i都成立!香农的这一惊人结论称为信道编码定理。这个结论的
关键是构造一个码，我们现在就来描述一下。
给定整数n,一个取值于Ax、码长为n的(信道输人)码是A的一个子集C=IM,x?,…,
。码的速率定义为r=(1/n)logM——如果对数运算以2为基底，速率的单位是比特每(信
道输人)符号。如果对于所有的i,有b(x:)=Z",b(x.)≤nβ,则码是β-容度的，其中
x=(x,…,x)是x,组成分虽的展开：
码C的译码规则是映射f:A-CUI?l。特殊符号“?”表示译码失败，它的特点将在下面
表现出来。
如下文所述，按照图2.5中的方式，可以设计一个通信系统。设k是一个整数，满足 k≤
log,M,则可以给2*个可能的信源序列中的每一个分配一个不同的码字x,:。所有可能的信
源序列到码C的——映射称为编码规则。如果被传输的信源序列是n=(u,…,a),就意
味若要通过编码规则将u编码为一个码字x,,并通过信道传输x:。在信道的另一端出现了x,
的噪声样本，称它为y。接收者通过译码规则f将y译为码字x,(或“?”);而口的估计a是与
码字x;对应的惟一信源序列(如果存在)。假设传输的是x?,系统的错误概率表示为P,由
下式给出：
=P{f(y)≠x;}
=Z{p(yx):f(y)≠x:} (2.20)
其中p(ylx,)=Ⅱ,,p(y,lx,)是信道转移概率矩阵Q中对应项的乘积。
在表述和证明编码定理之前，我们将通过三个相当初级的例子来说明编码过程。(本书
第二部分的任务才是给出高级的例子!)
!:非
46 信息论与编码理论(第二版)
例2.4 A=Aγ=10,I:
e=[3g
b(0)=b(1)=0(这是一个没有输入代价约束的BSC)。编码：π=3,M=2,C=|(000),
=3 (111),速率 比特每符号。译码规则：f(yy?y?)=(xx),其中x=yi,y?和y3的
P<2 “多票判决”。很容易证明P1)=P(2 =3p2-2p3,如采 ,该值小于原始的错误概率
p,并且当p的值非常小时，效果更明显[见式(0.1)]。
例2.5 Ax={0,2.1}.Aγ=10,11,
-1
b(0)=b(1)=1,b(贵)=0(这与例2.2相同)。编码：C={x?,x2,…,,立，2,…2):
x,=0或1,i=1,2,…,k}。这里去是某个≤n的国定整数而M=21。编码速率是k/n比特
每秒。对于所有β≥k/n,这个码是β-答度的。译码规则：f(yi,….y)=
(n,…,ya,…2)。这里对于所有的i.P3=0(见习题2.11)。
例2.6 Ax=10,11,A?=10,1,2,3,
e-
b(0)=b(1)=1(这是前面提到的“对称”信道)。编码：n=2,M=2;C=1(00),(11)},
r=空 迷率， 比特每符号：译码规则由下表给出：
:
0 I 2 3
0 00 (0 00
00 00 ? 11
00 ? 11 11
? 11 11 11
fvJ2)-
i 1
2
r)项
译础矩阵中的菜
3
这里P=9,i=1,2(见习题2.12)。
现在回到边界(2.19)式，我们要做的是，对于给定的β值、R<CCβ)和E>0,设计一个
k/n≥R的系统，满足对于所有的i,PIU≠0<ε。从前面的讨论看到，这需要寻找一个码
长为n的码C,以及相应的译码规则，满足M≥2以及PE<e(对于所有的i)。下面的定理
表明这是可以实现的。
第2章 离散无记忆信道及其容量-代价函数 47
定理2.4 设一个DMC的容童-代价函数为Cβ)。则对于任意β≥β和实数β>βo,
R<C(B),e>0,以及所有足够大的n值，存在一个码长为n的码C=1x?,x?,….xy!
和相应的译码规则，使得：
(a)每一个码字x,都是β-容度.
(b)M≥2i.
(c)P<E,对于所有i=1,2,…,M
推论(DMC的信道编码定理：10)对于任意R<C和E>0,存在一个码长为n的码C=
lx,…,xn!和相应的译码规则，使得：
(a)M≥2l。
(b)P!'<e对于所有i=1,2,…,M。
【推论的}证明：在定理2.4中设R=β
(定理2.4的)证明：在整个证明过程中，认为n是一个足够大的整数。后面将给出更精确
的定义。
考虑所有长度为n的信道输入序列x=(x?,…,x)和信道输出序列y=(y,…,yn)组
成的(x,y)序列对的集合。用符号横述，Ω=A×Ai。我们通过下面的定义将Q放入
一个样本空间
p(x,y)= p(x)p(ylx) (2.21)
这里p(x)=p(x?)…p(x。),其中p(x)是Ax上达到C(β)的一个概率分布；而p(ylx)=
p(y,ta,)…p(y。lx。),其中p(ylx)是信道的转移概率。
现在选择满足R<R'<C(R)的R',并定义子集TSΩ如下：
T={(x,y):I(x;y)nR'} (2.22)
其中T(x;y)=log[p(ylx)/p(y)]。集合T可以看做是通过某种方式联系在一起的序列
对的集合(习题2.17)、另外，定义子集BEA:
B={x:b(x)≤βn} (2.23)
这里B是β-容度码字的集合，最后，定义集合TST为：
T*={{x.y):(x,y)∈T、x∈B} (2.24)
现在设C=ix,x?,…,xy1是不论好坏、码长为n的任意码。我们定义如下译码规则。
如果接收到y,检测集合：
S(y)={x:(x,y)∈T*}CB
(可以看做是环绕y的一个“球体”。)如果S(y)仅包含一个码字x?,就设定f(y)=x,。否
则，由于S(y)不包含码宇或包含不止一个码字，故可以设定f(y)=x,即宣布出现了一个
错误。图2.6描述了译码规则。
如果对码C采用刚才描述的译码规则，假设发送的是x?而接收的是y,当且仅当x,ES(y),
48 信息论与编码理论(第二版)
或者x;∈S(y)而j≠i时出现错误。因此[见式(2.20)],
呢<PAseSO+P, SOo) (2.25)
Y
Ss Sty
(y) ●; f(yi-?
西
Sty)
fty) ?
图2.6 定理2.4证明中采用的译码规则
将式(2.25)表示为更方使的形式，我们定义集合T°的示性函数如下：
(2.26)
现在式(2.25)可以表示为：
=ZA(x,y)eryls)+ZZAx,yplyh) (2.27)
=Q(x1,…,M)
我们的目标是寻找到一个码|x,…,x,使得 Q?的值对于所有的；都非常小。但遗憾
的是，0是一个非常复杂的函数，不能够精确计算(甚至近似估计),除非是最简单的码
而不是n和M的值都狠大的复杂码!那么前面为什么还要引入界P'≤Q,呢?原
因是，尽管对于一个特定的码不可能估计Q.,但是当x,…,x取值于所有可能的码
时，可以估算出Q.的平均值。令人吃惊的是2,如果M=2并且n→四，这个平均值将
越近于0!这个著名的证明方法被称为随机编码，因为我们是根据一定的概率分布“随机
地”选择码|x,…,xyl,现在看一下它的细节。
第一步是适当地描述所有可选择码的概率分布。它是：
第2章 离散无记忆信道及其容量-代价函数 49
PC,xm)=Ⅱnx)
这里如果x?=(xn,xa,…,x),p(x.)= p(x)。这个概率分布对应随机地选择
码的实验，就是根据达到C(Po)的概率分布p(x)独立地选择各个码字的每一个分量。
现在将Q(x,…,xn)看做所有可选择码样本空间上的一个随机变量，它的期望值是[见
式(2.27)]:
E()={ZZ,ypeokx]+Z{2As,nk)
=E?+2E (2.28)
首先给出E?的界：
E=∑x)…p(xmZAix, y(lx)
-ZpPxpp(ylJZxy
-∑ns,yAcx,》)[见式(2.21)
=P{(x,y)ET*}[见式(2.26)]
=P{(x,y)tT orxB}[见式(2.24)]
≤P{(x,y)T}+P{x∈B}
(2.29)
因此，
E?P{[(x;y)<nR'}+P{b(I)>βn] [参见式(2.22)、式(2.23)和式(2.29]
但是，
(x;y)=lopy
=loe w
owi
-nx:m)
因此【(;y)是n个独立同分布随机变量(x;Yk)的和。根据定义，E[I(xuiy)]=
I(X;Y)=C(βe),因此每个(xx;y)的均值为C(β?)。由于R'<C(B),根据弱大数定
理(见附录A),有：
lim P{F(x;y)<nR'}=( (2.30)
50 信息论与编码理论(第二版)
同样，b(x)=∑.b(xA)是n个独立同分布、均值≤F的随机变量的和。由于β>B,
有：
lim P{b(x)>nβ}=0 (2.31)
结合式(2.29)、式(2.30)和式(2.31),我们看到通过选择足够大的π值，可以使E,的值尽
可能地小。
下面再考虑式(2.28)中的E{)项：
E2=∑pi)…pxw)∑Ax,yprylk,)
=Zplx,JAx,y∑pxpyix)
=∑nx,A(xy,yiDr
因此，根据式(2.26)和式(2.24),
2p(x)ply) (2.32)
现在对于(x,y)∈T,有p(x)p(y)≤p(x,y)·2-R[见式(2.22)]。因此界(2.32)式可以继
续写做：
E<mx)p(y)
≤2-ptx.y)
≤2·R'n
(2.33)
最后，结合式(2.28)、式(2.29)和式(2.33),我们有：
E(Q)≤P{/(x;y)<nR'}+P{b(X)>nβ}+M-2-A' (2.34)
如果 M=2·2RI。式(2.34)中的最后一项≤4-2-nR-R)。由于R'>R,所以只要n足够
大，这一项可以尽可能地小。我们已经观察到[见式(2.30)和式(2.31)]另外两项能够达
到任意小。因此可以通过选择足够大的n值，满足M=2·2,使得：
E(Q)<e/2 (2.35)
这几乎就是我们所需要的。
证明中的最后一步是定义一个函数P?(x,…,xu)为；
Pax,x)=六n….X) (2.36)
这里P是一个总的错误概率，假设M个码字的传榆概率都为1/M。如果我们认为Pe是
定义在所有码样本空间上的一个随机变量，则根据式(2.27)和式(2.35),对于M=2-2和
足够大的n值，我们有：
E(PE)<e/2
第2章 离散无记忆信道及其容量-代价函数 51
可见P的平均值<e/2,因此一定存在一个特定的码(x,…,x),它的Pe(x,…,xw)<e/2。
这个码也许不满足定理2.4的结论，因为它可能包含一个码字x,,该码宇的b(x;)>nβ和/
或P>E。但是，如果超过半数的码字x?的PYe,由式(2.36),我们将得到Pe≥8/2的
矛盾结论。因此如采从码中删除P≥e的码字，将得到一个码字数≥2的码，对于所有
的i,满足P3<e3。可见这个码满足定理2.4的结论(b)和(c)。最后，注意如果b(x,)>
nβ,译码球体S(y)=1x:(x,y)∈T并且b(x)≤n3不可能包含x,即P=1。由此可知新
的码不能包含任何不是β-容度的码字，可见(a)也满足。
习题
2.1 计算下列信道的容量-代价函数：
0-b(O)=1.b(1)=b(2)=0
(b)Q=L8pg].b(0)=0,b(1)=1。
[(b)中的信道称为二进制删除信道，它可以由下图描述：
0 上
4
·I
输入的符号可能被正确接收或删除(即接收到“?”)。]
2.2 我们称这样的信道是弱对称的：如果它的转移矩阵(Q的列可以被划分为若干个子集C,
对于每个i,由C,中的列组成的矩阵Q,中的每一行都是其他行的置换，列也是如此。
(例如，前面(是弱对称但不是对称的。)证明当输人等概时能达到弱对称信道的容量。
2.3 我们定义r阶强对称信道为r=4时具有如下形式转移矩阵Q的信道：
其中p≤1/r且(r-1)p+q=1.这道习题的目的是对应任意的输人代价b(x),通过下
面补充的细节，来计算出这个信道的 C(β)。(假设β=0;见习题2.4。)
如果X是一个达到C(B)的试验信源，对x∈10,1,…,r-1},设f(x)=PiX=xì,g(x)=
PIY=xl。则有f(x)=[g(x)-p]/q-p),而约束∑b(x)f(x)=β等价于≥b(x)g(x)=
β(q-p)+Bp,其中B=Cb(x)。I(X:Y)=H(Y)-H(q)-(1-q)log(r-1),所以目
标是在满足∑b(x)g(x)=β(q-p)+Bp的条件下使B(Y)最大。为此可以利用习题1.8
52 信息论与编码理论(第二版)
的结论，并得到含参数的结果：
C(β)=logA(A)-AA'(2)/A(A)- H(q)-(1-g)log(r-1)
β=-p(4Ca)/AA)+Bp)
其中λ的取值区间为λ∈[λo,0],β的取值区间为[0,(1/n)B],A。是方程A'(λ?)/A(Ao)=
-Rp的惟一解。
2.4 本习题的目的是，证明假设β=0是不失一般性的。如果给定一个信道，它的容量-代
价函数C(β)有β>0,令C(β)表示相同信道的容量-代价函数，在这个信道中所有的
代价都降低了β。证明C(β)=C(β-β)。
2.5 本习题的目的是证明C(β)在β=β处连续。为此补充了下述细节。
令(P?,p,…)是一个概率矢量序列，表示达到C(p),C(β?),…的试验倍源的输人概率分
布，其中 limβ=βm。则存在一个收敛于概率矢量p的子序列(pa,P?.…)。如果X
是一个输入分布为p的试验信源，则E[b(X)]=β且I(X;Y)=limg-gC(β)。因此
C(Pm)≥limC(β)。由于C(β)是β≥β的上升函数，这就证明了要证的连续性。
2.6 设f(x)是x≥x,的上升、上凸∩函数。假设f(x)当x≥x?时为常数，其中x?<x?o证
明当x≤x≤x?时f(x)是严格上升的。
2.7 尽可能全面地描述 C=0的DMC性质。
2.8 定义具有转移矩阵Q?,Q?…,Q=的DMC的和为具有如下矩阵的信道：
Q 0 0
Q-
Q?
0
如果c_表示第i个信道的容量，证明和信道的容量为：
Cmx=log?∑2° bis
2.9 考虑两个DMC,输人符号集为A,输出符号集为A°,转移概率为p(ylx),代价函数
为6(x),i=1,2。定义它们的积为这样的信道：输入符号集为A×A②),输出符号集
为A×A?,转移概率p((y?,y?)I(x?,x?))=p)(y?lx?)·p(2)(y?iz?),代价函数
b(xi,x?)=b"(x?)+b2(x?)。(物理上，积信道是一对并行使用的信道。)证明积信道
的容量-代价函数为：
Cβ)=max{Ci(1)+C?Iβ-}}
由此证明可以通过将曲线 C?(s)和C?(β)上斜率相同点的横纵坐标相加而得到C(β)的
曲线。
:: 
Q
:
第2章 离散无记忆信道及其容量-代价函数 53
2.10(一个简单的有记忆信道的容量)设Z,Z?,…是具有相同分布的随机变量，并且是一个
取值于i0,1,…,r-11的Markov 链(参考习题1.20)。根据规则Y;=X,+Z,(modr),可用
Z,来定义一个Ax=Ar=10,1,…,r-1的加性信道，其中X和Y,是i时刻信道的输人
和输出。n维容量定义为C=maxlI(X;Y)),当X取遍n维试验信源。而容重为C=
sup(1/n)Cm)。证明 C=nlogr-H(Z?,…,Z)=nlogr-H(p)-(n-1)H,其中p是
描述 Z共同分布的概率矢量，而H是这个链的熵。证明C=logr-H。将此结论应
用于下述情况：r=2,而链的转移概率由下述随机矩阵Q给出
e=[pa]
2.11 对于例2.5中的信道和代价函数，明确说明如何能达到编码定理所保证的内容，即给出
一个码C的准确描述，使其具有定理2.4中的性质(a),(b)和(c)。
PP=3 2.12完成例2.6的细节部分，并说明如何改进译码函数使之达到1 ,其中i=1,2。
2.13 在证明定理2.4时我们对于一个确定的码C=[x,…,xal给出了一个明确的译码规则。
这个规则，虽然能够满足我们的要求，但却不是最佳的，在实际中很少使用。在这里将介
绍和研究另外两种译码规则，它们比定理2.4中的更好但也更难分析。假设传输x;的
概率为pr,i=1.2,….M。给定接收矢量y,最小错误概率译码(MED)是选择使条件概率
p(x,Iy)最大的码字。最大似然译码(MLD)是选择使p(ylx,)最大的码字。
(a)证明 MED名副其实，即给定接收到的y,根据MED可使译码器的错误概率最小化，
因而也使平均错误概率P=Z"p.Pl)最小化了。
(b)证明如果对所有的i,p?=1/M,则MLD与MED的性能相同。
(c)在BSC中，定义x与y的汉明距离 dn(x,y)为它们之间不同码元的个数。证明MD
译码器总是选择与y汉明距离最近的码字s,(见习题2.17和7.3节)。
2.14(续)考虑下列码长为4的10,1码字：x=0000,x?=0011,xy=1100,x=1111。假设这些
码字以不同的概率送往 BSC(错误概率为p)中传输，Plx?l=2,Plx?=P{xa=8,
PIxt=4。 Pg=P+gP+P+4P最小。 。寻找一个泽码规则，使得
2.15 证明如果βo>F_,就可以将定理2.4中的结论(a)替换为“每个码字是β-容度的”;如
果βo<β,就可以将结论(b)替换为“M≥2Ax”。
2.16我们可以不要求每信道利用的平均代价≤β,而是要求最大允许代价≤β,即定义C(β)=
supl7(x;Y):b(X)≤β的概率为1}。计算例2.1、例2.2和例2.3的C(β)。编码定理对
C(β)仍然成立吗?
2.17 对于一个BSC,证明式(2.22)中定义的集合T的形式是T=I(x;y):dg(x,y)≤r|,其中
d(x,y)是x和y之间的汉明距离(即x和y间不相同码元的个数),找到用n,R',e,以
及信道转移概率表示的r。[假定p(x=0)=p(x=1)=2。]
2.18设Ω为有限集合，并设f是一个将Ω映射为实数的函数。证明存在一个元素w∈Ω,使
上·
e … htt te …
54 信息论与编码理论(第二版)
得f(u)<y的充分必要条件是，可以定义一个Ω上的概率分布使得E[?(a)]<ye
2.19 考虑具有如下转移概率炬阵的DMC:
[没有代价约束，即对所有x,b(x)=0.]
(a)计算C
(b)寻找一个码长为1、速率为log2的码，使得对于所有的i,P=0。
log 5的码,使得对于所有的.P=0。 (c)寻找一个码长为2、速率为
(d)对此信道，如果x,…,x是任意一个码长为n的码，并且对于所有的i,有Pg=
<loy2a。 0,证明这个码的速率
2.20 二进制删除信道的转移概率矩阵如下：
-98
其中0≤p≤2,p+g=[假设无输入代价，即对所有的x,b(x)=0]。它的容量为C=
1-p(见习题2.1b)、假设这个信道配备了无噪声、无延迟的反馈器，即接收方可以将他
收到的符号反传给发送方。发送方采用如下“编码”策略，将二进制对称信源的输出通
过信道传输：他不停地重发每个符号直到它最终被正确接收。
(a)如果采用此方法，计算一下传输每个信源符号平均所需要的信道符号数。
(b)利用(a)中的结论，对任意R<Cmm和e>0,设计一·个码长为n、有M个码字的码，使
得M≥2,且对于每个i,有P"<=(见定理2.4的推论)s。
在接下来的6道习题中，我们将简要证明一个没有代价约束的DMC的编码定理，这个定
理在某些方面比信道编码定理(定理2.4的推论)强，而在其他方面则比它弱。首先必须做一
些定义。对于任意一对xi,x?∈Ax,我们定义：
C,x21=EVukapCk
而
Jo=min{E(J(X.X?}
其中最小值是取遍所有取值于Ax中的独立同分布随机变量得到的。最后，重要的量R。定义
为：
Ro=-log?J
要证明的定理的内容是：
第2章 离散无记忆信道及其容量-代价函数 55
DMC的R,定理 对任意R<R?,存在一个码长为n、至少包含M=[27个码字的码
x,x?,…,x|以及相应的译码规则，使得如果以P,=(∑P)/M表示平均译码错误概
率，则PA<2-R)。
(这个定理比信道编码定理强在它给出了P&作为n的一个函数能够达到多小的精确估算。
它的弱点是R?<C_,因此当速率Ra<R<C时，不能说明P→0的可能性。)
2.21考虑一个码长为n的码，它仅含有两个码字x?=(x,x?,…,x)g)和x=(xz,xz,…,xz)。
假设给定接收到的一个n维的y,如果p(ylx,)>p(ylx?),则译码器输出x,而如果
p(ylx)>p(ylx,)则输出x。令Y?={y:p(yix,)>p(yix?),Y?=ly:p(ylx)>p(yix)H。
如果以P表示发送x,时译码器的错误概率，证明：
吧siu-) f=1,2
这需要证明如下步骤：
PC)
VMkjpONk)
=m)
2.22 现在如果|x?,…,x,1是一个码长为n、包含M个码字的码，则译码器选择使p(ylx,)最
大的码字x?,以P:表示发送x,时的译码错误概率，证明：
Dm,
2.23通过将习题2.22中所得的表达式对所有码求平均(其中每个码字是依照能够达到J。的
概率分布独立选取的),求出估计：
ETPY<M2-Rn
2.24现在完成R?编码定理的证明。
2.25 证明对于一个BSC,
Ro=1-log2[1+2√PA1同
cm<Ro<C_,其中Cm=1-H?(p)是 其中p是原始的误比特概率。进一步证明-
BSC的容量。
2.26 计算二进制珊除信道的R?(见习题2.1b).
注释
{1] 随机矩阵是由非负实数组成的矩阵，具有每行元案的和为1的性质(参考习题1.20)。
::
……………………3……………………………………………行中战所
56 信息论与躺码理论(第二版)
[2] 我们现在要强调一下，代价函数的一个最重要的例子是对所有x∈Ax,b(x)=0。
引人b(x)的主要原因是为了强调第2章和第3章结论的对称性，并为第4章中输
入受限高斯信道做准备。
[3] 我们引用的定理是，定义于度量空间的一个完备子集上的连续实值函数能够达到它
的极大值和极小值；见Apoetol[2],定理4.28。
[4] 这个术语是不标准的；在b(x)=0的特殊情况(参考注释2),C(β)显然对所有β≥0
都是一个常数，并只是称为信道的客量。
[5] 在给出定理2.2的结论后，读者可能会觉得奇怪，为什么我们首先给出的是复杂的
定义(2.5)式。答案是，这个定义可以简化编码定理逆定理的证明[见第5章，特别
是式(5.9)];而且，对于有记忆信道，定理2.2是不成立的(见习题2.10)。
[6] 仔细检查一下定理2.3的证明，可以发现我们所要求的仅是转移概率矩阵的行具有
恒定的熵而列具有恒定的和。
[7] 假设隐含对数运算的基底是2。
[8] 如果A是一个集合，那么符号A°表示基于A的有序n维集合|(a?,a?,…,a):
a∈A。
[9] 更普遍地讲，码C可用于传送任意信源的输出，不论是二进制的、无记忆的，还是其
他类型的，只要信源的可能输出个数≤M。这种健壮性使编码定理(定理2.4)比我
们讨论中所指出的更有价值，因为实际应用中很少有信源能够用二进制对称信源精
确地描述。
[10]这个推论叙述的是，在速率低于信道容量时可以实现任意可靠的通信，称为信道编
码定理，因为注释2中曾提到，代价约束通常是不存在的，所以定理2.4的更普遍结
论相对而言就不太重要了。
[11]这个译码规则可能并不是最佳的；见习题2.13和习题2.14。然而它分析起来相对
容易，并且在证明编码定理时是接近最佳的。
[12]见习题2.18。
[13]注意从C中删除码字是不会改变剩余码字的PL的，因为P=∑ip(ylx?):
yt f'(x,)1。
[14]这是一个著名的有关非零的无差错容量信道的例子。我们已经知道对于这个信道，
og 5的码；见香农的论文[25],112~113页，以及 不存在使PE=0同时速率
Lovásx[51]。
[15]当考虑到香农的定理[即反馈不能增加 DMC的容量(见Sharuon [25],120页)]时，这
个结果变得更有意义，然而实际上总的来说，反馈简化了编码器和译码器的设计。
有很多文献是关于含反馈信道的；见文献[25],373-436页。
:1■
第3章 离散无记忆信源及其率失真函数
3.1 率失真函数
考虑信息源在单位时间内产生一个符号u,该符号取自一个称为信源符号集的有限集合
A。假设信源产生的符号序列可以用一系列独立、同分布的离散随机变量U?,U?,…来描述，
其共同的分布函数为PU=ul=p(u)。这样的一个信息源称为离散无记忆信源(DMS),而
p(t)的数值称为信源统计。
现在设想我们需要将信源的输出通过一个信道传输到确定的信宿。假设传输的信源符号
u∈A,在信宿被还原为符号v,它是另一个称为信宿符号集的有限集合Ay的元素(Ay通常包
含Ag,将它作为子集，但并不总是这样)。同时假设对于每一对(u,v),存在一个非负值的数值
d(u,),用于度量信源符号u被还原为信宿符号v时的错误或失真。函数d称为失真
测度。1i
最后假设函数d的定义扩展到取自A×A的一对(u,v)=(u,u2:…,;v?,t?,…,v),
即
u,v=2do (3.1)
为方便起见，通常设A=30,1,…,r-11,Ay=10,1,…,s-1,并将失真测度d(u,0)表示为
一个rxs维矩阵D。
P≤2;而失真测度矩 例3.1 A=A=10,11;信源统计p(0)=p,p(1)=q=1-p,这里
阵为：
D=[1!
例3.2Au=i-1,0,+11、Ap={-2,+2};信源统计为[(33,3);;而失真测度矩阵
为：
-[
(这两个例题将在后面进一步讨论。)
设k是一个固定的正整数。将相互独立的随机变量U?,U?,…,U?作为信源输出的前k
个符号，设V?.V?,….V?为取值于信宿符号集Av的任意k个随机变量，并定义在与U,相同的
取样空间上。我们可以计算随机矢量U=(U?,…,UA)和V=(V?,…,V)之间的互信息量
油i
58 信息论与编码理论(第二版)
I(U;V),以及平均失真测度E(d)=Eid(U,V)],其定义如下：
Ed)=∑pu,vd(u,v
=∑pu)p(vlD)du,以 (3.2)
[式(3.2)是就对(u,v)=(u?,…,t,?,…,n)求和，这里u?∈Ap,b?∈Ap,而p(u,Y)=
PU=u,V=v},p(vlu)=PlV=vlU=ul。]
现在定义3函数R(B),它是信源统计(p(u))、失真测度矩阵D和实数δ的函数：
R(8)=min{/(U;V): E(d)≤kó} (3.3)
式(3.3)中是对所有取值于情×A的k维随机矢量对(U,V)=((U?,…,UA),(V,,…,V))求
极小值，其中U?.…,U.是相互独立的，并具有相同的分布函数PIU=ai=p(u),这里
(p(u))是给定的信源分布统计，而式(3.2)中定义的平均失真测度 E(d)≤城。由于信源分布
统计(p(u))是固定的，对于一个给定的8计算R(δ)时，必须改变决定V的条件概率p(vlu)。
这些概率可以看做是一个输人为U、输出为V的信道的转移概率。在此处该信道一般称为
k维试验信道，而式(3.3)是在所有平均失真测度≤的试验信道中求极小值。
下面初步介绍函数R?(8)的几个特点。首先注意对于固定的(p(a)),函数7(U;V)是s
个转移概率p(vlu)的连续函数。转移概率集合中满足E(d)≤城的子集是r's维欧几里得
空间中的一个封闭区间，因此函数I(U;V)在这个区间内能够达到极小值?。这就是我们在
式(3.3)中用“min”代替“inf”的原因。第二，注意E(d)的最小可能值由ke?给出，其中，
°m=plu)mindu,D (3.4)
从式(3.2)中可以看出，由于E(d)Z)p(u,v)min,d(u,v)= h城，因此R?(8)只定义于
≥8。最后，如果8>8?,满足E(d)≤ho?的k维试验信道的集合是满足E(d)≤8,的子
集，因此R(8)≤R(δ?),也就是说，R(8)是d≥8_的下降函数。
现在定义信源的率失真函数为：
R(o)=inf R(O) (3.5)
如果能够容忍的平均失真测度为8,R(8)的值是表示一个信源符号所需要的最少比特数(假设
所有的对数运算以2为基底)。这个结论的精确描述，即香农的信源编码定理，将在3.2节中叙
述并证明。本节下面的任务是研究在给定DMS 和失真测度条件下计算Rδ)的方法。
我们的第一个结论是有关函数R(8)的下凹性的。
定理3.1 R(8)是8≥8的下凹U函数。
证明：假设a,a?≥0,a,+az=1。必须证明，对于δ,δ?≥0,有：
R(α:点+a?O2)≤aR(6)+azR(d2) (3.6)
为此，设p(vlD)是达到R(δ;)的试验信道的转移概率，i=1,2。则如果V,,V?表示试验
信道的榆出，有：
第3章 离散无记忆信源及其率失真函数 59
(U;V;)=Rf(b,) (3.7)
E(d,)≤kO;, i= 1,2 (3.8)
其中d;=d(U,V,)表示第；个试验信道的平均失真测度。现在定义一个新的试验信道，
其转移概率为p(vlu)=a?pi(vln)+a?p?(vla),如果V表示这个试验信道的粉出，则由
式(3.2)和式(3.8)可知，E[d(U,V)]=a,E[d(U,V,)]+a?E[d(U,V?)]≤k(a,δ+
a?8?)。可见该试验信道满足计算R(a?8?+α?δ?)的条件，因而有I(U;V)≥R(a?8i+
a?δ?)。
另一方面由于(U;V)是转移概率p(vlu)的下凹U函数(定理1.7),1(U;V)≤a?F(U;V?)+
a?F(U;Y?)=α,R(8,)+a?R(δ?)。最后两个不等式联立得到式(3.6),从而证明了定
理3.1。
下一个结论表明，计算 DMS的R(8)显然比定义(3.5)式容易许多。
定理3.25] 对于 DMS,R(8)=kR,(8)对所有的k和86都成立。
证明：设p(vlu)是达到R?(δ)的k维试验信道的转移概率。则；
F(U;V)=R(6) (3.9)
E[d(U, V)]kδ (3.10)
由于U?,U?,…,U,是相互独立的，由定理1.8知：
u:v)=Zu:v) (3.11)
如果定义成=E[d(U.V)],有：
(U;V,)R?[δ;].i=1,2,…,k (3.12)
瓦du,VH=0,≤kd (3.13)
将式(3.11)和式(3.12)联立，我们有I(U;V)=公..R?(8;)。。但是由于R?是下凹U的，
根据式(3.13),以及R是δ的下降函数这一事实，有：
Rie)≥A.R(+)
kR(8)
因此R(8)=I(U;V)≈kR?(8)。为证明反向不等式，设p(viu)是达到R?(8)的一维试验
信源，并且定义p(vlu)=IⅡp(vv)。容易验证这样定义的无记忆试验信道满足 E(d)≤
ho和/(U;V)=kR;(8)(见习题3.3)。因此有R(8)≤hR?(8),从而证明了定理3.2。
推论
R(δ)=R(δ)
=min{LU;V):E(d)≤0}
60 信息论与编码理论(第二版)
证明：该结论可由定理3.2和定义(3.3)式以及定义(3.5)式直接得出。
现在总结一下函数R(8)的性质。我们已经知道R(8)是8≥8的下降及下凹U函数。
由下凹性立即可知R(8)在8>à范围内是连续的。R(8)在δ=8m点也连续，我们将证明
留做习题3.4。进一步将证明对于所有充分大的δ,R(8)=0。事实上，如果定义δ为：
m=min∑nu)du,o) (3.14)
则R(A)=0当且仅当δ≥0。为说明这一点，观察一个将所有输入u都映射为满足
∑p(u)d(a,)=&的某个确定的v的试验信道，则有(U;V)=0和E(d)=δ_。这表
明对于δ≥8,有R(&)=0。相反，如果R(&)=0,则试验信道的U和V必须相互独立(定理1.3),
因此根据式(3.14),
Eld)=∑pupuDdue)=∑n∑PAudlu)
≥∑po)-dm=0m
可见如果R(b)=0,则δ≥?。
出于R(8)对于&≥0_是下降及下凹U的，且当δ≥8时为常数，故可知R(8)在δm≤
8≤8范围内是严格下降的(见习题2.6),因此在这个范围内R(8)表示为：
RO)=min{I(U;V):E(d)=8},δmin≤δ≤0mx (3.15)
典型的R()曲线如图3.1所示[但是R(8)并不一定是严格下凹U的，见习题3.2]。习题3.8
证明了假设δ=0实质上不失一般性，即对于每个信源符号u,至少存在一个信宿符号，满足
d(n,v)=0,这种情况下R(8)的曲线如图3.2所示。
8 8m 8
图3.1 典型的R(8)曲线 图3.2 不失一般性，8=0
一般R(0)[或R(8m),如果δ>0]的值并不容易计算(见习题3.7)。但是，如果假设矩阵D
的每一行至少有一个0元素，而每一列至多有一个0元素，R(0)的值就很容易计算了。因为
在此情况下，满足E(d)=0的试验信道必然将每个u映射到它的“最佳”表示集合G=1vl
d(u,t)=0{中。但是根据对矩阵D的列的假设，集合G、是不相交的，可见通过试验信道的
输出V完全能够确定其输人U。因此R(0)=I(U;V)=H(U)-H(UIV)=H(U),即信源的
墒，在这种相当典型的情况下，R(8)的曲线如图3.3所示(参考习题3.5)。
现在将实际计算一下例3.1和例3.2中的R(δ)。
能： :
1
第3章 离散无记忆信源及其率失真函数 61
例3.1(续)这里信源统计为P\U=0=p,PU=li=q,其中P≤2 ,而失真测度矩阵为：
D=[i!
显然δ=0,8m=minip,ql=p,根据前面的论述，R(0)=H(U)=H(p)。为寻找
0<8<p时的R(8),注意对于达到R(δ)的试验信道，I(U;V)=B(U)-H(UIV)=
H(p)-H(UIF),并且E(d)=PlU≠V|=δ。但是根据Fano不等式(定理2.1的推论),
H(UIV)≤H(8),因此R(&)H(p)-H(δ):这个下界就是0≤δ≤p时的R()值。为
证明这一点，必须构造一个E(d)=à,(U;V)=H(p)-H(8)的试验信道。为此最佳方
案是定义一个“反向”试验信道，即给定转移概率p(a|a),满足如果u≠v,则p(ulv)=8;
而如采 u=v,则p(ui:)=1-δ。反向试验信道如图3.4所示。显然这样一个试验信道
将满足R(d)=8,H(UIF)=B(&):但是必须确定能够找到一个a=P{V=0|,使得
Pit=0i=p而PU=l}=q。因此必然有p=a(1-8)+(1-a)&,即α=(p-8)/(1-28)。
由于0<à<p≤,a的位在[0,1]区间内，可见所需的反向信道是存在的。因此最后(见
图3.5),
R(o)={H.P)-Ho) 0≤δ≤p δ≥p
0.顶( -6 v-0 v=
8
8
8
!-8 w-L v-1
图3.3 通常R(0)=信源的熵 图3.4 例3.1中的反向试验信道
Ho) 3g2
4:3
例31 例3.2
图3.5 例3.1和例3.2中的R(8)
p(u)=3,u=0,±1,而失真测度矩阵为： 例3.2(续)这里信源的统计分布为
·b
62 信息论与编码理论(第二版)
0-{
通过简单的计算可以得到δm=1,8=4。。由于(U;V)是试验信道转移概率的下凹
P{v=+立u=0}和p{v=-21U=0}的对称性，以及d(0,2)=d(0, 函数，根据
-2)),可知(见习题3.6)为了使试验信道达到R(8),必须使P{v=±U=0}=2。
P{v=+U=+1}=P{v=-2W=-1}=1-a,其中O≤a≤2。该 同理，必须设下
试验信道的(U;V)=R(V)-H(VIU)=log2-号H(a)-bog2=3[log2-H(a)],而
E(d)=3[(1-a)+2a]+3=1+2a。最后有(见图3.5):
o={082-HGO-z 1≤δ≤
8≥
本节的最后将介绍如何计算具有汉明失真测度(也称为错误概率失真测度)的一般r进制
对称信源的率失真函数。这里信源和信宿的符号集相同：Au=Ay={0,1,….r-11,信源
的统计分布为PIU=ul=1/r,其中u=0,1,…,r-1。而失真为：
duD)={9如柔≠
r=4时的矩阵D如下：
注意对于(U,V)试验信道，E(d)= ∑p(u,v):u≠f=PlU≠V},这就解释了为什
么达种特珠的失真测度被称为错误概率失真测度。
根据式(3.4)有=0,而根据式(3.14)有δ_=1-I/r。在0≤8≤1-I/r范围内R(&)
的值由下面的定理给出。
定理3,316]具有错误概率(汉明)失真测度的r进制对称信源的率失真函数为：
Ro)={08e-dlogr-I)-Hfo. 0≤δ≤1-1/r
δ≥1-1/r
推论 具有上述相同关真测度的二进制对称信源的R(B)为：
Ro)={0.82-(o)
P=2 (注意推论是r=2时定理3.3的特殊情况，也是 时例3.1的特珠情况。)
第3章 离散无记忆信源及其率失真函数 63
证明：考虑一个(U.VW)试验信源，对于0≤δ≤1-I/r范图内的一个固定值δ达到R(8)。
则R(δ)=I(U;V)=H(U)-H(UIV)。由于H(U)=logr(参照定理1.1),而8=E(d)=
PLU≠V,根据 Fano 不等式(定理1.2的推论),H(UIV)≤δlog(r-1)+H(8)。因此
R(δ)≥logr-δlog(r-1)-H(?)。为证明反向不等式，假设0≤δ≤1-1/r.并且定义试
验信道如下：
wum={— 如果v=u
如果u≠
则通过简单的计算可以得出E(d)=8,7(U;V)=H(V)-H(VIV)= logr-H[1-b,
8/(r-1),….8/(r-1)]=logr-δlog(r-1)-H(8)。
3.2 信源编码定理
在3.1节中从纯粹的数学角度研究过的率失真函数具有完美的通信理论意义，这就是：如
果允许的失真测度为8,R(8)等于表示每个信源符号所需的比特数。因此一个信源符号可以
被“压缩”为R(8)比特；由于R(8)随着δ的增大而减小，可见随着δ的增大可以进一步提高
压缩率。因此“率失真理论”有时也称为“数据压缩理论”。
为了解R(8)为什么能具有这样的意义，考虑下面的情况。设(U?,U?,…,D)=U表示一
个确定 DMS输出的前k个符号。现在假设这k个符号被“压缩”为n比特(X?,X?,…,X)=X,
并且可以通过某种方式由X还原出k个信宿符号(V,,…,V?)=V,满足∑E[d(U,、V,)]≤
h城。由这些条件可以确定用n比特X?,…,X,表示k个信源符号U,,…,U的平均失真测度≤8。
U,X和V之间的关系可以表示成如图3.6所示。
(…—(x?.,x》—.…
图3.6 -般的数据压缩方寒
现在由式(3.3)和式(3.5)可知，I(U;V)≥R(8)≥kR(B);根据定理1.5可知I(U;V)≤
(X;V);由(X;V)的定义[见式(1.4)]可知I(X;V)≤H(X);井且根据定理1.1可知H(X)≤
n比特。综合这些结论，我们得出kR(8)≤I(U;V)≤I(X;V)≤H(X)≤n,即(隐含了对数运
算以2为基底),
“≥R(8) (3.16)
式(3.16)中的比率 n/k是在上述数据压缩方案中表示每个信源符号所需的比特数。由此我们
立即可知，如果平均失真测度必须≤δ,R(8)就是表示每个信源符号所需要的最少比特数。下
面将要证明的信源编码定理表明某种意义上需要的比特数可以不超过R(8)。
首先必须定义一个信源编码。一个码长为天的信源编码是A的一个子集，即码长为无的
信宿序列的集合C=lv?,V?,…,val。它的迷率定义为R=k?1bog?M。对于每个码长为k的
信源序列=(a?,…,出),设f(u)是“最接近”u的码字v,即，
d(u,f(u)≤d(u,v)j=1,2,…,M (3.17)
码C的平均失真测度定义为：
.、!
64 信息论与编码理论〔第二版〕
C)=kZpudiu,f(u) (3.18)
在式(3.18)中p(u)=p(u?)p(u?)…p(u)是信源输出的前k个符号为u…,的概率
如果M≤2”,这样的一个信源编码可用于设计图3.6所描述的数据压缩方案。给M个信
源编码码字中的每一个v,分配一个不同的二进制n维x(v?)=(x?(v,),…,x。(v?))。由于
M≤2”,这是可以实现的。则信源序列u=(u,…,)由n比特x=x[f(u)]表示，并且信宿序
列v就是码字f(u)[由于v+x(v)的映射是…一对应的，f(u)可以惟一地由x[f(u)]还原]。显
然这种方案的平均失真测度就是d(C),如式(3.18)中所定义的，而压缩率 n/k就是
「log?M/k。
p=q=2。考 例3.1{续)与前面的例3.1完全相同，只是现在我们设定信源的统计分布为
虑一个码长为7的有16个码宇的信源编码，即引言中描述的有16个码字的(7,4)汉明
码。当时首介绍过所有128个长度为7的二进制矢量至多有一位与某个码宇不同。
因此，
dC=;(128-6)=
压缩率为n/k=4/7=0.5714。[这种情况下如我们所看到的，R(6)=1-H?(8),不等式(3.16)
变为4/7≥1-H?(0.125)=0.456 4。]
例3.2(续) 这里信源，失真测度等与前面例3.2中的相同，我们考虑下面的码长为2的信源
编码：
C={(+t,-),(-2,13)}
通过直接计算(见习题3.14)得出d(C)=9=t.J1。,压缩率 n/k= 1/2=0.50。由于
R(9)=3[1-H?()J=0.2333,我们再次看到它满足不等式(3.16)。
现在很容易猜测信源编码定理的核心内容；即存在信源编码，满足d(C)≈δ和
lug M/k≈R(8)。更精确的描述见下面的定理。
定理3.4(香农信源编码定理)给定8≥8,对于任意8>δ和R>Rδ),以及足够大
的k,存在长度为k、有M个码字的信源码C,满足：
(a)M≤2R。
(b)d(C)<8。
注意 站论(a)确保我们可以取n=LkR'J,并且得到的压缩率 n/k≤R;结论(b)确保最终失真测度将<
引入两个数值尺和而不直接用R(8)和δ虽然很麻烦，但却是必要的[我们一般不希望n/k=
R(&)的一个原因是R(8)有可能是无理数!参见习题3.15],
Hi
第3章 离散无记忆信源及其率失真函数 65
证明：先选择R和8,满足
R(b)<R"<R', δ<δ"<δ' (3.19)
现在如果C=Iy,Y?,…,Vnl是一个码长为k的特定信源编码，并且f(u)是如前面定义
的一种信源编码函数，定义A临的子集S和T为：
S={u:d(u,f(u))≤ko"}
r={u:d(u,f(m))>k8"}
这里S是被C以较小失真所表示的信源序列的集合，T是以较大失真所表示的信源序列
的集合。则根据d(C)的定义(3.18)式，
dC=k∑nuldiu,/(u)
-k2nrundia,o)+ Pubt.,(a) (3.20)
显然式(3.20)中的第一个求和项≤0;因此如果定义B为失真测度矩阵D中的最大元
素，即B=max[d(u,v):u∈Ay,v∈Ay},我们有：
d(C)≤6°+B∑pu (3.21)
式(3.21)中的求和项恰好是被C以较大失真表示的信源序列出现的概率，即Pid(u,
f(u))>ho|。
现在d(u,f(u))大于kB”的充要条件是d(u,v)>k8”,对于每个i=1,2,…,M[见
式(3.17)]。因此如果定义网位函数为：
如果d(u,v)≤ko° Am.v={! 如果 d(u,v)>ko” (3,22)
式(3.21)中的求和项变为∑.p(u)[1-A(m,v?)]…[1-△(u,V)],所以如果我们定义：
K(C)=ZY0-Auvu (3.23)
式(3.21)变为：
d(C)δ"+B·K(C) (3.24)
观察式(3.24),如果能够找到一个码长为大、至多有2-*RI个码宇的信源编码，满足
K(C)<(0-8)/B,就完成了证明。这里直接找不到这样的编码，但是通过随机编码方
式可以间接推断出它的存在。也就是根据一个确定的概率分布，对所有可能的码长为k、
含z个码宇的信源编码求K(C)的平均值；并证明这个平均值将随着k的而趋近于
0。因为对于足够大的左值这个平均值将<(8-8")/B,由此可知至少也存在一个特定
编码，满足K(C)<(8-8")/B并满足定理3.4的结论。
因此现在的任务就是对所有码长为k、含有M=z+R'个码字的信源编码求K(C)的平均
值。当然首先必须确定求平均值所对应的概率分布。正确的选择是尽可能地接近随机变
量V在一个达到R(8)的试验信道中的分布。因此下面的证明是设p(u,v)表示一个在
.、
66 信息论与编码理论(第二版)
5……
Ae×Ay上达到R(8)的概率分布，即，
(U;V)= R(d) (3.25a)
E[4(U.]≤δ (3.25b)
Ar和Ay上的边缘分布给定为：
pu)=∑pu,D (信源统计)
pO)=nu,D)
进一步假设信源和诚验信道是无记忆的，将这个概率分布扩展到Ai×A上的一对
(u,v)=(u…,u,…,),即定义：
r=eu)
wim=t puim (3.26a)
由此可得：
p(a.)= u
rw=Tnu) (3.26b)
所有我们需要的码长为k、含M个码宇的信源编码的概率，就是指定给码C={v?,…,
vu!的概率：
no-aw
其中p(v)由式(3.26b)给出。[这种概率指定有时描述为：信源编码是根据概率分布
p(0)被“随机”选取的。]
回顾K(C)的定义[见式(3.23)],我们开始计算它的平均值E(K):
E(K)=∑pw)prwwZrI-Aru,)
-∑oZMnnI-ACm,vJ] (3.27)
-2pu{Znon-A}"
[如果不被表示符号所迷惑，显而易见上面的最后一步依据这样一个事实，即如果f(x)是
定义在一个确定集合A上的函数，则，
第3章 离散无记忆信源及其率失真函数 67
∑rw]"=Z ∑m)ftm)
式(3.27)中括号内的求和项等于：
∑plt-Au.=1-∑prVA(u,v)
因此式(3.27)变为：
u)-Z|1-LnvAmu (3.28)
[至此，读者应该能够直接看出式(3.28)表示的是，被“随机”选择的信源码v?,…,vm以较
大失真表示的信源序列的概率。]下一步证明是估计式(3.28)中的内部求和项。为此
定义：
如果d(u,v)西kδ"且((a;v)九R Ac(u,)={! 其他情况
其中/(u,v)=log?[p(vlu)/p(v)]。根据式(3.22)△。(u,v)≤△(u,v),因此，
∑rv)△oC,)∈∑pA(u,v (3.29)
如果△。(u,v)=1,则I(u,v)=log?[p(vlu)p(v)]≤kR,而p(v)≥2-*°p(vlm),因此，
∑p(W△o(u,)=2-∑p(l)A(u,V (3.30)
结合式(3.29)和式(3.30),我们有：
i-oAu]"≈|i-2"_pwcuu (3.31)
现在引入下面的不等式：
(t-xy)M≤1-x+e-(如果(≤x,y≤1,M>0) (3.32)
(证明留做习题3.16。)其中x=式(3.31)中右边的求和项，而y=2-*",结果是：
Af l-Zpc.
≤1-∑p(vlu)Aofa,v)+exp(-2-".M)
(3.33)
结合式(3.28)和式{3.33),我们有：
E(K}≤1-∑p(u,v)△o(a,)+exp(-2-R°.M)
-∑pu.MI-AuC,J+cxe(-2.M) (3.34)
现在将证明随着k趋近于无穷，式(3.34)中的两项都趋近于0。首先注意由于M=24R
;
68 信息论与编码理论(第二版)
并且R>R[见式(3.19)],exp(-2-R·M)<exp[-2k(A'-R-]非常快迷地趋近于0。
其次，注意1-△。(u,v)等于1的充要条件是d{a,v)>k8或者I(u;v)>LR",因此，
∑pu,vI-Ao(u,
≤P{d(U,V)>kǒ"}+P{(U;V)>kR"}
(3.35)
式(3.35)中的概率取自(U,V)空间，式(3.26)描述了其概率分布。但是，
tU.v= 40i
是独立、同分布随机变量的求和，根据式(3.25b)和式(3.19),其中每个随机变量的均值都
满足E[d(U,V)]≤8<8”,所以根据弱大数定理(见附录A),式(3.35)中的第一个概率随
着k的增加而趋于0。类似地，
u:v=u)
是独立、同分布随机变量的求和，其中每个随机变量的均值都满足【(U;V)=
R(o)<R[见式(3.25a)和式(3.19)],因此再次应用弱大数定理，式(3.35)中的第二个概
率也随着k的增加而趋于0。综合所有这些结论，我们看到式(3.34)中给出的E(K)的上
界趋近于0;特别是对于足够大的无，它将小于(8-8”)/B,回顾前面的讨论，这就完成了
证明。
习题
3.1 计算 R(8),信源p=(2,2)),相应的失真测度矩阵为：
D-[2
3.2 计算 R(δ),信源」p=(2,2)),相应的失真测度矩阵为：
D=[i
[本题说明了R(8)不必是严格下凹的。]
3.3 证明在定理3.2证明过程中最后定义的k维试验信道满足E[d(U)]≤k8及(U;V)=
kR,(δ)。
3.4 本题的目的是要证明R(δ)在d=δ_处连续。为此补充下述细节。
令Q,Q?,…是随机矩阵序列，分别表示达到R(8i),R(8?),…的试验信道的转移概率，
其中 limδ=8。则存在一个子序列Q,Q,…,它收敛于一个随机矩阵Q。对应
于Q的试验信道满足E[d(U,V)]=δ_和1(U;V)= limR(δu)。因此
R(5m)≤lin+_R(8),而R在8=8处连续。
第3章 离散无记忆信源及其率失真函数 69
3.5 在前面我们证明了R(0)=H(信源的熵)的充分条件是，D的每一行至少有一个0元素，
而每·列至多有一个0元素。试证明这个条件也足必要的。
3.6 在例3.2中，我们利用“对称性”来寻找一个达到R(8)的试验信道。在本题中将明确表
述这一概念。令π是A,的-个置换，对所有的u∈U,满足p(u)=p(π(n))(如果信源
是均匀分布的，对π没有限制),令p是Ar的一个置换，对所有v∈U和v∈V,满足
D(u,t)=D(π(w),p(c))。这就是“对称性”所要求的，在例3.2中，
π(-)=+1,π(0)=0,π(+1)=-1;p(一去)=+六p(+)=一
证明对每个δ≥0,都存在一个能达到R(δ)的试验信道p(vlm),使随机矩阵Qa,v)=
[p(vln)]具有与D相同的对称性，即对所有的v∈U和v∈V,Q(π(u),p(v))=
O(u,D).[提示：如果Q(n,v)表示一个能达到R(8)的试验信道，定义Q(n,v)=
Q?(π(u),p(v)),并证明当i=1,2,3,…时，Q,表示一个能达到R(8)的试验信道。然
后定义Q(u+v)=n-1Q:(u,v),其中n是x和e阶数的最小公倍数。]
3.7 在最普遍的情况下，计算R(n)并不是一件简单的事情。然而，下述结论经常是有帮助
的，请证明它的正确性。
对每个u∈A,令B(u)代表“表示μ的最佳信宿”的集合，即B(u)=ip∈Ay:d(u,e)≤
d(u,n),对所有的'∈AF。则存在一个能达到R(8m)的反向试验信道p(ulv),使得
对任意 v?,v?∈B(u),有p(rlr?)=p(ulv?)、
(,3,号),相应的失真 将这一结论用于寻找下述信源的R(δm):信源的统计分布为
测度矩阵为： =
3.8 考虑一个固定信源p=(piP?,…,p,)和失真测度矩阵D,对应率失真函数R(ò)。考虑
一个新的失真测度矩阵D,它是由D通过第；行加上一个常数w,而形成的，即d(i,j)=
d(i,j)+t,。证明新的率失真函数为R(&)=R(8-元),其中w=∑wp。利用这个结
论证明假设δ=0实质上不失一般性。(此结论由J.Pinkston[25],300页给出。)
3.9 考虑一个信源p=(p,,…,p.),它的失真测度矩阵的第一行全为0。证明R(8)=(I p?)R(o/(1-p?)),其中A是信源(p?/(L-p?),…,p.(1-p?))的率失真函数，它的失真
测度矩阵D是巾D刷除其第一行而得到的。(此结论由J.Pinkston[25],300页给出。)
3.10(香农的R(8)下限)假设失真测度矩阵D具有如下性质：它的每一列都是(di,d?,…,
d,)的一个置换、定义虫(δ)=max|H(a?,…,a,):21ad=8i(见习题1.8)。通过
证明下述结论来证明R(8)≥H(U)-Φ(δ),其中H(U)是信源熵；
(a)如果(U,V)是一个能达到R(8)的试验信道，则R(&)=H(U)-∑,p()H(U1
V= )。
(b)如果8(v)=∑,p(uln)d(z,v),则H(UIV=2)≤(8(D))。
ia.·
70 信息论与编码理论(第二版)
(c)∑p(D)更(8(v))≤φ(∑,p()8(0))≤(8)。
3.11(续)如果D还具有下述性质：它的每一行都是其他行的置换，证明如果信源是对称的，
对8≤δ≤8有R(8)=H(U)-Φ(8)。
3.12 考虑两个 DMS,输人符号集为A?,输出符号集为A#,失真测度函数为d(u,v),i=1,
2。它们的积具有信源符号集AJ×A?,信宿符号集A?×A?),失真测度矩阵的元素为
d[(,u?),(v?,v?)]=d(u,b)+d2(u?,o?)。(物理上这相当于两个独立、并行的
信源。)证明积信道的率失真函数是R(8)=min.IR(6)+R{2〕(8-t)},其中R3和
R2)分别是信源1和信源2的率失真函数。由此证明R(δ)的曲线可由将曲线R(1)和
R2)上斜率相同点的横纵坐标相加而得到。(此结论由香农得出。)
3.13(Lee测度下的最佳码?)如果q是奇数，而A,=Ay=10,1.…,g-1H,Lee失真测度(或
Le测度)定义为d(u,v)=min{Ia-l,lq-u+。如果q=2c2+21+1,考虑这个
码长k=2、有M=q个码字的信源编码：C=l(v,b?):v?=(2z+1)v,(modg)。证明围
绕这些码字的半径为t的球体完全覆盖了q2对(u?,A?)的集合而没有重叠。[围绕(z?,
t?)的半径为：的球体是集合(u,u?):d(u,v?)+d(m2,v?)≤1。]证明这个码的平均
3×(z3+31+1)(222+2t+1)。 失真测度为
3.14证明例3.2中信源编码的d(C)=9。
3.15 证明如果定理3.4的结论(a)替换为“M≤21(8”,它仍然是成立的；而如果δ>8,保
持(a)不变，将(b)替换为“d(C)≤δ”,它也仍然是成立的。
3.16证明如果0≤x,y≤1,M≥0,则(1-xy)“≤l-x+e-[见式(3.32)]。
3.17 描述一下在8=8时怎样才能确切达到信源编码定理(定理3.4)所保证的内容。
注释
[1] 专业上d(x,v)被称为单个字符失真测度，以区别于直接定义于某k维(n,v)=
((a,…,),(v,,…,vk))的失真测度，而不是由式(3.1)定义的失真测度。
[2] 这个例子是由香农给出的(参见文献[25],246-247页和262页图2)。在描述这个
很特别的信源时，他写道：“…(信源)符号集包含三个可能的符号，即-1,0和+1。
或许，由于某些经济原因，希望采用只有两个符号-量 +·和 的再生符号集。于是
可能会有例3.2所示的矩阵。”
[3] 后面的定义[式(3.3)和式(3.5)]可应用于任意的稳态信源；见式(5.3)和式(5.4)。
[4] 见第2章的注释3。
[5] 考虑到定理3.2,读者可能会奇怪，为什么首先介绍的是函数R(&)。原因有两点。
第一，对于一个有记忆的稳态信源，定义(3.3)式和(3.5)式是有意义的，井且一般对
于固定的δ,R(8)是t的减函数。(但我们在本书将不研究有记忆信源。)第二(对
我们来说更为重要),给出的这些定义简化了信源-信道编码定理逆定理的证明[见
第5章，特别是式(5.10)]。
第3章 离散无记忆信源及其率失真函数 71
[6] Pinkston(参见文献[25],296页开始)将这一定理推广到任意具有汉明失真测度的
DMS,如下所述。如果信源概率是有序的：pi≤p?…≤p,定义S=Z.,p,8=
Sk-1+(r-k)p和H=H(p+1/(1-S),…,p./(1-S))。则对于δk-I≤8≤,
R(8)=(1-Sa-1)(H-1-H((8-S-1)/(1-S))-(8-S)/(1-5)log(r-k-1)),其
中k=0,1,…,rc
[7] 关于这个专题的更多论述，参见 Berlekarnp[14],305~309页。
第4章 高斯信道和信源
4.1 高斯信道
这里信道的全称为“平均功率限制条件下的离散时间无记忆加性高斯信道”,它的信道输
入符号集AA和信道输出符号集Aγ都等于全体实数的集合。如果X、X?,…是信道在时刻1,
2,…的输人，则相应的输出Y,,Y?,…由Y=X,+Z.给出，其中Z,Z?,…是独立、同分布的正
态随机变盘，均值为0,方差为o2。这个信道经常描述为如图4.1所示。另外，对应每个输入x
存在一个“代价”;它是b(x)=x2。这一节里将证明该信道的容量-代价函数如下：
〔(A=log(I+β/n2) (4.1)
正如第2章中对离散信道的讨论，我们将证明如果平均输入代价限制为≤β,则C(β)代表信
道无误码传输信息的最大速率。
正态随机变世：
均值0,方差a
X一 + y
图4.1 高斯信道
在推导式(4.1)之前，我们首先简单地描述--下实际应用中可能山现的信道。
假设我们希望在T秒内将一系列n个实数xi,x?,…x?由一点传输到另一点，并要求将
这些x,转换为时间的连续函数x(1)。[为表述得更滑晰，假设x(z)表示通过10(欧姆)负载
的电压：]为此，一种方法是找到n个函数中，(t),i=1,2,…,n,它们在[0.T]时间间隔内正
交，即，
om={1蜘买 (4.2)
而传输的信号为：
9=(0 (4.3)
数值x,可以由x(t)获得：
x=。D(d (4.4)
但是，由此出现了几个复杂问题。首先，我们的传输可能是功率受限的，比如限制为P瓦。则
第4章 高斯信道和信源 73
。x2(2)d给出，根据式(4.2)的正交性， T秒内消耗的总能量不能超过PT焦耳。能量由积分
结果为∑,x2。因此必须有：
2笑 (4.5)
也就是说输人矢量x=(xy,…,x)不能是任意的；它必须在半径为√PT的欧几里得球体内。
另一个复杂问题是当传输x(t)时，接收信号的形式通常为x(t)=x(1)+z(t),其中z(t)
是某种类型的噪声过程。常见的一类噪声是Johnson(热)噪声，是由接收机中电子器件的热运
动造成的。在这种情况下将z(t)看做白高斯噪声是合理的。这就意味着存在一个噪声谱密
度值N?,使积分z,=|z(1)中；(t)d:成为统计独立的、均值为0、方差为N。/2的高斯随机变
量。因此如果接收者试图通过计算[参照式(4.4)](t)中；(t)d来恢复x;,他将得到估计
值=x:+着；c
现在总结如下：传输x=(x?,…,x。),这里x必须满足式(4.5),而接收的是=(x?+z,…,
x+0),其中艺，…,是独立的，均值为0、方差为N?/2的高斯随机变量。当然这只是本节开始
时所介绍的高斯信道的情况，其噪声方差o2=N?/2,而输人限制为β= PT/n。根据式(4.1),
og?(1+2PT/nN。)比特每符号。如果现在定义传输“带宽”为W=n/2T, 该信道的容量为-
并观察到每秒钟传输a/T=2W个符号，则容量变为：
C=Wlog?(1+P/N?M)比特每秒 (4.6)
式(4.6)是香农的有关带宽受限、功率受限高斯信道容量的喾名表达式。注意如果
W>>PIN?,则最终的“宽带”高斯信道的容量为：
c=2 (4.7)
=1.4427P/No比特每秒
现在回到本节主要关心的问题，即式(4.1)的推导。
类似于式(2.3),我们定义高斯信道的n阶容量-代价函数C(B)为：
D)=sp{xnEu3)≤n} (4.8)
其中的上确界是遍历所有满足下述条件的n维随机变量对X=(X?,…,X.)和Y=(Y,…,Y)
而得到的：
X具有连续密度函数p(x) (4.9a)
EX3)≤nB
Y?=X+Z,1=1,2,…,H
(4.9b)
(4.9c)
籍:
74 信息论与编码理论(第二版)
这里Z?,Z?,…,Z,是独立的(彼此相互独立并且与X,独立)、均值为0、方差为a2的随机变
量。高斯信道通用的容量-代价函数现在定义为：
CB)=sup C(B (4.10)
我们直接证明下面的定理。
C(β)=log(1+91o2)。 定理4.1 C(β)=(a/2)log(1+β/c2),因此
证明：设X=(X?,…,X.)是满足式(4.9a)和式(4.9b)的任意试验信源，则根据式(4.9c),X
和Y的联合密度为：
p(x.y)=p(x)g(2)
其中z=(y-x:,…,y-x。),而g(z)是Z?,…,Z。的联合概率密度，即，
8171.…、2)=zxp(-)
[参照式(1.27)。]
设A?=E(X2),由于X,和Z:是相互独立的，E(Y)=E(x2)+E(Z2)=A?+c2,因此根据
定理1.11,
n=号0g27(iu+02)] (4.11)
现在根据式(4.9b)∑,(A+a2)∈n(β+a2),并且根据算术-几何平均不等式，
式(4.11)中的乘积不大于(β+o2)",故，
hY)≤" log2πe(β+o2) (4.12)
根据定理1.10,1(X;Y)=h(Y)-h(YIX),但是h(YIX)=h(Z)=(n/2)log2πe2(见例1.13
和习题1,27)。因此，
I(X;Y)=h{Y)-h(Z)
≤2e(1+号) (4.13)
从而证明了C?(β)≤(n/2)log(1+βla2)。为证明反向不等式，设X?,X?.…,X。是独立
的、均值为0、方差为β的高斯随机变量，则满足式(4.9a)和式(4.9b)。因此Y?,Y?,…,y,
是独立的、均值为0、方差为β+o2的高斯随机变量(参照习题1.29),而I(X;Y)=h(Y)-
h(Z)=(n/2)log(1+β/o2)。这就完成了定理4.]的全部证明。
注寒 定义 C(B)的男外一种方式是特条件(4.9a)式普换为：
性设X只取有限多个值 (4,9a)
在习题4.11中将证明这两个定义是等价的。
这一节中最后的结论是高斯信道的编码定理。它完全类似于离散信道编码定理2.4:一
匀，
第4章 高斯信道和信源 75
个码长为 n的(信道)编码，就是一个包含M个n维矢量x?,…,x的集合。如果一个码字
X=(x?,…,x)在信道中传输，接收到的将是y=x+z,其中z的分量是相互独立的高斯随机变
量，均值为0,方差为c2。这种编码的译码规则是从所有n维矢量y的集合到该编码的一个映
射f。假设传输的是第i个码字，则错误概率P表示译码失败的概率，即P=
P|f(y)≠x,I传输的是x,l,其中y=x;+z同上。
定理4.2(高斯信道编码定理)给定β≥0,则对于任意β>β,R<C(β)=2log?(1+
8/o2),以及ε>0,存在一个码长为n的码C={x,…,x,以及相应的译码规则，使得：
(a)△,",x2≤nβ°,对于i=1,2,…,M,x;=(xu,…,xm)。
(b)M≥2
(c)P!'<e,对于所有i=1,2,…,M。
证明：由前面的讲解可知，可以选择一个只有有限个取值的随机变量X,满足E(X2)≤β
使得I(X;Y)任意趋近于C(β)。相应的Y一定不是离散的，但是由于随着量化[Y]越来
越细化，I(X;Y)= limI(X;[Y])[见式(1.17)],可以找到一个离散随机变量[Y],满足
I(X;[r])>R。以X的取值为输入，并以[Y]的取值为输出且输入满足E(X2)≤β限制
的离散无记忆信道，其容量大于R,因此根据定理2.4,可以立即得出存在一个城码，同时
满足(a),(b)和(c)的结论。
4.2 高斯信源
这里信源的全称为“离散时间无记忆高斯信源”,它的信源符号集A,是全体实数的集合，
而信源输出由独立、同分布正态随机变量的序列 U?,U?,…描述，随机变量的均值为0、方差为
o2。本节的目标是计算对应“平方误差”失真测度的信源的率失真函数，这里的信宿符号集Ar
也是实数的集合，而信源符号a和信宿符号v之间的失真度由下式给出：
d(u,D)=(2-D)2 (4.14)
率失真函数为：
-{8 如果δ≤a2
如果d=a2
(4.15)
它的曲线(单位为比特)如图4.2所示：
I
R(δ)
0.5
D.250.50 1
Co2
图4.2 高斯信源的率失真函数
76 信息论与编码理论(第二版)
高斯信源几乎在任何类型的数据采集实验中都有可能遇到。由于完全无失真地表示一个
实数u需要无限多个比特，所以了解如何在表示实验输出的比特数与最终失真度之间进行折
中是很有意义的。根据式(4.15)中的定义，如果允许的最大均方误差是δ,R(δ)实际上是充
分表示一个高斯随机变量(方差为c2)所需要的最少比特数。这个事实将被信源编码定理，即
定理4.5,以及第5章的结论所证实。
为了得到式(4.15),我们首先定义对应均方误差测度[见式(3.3)]的高斯信源的无阶率失
真函数为：
R(6)=inf{/(U;V);E(|U-VII2)≤to} (4.16)
这里的下确界是遍历所有满足下述条件的k维随机矢量对U=(U,,…,UA)和V=(V?.…,
V?)而得到的：
U?,U?,…,U.是独立的、均值为0、方差为c2的高斯随机变量 (4.17a)
(U-VP)=u-vM≤ko (4.17b)
U和V的联合分布由连续密度函数p(a,v)给出 (4.17c)
通用的率失真函数R(a)则定义[参照式(3.5)]为：
R(o)=ine Ro) (4.18)
同第3章中对离散无记忆信源的结论一样，式(4.18)中的下确界在k=1时已经达到。但是在
证明这个结论之前，要给出R?(8)的解析表达式，它当然也就是R(&)的值。
定理4.3
A-{ 如果8≤o2
如果S≥σ2
证明：选取δ,e>0和一对随机变量(U,V)满足：
(U;V)<R?(6)+毛 (4.19a)
U是高斯分布的，它的均值为0.方差为α2
E[(U-V)2]≤δ
U,V具有一个连续联合密度分布p(u,v)
(4.19b)
(4.19c)
(4.19d)
根据定义(4.16)式和条件(4.17)式，这是可能的。由式(4.19c)和式(4.19d),
o=JJnu,Dru-D2dudo (4.20) =jpo]p(ulo)u-v2dudu
p(v)=[p(u,v)du是V的边缘密度，而p(ulv)=p(u,D)/p(v)是给定V=v时U 其中
的条件密座。根据式(4.20),如果我们定义：
■
第4章 高斯信道和信源 7
8(u)= pulDru-02du (4.21)
则δ(》)对于几乎所有的v值都是确定的。因此根据定理1.11,条件熵h(UIV=s)对于
几平所有的t值都存在，并且事实上，
hUIV=D)=- pulDJlog pulo)du
≤iog2πeδ(v)
(4.22)
现在根据定理1.10,
(U;F)= h(U)-h(U|V) (4.23)
但是h(D)=2log2me2(参照例1.13),并根据式(4.20)、式(4.21)和式(4.22),
h(UIV)=?p(u)h(UIV=D)d
≤[p(v){2log(2ze(v))}d
=?f(8(v))p(v)du[根据式(4.22)]
其中f(x)=方log(2πex),由于f(x)是上凸∩的，因此根据Jensen不等式，我们有：
h(UIV)≤f(js(u)p(v)d)
≤f(8)
=2log(2πe)[根据式(4.20)]
因此R?(8)+e>/(U;V)≥2loga2/8;但是由于这对于所有的e>0都成立，并且由于在
任何情况下都有R?(δ)≥0,故可得：
Rio)≥max(10g°,) (4.24)
下面要证明的是下界(4.24)式是精确的。为此，注意如果δ<o2,而V是一个均值为0、方
差为o2-δ的高斯随机变量，井且如菜U=V+G,其中G是独立于V的、均位为0、方差
为δ的高斯随机变量，则当k=1时(U,V)满足式(4.17),因此R,(8)≤1(U;V)=h(U)-
h(UIV)=h(U)-h(G)=2log2πc2-2log2meo=2loso218(死习题1.27)。另一方面，
如果8>o2,选取e>0并设V是一个方差为e的高斯随机变量，则G是一个方差为a2-e
的高斯随机变量。这样仍然满足式(4.17),因此R?(δ)≤I(U;V)=h(U)-h(G)=
2log2πe2-2log2ne(a2-s)=zlos[l+e/(c2-e)]。由于这对于所有e>0都成立，在
这种情况下R?(8)≤0。因此下界(4.24)式同时也是上界，从而完成了证明。
·
:
78 信息论与编码理论(第二版)
(在定理4.3证明过程的最后部分所描述的U和V之间的奇特关系，经常称为计算 R(B)
的“反向”试验信道，因为它可以描述为如图4.3所示，尽管事实上U是信源而V是信宿!这
个试验信道的“正向”描述见习题4.18.)
G
U V
图4.3 个高斯信源的反向试验信道
现在就可以计算R(8)了。
定理4.4 对于所有的k,R?(8)=hR,(8),而R(8)=R?{8)=ma(loeo2/8,0)。
证明：选取ε>0,并设U=(U?,…,UA)和V=(V?,…,V.)是满足式(4.17)和下式的一对
随机矢量，
/(U;V)<R(b}+E (4.25)
于是根据定理1.8,/(U;V)=2_I(U?;V)。如果我们定义δ=E[(U-V:)2],则根
据R?(8)的定义，I(U,;v.)≥R?(b;),并根据式(4.17b)∑8≤d。另外
Z,R?(8)≥kR?(8)≥kR,(8),其中δ=k?1∑Bi,这是由于根据定理4.3,R?(δ)
是下凹U的并且单调下降。因此，
R(δ)+E>/(U;V)
)
R)
kR?(δ)
kR?(6)
因为这对于所有ε>0都成立，所以有R(8)≥kR?(8)。为证明反向不等式，设(U,,V?),…,
(U,V)是达到R?(8)的反向试验信道的独立相同复制。则对于δ<a2,满足式(4.17)
并且(U;V)=(k/2)logo218。(对于δ≥o2,证明是类似的，留做习题4.20。)
注意 如果R(8)定义中的条件(4.17c)式被替换为：
假没V只取有限多个高散值 (4.17c)
R(8)的催不变、这是习题4.21的内容，
在本节的最后一部分，我们介绍高斯信源的信源编码定理。本书中，码长为k的信源编
码是一个包括M个k维欧几里得矢量的集合C=|,?,…,v。如果u是另一个k维欧几
第4幸 高斯信道和信源 79
里得矢量，定义f(u)是使欧几里得距离||u-v:Ⅱ尽可能小的一个码字v?。则该码的平均失
真度为：
d(C)=E(lu-f(u)|2) (4.26)
其中的期望对应u上的一个k维、均值为0、方差为o2的高斯分布。显然如果用这样的编码
来表示一个高斯信源，则每个矢量[如果用它的码字f(u)表示]就可以被限定为[logM]比
特，并且最终的每符号均方失真度是d(C)。
定理4.5 设R(8)=max(1ogo28,0)表示对应均方误差失真测度的高斯信源的率失真
函数。给定&0。如果R'>R(δ)并且δ>8,则对于足够大的无值，存在一个包含M
个码字的信源码C,满足：
(a)M≤2
(b)d(C)<8
证明：如果8≥o2,则通过选择长度为1的单个码字0,就可以达到目的。另一方面如果
δ<α2,设(U,V)是在定理4.3证明过程中描述过的达到R(δ)的反向试验信道；见
图4.3。选择8?和δ?满足：
δ<δ?<δ?<8' (4.27)
接下来选取函数α和β,假设每个函数只取有限多个值，满足：
E{[a(U)-β(V)}}<81 (4.28)
E{[U-α(Ur}=E (4.29)
其中，
8+2√EO?+&?<6° (4.30)
(这是习题4.22的内容。)我们现在考虑高散无记忆信源a(U),它的信宿符号集与β的取
值相同，并且关真度函数d(u,v)=(u-v)2。根据习题1.22,(a{U);β(V)]≤I(U;V)=
R?(8),如果我们定义这个信源的率失真函数为R,根据式(4.28)有：
R(δ)≤R(d)<R' (4.31)
因此根据离散无记忆信源的信源编码定理(定理3.4),对于信源a(U),存在一个码长为
k的信源编码，满足：
M2ltR (4.32)
d(C)<dz (4.33)
现在考虑将这个编码应用于最初的信源U。如果u=(M?,…,a)是一个长度为k的任意
随机矢量，并且如果v:是最接近于a(u)=(a(a?),…,a(m))的信源码字，则|-v:ll=
l[u-a(u)]+[a(a)-v.],因此根据Schwarz不等式3,
E(IU-V:}2)≤E[HU-a(U)|21+E[|a(U)-v?I2]
+2E[IIU-aU|2}1/2ET[la(U)-v:il2}/
.r.1、
(4.34)
80 信息论与编码理论(第二版)
其中V,表示最接近于随机变量U的码字。但是根据式(4.29)E[|U-a(U)|Ⅱ2]=kE,
并且根据式(4.33)E[llα(U)-V,I2]<kδ?,因此结合式(4.30)和式(4.34),我们得到：
E[IU-V:2]<k8' (4.35)
该式与式(4.32)结合即证明了定理。
习题
4.1 考虑一个Ax=Ay=实数轴的信道，它的输出Y是输入X与一个独立噪声随机变量Z的
和，Z均匀分布于[-2,2]:。假设输人X受到IXI≤β的限制。如果β是一个整数，
证明容最[类似于式(4.8),式(4.9)和式(4.10)的定义}是C(B)=log(2β+1)。如果β不
是整数会怎么样?
4.2 考虑一个如图4.1所描述的加性噪声信道，其中Z不一定足海斯分布的，但它独立于X
2beg(1+B1o})≤C(β)≤ 并且具有方差c2。如果E(X2)≤β,证明相应的容量满足
亏log((β+a2)/a3),其中a3=exp[2h(Z)]/2re。[提示：见习题1.30] L
在下面的7道习题中我们将简要叙述一个高斯信道编码定理的证明，它在某些方面比定
理4.2强，在某些方面则比定理4.2弱。这一定理将指出下面这个量的意义：
E,=loe(+)
定理的内容是：
高斯信道的R。定理 对于任意R<R?,都存在一个码长为n、有M=L2J个码字的编码
x?,…、X,每个码字的坐标为±√β,同时对应一个译码规则，使得如果以Pe=
(∑"Pg)/M表示平均译码错误概率，则Pg<2R-。
(这个定理比定理4.2强，是在于它给出了P作为n的一个函数能够达到多小的精确估算。
它的弱点是R?<C(β),因此当速率Ro<R<C(β)时，不能说明P→0的可能性。)
4.3 首先证明对于一个只有两个码字[x?,x?的编码，如果译码器选择的是与接收矢量y最
接近(欧几里得距离最小)的码字，则错误概率为：
P?[x1,x?]=QHx?-xz1/20)
其中Q(a)=(1√2x)e3d。
4.4 接下来证明一般情况下，如果编码ix,…,x|按照最近码字策略进行译码，并且如果
P"表示传输x;时的译码错误概率，则，
us)
第4章 高斯信道和信源 81
4.5 然后证明估计：
Qla)<Le-22, a>0
4.6 现在设所有码字的坐标为±√F,而dg(x?,x,)(x,与x,之间的汉明距离)定义为x与x
之间不同坐标的个数。证明：
其中y=e-22。
4.7 利用习题4.4的结论，得出下面的平均估计值E[P],其中码字的坐标是根据分布
P{x=+√β}=P{x=-√F}=-独立选取的：
L|<u.(1)
4.8 现在通过选取M=L2*」,完成R。定理的证明。
4.9 最后证明：
(a) lim R?(B)=lo2
(b))-
在下面的7道习题中我们将研究最化对高斯信道的影响。如果继续假设输人X至多取r
个离散值，而输出Y被量化为至多是s个不同值中的一个，则以 cr(β)表示高斯信道的容
量。对干所有的n,我们正式定义c)(β)=sup{I(X,,…,X;f(Y,),…,f(Y。)},这里每个
X,至多可取，个离散值，∑",B(X2)≤ng,Y,=X,+Z,,其中Z,是相互独立、均值为0、方
差为2的高斯随机变量，面f是一个至多可取s个不同值的任意函数，干是c(β)=
sup,n-1c(β)。
4.10证明 C(β)=C3(β)。
4.11证明 lim,c(β)=2log(1+B/2)。[证明简述：首先证明对于一个固定的，值，
lim,ctr.0(β)=cr.(β)由公式 cr)(β)=sup(X:Y)给出.其中的极大值是取
遍所有随机变量X而得到的，X至多取，个不同值且E(X2)≤β,而Y=X+Z中的Z是
相互独立、均值为0、方差为c2的高斯随机变量。利用公式T(X;Y)=h(Y)-h(Z)(参
c)(β)≤zlog(1+βia2)。接下来令X是一个均值为0、方差为β 照习题1.27)证明
的高斯随机变量，令I?,…,1,是将实轴划分为r个区间的一种分割，且对于每个i=1,2,…,r
选取x∈I,使lx:I尽可能小。定义新的随机变量 X,PIX1=x,t=PIX∈Il,i=
1.2,…,ro则C)(β)≥(X;X'+Z)。现在，随着→四，分割变得越来越精细，根据
Lechegue的控制收敢定理，b(X'+Z)→h(X+Z)=÷he(c2+B)。因此，
汉
82 信息论与编码理论(第二版)
lim,-xC'×*(B= og()+β/o2)
4.12 对于固定的r和s,证明limm2C(β)=min(logr,logs)。
4.13 证明如果r≥s,则Cr.(β)=C(B)。[此结论由H.Rumsey,Jr得出。]
4.14 如果flc2=a2,证明 c2)(3)=a2-g(y)log cosh(a2+ay)dy,其中g(y)=
(2π)-ae-2。并证明对于小的α值，cl2.)(β)=a212-a?/4+0(a?),注意这实质上等
C(β)=2og(1+a2)。因此有我们熟知的定理“在小信噪比条件下， 于未经量化的容量
二进制输人量化无损失”(见习题4.9b)。事实上对于a≤1,比值C(2.(β)/C(β)≥0.97
总是成立。
4.15 寻找 c22)(β)的一个表达式，并证明 limC2.2)(β)/C(β)=2/π。由此有我们熟知的定
理“在小信噪比条件下，二进制输出量化损失2dB”(注意；无量纲的比值θ等于10log?
“dB”)。
4.16利用数值方法，证明对于小的a值，C°3(β)=0.405a2+0(α3),而 c(β)=
0.441a2+0(a3),其中r=2。
4.17[注意：当噪声过程z(t)不是白噪声时，本习题的结论可以用于计算“波形信道”的容
量，]考虑n个“并行”高斯信道：
Z
Xi- Y?
Z
x- Y
其中Z?,Z?,….Z。是相互独立、均值为0的高斯随机变量，且 var(Z,)=c2。定义“容
量”为C(β)=auplI(X;Y)|,极大值是取遍所有满足∑E(X})≤n3的输人分布得到
的。证明C(β)的参数表达形式如下：
p-Zo2-03
cm=()
其中独立变量2的取值范围是从min,o2到β。
4.18本习题的目的是，对于高斯信源和均方误差失真测度，推导出一个达到R8)的“前向”
试验信道。回忆一下所需的条件：U是均值为0、方差为o2的高斯随机变量，δ≤o2,而
寻找的V必须满足Ei(U-V)2]=8及I(U;V)=2logo2/8。。证明通过合理选取δ和
o2,可以取V=aU+z,其中a是常数，而Z是高斯分布的，方差为o2;或者取V=
第4章 高斯信道和信源 B3
βU+Z),其中β是常数，而Z是高斯分布的。这两个“前向”试验信道可以描述为如下
图所示：
α 7. 7 β
!- + U- +
4.19考虑一个信源U?,U?,…,其中U,是相互独立的随机变量，具有共同的概率密度p(u)
和方差o2。证明这个信源的率失真函数满足R(8)≤max( log218,0)(提示：利用习题4.18
中的前向试验信道.)
4.20证明如果δ≥o2,则R(8)=0。(见定理4.4的证明。记住(U,V)必须有连续的联合概
率密度，因此不能定义V=0:)
4.21本习题的目的是证明，如果将条件(4.17c)式换为条件(4.17e')式，R(δ)的值将不变。
在下面证明的简述中，假设k=1且δ<o2。(k和8向更大值的推广非常简单，因此没
有给出提示。)你的工作足补充细节。因此令R(8)表示满足式(4.17a)、式(4.17b)和
Ri(8)≤()log2/8,如定理4.3的证明 式(4.17c)的/(U;V)的最小可能值。为证明
中所述，令(U,V)是达到R?(8-e)的一个试验信源。选择c>0,并令V是V的一个确
定函数，它仅取有限多个函数值，满足E[(U-V2]<8。则1(U;V)≤I(U;V)=
R?8-e),而 Ri(8)≤21ogo28-e)。由于这对所有s>0都成立，所以R{(8)≤
ogo2/8。为证明R;(δ)≥logo2/8,令(U,V)是满足式(4.17a)、式(4.17b)和
式(4.17c')的一个试验信道，则I(U;V)<R{(δ)+ec令V=V+C,其中G是独立于V
的、均值为0、方差为e的高斯随机变量。则(U.V)试验信道满足式(4.17a)和
式(4.17c),HE[(U-V)2]∈δ+e。因为I(U;V)≤(U;V),由此得出Ri(δ)+E>
logo2f(δ+E)。又因为这对所有的ε值都成立.所以R(8)≥2logo3/8,
4.22 证明存在函数a(u)和β(:),满足式(4.28)、式(4.29)和式(4.30)。
4.23(香农下限)考虑一个信源U?,U?,…,其中U.是独立、同分布的随机变量，具有相同的
密度函数p(u)和相对熵h(U)。令f(x)是实数变量x的任意非负偶函数，并根据失真
测量d(a,D)=f(u-0)定义信源的率失真函数为R(8)=inf{I(U;V),极小值是取遍
所有的随机变量对(U,V)而得到的，其中U分布的概率密度为p(u),(U,V)有联合密
度函数，且E[(U-V)]≤。[实际上，为了与第4章的表述一致，应定义R(8)类似于
式(4.16),而R(8)=inf,k-'R(8)。然而，由于R(8)=kR,(8),所以本习题的定义实
际上是与之相同的。]定义中(8)=saplh(X):E[f(X)]≤δl。证明R(8)≥R?(8)=h(U)-
δ(u)=(fu-0)p(u ID)du, 中(8):提示：首先证明中(δ)是8的上凸∩函数，则如果
1 i
84 信息论与编码理论(第二版)
了(U;V)=五(U)-h(UIV),且
AUIV)=|g(u)[p(ulologdudu
φ(5)
4.24(续)利用习题1.35的结论，估计下述情况下的香农下限R(8):
(a)p(u)=V2, f(x)=lxi°,α=1,2
(b) p(u)=2Aa, f(x)=1x1
(c)p(u)=2(1+u2)-2, f(x)=Ixl
4.25 通过构造一个合适的试验信道，证明习题4.24b中信源的R(&)=R(δ)。
4.26[注意：本习题的结论可作为研究有记忆高斯信源率失真函数的出发点、见Berger[13],
第4章。]考虑k个“并行”高斯信源U?.U?,…,U,即U,是相互独立、均值为0、方差为
o2的高斯随机变量。定义R(δ)=inf|T(U;V)},其中极小值是取遍所有(U;V)对而得
到的，(U;V)具有联合概率密度，且∑B[(U.-V.)2]≤。证明R(8)的参数表达
形式如下：
N6)=二 (08)
6-mimo'.0})
其中参数σ2的取值范围是从0到max,o2。
4.27根据1.3节的定义，证明高斯信道是无记忆的。
注释
[1] 约翰逊(Johnson)噪声的谱密度是N。=kT,其中k=波尔兹曼(Boltzmann)常数=
1.38×10-"J/°K,而T是有效噪声温度。实际上谱密度依赖于频率，为P(f)=hfl
(e7k-1)瓦/赫兹，其中了是以赫兹为单位的频率，h=普朗克(Planck)常数=
6.6×10·焦耳-秒。只有当信号φ:(t)的大部分能量局限于使近似公式P(/)N?
有效的频率范围内时，推断"|z(1)Φ;(t)dr是方差为N?/2的高斯随机变量"才成立
(见注释2)。而实际上直到非常高的频率这个近似公式都是基本有效的；例如，如
果/<0.02MT/h=4×10r,则0.99N?<P(f)<N。(一个实际应用是，美国航空航
天局(NASA)在加利福尼亚戈尔德斯通的64米天线，T≈25°K,f≈10°-10°,f≈
…;、……………………………………r
J
第4章 高斯信道和信源 85
0.01kT/h。)[参见 Feynmann,Leighton和Sands[5],第1卷，第41章：]
[2] 这个相当随意的带宽定义需要一些说明。在物理学领域，通常需要限定传输信号
x(t)的频率不高于某个固定极限值(比如W赫兹)。数学上，这意味着当Ifl>W'
时，傅里叶变换X(F)=Jx(1)e?2dt成为0。如果是这种情况，根据博里叶积分
x(c)=x(f)e2df,这表示x是：的解析函数。但是对任何物理可实现 定理，
信号，t<0时x(t)=0,这意昧着x(t)恒等于0。因此不要求X(f)对Ifl>W变成
0,而是选取0<e<1,并做较弱的假设：x(1)至多有ε部分的能量在频带[-W,W]外，
1xfl24/1xAl2d>1-e。这个约束条件限定了[0,T]时间段内所能 即
选取的正交信号个数的极限为n=n(T,e)。实际上可以证明limyn(T,e)/2T=W
对所有e>0成立。这就解释了为什么定义W为n/2T而不引入带限函数的不精确
概念是合理的。[参见Gallager[17],第8章。]
[3] 这里引用的Schwarz不等式的概率形式是：如果X和Y是定义于同一样本空间上的
随机矢量，则E(X·Y)2≤E(IXI2)E(IYI2)。(参见Feller[4],第2卷，v.8节。)
!物：、 .
第5章 信源-信道编码定理
本章是第一部分中最重要的章节，这里将应用第1章至第4章的结论，研究一个信息源的
输出在噪声信道中传输的问题。在整个这一章里，将采用图5.1中的方框图作为我们的示例。
实二 倍源
信道
信宿
图5.1 一个通用的通信系统
事实上任何实际的通信系统都可以山纳为图5.1中的模型，编码器模块代表在传输之前
对信源输出所做的全部数据处理(可能包括量化、调制，以及差错控制编码)。假设存在整数k
和n,系统可以独立地处理顺序的、包含k个信源符号的分组，并将它们转换为顺序的、包含 n
个信道输人符号的分组。(例如k可以是系统运行期间信源所输出的全部符号的个数，但是
对于大多数系统，h的取值要小得多。)假设信道在离散时间间隔内接收信道输人符号，并一一
对应地输出相应的信道输出符号1。信道是“离散时间”的假设并不是一个很严格的限制，因
为大多数“连续时间”信道可以看做是“离散时间”信道而损失很小。“译码器”模块代表在将信
道输出传送给信宿之前所做的全部数据处理。假设译码器独立地处理顺序的、包含n个信道
输出符号的分组，并将它们转换为包含k个信宿符号的分组，信宿序列V=(V?,V?,…,VA)是
系统对信源序列U=(U?,U?,…,U)的估计。
现在按照方框图5.1回顾一下本书第一部分的基本结构。在下面的讨论中，我们将采用
非常通用的信道和信源模型；但是读者应该注意到，这里只是针对某些特殊情况证明了相应的
编码定理。
首先考虑信道。给定信道输入符号集Ax和输出符号集Ay;对应每个输人符号x∈Ax,存
在一个非负的实数b(x),即“传输x的代价”。更普遍地，对应每个x=(x?,…,x)∈A,
b(x)是传输x的代价。另外，给定信道统计分布，即对应每个n给定条件概率分布子，使得一
旦知道输人X=(X,,…,x。),就可以计算输出Y=(Y,,…,Y。)的分布，对于所有的正整数n
和β≥0,定义C(β)为：
Cn(β)=sup{I(X;Y):E[b(X)]≤nβ} (5.1)
式(5.1)中的上确界是取遍所有取值于Ax的并满足E[b(X)]≤n3的n维随机矢量X=(X?,…,X)
而得到的，而Y是取值于Ai的n维随机矢量，如果信道的输入为X,Y就是信道的输出。本书
中X称为一个n维、β-容度的试验信源。信道的容量-代价函数C(β)定义为；
第5章 信源-信道编码定理 87
CB)=sup{CaB:n=1,2.…} (5.2)
通常当β≥βn=inf}b(x):x∈A?F时，C(β)是β的连续、上凸∩和单调上升函数。下面介绍
C(β)的重要性质(所有的对数运算仍然以2为基底):
信道编码定理：给定β≥βm,则对于满足β>βo,C'<C(β),e>0的任意三个参变量
(β,C",e)和所有足够大的n值，存在一个码长为n的码|x,x?,…,xul,以及相应的译码
规则，使得：
(a)每个码宇满足b(x)≤nβ。
(b)M≥2C?
(c)Pg<e,i=1,2,….M。
(P是传输x?时译码失败的概率。)
接下来讨论信源。给定信源符号集An,信宿符号集Ap,以及对应每一对(a,)∈A×A,
的一个非负实数值d(u,o)(它表示信源符号n到达信宿时变为》的“失真”)。更普遍地，对应
每个正整数k和每一对(u,v)∈Ai×A,如果信源序列u=(山…,a)到达信宿时变为序列
v=(p,,…,v),d(u,v)是对全部失真的度量。另外，给定信源统计分布，即对应每个k,给出
描述信源连续左个输出的随机大量U=(U?,…,UA)的分布。对于所有的正整数k和δ≥8,
定义 R(8)为：
R(0)=inf{7(U;V):E[d(D,V)]≤ko} (5.3)
这里的下确界是取遍所有取值于AE×A的k维随机矢量对(U;V)=(U?,…,U;V?,…,V?)
而得到的，其中U的边缘分布由信源的统计分布给定，并且E[d(U;V)]≤h。因此在
式(5.3)中我们真正改变的是给定U时V的条件分布，而这个条件分布称为k维试验信道。
式(5.3)中是对所有k维、a-容度的试验信道求下确界。信源的率失真函数定义为：
R(o)=mf{Rio)rk=1.2.…} (5.4)
通常当书>0,时，R(8)是8的连续、下凹U和单调下降函数。下面的定理介绍了R(B)的重
要性质。
信源编码定理：给定δ>8,则对于满足δ>0和R'>R(8)的任意一对参变量(8,R'),
以及所有足够大的k值，存在一个码长为无的信源码C={v,V?,…,V,使得；
(a)M≤2Rkl
(b)d(C)<8
[回顾信源码C的平均失真度d(C)被定义为d(C)=k?1E[d,(U)],其中对于每个u∈
Ai,d(u)=min|d(u,v,):j=1,2,…,Ms]
现在回到方框图5.1、注意到一旦确定了编码器和译码器，就可以将U,X,Y和V看做随
机矢量，U是最先定义的随机矢量，而给定U后X的条件概率，给定X后Y的条件概率，以及
..a.t,
88 信息论与编码理论(第二版)
给定Y后V的条件概率决定于相应的编码器设计、信道统计特性和泽码器设计。现在定义三
个能够体现更多系统性能的参数。
平均代价：
F=贵E1b(X)] (5.5)
平均失真度：
δ=du;V (5.6)
传输速率：
r= (5.7)
这些参数的物理意义应该是很明确的：β告诉我们系统运行的代价是多大(基于每信道输人);
表明系统传输信源输出的可靠度如何；而=度量系统传输信意的速率(单位是信源符号每信
道符号)。对于给定的信源和信道，我们希望设计的系统具有小、小δ和大产，但是这些目标
当然是相互矛盾的。下面的定理就是信息理论的核心结论，它明确地告诉我们什么是可能的，
而什么是不可能的。
走理5.1(信源-信道编码定理)对于给定的信源和信道：
(a)参数序于和产必须满足：
0
(b)相反地，给定数值β>fm,8>8和r<C(β)/R(8),可以设计出图5.1中所描述的
一类通信系统，使得≤β,δ≤8并且Fr。
证明：首先将证明(a),证明过程中将只用到定义式(5.2)和式(5.4),而没有采用蠕码定
理。因此定理的第一部分(有时称为编码定理的“逆”或“弱逆”定理)在通常的情况下都
成立。
假设给定图5.1中所描述的通信系统。我们首先观察到随机矢量的序列(U,X,Y,V)是
一个Markov 链(Y只通过X依赖于 U,V只通过Y依赖于X),因此根据数据处理定理
[式(1.15)].
I(U;V)≤I(X;Y) (5.8)
下面注意到由于E[b(X)]=np[见式(5.5)],根据式(5.1)有/(X;Y)≤C(β)。另一方面
根据式(5.2)C.(β)≤nC(P),因此，
I(X;Y)≤nC(P) (5.9)
同时，由于R[d(U;V)]=[见式(5.6)],根据式(5.3)有I(U;V)≥R(ō),而根据
式(5.4)有R(8)≥R(δ)。因此，
(U;V)≥kR(O) (5.10)
第5章 信源-信道编码定理 89
结合式(5.8)、式(5.9)和式(5.10),我们得到信源-信道编码定理的结论(a)3。
当然按照我们的安排，(a)并不是一个深奥的结论，它只是C(β)和R(8)定义的一个推
论!令人惊奇的是，它的相反结论(b)的成立，当然在信道编码定理和信源编码定理的帮
助下，这个结论并不难证明。
因此从现在开始，假设给定β>β,8>8和r<C(β)/R(8)。我们的任务是设计一个
编码器和译码器，使得最终的β,和满足β≤β,δ≤6和F≥7。
首先是初步设计。选择数值肉，80,81,C和R'满足：
βmun≤βo<β (5.11)
0mnd<δ?<δ (5.12)
C'<C(βo) (5.13)
R'>R(δa} (5.14)
r<C'/R' (5.15)
(习题5.2说明这是可以做到的。)
编码器的设计将包括两个部分，即图5.2中所示的信源编码器和信道编码器。现在描述
围5.2中的信源编码器。根据信源编码定理，对于足够大的后，存在一个码长为ho、包含
M,个码字的码C,满足：
M?≤2LR'kJ (5.16)
和
d(C)<8? (5.17)
对于一个确定的整数 m(将在后面定义),我们取k=kom。困5.2中的信源编码器将长
度为k的信源序列U划分为m个长度为k的分组，并且对应这个信源分组序列翰出m
个信源码宇。因此中间天量W=(W,…,W)是给定信源码 C中m个码字的序列。特
别地，假设W至多有M≤2个不同的值。以上是有关信源编码器的描述(除了m的
说明)。
U
编码器
信源
-
信源
端码器
W
、W)
图5.2 编码器的通用设计4
为描述信道编码器，首先需要定义信源码C的最坏情况失真度。对于每个信源序列n∈
A?,设d_(u)= maxld(u,v.):v?∈Cl。因此，如果信源输出且而信源编码处理不知何故
发生了故障，则d_(U)表示最终可能出现的最大失真度。码C的最坏情况失真度定义
为下面的归一化到每符号的平均值：
DC=Edmc(U (5.18)
这里的期望是就描述正分布情况的信源绕计来计算的。(如果信源符号集Ae是无限的，
·àn.:
90 信息论与编码理论(第二版)
显然不能立即确定D(C)是有限的；见习题5.6.)定义：
E=(8-δ)/D(C)[见式(5.12)] (5.19)
现在可以描述图5.2中的信道编码器。对于每个m=1,2,…,定义整数n为：
7m=[mkoR'/C (5.20)
则根据信道编码定理，对于所有足够大的m,存在一个码长为n的信道码!x,,…,X?i,
以及相应的译码规则，使得：
b(x,)≤nmβ,=1,2,…,M?
M?≥2iC'ml≥2toR'
(5.21)
(5.22)
P<e,=1,2,…,M? (5.23)
进一步假设m的值足够大，使得：
Aom/nm=r (5.24)
[根据式(5.15)这是能够满足的。]图5.2中的信道编码器将m个信源码字所对应的每一
个序列W=(W,,…,W)映射为一个不同的长度为n=nm的信道码字。这是可实现的，
因为据我们前面的观察，至多有2个不同的W,而根据式(5.22)至少有这么多个不同
的码字。
描述完图5.1中的编码器，由式(5.24)可以立即得到r=k/n=kom/nm≥r,并由式(5.21)
得到nβ=E[b(X)]≤nβ。还需要证明的是平均失真度δ≤8,当然为此必须设计图5.1
中的译码器。图5.3中描述了译码器的通用设计。其中信道译码器的原理依据信道编码
定理；它将受噪声干扰后的码字Y=(Y,…,Y。)映射为一个信道码字，例如Z=(Z,…,Z)。
最后，图5.3中的信源译码器将信道码字Z作为输入，并相应输出m个信源码字的序列
V=(V?,…,V?),如果存在的话。(这种对应关系是由图5.2中的信源编码器确定的。)如
果不存在m个信源码字的序列与乙对应，我们就假设信源译码器从信宿符号集Ap中产
生一个包含k个符号的确定“无效序列”v=(°,…,v)并输出。
译码器
宿道 俏源 信道 译码器 译码基
图5.3 译码器的通用设计
描述完图5.1至图5.3中的通信系统，剩下的任务就是计算平均失真度δ=k1E[d(U,V)].
为此引入一个新的随机变量B,它将告诉我们图5.3中的信道译码器译码是否成功。
因此，
B={9 如果译码成功； Z=X
如果译码失败； Z≠X
则，
E[d(U,V]=E[d(u,v)|B=0]P{B=0)+E[d(U,V|B=1]P[B=1} (5.25)
i
第5章 信源-信道编码定理 91
现在如果B=0,则表示译码成功，信宿序列V与信源编码器的输出相同。因此如果U=
[U,U2,…,Um3]是将U划分为m个包含个信源符号的分组，则若B=0,有
d(U,V)= ∑/d[U"],于是根据式(5.17)有E[d(U,V)IB=0]=mE[d(U)]<
kam?-由于P|B=0l≤1,我们有：
E[d(U,V)|B=0]P{R=0}<kǒ? (5.26)
另一方面，如果译码失败(B=1),则在任何情况下 d(U,V)≤∑”。d[U](回顾
d(u)=maxid(u,v,):j=1,…,Mi),因此E[d(U,V)IB=1]≤mE[d(U)|B=1}。
但是E[d(U)IB=1]=”"E[d(U)IB=1,X=x,]·PiX=x:IR=1F;并且
由于随机变量U,X和B形成一个Markoy 链(因为译码器的成功或失败只依赖于传输的
码字X,而与对应 X的信源序列U无关),这就意味着 E「d(U)1
B=1]=△.:E[d(U)1X=x:]·PIX=x.IB=1。现在PiX=x,IB=1}=
P[B=11X=x:PlX=xi/P{B=1.但是根据式(5.23),对于所有的i,PIB=1IX=xl=
P<ε,因此，
P{B=1}E[d(U;V)|B=J]
me Ad(UIX=xJP(X=小
=mEE[dmx(U)]
=h(8-δi)见式(5.19)
(5.27)
结合式(5.25)、式(5.26)和式(5.27),我们得到了预期的=k1E[d(U,V)]<δ。
讨论；假设平均代价β是固定的(或者代价函数b(x)等于0,在这种情况下容量函数
C(3)是一个常数C,即信道容量),并研究如何权衡图5.1中通信系统的速率和平均失真
度δ,图5.4总结了信源-信道编码定理的结论。信源-信道编码定理的结论(a)是，对于任何
可靠的系统，一对(F,子)必须位于“可实现区域”,包括深黑色边界。结论(b)是，可实现区域中
的任何一点都是可以达到的，但不包括边界。一般情况下并不知道边界上的哪---点是可以达
到的，这是一个相当有意义的理论问题(见习题5.4)。但从实际角度来看并不重要，因
为如果一个通信工程师所设计系统的参数(F,ā)落在边界上，那么当然可以通过参数
(F.8(1+10-°))实现系统!
8=8
8 不可实现区域 F(DrR F-
图5.4 信源-信道编码定理的图示
·,, i 上：
92 信息论与编码理论(第二版)
习题
5.1 某个实验者希望设计一个通过二进制对称信道传输高斯随机过程观测值的系统。二进
-1 制对称信道每秒接收100000比特，其原始误比特概率为： 并且信道传输“0”是免费的，
而传输“1”需花费10??美元。为此他计划以每秒R个样点的速率进行采样(样本是均值
为0、方差为1的高斯随机变量),并在传输前进行编码。假设他可以容忍的平均均方误
差至多为8,而在信道上平均每天最多能花费B美元。下面三组(B,8,R)中哪一组在
理论上是可实现的?
B R δ
864 0.1 J2500
2592 0.2 150-000
4320 0.00L 11000
5.2 证明能够选取数值，80,81,C和R'满足式(5.11)至式(5.15)。
5.3 考虑一个每秒产生R比特的二进制对称信源，其输出通过一个“宽带”高斯信道传输。
以E表示比值PIR(它的单位是焦耳每比特，比值E/N?称为比特信噪比)。证明如果
采用图5.1中所描述的通信系统进行通信，只要E/N?>[1-H?(P.)]log2,最终的误比
特率就可以达到P,反之则不成立。但是如果码的速率r=h/n还必须满足≥r,证明
E,/N。的最小值是+22.1-B?(P)-1|/2r。
5.4 考虑将二进制对称信源的输出通过一个原始误比特率为p的二进制对称信道进行传
输：参见图5.4,证明边界上满足δ=P的每一点都是可实现的。(注意如果p=0,则这
部分边界是连续的。)
5.5 证明在信源-信遵编码定理的(b)部分中条件β>β不是必需的。
5.6 证明如果对于每个y∈AP,期望值E[d(U;v)]是有限的，则式(5.18)中所定义的信源编
码的D(C)是有限的。然后证明第4章中的高斯信源满足这一条件。
5.7(E.C.Poener)本习题说明了为实现信源-信道编码定理的结论而构造的“分解式”通信系
1心 统，可能存在缺陷。假设我们将二进制对称信源的输出通过一个原始误比特率为 的二
进制对称信道传输。(这里假设信道的使用是免费的。)进一步假设要求δ≤0.10,F≥
1.0.根据对定理5.1的证明，对此需要首先为BSS设计一个d(C)≈0.10的信源编码，
再为BSC设计一个适当的错误概率非常小的信道编码。证明存在一个更简单的系统，
能够达到希望的(δ,r)。
5.8 本习题的H的是证明，如果将高斯信源的输出通过高斯信道传输，有时候不需要任何缩
码，就可以实现信源-信道编码定理所给出的结论。为明确说明，考虑下面的图示：
第5章 信源-信道编码定理 93
九 Z
U- V
信源 停道 信宿
这里U是均值为0、方差为2的高斯随机变量，它通过一个设备(放大器)被乘以一个常
数λ:然后再加上一个均值为0、方差为σ2、并与U相互独立的商斯随机变量Z,最后的
结果通过一个设备(衰减器)被乘以常数μ。信道的输入X必须满足E(X2)≤β。
证明存在失真度6和常数λ,μ,使得：
(a)R(8)=Cβ)
(b)E[(U-V)2]=8
其中R(8)是信源的率失真函数，C(β)是信道的容量-代价函数。由此证明不等式
k/n≤C(β)/R(8)可在k=n=1时取到等号。
注释
1] 注意那些在传输数据流中破环性地增加或删除符号的信道不在我们讨论的范围中。
[2] 为了明确 C(β)和R(6)的定义，必须假设信道和信源是稳态的，即统计分布不依赖
于我们何时开始传输信源的输出或者何时开始使用信道。
3] 实际上，为证明不等式k/n≤C(β)/R(8),不一定要假设编码器和译码器是确定的
设备。所需要的只是编码器和泽码器能够保证(U,X,Y,V)形成一个Markov 链；例
如，一个编码器使X不仅依赖于U,也依赖于一些本地产生的随机变盘，这样的编码
器也是可以接受的。
[4] 我们在证明信源-信道编码定理时所用到的特殊结构(即将编码器和译码器分解为
信源和信道编码器以及信源和信道译码器)需要解释一下。有理由认为，独立地进
行信源和信道编码，最终得到的系统可能比需要的更复杂(例如见习题5.7和习
题5.8)。然而，从(F,8,)的角度来肴，却没有什么损失，因为如果这三个参数能以
任何方式达到，就也能通过一个分解的系统达到。
乐；～1于，
第6章 第一部分前沿课题综述
6.1 引盲
本章将对前文中未做详细介绍的信息理论中的一些重要结论进行简单地总结。这里不提
供详细证明，但向感兴趣的读者推荐了一些参考文献，通常是一本教科书，有时也可能是原
论文，
我们主要讲述信息理论中两个最重要的定理，即香农信道编码定理(定理2.4及它的推
论)和信源编码定理(定理3.4)的深入研究。下面分两节讨论这两个定理。
6.2 信道编码定理
作为参考我们重述这个定理(见定理2.4的推论)。
对应每个离散无记忆信道，存在一个具有下述性质的非负数值 C(称为信道容量)。对于
任意ε>0和R<C,以及足够大的n值，存在一个码长为 n,并且速率≥R的码(即至少包含
2"个不同的码字),以及相应的译码算法，使该码在给定信道中传楠时，译码蜡误概率<e。
现在要仔细研究一下这个定理的表述，并指出哪些假设可以削弱，或者哪些结论可以增
强。注意“离散无记忆信道”、“一个非负的数值C"、“足够大的n值”以及“存在一个码……译
码算法”这些措辞。我们还将简单讨论一下这个编码定理的不同逆定理。
●离散无记忆信道：这个定理也适用于许多其他类型的信道。其中最简单的例子是信道
的输入符号集Ax和输出符号集Ap都等于一个有限的阿贝尔(abelian)群A,并且信道的第i个
输出Y,与第i个输人X,之间具有如下关系：
Y;=Xi+Z;
这里Z.Z?,…取值于群A,并形成一个各态历经的随机过程。信道容量可以定义为：
C=sup(mx(x;v) (6.1)
其中括号内部的求极大值是对所有取值于A"的n维随机变量X进行的，而随机矢量Y=
(Y?,…,Ya)是与输人X对应的信道输出，即Y=X+Z,其中Z=(Z,,…,Z)代表噪声过程的
前》个分量、容易证明当X均匀分布于A"时，括号内的求极值项达到极大值，并且由于
I(X;Y)=H(Y)-H(Z)(见习题1.13),
C=logg-ineH(Zj,Z?,…,Z.)
其中q表示A中元素的个数。因此得出：
第6章 第一部分前沿课题练述 95
eH(Z,,Z)=mHz,…,ZJ)=Ho
这个值被称为过程Z,Z?,…的熵。
现在可以按照证明定理2.4的线索，来证明加性各态历经噪声信道的编码定理。惟一的
困难是，证明对于任意E>0,如果n值足够大，概率
{ I(x》-c}
趋近于0。幸运的是，根据McMillan的渐近均衡性定理，对于任意e>0,如果n值足够大，概率
结Ha,2)-Ro>e}
趋近于0。因此I(x:y)=nlogq-H(z…,z),这正是所需要的结论。
编码定理也适用于许多有记忆的离散信道；详细内容请参考Gallager[17]或者 Wolfowitz
[27]。
有关第4章的高斯信道可做如下归纳。设A=Ay=实数，并设Y=X,+Z,其中的Z?
Z?,…现在是实数值随机过程，并且可能还有一些输人约束条件。对于这类信道，当Z是独
立的(即信道是无记忆的，但并非离散),或者当Z,形成一个高斯过程时，编码定理最适用；参
考Gallager[17]的第7章和第8章。
到目前为止，我们讨论过的全部信道都具有这样的特点，即单一的信息流向同一个方向流
动。但是编码定理的一些最令人感兴趣的推广却是针对多终端信道的。其中最早的结论由香
农本人提出，是关于有反馈信道的，即对应信道输入x的输出y:又返回到信道的输人端。香
农(见文献[25],119~120页)对此得出了惊人的结论：离散无记忆信道的加性反馈不能改变它
的容量。它只会使通信速率更早地低于容量(见文献[25],373~436页的8篇论文，也可参见
习题2.20)。
具有反馈的信道仍然只是一个单输人、单输出信道。前不久，刚刚得出一些有关多输出或
多输人信道的令人瞩目的结论。例如考虑下面所谓的多接入信道的例子。这里有两个发送者
和一个接收者。信道是无记忆的，并且单位时间内允许每个发送者从[0,1}中选出一个符号送
到信道中。如果将两个输人表示为x?+x?,相应的输出y∈10,1,?|由下表给出：
1 2 J
D 0 0
0 I ?
上 0 !
1 I 1
(这里“?”表示一个特定的制除符号。)该信道实质上是一个具有四种输人符号和三种输出符号
的无噪声信道，它的容量是 log3。但是如果两个发送者试图同时在信道中传输独立的信息流，
他们将相互干扰。因此一个重要的问题是：对于给定的一对速率(R?,R?),是否有可能发送者I
摇.I
96 信息论与编码理论(第二版)
找到一个速率为R,的码，发送者2找到一个速率为R?的码，而接收者也找到了一个译码规
则，便他能够以尽可能小的错误概率，同时译出两个消息?回答"是"的充分必要条件是点
(R?,R?)位于信道的容量区域，本例中信道的容量区域如图6.1所示。
log 2
1g2
R
zlog2 kaig2
R?_
图6.1 一个简单多接人信道的容量区城
对于更一般的无记忆双输人、单输出信道，情况本质上是相同的。在坐标系的第一象限有
一个同样被称为容量区域的凸状区域，对应该区域的任意一对速率，可以实现可靠通信。类似
地，广播信道具有一个输人和多个输出(通常是两个)。可以证明它也存在容量区域(有关多终
端信道更详细的介绍，请参考Wymer[49])。
●一个非负的数值C。即使是计算第2章中离散无记忆信道的信道容量，也可能非常困
难，除非信道具有高度的对称性、回顾C的计算公式
C=max (X;Y)
该式是对所有(一维)试验信源X求极大值，即需要考虑信道输人符号集Aγ的所有可能概率
分布。这个变分问题虽然并不简单，但在某种程度上可能比它第一次出现时要容易一些，因为
(X;Y)是X的上凸∩函数，由此可知任意局部极大值也就是全局极大值。以这个事实为起
点，Gallager[17]中有两节是专门讨论 DMC容量计算的。最近，Arinoto[29]和 Blahn[32]给出了
计算C的高效数值程序。
如果信道不是离散无记忆的，计算容量通常更加困难，因为一般情况下，定义(5.2)式甚至
是无效的。对于加性各态历经噪声信道，如我们所看到的，计算 C等同于计算噪声的熵。如
果噪声是Markov 过程，可以很容易计算出它的熵(见习题1.20),但是一般而言，我们对噪声了
解得并不多。至于计算多终端信道的容量区域问题，本书实质上并未涉及。
●足够大的n值。对于离散无记忆信道，译码错误概率e、速率R,以及码的最小码长 n
之间的关系问题，一直以来都是需要深人研究的课题：
简单地说，对于任意0≤R<C,码长为n、速率为R的最佳码的译码错误概率近似为：
PE≈2-nEIR)
其中信道的可靠指数E(R)是R的下凹U函数，其曲线类似于图6.2。如果要更精确地表示，
就用P(R,n)表示码长为n、速率≥R的最佳码的译码错误概率，并定义：
E(r)= lim-ogPE(R,m)
[事实上，没有人证明过这个极限存在，但是在下面的讨论中，我们将忽略这个技术问题，认为
:s
第6章 第一部分前沿课题综述 97
E(r)的上界实质上就是E(R)=lim sup-n-'logP(R,n)的上界。]尽管并不知道一般 DMC的
E(R)精确表示，但E(R)存在极好的上界和下界，通常如图6.3所示。因此存在一个“临界速
率"R,大于它时 E(R)的上界和下界重合，但当0<R<R时，二者之间存在着缝隙、例如，
考虑一个原始错误概率p=0.01的BSC。图6.4中画出了已知的最佳E(R)上界和下界。(注
意图6.4中下界下面的直线。它对应R,编码定理，见习题2.21至习题2.26c)
-E(R)的上界
E(R) ER)
C E(R)的下界 Rral C
R- R-
图6.2 DMC可靠指数的近似曲线 图6.3 E(R)已知界的近似曲线
1.6
14
12
10
ERXbase2)08
06
04
02
0
a 01 02 03 04 03
R— 86 Ro C
图6.4 BSC(p=0.01)的E(R)已知最佳界的近
似曲线(选自McEliece和Omura[40])
●存在一个码……译码算法。信道编码定理最不能令人满意的地方，是它的不可构造性。
这个定理断言存在好的码，但是既没有说明如何去导找，也没有说明如何去利用它们。在某种
程度上，可以将我们称之为“编码理论”(本书第二部分的主要内容)的学科，看做是在寻找一种
可设计和可应用的信道编码定理。但是目前已知的任何具体编码方式，都不能以非常接近信
道容量的速率达到极小的错误概率。换言之，编码理论学家一直以来都是以牺牲编码定理的
“对于所有R<C,P?→0”的结论来实现设计的。面对于信息理论学家来说，这一结论是神圣
的，并为维护这一结论做了许多努力，同时也强化了结论中“存在一个码和相应的译码算法”部
分。下面将介绍一些这方面的成就。
·,拙K
98 信息论与编码理论(第二版)
首先，我们可以将注意力集中于相对较小的一类码，并证明编码定理成立。例如，从编码
定理的角度来看，线性码(见第7章)类中的某些码的性能非常好(例如，可参见Gallager[17].
6.2节).因为很容易实现线性码的编码，这表明性能好的码，其编码算法并不一定非常复杂。
另外已经证明编码定理同样适用于时变卷积码；见Massey[21],第6节和第7节。但是目前对
这两类码都没有实用的译码算法：
我们所说的“实用”算法究竟是什么含义?这里采用一种广泛被计算机科学家接受的观点
(例如，可参见Aho,Hupcmof和Ullrcan[1],第10章),假设某种算法有n个输入，其运行时间和
存储需求都可以用n的某个多项式表示，那么它就足“实用”的。如果我们接受这种观点，由
Fomey(参见文献[25],90-95页)给出的下述结论，无疑是一个“实用”的编码定理：
对于任意R<C,存在一承列码C?,C?,…(码C。的码长为n),每个码的速率都≥R,并
满足：
(a)PE,<2-((这里Pe..是第n个码的错误概率，而Be(R)是R的单调下降函数，并
且对于所有的R<C,它的值都大于0)。
(b)G。的编码和译码复杂度为0(n?)。
Fomey证明中的核心思想是级联，即将信道编码器和信道译码器以某种方式进行分解。
考虑一个给定信道的普通编码器和译码器：
u- 编码 一X· 信道 Y 译码器 -v
这里V=(V,,…,V?)是对U=(U?,…,U)的一个估计，它一般等于U,当然并不总是如此。
换一种说法，V是U的--个噪声样本，因此可以将上图中的“编码器-信道-译码器”看做一
种“超级信道”或者外部信道。我们为这个外部信道设计…种码，并得到如图6.5所示的方框
图。通过随机地选择内码，而选择一种特定的外码(一种Reed-Solomnon码；见第9章),Fomey证
明了上述的低复杂度编码定理。
外部
编码器
内部
编码器
图6.5 一个级联的编码系统
Fomey的结论极大地缩小了信息理论(证明应该能够达到)和编码理论(证明实际可以实
现)之间的差距。但是Fomey 的定理只说明了“实用性”,仍然没有解决“设计”问题，因为它并
没有告诉我们如何去寻找相应的内码。所以对于给定的R<C,如何寻找一系列可构造、可实
现的码，满足Pg按指数趋近于0的问题，仍然有待于进一步研究。如果有人能够提出这样一
个定理，就可以将信息理论和编码理论的研究课题结合起来(甚至可能将两者淘汰出局)。
●编码定理的逆定理。习惯上将编码定理的逆定理分类为“弱逆定理”和“强逆定理”,但
是这种命名方式可能会产生误导，因为强逆定理并不包含弱逆定理。
我们在前面已经见过弱逆定理。它说明如果试图将一个二进制对称信源的输出，以超过
信道容量的速率在信道中传输，最终的误比特率不会趋近于0。而信源-信道编码定理5.1告
信道 内部
译码器
外部
译码器
第6章 第一部分前沿课题综述 99
诉我们，如果采用图5.1所示的通信系统模型，则必须满足不等式k/n≤C/R(8)[假设信道没
有输人代价约束，而二进制对称信源的R(&)=1-H?(8)比特]。比率k/n 是传输速率的度
量；显然如果k/n超过C,则R(&)<1,迫使误比特率δ不等于0。这个结论的证明只依赖于
信道容量的互信息量形式的定义[见式(6.1)],因而也适用于一般的信道。
强逆定理更适合于作为前而所述的编码定理的逆定理，该编码定理说明，对于R<C,码
长为n、速率为R的最佳码，其错误概率随着n→而趋近于0。而强逆定理说明，如果R>
C,最佳码的错误概率随着n→∞而趋近于1。(见Viterbi和Omura[26],第3章。)目前强逆定
理的最强形式表明，P,指数地趋近于1,即
PE≥-2-nEA(R),R>C
其中E(R)是Arimolo错误指数，它的一般曲线如图6.6所示。
对于原始错误概率p=0.1的BSC这种特殊情况，图6.7中给出了E(R)的精确曲线。
斜率为」
的直线
E,(Rl
R— C
图6.6 Arimoto 指数E?(R)的一般曲线
05 .9
04 .I
0.3 .9
E(R) 0.2
01
o 01 02 03 04 05c06 07 0.8 09 10 11 12
R-
图6.7 p=0.1的BSC的E(R)
6.3 信源编码定理
这一节将采用与6.2节基本相同的结构。不过首先应该提醒读者，尽管我们强调了信道
编码与信源编码之间的高度相似性(或者对偶性),但广义上来讲，对信源编码或率失真函数理
论的研究更为困难，因此目前该方向的研究相对落后。
作为参考，我们现在重述信源编码定理3.4。
临1 1
100 信息论与编码理论(第二版)
对应任意离散无记忆信源和单个符号失真测度，存在一个定义城为8≥8的非负、下凹
U减函数R(8),具有下述性质。对于任意e>0和8≥8mi,以及足够大的k值，存在一个码长
为k的信源编码，至多包括28]+个码字，并且平均失真<8+E。
下面我们将研究该定理的表述，注意“离散无记忆信源”、“一个函数R(8)”、“对于足够大
的k值”,以及“存在一个信源编码”这些措辞。并会简单讨论一下信源编码定理的逆定理。
●离散无记忆信源。对信源编码定理而言，其最自然的扩展方式是证明除了离散无记忆
信源以外，它还适用于更广泛类型的信源。按照这种思路，已经证明了该定理适用于大量的信
源。事实上，人们已经研究过任何一种可以被模拟为平稳随机过程…x,x,x?,x?,…的信
源。但遗憾的是，只能计算出一小部分信源模型的有效率失真函数R(8)(见Berger[13])。
在6.2节中已经看到，目前我们对于某些多终端信道的容量区域已经了解了很多。而对
于多用户的信源编码却知之甚少，但是有一个结论值得一提，这就是有关相关信源无噪声编码
的Slepian-Wolf定理。为介绍 Slepian-Wolf定理，必须先介绍一下信源编码定理的一个重要应
用(顺便提一句，这也是第11章的全部内容)。
设X?,x?,…是由取值于集合A的独立、同分布随机变量组成的序列。将这个序列看做
一个对应汉明失真函数的信息源，即信宿符号集也是A,并定义：如果x≠y,则d(x,y)=1;如
果x=y,则d(x,y)=0。正如我们在前面所看到的，此时R(0)的值等于信源的熵 H(X)。因
此对于这种特殊情况，信源编码定理的含义是，对于任意e>0和R>H(X),以及足够大的k
值，存在一个码长为k的信源编码，它至多包括2个码字，并且平均误差<e。换一种说法就
是，无失真地表示信源的每个采样点，实质上只需要H(X)比特。这当然是信源编码定理的一
个简单结论，而在第11章中我们将具体介绍所谓的无嗓声编码技术。
现在来介绍 Slepian和Wolf的结论。设(X,,Y,),i=1,2,3,…是由独立、同分布的离散随
机变量对组成的序列，它们具有相同的分布函数p(x,y),以及相同的熵H(X),H(X,Y)和
H(XIY)等。问题是如何寻找X和Y序列的独立信源编码，使最终的失真可以忽略不计。这里
以图6.8所示的系统为例：将矢量X编码为码宇f(X),它可以是M中的任何一个值。同样
假设g(Y)是My中的任何一个值。定义迷率为：
Rx=logMx
和
R=klogMr
而错误概率是：
PE=P{X≠XorY≠Y}
当且仅当对于任意e>0,存在如图6.8所示的一个系统，满足Pe<e,才称一对速率(Rx,Ry)
是容许的。Slepian和Wolf(参见文献[25],450~457页)证明了容许速率的集合如图6.9所示。
Slepian-Wolf定理的意义也许并不显著。但是如果将图6.8中的编码器合并为一个，就简
化为研究具有熵H(X,Y)的独立随机矢量序列的无失真编码问题，因此容许区域是以直线
2il
第6章 第一部分前沿课题综述 101
Rx+Ry=H(X,Y)为边界的半平面。如果再考虑将编码器分开，容许区域的面积并不会增
加，因此S.-W,容许区域应该全部位于这条直线上方。另外，如果假设译码器已知Y,则有关
X的不确定量变为H(XIY),因此容许区域内的每一点都需满足Rx≥H(XIY),类似地
Ry≥H(YIX)。可见容许区域必然是图6.9所示区域的一个子集。一个重要的结论是它就是
最大子集。
8众-盒 X=(xj….Y) X) X-编码器
,…众F Y={Y?….K) Y-编码舂 g(X)
图6.8 Skepian-Wolf定理的方框图
wZ
1
Hx,n
An 客许
区域
H(Yu)
译码器
W-Z.区域[
o H(X1Y) HX) HX.Y
Rxr----
36.9 容许速率的集合
最近，Wyner和Ziv[50]研究了当速率Rx和Ry位于图6.9中标明的“W.-Z.区城”内时，
图6.8所示系统的最佳性能。在W.-Z.I区域内，由于Rx≥H(X),X可以被精确再生。但是
此时R<H(YIX),在接收Y时不可避免地将产生失真。Wyner和Ziv确定了可能的最小失
真度。
Slepian-Wolf和Wymer-Ziv的结论预示了率失真理论在多用户领域的深入发展。
●一个函数R(8)。我们已经在第3章中看到，除非具有大量的对称性，否则即使是计算
离散无记忆信源的率失真函数R(8)也相当困难。但是Blahut[32](也见 Viterbi和Cmura[26],
附录7A)发现了一种计算R(8)数值的快速收敛算法，因此目前普遍认为计算此类信源R(δ)
的问题已经解决。
不过对于更一般的信源和失真测度，计算 R(O)的问题更为困难。现在已知R(8)简单公
式的最著名的一类信源，可能就是对应均方误差测度的离散时问稳态高斯信源。此类信源的
模型是由随机变量…,X_i,Xo,xX?,,X?,…组成的平稳高斯序列。率失真函数R(8)是通过参
变量的形式给出的：
·..
102 信息论与编码理论(第二版)
(0)=min(,S(c)da
R(e)=4max(0.log)do
其中S(w)是过程的谱密度，而θ取值于区间[0,esB,sup S(ao)]:如果X,是具有相同方差o2
的独立随机变量，则对于所有的心，有S(m)=c2,因而定理简化为8(8)=θ,R(0)=2loge210,
0≤θ≤o2,即定理4.4。Berger[13]的第4章中给出了相应的证明和几个例题。
这里并不知道大多数有记忆信源的有效R(8)公式。[实质上由式(5.4)总能给出一个公
式，但并不定有效。]例如，我们显然还不知道哪些有记忆离散信源的R(6)可以精确求解。
但是有很多方法可以定出R(B)的界，这里再一次向有兴趣的读者推荐 Berger[13]。
●对于足够大的k值。在6.2节中已经看到，DMC的信道错误概率可以随着分组长度的
增加而指数地趋近于0。对于信源编码定埋而言，类似的问题是：码长为无、速率≥R(8)的最
佳信源编码，它的失真度是如何趋近于δ的?在这方面Pile[43](也见 Gallager[17],9.3节)证
明了对于 DMS,如果用d(h)表示一个码长为无、速率≥R(8)的信源编码的最小平均失真，
则，
(t)=6+0(R)
可见d(k)趋近于δ的速度远低于Pe趋近于0的速度。
●存在一个信源编码。信源编码定理面临着与信道编码定理相同的问题，就是它的非构
造性。人们为了寻找一类满足信源编码定理并且易于应用的信源编码，已经做了大量的研究
工作，得出了如下形式的信源编码定理：“对于任意e>0和δ≥8,存在T类信源编码，满足
速率≤R(8)+E,并且平均失真≤δ+E。”并证明当T类码是线性码的集合(见第7章)或树状
码的集合(见第10章)时，该定理成立。细节请参考 Berger[13]第6章或 Viterbi和Omura[26]
第7章。本书第12章还将进一步介绍某些特定线性和树状信源编码的性能。
●逆定理。事实上信源编码定理只有一类逆定理，我们已经见过它的变换形式。前面并
没有详细叙述该定理，因为当时我们更关心的是，研究信源输出在给定信道中传输时，信源编
码定理的应用情况。下面将要完整叙述的结论，实质上是信源-信道编码定理5.1结论(a)的
一种特殊形式，此时信道是无噪声的。信源编码定理的逆定理表述如下：
如果信源编码的平均失真≤8,它的迷率必然≥R(8)。
为了证明这个定理，设给定码的码长为k,并定义它为Iv,Q?,…,vul。考虑图6.10中的
方框图，其中信源编码器将每个信源序列a=(u?,…,u)映射为一个码字v,,使得 d(u,v:)尽
可能地小。现在由于码的平均失真度≤8,我们有E[d(U;V)]≤甜，因此[见式(3.3)和
式(5,10)]7(U;V)≥R(8)≥kR(8)。但同时K(U;V)≤H(V)≤logM,故，
ogM≥Ro)
由于(1/h)logM被定义为码的速率，这就完成了该定理的证明。
■
第6章 第一部分前沿课题综述 103
注意这个定理的证明只利用了R(o)是(1/k)R(8)的下确界这个基本定义，以及互信息
量和熵的一些基本性质。因此信源编码定理的逆定理本质上适用于任何信源和失真测度。一
个重要的事实是，我们也可以证明信源编码定理适用于非常普遍的情况。
U=,…) 信源编码器 1·LrX
图6.10 信源编码定理逆定理的证明
:
第二部分 编码理论
第7章 线性码
第8章 循环码
第9章 BCH、Reed-Solomon 码及其同类码
第10章 卷积码
第11章 变长信源编码
第12章 第二部分前沿课题综述
i:
………………t…………………………… 邪
第7章 线 性 码
7.1 引言：生成和一致校验矩阵
我们已经注意到，从实际应用的角度来看，信道编码定理2.4是不能令人满意的。因为该
定理证明存在的码至少有三个明显的缺陷1:
(a)很难找到它们。(虽然从定理2.4的证明中可以看出，如果码长足够长，"随机"选择
码的性能可能较好。)
(b)很难分析它们。(给定一个码，怎样了解它的性能呢?最初就是因为无法计算一个特
定码的错误概率，才采用了随机编码的技巧1)
(c)很难实现它们。(特别是很难实现译码：定理2.4建议的译码方法----例如寻找码字
的S(y)区域等——复杂得令人望而生畏，除非码很小。)
实际上，到目前为止我们遇到的惟—一种没有这些缺陷的缩码方案，就是引言中介绍的
(7,4)汉明码。本章指出汉明码是很大--类码中的一种，这类码被称为线性码[2,在第7章至
第9章我们将看到，某些性能非常好的线性码并没有前文提到的三个缺陷。
现在试图寻找这样的一类码，从编码定理的意义上来讲性能要好，同时又要比较容易实
现，因此这就要求这类码具有某种结构。为此我们的第一步是使信道输人符号集Ax具有某
种结构：从现在开始，假设Ax=包含q个元素的一个有限域F{3。(附录C介绍了有限域的基
本概念。)在这个假设的基础上，我们注意到可以将一个码长为n的码字x=(x?…,x)看做
是F,上的一个n维矢量。
定义4 F,上的一个(n,t)线性码，是n维矢量空间V(F。)=|(x?,…,x):x?∈F,}的
一个台维子空间；n称为码的长度，k称为维数。码的速率是比值k/n。
线性码对比非线性码的一个主要优点是，它们更容易定义。一个(n,k)线性码C可以完
全由任意一组k个线性无关的码字x?,?,…,x来描述，因为C巾的每个码字都是q个线性
组合∑..,a,x,(a;EF,)中的一个。如果将这一组码字排列成一个kxn维的矩阵C,则C称
为C的生成矩阵：更普遍的是：
定义 令C是F,上的一个(n,k)线性码。一个行空间等于C的无×n阶矩阵G称为C
的生成矩阵。相反，如果G是元素取自F,的一个矩阵，则它的行空间称为由G生成
的码。
通过指定一个生成矩阵，就完整地描述了某些有意义的码。本章中将反复利用下面的三
个例子(它们都取q=2;即是二进制码)来说明问题。
x:
108 信息论与编码理论(第二版)
例7.1 一个(5,1)线性码C,具有生成矩阵：
G=[11111]
例7.2 一个(5,3)线性码C?,具有生成矩阵：
c-98
例7.3一个(7,4)线性码C,具有生成矩阵：
[C?仅含有两个码字00000和11111;它就是引言中讨论的速率为1/5的重复码。C?是引言中
的(7,4)汉明码。C?是一种新的码型。]
线性码的另一个优点是编码易于实现。一个(n,e)线性码有q个码字，因此可以用于传输
种不同信息中的任意一种。如果假设这些信息是(表示为)q个k维u=(uj,uz,…,)∈V(F),
并且G中各行是线性无关的，则将信息a映射为码宇x的一个非常简单的编码规则是：
→uG (7.1)
在式(7.1)中uG表示1×k维矢量u与k×n阶矩阵G的乘积。例如，利用C?的生成矩阵
G?,映射(7.1)式变为：
(1,uz,u3)(M?+My,ü+,M+42+u,z2+,urg)
利用下面的性质，通常可以进一步简化映射(7.1)式，即如果G是C的生成矩阵，则任意
与G行等价的矩阵也是C的生成矩阵。我们知道任意矩阵都行等价于一个行递减阶梯
(RRE)炬阵，因此任意线性码都具有惟一的一个RRE生成矩阵。为了“刷新”读者的记忆，下
面给出域F上RRF.矩阵的三个性质：
(a)每行最左边的非零元素是1。
(b)每个包含这样…个最左1元素的列中的其他元素都为0。
(c)如果第i行的最左非零元素出现在第；列上，则：1<t?…<1,
可见生成矩阵G?和C?已经是RRE形式了，而G?则不是。实际上C?的惟一 RRE生成
矩阵为：
-
为了清楚起见，我们用圆圈标明了每行的最左1元素。用G?代替C?,C?的编码[利用
式(7.1)]变为：
(M1,2,u3)→(,u;MI+42+W3)
C?的编码具有我们希望的特点，就是信息符号山，u?,u?独立地出现在码字中；一般来讲，如
第7章 线 性 码 109
果G中第i行的最左元素出现在第；列，则符号u将作为码字x=0G中的第：,个元素出现。
无论是线性码还是非线性码，如果具有这样的性质，即存在一个编码规则，使信息符号独立地
出现在码字中，就称它是系统的。因此也就证明了所有线性码都是系统的。
注意C?和C?的RRE生成矩阵具有G=[JA]形式，其中I是h×k阶单位矩阵。显然
并不是每个线性码都具有这一性质(例如C?);但如果这个码用于无记忆信道，则对G进行列
置换并不会改变码的性能，因此在这种情况下总可以假设G=[IA]。例如，通过将G的列
按照(13245)的顺序重新排序，我们得到：
-
在任意无记忆信道上，它所生成的码的性能与C?是相同的。
以上介绍的是生成矩阵。另外对应每个线性码，都存在一个也许更有价值的矩阵，我们称
之为一致校验矩阵，现在就来介绍它。
如果C是F,上的一个(n,k)线性码，则C的一致校验6是一个具有下面形式的等式：
(7.2) axi+a2x2+…+anXn=0
它对所有的x=(x?,x?,…,x)∈C都成立。对干任意x∈C,使式(7.2)成立的所有矢量a=
(a,,…,a)的集合，本身也是V.(F?)的一个子集。将它记做c(C的“正交”),并称之为C
的对偶码。根据线性代数中的有关结论，C一的维数是n-din(C),即C广是F,上的一个(n,
n-t)线性码。现在定义C的一个一致校验矩阵为C的一个生成矩阵。更直接地：
定义 令C是F,上的一个(n,k)线性码。如果当且仅当x∈C时，矩阵H具有性质Hx3=0,
则称矩阵H为码C的一致校验矩阵。
根据前面的讨论，显然每个(n,k)码都存在惟一的(n-后)×n阶RHE一致校验矩阵。但
是更常见的是，采用一种略有不同的规范形式来表示H。例如，如果G=[7A],则可以将H
写做：
H=[-A'I-k] (7.3)
如果G不具有这种形式，则可先通过列置换将G变换为[ IA]形式，然后再对[-A'.]进行
逆置换而得到Hl。
例如，通过这种方法，由G?,G?和G?生成的一致校验矩阵是：
m-
m=
注意当H具有这种形式时，C中码字的定义式Hx?=0给出了信息符号和冗余或一致校验符
号之间的明确函数关系。例如，在C?中，x,是信息符号，而xz=xy=x=xg=x。类似地，在
·::热
110 信息论与编码理论(第二版)
C?中，x?,xs,x4是信息符号，而x?=x?、xs=x?+x?+xa。最后，在C,中，一致校验比特 x?,
x?,x,与信息比特x?,x?,xg,xa之间的关系为xs=32+x?+4,x=xi+x?+x?,x?=
x?+x?+x[见式(0.6)]。当然信息符号的位置不是惟一的，见习题7.13:
现在利用下面的定理总结一下本节的主要内容。
定理7.1 今C是F。上的一个(n,k)线性码，则存在惟一的一个k×n阶RRE矩阵C,
满足x∈C,当且仅当x在G的行空间内。另外，存在一个(n-k)×n阶矩阵H,满足 x∈
C当且仅当Hx?=0。如果码C被用于一个无记忆信道，则不失一般性，可以假设存在一
个k×(n-h)阶矩阵A,使得：
G=[IA]. H=[-A'I-k]
在这种情况下，矢量u∈V?(Fq)的编码由→(n,uA)给出。
7.2 q进制对称信道上的伴随式译码
到目前为止，我们对于线性码的讨论还没有涉及信道输出符号集Ay或者信道特性。但是从
现在开始，可以假定Ay=F,,即输人和输出符号集是相同的。(参见习题7.11和习题7.20。)
因此如果传输的是x=(x?,…,xa)∈Va(F,),则接收矢量y=(y?,…y。)也将属于V.(F);二
者的差值z=y-x称为错误图案。如果2≠0,我们就称在第；个位置上出现了一个错误。
在这种情况下，7.1节引入的一致校验矩阵H被证明是译码的一个有效工具。假设传输
的是x,因为x是一个码字，满足Hx'=0。如果信道引起了一些错误，即如果z≠0,则很可能
Hy?+0。矢量s=Hy*称为y的伴随式9。伴随式的最重要特征是，它只依赖于错误图案z
而不依赖于所传输的码字，因为Hx3=0,即：
s=Hyt
= H(x+z)
=Hx?+HeI
=Hz
当然接收方对z并不感兴趣：他想知道的是x。但是既然他已经知道 y,而x=y-z,因此就可
以专注于寻找z。
伴随式提供了z的一些信息，但是并不充分。这是因为对一个固定的s∈V._.(F,),方程
Hz?=s的解的集合形成了码C的一个陪集0],即一个具有如下形式的V?(F,)的子集：
C+zo={x+Za:x∈C} (7.4)
对应于q"*个可能的伴随式s,码C一共有q-个陪集；每个陪集包含g个元素。因此一口
接收方计算出s,就可以将对z的搜寻范围从g°种可能降低到q种可能，即搜寻范围是与s相
对应的陪集元素。
然而，为了区分z的q个候选者，有必要了解更多关于信道的知识。在本节中假设信道
是q进制对称信道(qSC),即如果X是表示信道输人的随机矢量，Y是表示信道输出的随机矢
量，则Y=X+2,其中Z=(Z?,Z?,…,Z.)是一个随机矢量，它的分量是独立、同分布的随机变
第7章 线 性 码 1t1
量，具有相同的分布：
P{Z=0}=1-(g-1)e
P{Z=z}=e,如果z≠0 (7.5)
对于这个信道，很容易区分互相竞争的错误图案，因为如果z∈V(F?),则，
P{Z=z}=[1-(q-1)e]"-Wn(z1ewnz (7.6)
其中w(z)为z的汉明重量，被定义为z中非零分量的个数。或者说，w(z)是z中出现错误
的个数。如果e≤1/g,式(7.6)等号右边就是wg(z)的减函数，因此最有可能的z就是具有最
小重量的z.[对于1/q<E<1/(g-1)的情况，见习题7.3.]
图7.1说明了伴随式译码器的工作原理，至少在理论上是这样的。当然，这个算法中的步
骤2工作量巨大；实际上第8章和第9章的主要目的就是针对q进制对称信道设计一些线性
码，使得步骤2易于处理。当然，如果k和n-k的值都相对较小，就可以通过“查表”的方法
实现步骤2,我们现在就来介绍这种方法。
1.计算伴随式sxHy。
2.在对应于B的陪集中找出最小重量矢量，称它为z。
3.输出码字=y-为
图7.1 q进制对称信道的伴随式译码算法
再一次考虑码C?,前面给出它的一致校验矩阵为：
H=[1!91
在这个简单的例子中只有四个可能的伴随式：00,01,10,11。可以将32个矢量z=(z?,Z?,z,
Zs)依照它们的伴随式进行分类，并如图7.2所示，将它们排列在一个4×8阶矩阵中，矩阵
的元素都属于 V?(F?),这样的排列称为标准阵列。标准阵列的行是C的陪集；例如，第一行
就是码本身。在每个陪集中具有最小重量的一个矢量被列在最前面，称为陪集首。一般说来，
除码本身以外，陪集中的每个元素等于它的陪集首加上写在它上面的那个码宇。例如第三行
的元素01101等于它的陪集首01000加上码字00101。注意在这个例子中，伴随式01有三个候
选的陪集首(三个斜体的重量为1的矢量),而在其他的三个陪集中没有出现这种情况。
伴随式 陪集首
00 0000 000H 0010 00LEO 110G 11010 11100 111
01 00100 00111 00001 00010 1110L 11110 J1000 11011
10 or000 01011 01101 01110 10001 10010 1010010111
11 20000 10011 10101 10110 01001 01010 O1100 Q111
图7.2 C?的标准阵列
给出标准阵列后，就很容易实现图7.1中译码算法的步骤2:在传输前先建立一个表，它包
含所有的(s,z(s))对，其中s是q个可能伴随式中的一个，面z(s)是伴随式s的陪集首。这
■
112 信息论与编码理论(第二版)
样步骤2就简化为：
2'.令= z(s)
如果这种方法是可行的(即对应于q"个伴随式中的每一个伴随式，如果能够预先计算和存
储它的陪集首),那么相应的泽码算法就是已知最快的一种译码算法。
7.3 汉明几何和码的性能
如果定义两个矢量x与y之间的汉明距离如下，矢量空问V.(F)就可以变为度量空间：
dH(x,y)=分量x?≠y的个数
=WA(y-x)
(这个距离满足一个度量所需要的基本性质；见习题7.4。)码的汉明几何与它在q进制对称信
道上的纠错能力之间存在若有趣的关系，现在就来研究一下。
令C=|x,,?,…,x!是一个码长为n的码，但不一定是线性的，将它用于q进制对称信
道上。假设希望 C能够纠正汉明重屋≤e的所有错误图案；即如果发送x,,接收到y=x+z,
且 wa(2)≤e,我们希望译码器的输出是X=x。容易看出如果每个码字以1/M的概率等概发
送，那么接收方猜测发送码字的最佳策略是选出与y距离最近的那个码字，即可以使dg(x:,y)
最小的那个码字(见习题2.13)。[注意：因为dg(x,,y)=we(z),图7.1描述的线性码伴随式
译码方法等价于“寻找距离最近的码宇”译码方法。]显然如果采用这种几何译码策略，则码能
够纠正所有重量≤e的错误图案的充分必要条件是，每一对码字之间的距离都≥2e+1。因为
[见图7.3(a)]如果da(x,,x,)≥2e+1,即围绕x,与x,的半径为e的汉明球体是不相交的，并
且发送x,而da(x,,y)≤e,则y与x,的距离不可能小于它与x的距离，所以几何译码器会选
择x,而不是x,。相反，如果 dη(x,,x,)≤2e,即如果半径为e的汉明球体相交[见图7.3(b)],
那么很显然，如果发送x,,则存在一个y满足 dn(x,,y)≤e,它与x,的距离至少等于它与x:的
距离。由此我们定义码C的最小距离为：
dmi(C)=min{d?(x,x'):x,x1∈C,x≠x'}
而且证明了下面的定理。
x ·1 8, & 大· &
{B) (b)
图7.3 围绕相邻码字的半径为e的汉明球体
定理7.2 码C=ix.x?,…,xg能够纠正所有重量≤e的错误图案，当且仅当d_(C)≥
2e+ 1。
例如，一个dm=7的码能够纠正所有重量≤3的错误图案；如果d=22,则能够纠正所
有重量≤10的图案；等等。
第7章 线 性 码 113
现在将这些对任何码都适用的通用结论，应用于线性码这种特殊情况。首先观察到，因为
dg(x,x')=un(x-x'),又因为如果C是线性码(且x≠x'),则x-x'一定是C的一个(非零)码
字，所以线性码的最小距离与它的最小重量 w(C)相等，其中，
Wmn(C)=min{wH(x):x∈C,x≠0}
因此，要计算(n,k)线性码的d,不必计算(q2-g2)2个距离dg(x,x')(其中x≠x');而只
需计算q-1个重量wa(x)(其中x≠0)就足够了。下面的定理给出了计算线性码d的另一
种方法，有时这种方法更为简单。
定理7.3 如果C是F,上的一个(n,k)线性码，具有一致校验矩阵H,则d(C)=H中
线性相关列的最小数目。因此如果H的任意26及更少的列所组成的子集都是线性无关
的，则这个码能够纠正所有重量≤t的错误图案。
注意 如果q=2,刑“线性相关”可以替换为“求和为0”。
证明：C的码字是满足Hx?=0的所有失量x∈V(Fg)(定理7.1)。而乘积Hx1是H中各
列的一个线性组合；实际上，如果[c,?,…,c,]是H的列，则Hx?=xic?+…+xC。因
此一个重量为 o的非零码字产生了H中w列之间的一个非平凡线性相关；反之也成主。
这就证明了该定理。
推论 如果q=2,且H中≤e列的所有可能线性组合都不相同，则d(C)≥2e+1,由此
可知C能够纠正重量≤e的所有钳误图案。
证明：证明过程留做习题7.7n
为了说明定理7.3,不妨考虑前面的三个一致校验矩阵。显然H?中任意4列或更少列的
子集是不相关的，但是所有列的和等于0;因此d(C)=5。而H?的d(C?)=2,因为H?
的第3列和第4列是相同的。对H?的研究非常重要，我们将在下一节中进行讨论。
7.4 汉明码
作为参考，这里重新写出C?的一致校验矩阵： =
现在利用定理7.3来确定它的d。根据定理后面的注释，d是H中相加等于0的最少列
数。显然d*1和2,因为H?的列不为零而且互不相同。但是，H?存在许多三列组成的子
集，例如，第1列、第2列和第3列，它们相加等于0。因此d=3,C?是一个能够纠正单个错
误的码，即它能够纠正所有重量为0或1的错误图案。最后，注意到如果C是任意能够纠正
单个错误的(n,n-3)码，那么n≤7.因为若3×n阶一致校验矩阵的n≥8,则它将有一列为0
(d=1)或者有一对相同的列(d=2)。下面是二进制汉明码的一般定义。
定义 令H是一个m×(2"-1)阶二进制矩阵，H的列是V2(F?)中以某种顺序排列的
、 114 信息论与编码理论(第二版)
2”-1个非零失量。则在F?上，一致校验矩阵为H的(n=2"-1,k=2"-1-m)线性码
被称为码长为2”-1的(二进制)汉明码ilt。
下面介绍汉明码的两个特点。首先，非常容易实现伴随式译码。如果错误图案z=0,则
伴随式s=0;但是如果wr(z)=1,比如说z,=1,则s=c,,即H的第i列。因此由伴随式可以
直接确定错误位置，图7.1中的通用泽码算法变为图7.4所述的特定算法。其次，码C能够纠
正重量≤1的所有图案，当且仅当围绕各码字的半径为1的汉明球体互不相交。但是V?(F?)
中半径为1的汉明球体内包含有n+1个矢量，因此一个能够纠正单个错误的码至多包含
2"/(n+1)个码字。特别地，当n=2"-1时，至多有22-1/2"=2"-I-"个码字，这正是汉明码
中码字的数目!因此汉明码具有完美的几何性质，即围绕各码字的半径为1的球体恰好填满
V.(F?)而没有重叠。这意昧着汉明码属于一类非常特殊的码，即完备码。除此之外，仅有的
二进制线性完备码是重复码(见习题7.18)和(23,12)Golay码(见9.8节)。(另见第12章关于
完备码的讨论。)
1、计算伴随式s=Hy?
2.如果s=0,箱出-y.
3.否则。等于H的某一列，例如s=c。在y的第；个分叠上
加模2),将结果作为f输出：
图7.4 汉明码的伴随式译码
习题7.17和习题7.19给出了汉明码的几种变形，其中包括非二进制汉明码。然而，汉明
码最有意义和最有价值的推广，是一类能够纠正e(e>1)个错误的码；这个推广是第9章的
主题。
7.5 一般q进制信道上的伴随式译码
在7.2节中介绍了q进制对称信道上线性码的一种译码算法。然而，只有少数具有q个
输人和g个输出的信道可以模拟为q进制对称信道，因此本节中将简单地讨论在更复杂的信
道条件下，线性码的译码问题。
令C是F,上的一个(n,k)线性码，用于一个输人和输出符号集都等于F,的信道。我们
假定信道噪声是加性的，就是说，如果x=(x?,…,x。)是发送的码字，则接收矢量y由y=x+Z
给出，其中Z=(Z,….Zn)是随机噪声矢量，其分布由p|Z=xf=p(z)给出，z∈V(F)。[注
意7.2节的q进制对称信道符合这一描述，它的p(z)由式(7.5)给出。]
在这个信道上怎样译码 C呢?像以前一样，第一步是计算伴随式s=Hy°,以确定错误图
案z所属的陪集。但是此时在对应伴随式s的陪集中，最可能的错误图案是具有最大p(z)值
的那个，而不是具有最小重量的那个错误图案。因此在这种情况下，译码算法(对比图7.1)一
般由图7.5给出。
第7章 线 性 码 115
1.计算伴随式s=Hy?、
2.在对应丁s的陪集中，寻找具有最大概率p(z)的矢量，称
之为zh<
3.输出码字X=y-Z、
图7.5 任意加性q进制信道上的伴随式详码
例如，考虑在一个信道上采用C?,对于该信道上长度为5的错误图案，其出现概率由下表
给出：
z p(z)
00000 0.80
00100 0.06
01010 0.05
10001 0.04
0110 0.03
HO10t 0.02
其他 0
通过检查 C?的标准阵列(见图7.2),我们发现伴随式00的陪集(码本身)仅含有六种可能的
错误图案之一，即00000,因此00000仍然是它的陪集首[p(z)最大的错误图案]。类似地，
00100仍然是01的陪集首。10的陪集包含10001和01110,但是因为10001更有可能，所以它
是陪集首。最后，在11的陪集中，0E010而不是10101被选为陪集首。可见，对于这个特定的
码和信道，伴随式和陪集首的对应关系应该如下表所示：
伴随式 陪集前
00 00000
0L 00100
10 10001
11 01010
而译码错误概率(实际错误图案不是陪集首的概率)为p(01110)+p(10101)=0.05。
遗憾的是，图7.5中的译码算法有两个难点、第一个难点是，如我们在7.2节所看到的，
步骤2的实现可能会非常困难，除非码足够小，能够预先算出一个陪集首的表。第二个难点
是，对于大多数“真实”信道，只能通过测试经验性地获得概率p(z);实际上，如果n的值稍微
大一些、就会根本观察不到大多数可能的z,因此对它们只可能做一个粗略的估计，即对于某
个a值，做出p(z)<a的估计。下面将介绍在这种情况下有时很有用的一种通用方法。
令F为V。(F)的一个子集，将F看做信道上具有“中等”以上发生概率的错误图案的集
合；令E为F的一个子集，将E看做是具有“高”发生概率的错误图案的集合。给定一个线性
码C,如果可能，我们希望设计一个译码器，它能够检测到F中的错误图案，并纠正E中的错
误图案。这意味着，允许译码器输出一个码字&,或者一个特殊的删除符号“?”。假设现在发
送的是x,接收到的是y=x+z,则有下面三种可能：
(a)译码器输出码字X=x。
116 信息论与编码理论(第二版)
(b)译码器输出码字×≠x。
(c)译码器输出“?”。
在情况(a)下，我们说错误图案z被纠正了；在情况(b)下，泽码器产生了一个错误；在情况(c)
下，译码器检测到一个错误.现在做如下定义：
定义 如果可以设计码C的译码器，它能够叫正E中的错误图案z,并能够纠正或检测
F中的错误图案z,则称码C为E纠错、F检错码。
定理7.4 令C是F,上的一个(n,k)线性码，具有一致校验矩阵H,并令ECF为
V.(F)的子集。则C为E纠错、F检错码的充分必要条件是它具有下列性质：
(a)z,z∈E,z≠z,即Hz[≠Hz2。
(b)zEE,z?∈F-E,即HZ3≠Hz。
证明：首先假设(a)和(b)已经满足。设计一个合适的译码器：第一步是建立一个包含
q对(s,f(s))的表，每一对(s,f(s))对应于一种可能的伴随式s,并且对于所有的g,设
f(s)=?。第二步是修改这个表，对所有z∈E,设f(Hz2)=z。则使定理成立的译码算法
如下：
1.计算s=Hy'。
2.如果f(s)∈V,(F?),则输出X=y-f(s)。
3.否则输出f(s)=?。
在习题7.9中，将验证这个译码算法的有效性，并证明其进命题。
例7.4 令C是(7,3)码，具有：
(这个矩阵是前面的矩阵H?附加上一行1。)令E={z:wn(z)=0或1|,F={z:wg(z)=
0,1或21。容易证明码 C是E纠错、F检错码，通常也表述为，纠正单位错、检测两位错
码(证明和推广见习题7.17)。
例7.5 令C是任意(n,k)线性码。设计 C的一个单检错译码器：令f(0)=0,而对所有的伴
随式8÷0,令f(s)=?。这个译码器不能纠正任何非零错误困案，但是它可以检测到任意
错误困案z,除非z是C的一个非零码宇。因此译码器的错误概率就是z为C中非零码
字的概率。如果我们假设信道是q进制对称信道，则z等子一个重量为w的特定码字的
概率是[1-(q-1)e]"-“ε[见式(7.6)]。因此如果以A,表示C中重量为i的码字数目，
则这个单检错方案的错谈概率是：
P=L4el1-(q-1e (7.7)
=[1-(q-1)e]"[A(O)-1]
啡■
第7章 线 性 码 117
其中&=e/[1-(q-1)e],而A(z)=Aa+A?z+…+A,z(注意对于所有的码，有A?=1)。
生成函数A(2)称为码C的重量枚举多项式
7.6 重量枚举多项式和MacWiliams恒等式
重复一下：如果C是一个(n,k)线性码，则它的重量枚举多项式为
A(z)= Ao+A[z十…+Anz"
其中A.表示码C中汉明重量为i的码字数日。显然，Aa=1,而A(1)=q3。正如我们所看到
的[见式(7.7)],当C仅用于检测错误时，可用A(z)来计算错误概率。
下面的定理说明了，当信道为离散无记忆信道并采用最大似然准则泽码时，可利用A(z)
给出错误概率的界限，这是A(z)的一种更有意义的应用。(伴随式译码是一种最大似然泽码
方法。)为简单起见，我们只考虑二进制码，更一般的情况参见习题7.10。
定理7.5 令C是一个二进制线性码，用于输入符号集A={0,1}及输出符号集为Ay的
DMC上；并且采用最大似然准则译码。则最终的错误概率界限为：
PE≤A(y)-1
其中，
r=EVPoyo)pt) (7.8)
(特别地，对于原始误比特率为e的BSC,y=2√e(1-e)。)
证明：令C=|xo,x.…,xn-11,其中x?=(00...0),并令P表示传输x,时的译码错误概
率。如果接收到y,ML译码器输出的是使p(yIx,)尽可能大的码字。现在假设传输的是
如果p(ylx)>p(yix,),则译码器肯定不会输出x;,因此如果Y;={y:p(ylx:)≥p(ylx?),
则有：
吧<Zo (7.9)
其中，
e=>nyixo (7.10)
因为对于所有y∈Y,,√p(ylx,)/p(ylx)≥1,所以可以将式(7.10)求和中的每一项乘以
这个因子，得到：
e≤∑VPYho)p(iz)
现在，将求和扩展为对所有的y∈A"求和，可以得到Q的一个比较弱的上界：
0.≤ZVpyYipyi) (7.11)
进一步利用条件p(ylx)=p(y,x)…p(yaIxn),其中y=(y…,y),x=(x;,…,x)。交
李潴苏 就A !
118 信息论与编码理论(第二版)
………………和
换式(7.11)中来积与求和的顺序，得到：
eZVpuwo)plx) (7.12)
其中x=(A,…,x),x,=(x…,xin)。显然，如果 xm=x,式(7.12)的内部求和项等
于1,如果xm≠x,则内部求和项等于γ[见式(7.8)]。因此式(7.12)简化为：
Qyn(c,) (7.13)
其中dg表示汉明距离。结合式(7.9)和式(7.13),我们得到：
唱9v (7.14)
其中A"为与x汉明距离为i且不等于x的码字数目。而这正是汉明重量为i的码字
数目，即A。因此如果传输x?,则如前面所保证的，译码器的错误概率≤A(y)-1。如果
传输的是某个其他码字，例如x,,同理可以证明最终的错误概率P'≤Z'=:A°y,其中
A为与x,汉明距离为i且不等于x,的码字数目。但是因为码是线性的，所以有A?"=
A=A,(见习题7.12),这就证明了定理。
例7.6 本章中的码C?仅有00000和11111两个码字。显然它的重量枚举多项式是
A(z)=1+z3。在BSC上，定理7.5给出的界是PR≤32[e(1-e)]2,而我们在本书引言部
分就看到，P=10e3(1-e)2+5e?(1-e)+e?=10e3-15e?+6e3。因此对于非常小的E
值，定理7.5的界与实际值相差不太多(32e?2对比10e3)。习题7.26提出了一种改进
方法。
现在可以很容易地计算出码C?和码C?的重量枚举多项式，因为它们分别仅含8个和16
个码字。不过尊先将证明下面这个著名的定理，它说明通过将对偶码 C+的重量枚举多项式
进行简单的线性变换，可以得到码C的重量枚举多项式。
定理7.6(MacWilliams 恒等式)令A(z)是一个(n,k)线性码C的重量枚举多项式，并令
B(z)是其对偶码C1的重量枚举多项式，即，
2)=二Bp
其中B,=C+中重量为j的码字数目。则A(z)与B(z)的关系为公式：
Ka)=AL-2M0+(q-1)2)
证明：这里仅就二进制码的情况详细证明该定理，特定理的推广留给读者(见习题7.27)。
首先建立一些约定。设x=(x?,…,xn)是域F上一个任意长度的失量，甚至m=1也可
以，w(x)表示它的汉明重量，即非零分量的个数。特别地，如果x是一个标量(即x∈F),
则，
ma)={1;x≠ (7.15)
1
第7章 线 性 码 119
现在令F=F?为一个包含两个元素的域。如果x=(x?,…,xm)和y=(y?,…,m)是两个
矢量，其分量取自F中，定义：
(x,y)=(-1)n +…+y- (7.16)
其中(-1)°=1,(-1)'=-1。
引理1 令C是F?上的一个(n,k)线性码，即为V(F?)=V的一个子空间。因此如果y
是V中的任意元素，则，
={8yE
证明：对于一个困定的y,x→<x,y>是C到乘法群|1,-1|的一个同态映射，如果
y∈C-,那么对于所有的x∈C,有<x,y>=1,显然引理1的第一种可能成立。但是如果
y≠C,则这个同态是非平凡的，+1和-1出现的次数相同；因此求和式等于0。
引理2 令x是V=V。(F?)中的一个固定矢量，并令z是一个不确定值。则，
2O》)=(1-2)1+2)
证明；只需计算
2?=Z ?+xn…mY)
[见式(7.15)和式(7.16)。]
- Zix
交换求和与乘积顺序，我们得到：
2O》=1Z?(》
显然如果x:=0,最后的求和项为I+z,如果x:=1,则为1-z,又因为D(x)定义为x中等
于1的分量 x,的个数，这就得出了引理2。
现在继续证明定理7.6。思路是通过两种方法计算求和式：
∑S?,x-x? (7.17)
如果先计算式(7.17)的内求和项，由引理2,会得到：
∑(-zM(1+2)=AL-2)(1+2)-
其中A,等于满足w(x-x')=i的码字对(x,x')的数目。容易证明这个数目是2*·A,,这
里A:是重量为i的码字数目《见习题7.12),因此式(7.17)等于：
240-z(1+2) (7.18)
,:ir
120 信息论与编码理论(第二版)
现在如果改变式(7.17)的求和顺序，可以得到：
化x-x)
它的内求和式为：
二mx)二x-x)-|20,x)
根据引理1,如果y∈C-,这个式子等于2*,而如果y C+,则等于0,因此式(7.17)变为：
“=2“二Bp (7.19)
联立式(7.18)和式(7.19),就得到了定理7.6的结论：
MacWiliams 恒等式的重要价值在于，为了计算一个(n,h)线性码的重量枚举多项式，通常
需要了解所有g个码字的重量。显然这是一项艰巨的任务，除非无的取值相对较小。但是如
果k的值非常大而n-k的值很小，就可以先计算其对偶码 C-的重量枚举多项式，由此再计
算出 C的重量枚举多项式。例如，一般的二进制汉明码(见7.4节)有n=2"-1,
k=2"-1-m,计算所有2"-1-m个码字重量的任务看来可能是无法完成的。但是它的对偶码
仅有2”个码字，其重量枚举多项式也非常简单、因此利用定理7.6,可以计算出汉明码的通用
A(z)公式(见下面的例题，以及习题7.29和习题7.30)。
例7.7 现在我们准备计算本章中码C?和码C?的A(z)。C?是一个(5,3)码，有8个码宇。
但是它的对偶码C?是一个(5,2)码，仅有4个码字，因此先计算出对偶码的重量枚举多
项式。根据7.1节的结论，C?的一致校验矩阵就是C的生成矩阵，在前面我们找到了
这个矩阵：
[H6119]
因此C?的4个码字为0000,11000,1011]和01111;它的A(z)=1+z2+2z?:根据定理7.6,
C?本身的重量枚举多项式为，
(+2a()=410+3+(1+2P(-z2+201+21-2
=1+3z2+3z3+z3
可见C?含有1个重量为0的码字，3个重量为2的码字，3个重量为3的码宇和1个重量
为5的码字(当然，很容易直接脸证这个结论)。
例7.8 类似地，(7.4)汉明码C的对偶码C时具有生成矩阵：
当计算它的重量枚举多项式时，我们惊奇地发现，7个非零码字的重量都是4!因此
i
第7幸 线 性 码 121
A(z)=1+7z?,根据定理7.6,C?本身的重量枚举多项式为：
[[1+z]?+7(1-z)(+z)3]=I+7z3+7z?+z?
习题
7.1 设C为定义在整数(mod 3)城F?=|0,1,2F上的线性码，其生成矩阵为：
c-[2619]
(a)利用伴随式译码方法对下列矢量进行译码：2121,1201,222Z(假设信道是对称的)。
(b)计算该码的重量枚举多项式。
7.2 设一个(6,3)二进制线性码C的生成矩阵为；
-8
(a)写出C的行递减阶梯生成矩阵。
(b)写出C的一致校验矩阵H。
(c)分别写出C的8个陪集中的最小重量陪集首。
(d)设A,(i=0,1,…,6)表示C中重量为i的码字个数，写出A的值。
(e)对下列接收矢量进行译码：111010,000011,101010(假设信道为二进制对称信道，且
p<1/2)。
7.3 假设g进制对称信道的错误概率ε满足E>1/q,应该如何修正7.2节中介绍的译码
算法?
7.4 说明7.3节定义的汉明距离d满足真正的测度所具有的下列性质：
(a)d(x,x)=0。
(b)如果x≠y,则d(x,y)>0。
(c)d(x,y)=d(y,x)。
(d)d(x,y)≤d(x,z)+d(z,y)。
7.5 证明码长n=2"-1的不同汉明码的总数为(2"-1)!/π(2"-2')。
7.6 比较利用伴随式译码方法和多票判决译码方法(见本书引言部分)对码C?进行译码的
复杂度。
7.7 证明定理7.3的推论，
7.8 对于不同的n值，寻找一种d(C)=2且编码速率最大的线性码C。它是惟一的吗?
7.9 完成定理7.4的证明。
7.10设C是在q进制对称信道上传输的一个g进制线性码，译码采用最大似然准则。证明
译码后错误概率的界为A(Y)-1,其中A为码的重量枚举多项式，而γ=
2√E[1-(q-1)e]+e(q-2)[g进制对称信道的定义参见式(7.5)]。
7.11 q进制删除信道是一种离散无记忆信道，其输入字符集Ax=F,F,是一个含q个元素
·,.1:
2…………………………………………………………………………………………时5……;不亦 122 信息论与编码理论(第二版)
的有限域，而输出符号集Aγ=F,UI?},其中“?”表示一个特定的删除符号。假设发送
x=(xj,…,x。),并接收到y=(y?,…,y)。如果y∈F,但是y:≠x?,说明第i个位置上
出现一个错误；如果y,=“?”,说明该位置上出现一个别除符号。
(a)设C是F,上的一个(n.k)线性码，其最小距离为de证明当且仅当
dm≥2e+?+1时，码C能够纠正所有e个错误和f个刷除符号的组合。
(b)假设信道是一个纯删除信道，即除非y=x或y=“?”,否则p(ylx)=0。试说明在
这种情况下，可利用判断x是否为码字的条件Hx?=0,得出码字中未知删除符号的
n-k个线性方程组
(n)利用(b)中提供的方法，对(7,4)汉明码(参见前面的一致校验矩阵H?)的下列接收
码字进行译码：10?0?01,???0000,?0??01?。该接收码字中只含删除符号不含错误。
7.12设C为F,上的一个(n,k)线性码，对任意y∈V(q),定义C-y=lx-y:x∈Ch。根据
式(7.4),显然C-y是C的一个陪集。证明当且仅当y∈C时，C-y=C。并进一步
证明：
(a)如果x,是C中的一个确定码字，则与x,的汉明距离等于i的码字数目为A,,A;是汉
明重量为i的码字数曰。
(b)满足汉明距离dn(x,x')=i的码字对(x,x)的数目为qA。
7.13设C为F,上的一个(n,k)线性码。对于F。中任意选取的k个元素a,az?,…a,C中
存在惟一的码字，满足x;=a?,…,x=a,则称子集I={i,i?,…,iiCI1,2,…,nl是
C的一个信息集。[这个术语的定义，是根据码字中的位置，i?,…,可以用于携带信
息，即信息a=(u.…,u)。]
(a)证明每个线性码至少具有一个信息集。
(b)证明当H仅当生成矩阵的第i,…,i列线性独立时，I是C的一个信息集。
(c)计算本章中的码C?,C?和C;具有的信息集数目。
(d)设C是一个二进制线性码，满足集合11,2,…,n}的任意一个含有k个元素的子集
都是C的信息集，证明k=0,1,n-1或n。(注意：一些非平凡、非二进制码也具有
此性质，例如9.6节将要介绍的 Reedl-Solomon码：)
7.14(续)习题7.13所引入的信息集概念，可用于设计一种明显不同于伴随式译码的线性码
译码算法。这种算法有时称为错误跟踪算法或者多重译码算法。假设C是一个(n,k)
线性码，我们希望它能够纠正所有含e个或更少个错误的图案。设I?,lz,…,I,是C的
信息集，并具有如下性质：对于任意一个含有e个元素的子集JS11,2,…,nl,至少存在
一个I,满足I:AJ=φ。
(a)假设y是接收到的码字，它包含≤e个错误。对于任意i=1,2,…,r,令x?=C中惟
一在!所定义的位置上与y对应位置上的分量相同的码字。试说明这样产生的x,
中至少有一个是实际发送的码字。
(b)假设 d,(C)≥2e+1,试说明：通过将所有的x:依次与y进行比较，可以惟一地确
定发送的码字。
(e)将这种方法应用于(7,4)汉明码。为了纠正一位错误，最少需要多少个信息集?
第7章 线 性 码 123
7.15假设一位通信工程师告诉你，在他的(二进制)信道中接收到码长为n的码字，井且已经
观察到错误图案只有n+1种(例如 n=6时，错误图案只可能为000000,000001,000011,
000111,001111,011111,111111)。试设计一种能够纠正全部此类错误图案，并具有可能
的最大编码速率的(n,k)线性码。描述一下n=7时所构造的码。
7.16设C是一个(n,k)线性码，其最小距离为d,并设e≤f,e和f均为非负整数。定义
E=|z:wg(z)≤ei,F=|z:wx(z)≤fl。试证明：如果e+f<d,则根据定理7.4,C是
一个E纠错、F检错码。(在这种特殊情况下，这类码通常称为“e位纠错、位检错”
码。)
7.17 尽管二进制汉明码非常适合于纠正单个错误，但是当信道中出现多个错误时，它的性能
就会大打折扣。本习题将分析这个问题，并提供改善其性能的可行方法。
(a)试说明当信道中出现两个或更多个错误时，汉明码的译码器总是产生译码错误。
(b)码长为2”的扩展汉明码，是在原来汉明码的基础上附加一个全校验位而得到的；
即，如果H为原汉明码的一致校验矩阵，则新得到的扩展汉明码的一致校验矩阵
为：
0
0
H'=:
0
111!…1
类似地，删除汉明码的码长为2”-1,其一致校验矩阵为：
H"=
H
11..
计算这两种码的维数，并说明它们的最小距离d=4。
(c)说明扩展汉明码和删除汉明码在译码时，至少能够纠正单位错误，检测两位错误(参
见习题7.16)。
7.18 n维主复码是指生成矩阵为C=[11…1]的(n,1)线性码，其中n为奇数。试证明它是一
种完备码，即半径为(n-1)/2的汉明球体填满了整个V(F?)空间，而它们相互之间并
不重叠。
7.19本习题将介绍如何构造非二进制汉明码。设H是定义在F,上的一个m×n阶矩阵，它
是某个线性码C的一致校验矩阵。
(a)试证明当且仅当H不含全0列，并且H中各列之间没有倍数关系时，码C能够纠正
单个错误。
(b)试证明对于给定的m值，如果H具有(a)中描述的性质，则n≤(q"-1)/q-1),并
且这个界是严格的。如果 n=(q"-1)/(q-1),该码就称为g进制汉明码。它的
n=(q"-1)(q-1),k=n-m。
124 信息论与编码理论(第二版)
(c)构造下列汉明码的一致校验矩阵：
k
3 4 2
3 13 10
5 6 4
7.20本习题的目的是研究二进制线性码在高斯信道(参见4.1节)上的性质，信道的能量约束
为E(X2)≤β,噪声方差为a2。我们特别希望能够得到该信道的一个类似于定理7.5的
结论。因此设C是一个(n,k)二进制线性码，为了用于高斯信道，将码字中的每个“0”分
量都映射为+√β,每个“1”分量都映射为-√F。假设发送的码字为x,x,…,Xx-1(现在
各码字的欧几里得长度为√ns),每个码字的发送概率为1/M,而y为接收码矢。
(a)最小错误概率译码准则(参见习题2.13)是选取使P|发送x;1接收y最大的码字 x;
作为译码估值。证明这等价于选取与y欧几里得距离ily-x,I1最小的x,作为食，
也同样等价于选取与y的内积x?y最大的x;作为。
(b)试证明：如果存在一个码字x:,满足x,·y>lly-√βn-d),其中d_为码间最小
距离，则x,一定是(a)中所描述的最大似然译码器的输出。(此结论最先由
(L.D.Raunert给出。)
(c)在定理7.5的证明中，假设发送z=(0,0.…,0)(调制后=(√β√β,…√β)),令
Q.=P|译码输出为x,1发送xl。试证明：0.≤Q(II-x;I12o),其中Q(a)=
?(2π)e2ad。
(d)利用习题4.5给出的界和(c)的结果，证明Q.≤rm),其中γ=e-a2,w(x)表示x,
的汉明重量。
(e)最后证明泽码器的错误概率满足P≤A(Y)-1,其中y=e-2:
我们在7.3节中看到，当且仅当以各个码字为中心、为半径的球体互不相交，或老当且
仅当由H的任意不大于e列的矢量所构成的子集线性无关时，该码能够纠正所有不超过e个
错误的图案。这意味着码的纠错能力越强，它的编码速率就应该越低。在下面的5道习题中，
将推导出最佳码的一些d与k之间关系的界。为了简单起见，这里仅考虑二进制线性码。
对于给定的n和d,令M(n,d)表示一个码长为n、最小距离≥d的线性码中最多可能包含的
码字数。
7.21(Gilbent-Varshamov界)证明：M?(n,d)≥2"/[1+(1)+…+(d-1)1。(提示：如果一个最
伟线性码所包含的码字数少于上述界，则它至少有一个陪集中的全部码字都满足重量≥d。
而一个线性码与它的一个陪集的并集也是线性码。)
7.22(汉明界)证明：如果一个码长为n的二进制码，无论它是否是线性码，都能够纠正e个
错误，则它至多包含2/1+(f)+…+(C)1个码字。
第7章 线 性 码 125
7.23(续)证明汉明码达到了习题7.22中的界。
7.24(Ploikin界)设映射π,;(xj,…,x。)→x?将一个二进制矢量映射到它的第；个分量。试证
明：如果x是(n,k)线性码C中的任一码字，方程π,(x)=0有2或z-1个解。利用这
个结论，证明：
Zmx)sn.2-
从而得出结论 d(C)≤n·2-'/(2*-1)。
7.25(续)假设n≥2d-2,选出码C中前n-2d+2位全为0的码字，并去掉这些全0位，得
到一种新码C。利用习题7.24的结论，证明对码C。有下列不等式成立：
M?(n,d)≤2"-2d2d
7.26 本题的结论(由Van de Meeberg给出)将说明在二进制对称信道中如何强化定理7.5。
(a)证明：如果dg(m,x,)是奇数，界(7.13)式可以加强为Q,≤rn'·:+3。[提示：在习
题0.2中已经证明，码长为2n的重复码的错误概率与码长为2n-1的相同。]
P?≤2[(1+Y)A(y)+(1-r)a(-y)]-1。 (b)由此证明定理7.5可被加强为
(c)将(b)中得到的界应用于本章中的码 C?,并与例7.6的结果进行比较。
下面的两道习题将推广定理7.6,即MacWillars恒等式。习题7.27将完善定理7.6在
q≠2时的证明。习题7.28是针对非线性码的。
7.27 对于任意q值，证明定理7.6。[提示：将<x,y>的定义[见式(7,16)]做适当的推广，前
文中给出的证明就能电新适用。为此，定义<x,y>=λ<xy>,这里λ是将F,的加群
映射为p阶复数本原根的任意非平凡同态映射，其中q=p,而p为素数。]
7.28证明非线性MacWiliams恒等式：如果C=|x,…,xMl是V。(F,)的一个子集，定义A=
M'(码C中汉明距离d(x,x)=i的矢量对(x,x)的数目)。如果定义 B,满足下列
公式：
二A1-2YI+(9-1a=二Bp
则对于所有的j,均有B,≥0成立。(一般而言，B,显然没有自然组合特性。)
7.29本习题的目的是计算一般汉明码的重量枚举多项式。
(a)证明对于码长为n=2"-1的二进制汉明码，其对偶码中任意非0码字的重量均
为2°-1。
(b)由此证明二进制汉明码的
A(z)=(1+2"+m1-2)-21+2
(c)将此结论推广到非二进制汉明码(参见习题7.19)。
7.30在本习题中，我们将定义并研究重要的Reed-Muller码。令P(m,d)表示F?上含有m
个变量、阶数≤d的多项式集合。并令(vo,v?,…Pu-1)(其中M=2")表示按一定次序
排列的全部2”个二进制矢量(x?,x?,…,x)。对于任意f∈ P(m,d),通过映射f→
126 信息论与编码理论(第二版)
(f(v?f(v?),…,f(vy-1))我们得到一个长度为2”的矢量。按照这种方法，利用
P(m.d)中多项式得到的全部矢量的集合称为码长为Z"的d阶Reed-Muller 码，用
RM(m,d)表示。
(a)试证明RM(m,d)是一个二进制(n,k)线性码，其中n=2",k=1+(m)+…+
(a):
(b)试证明 RM(m,d)的最小距离是2"-。(提示：为证明d≥2-4,令f=f(x?,x?,…,
xm)∈P(m,d),并将f(0,xz,…,xm)和f(1,x?,…,xm)看做P(m-1,d)中的多项
式。)
(c)证明RM(m,d)=RM(m,m-d-1)。
(d)证明RM(m,m-2)就是习题7.17b中介绍的扩展汉明码。
(e)对于任意m,当d=0,1,m-2.m-1,m时，计算RM(m,d)的重量枚举多项式。
7.31(缩短线性码)设C是一个(n,k)线性码，其一致校验矩阵具有H=[BI.]形式，其中B
是一个(n-k)×k阶矩阵，I-是一个(n-k)×(n-k)阶单位矩阵。如果1≤I≤k,B,
表示将矩阵B的前：列删去后得到的(n-t)×(k-t)阶矩阵。如果码 C的一致校验
矩阵具有H,=[B?I-k]的形式，则称码C.是码C的缩短码(也见习题7.25)。
(a)试证明，选出码C中前1位全部为0的所有码字并删除这些全0位，就得到码Co
(b)试证明码C,是一个(n-1,k-1)线性码。
(c)证明d(C,)≥d_(C)
7.32(纠突发错误的交织码)一个长度为n的二进制错误图案 z,如果它的“1”分量集中在连
续b位内，则称它是一个长度为b的突发，例如z=(00…00100101100…00)是一个长度
为b(b≥7)的突发。类似地，如果z中的"1"分量集中在e个这样的突发中，则称z是一
个长度为b的e重突发。例如，可以认为上面的z是一个长度为4的2重突发。
现在设H是一个(n,k)二进制线性码C的mxn阶一致校验矩阵。定义码C的b重交
织码是一个(nb,kb)码，用Cb表示，其mb×nb阶一致校验矩阵为：
Cn C2
cn」
其中[c,…,c,]是H的各列，而空白处的元素为“0”。
(a)说明码 cb的每个码字，都是由码C的b个码字“交织”排列而成的。
(b)假设原来的码C能纠正所有重量≤e的错误图案，并能检测所有重量≤f的错误图
案(参照习题7.16)。试证明，码cb)能纠正所有长度为b的e重突发错误图案，检
测所有长度为毒的了重突发错误图案。
(c)构造下列码的一致校验矩阵：(i)一个(21,12)码，它能够纠正所有长度为3的单个突
发错误图案；(ii)一个(25,20)码，它能够检测出所有长度为5的突发错误图案。针
对以上两种码，设计出有效的译码方法。
…………………………………… 第7章 线 性 码 127
注释
[1] 我们将不再讨论香农理论；而致力于寻找一些香农编码定理已经预测存在的，却没
有明确给出的码。
[2] 更精确地，应该称做线性分组码，以区别于第10章将要介绍的线性卷积码。
[3] 因为这要求q必须是素数的方霉，所以不能考虑含有6,10,12,14,…个元素的输人
字符集。
[4] 下面的讨论假定读者已经具备某些线性代数的基础知识。这些知识可以参阅Birk bofT和Maclane[3]的第7章。
[5] 通常允许一个RRE矩阵的某些行全为0,以便矩阵在变换为它的RRE形式时行数
不改变。但是这里假设，在变换过程中如果出现了全0行，就将这些全0行删除。
[6] 这个名称的内来，是根据在二进制情况下，一致校验说明每个码字在相同位置的确
定子集内有偶数个1。
[7] 此处和其他各处的T均表示转置运算。
[8] 这个变换(从G到H)的简化当然决非偶然；RRE矩阵就是为此而设计的。例如，为
求解G?表示的齐次线性方程组：
xi上x?+x3 =0 ++x++=8
第一步就是将C改写成RRE形式；方程组变为：
此时显然能够看出，可以独立选取x?和x,,而x,=x?+xs,x?=x?,x?=xs,这就意
味着，原方程组的每个解均是下面矩阵中各行的一个线性组合：
[16119]
而这正是本章开始时介绍的矩阵H?。
[9] 参见引言的注释5。
[10] 如果我们不考虑域F。的乘法结构，面仅仅将它看成含有g个元素的加法群，则码
C是直积Fx…×F,的一个子群，式(7.4)定义的子集C+Z是这个子群的一个
陪集。因此，你可能会发现线性码有时也被称做“群码”。
[11] 通常不认为m=1,2时的码是汉明码，因为它们过于简单。
[12] G.Solomon提出的这个概念是基于以下事实。如果I是C的一个信息集，令m=
(m,m?,…,m)为I的指示向量，即，如果i∈1,则m=1,否则m=0。设y是接
收码字，如果信息集中没有出现错误，则可以用m,乘以y的方法恢复出x。
[13]这样命名是因为奇数重量的码字已经从C中删除了。
:
第8章 循 环 码
8.1 引言
在第7章的开始，曾强调要将注意力集中于线性码(而不是任意无结构的码),我们希望能
够找到一些易于应用的好码。显然一个“小型”线性码(比如维数或冗余不超过20)通过硬件
实现没有多大困难(例如，通过伴随式译码)。但是，为了达到香农定理所述的性能，必须采用
更大规模的码，而一般来讲，大型码很难实现，即使它是线性的。正是由于这个原因，几乎所有
实际中应用的分组码都是循环码；循环码形成了线性码集合中一个非常小且高度结构化的子
集。在本章中，我们将对循环码做一个全面的介绍，讨论范围不仅包括基础数学理论(8.1节),
还包括用于实现循环码的基本电路(8.2节)。在8.3节中将看到，汉明码可以作为循环码来
实现。而在8.4节和8.5节将说明如何利用循环码来纠正突发错误。我们的介绍将延续到
第9章，在第9章中将研究目前所发现的循环码中的最重要家族：BCH/Reed-Solumon码。
现在，首先从看起来很随意的循环码定义开始。
定义 对于城 F上的一个(n,k)线性码，如果每个码字C=(C,C,…,Ca-1)的右循环
移位，即C?=(C-1,C,….C-2),也是一个码宇，那么就称这个码为循环码。
后面将会看到，有许多不同类型的循环码，但是与线性码比起来，它们所占的比例却非常
小。例如，在GF(2)上有11811个(7,3)线性码，但其中只有两个是循环的!
例8.1 如果F是任意城，n是一个≥3的整数，那么城F上总是至少存在4个长度为n的循
环码，通常称之为4个最简单循环码：
●一个(n,0)码，仅含全零码字，称为无信息码。
●一个(n,1)码，所有码字的形式都是(a,a,…,a),其中α∈F,称为重复码。
●一个(n,n-1)码，包含能使>C=0的全部矢量(C,C,…,Ca-1),称为单奇偶校验
码。
●一个(n,n)码，包含所有长度为n的夫量，称为无奇偶码。
对某些n和F值，例8.1中所描述的最简单循环码是域F上仅有的码长为n的循环码
[例如，n=19,F=GF(2)]。然而，正如下面两个例题所描述的，经常存在一些其他的更有意
义的循环码。
例8.2 考虑GF(2)上的一个(7,3)线性码，其生成矩阵为：
-9
这个码有8个码字。如果以C,C?和C?表示G的行，那么非零码宇为：
1.
第8章 循 环 码 129
C=10H1100
Cz=0101110
C?=0010111
C?+C2=1110010
C?+C?=1001011
C?+C?=0111001
C:+Cz+C?=1100101
这个码实际上是一个循环码。为证明这一点，我们需要检验每个码宇的右循环移位是否
也是一个码宇。例如，C的右循环移位是C,右循环的完整列表如下所示：
C→C?
C?→C?
C?→C?+C?
Ci+C2→C?+C?
Ci+C?→C+C?+C3
C?+C?→C
C1+C?+C?→C+C2
例8.3 考虑GF(3)上的一个(4,2)线性码，其生成矩阵为：
c=[1922]
这个码有9个码宇。如果以G,C,表示G的行，那么非零码字为：
C=1020
2C=2010
C?=1122
C1+Cz=2112
2C1+C?=0102
2C?=2211
C+2C?=0201
2C?+2C?=1221
这个码也是一个循环码。例如，C的右循环移位为2C,+C。右循环的完整列表如下：
C:→2C+C?
2C?一Ci+2C?
C2→C+C?
C+C?→2C?
2C?+C?→2C
2C2→2C?+2C?
C?+2C?→C
2CL+2C2→C?
.i.
130 信息论与编码理论(第二版)
循环码的定义表面上看起来很随意，但实际上这样做的理由很充分，特别是在我们引入码
字的生成函数这个概念以后，如果C=(Co,C?,…,C)是一个码字，那么它的生成函数定
义为多项式：
C(x)=Co+Cx+…+Cn-1x*-
其中x是一个未知数。生成函数的作用在于，通过利用它，可以给出码字右循环移位的一个
简单代数描述。为了给出这一描述，需要定义整数和多项式运算的一个重要的“mod”算符。
定义 如果p和m是整数且m>0,则“p mod m”表示p除以m得到的余数，因此p mod m
等于一个能使p-7被m整除且0≤7≤m-1的整数r。类似地，如果P(x)和M(x)是多
项式，则P(x)mod M(x)表示P(x)除以M(x)的余式；因此P(z)mod M(x)等于惟一能
使P(x)-R(x)被M(x)整除，且deg R(x)<deg M(x)的多项式R(x)。
例8.4 这里有一些例子。
7mod5=2
-6mod4=2
4mod6=4
21mod7=0
x3modx2=0
x2cmodx3=x2
x1000mod(x2+x+1)=x
(5x2+1)mod(x2+1)=-4(在实数城上)
(x+1)3mod(x2+1)=0(在GF(2)上)
x'mod(x"-1)=ximdn
下面的引理列出了多项式 mod 运算的最重要性质。
引理1
(a)如果deg P(x)<deg M(x),则P(x)md M(x)=P(x)。
(b)如果M(x)IP(x),则P(x)mod M(x)=0。
(c)(P(x)+Q(z))mod M(x)=P(x)mod M(x)+Q(x)mod M(x)。
(d)(P(x)Q(x))mod M(x)=(P(x)(Q(x)mod M(x))}mod M(x)。
(e)如果M(x)IN(π),则(P(x)mod N(x))mod M(x)=P(x)mod M(x)。
证明：证明过程留做习题8.5。
现在可以介绍右循环移位操作的代数描述了。
定理8.1 如果C=(Co.C?,…,Ca-1)是一个码字，其生成函数为C(x)=C+Cx+…+
Cnx?1,则右循环移位 C的生成函数C(x)可以由下面公式给出：
CR(x)=xC(x)mod(x"-1)
证明：因为C(x)=C+C?x+…+C.-x-1,所以有
第8章 循 环 码 131
xC(x)= Cox+…+Cn-2x"-1+C-lx"
CR(x)=Cn-1+ Cox-…+Ca-2x"
因此 xC(x)-C(x)=C-(x-1)。因为deg C(x)<deg(x°-1),且xC(x)-C(x)是
x"-」的倍数，所以根据ed运算的定义可以得出结论。
码字的生成函数非常重要，以至于我们常常不去区分一个码字与它的生成函数。因此，形
式上可以将一个(n,k)线性码看成是一个次数不超过 n-1的多项式集合，码中多项式的任意
线性组合还在码中。从这个观点来看，根据定理8.1,循环码是一类线性码，如果C(x)是一个
码字，那么xC(x)mod(x”-1)也是。通过反复应用右循环移位，我们发现对于所有i≥0,
xC(x)mod(x"-1)也是…个码字(见习题8,6)。下面的定理是这个观察结果的一个推广。为
方便起见，引人符号：
{P(x)]a
作为P(x)mod(x?-1)的缩写。
定理8.2 如果C是一个(n,k)循环码，并且如果C(x)是C中的一个码字，那么对任意多
项式P(x),[P(x)C(x)]。也是C中的一个码宇。
证明：设P(x)=∑=oP,x。则根据引理](c),
TPuCxn=[(nx)cu].
=PixCx)。
再根据这个定理前面的阐述，对于任意i,[x'C(x)],是一个码字，又因为码本身是线性
的，所以线性组合SP,[x'C(x}]。也是一个码字。
例8.5 考虑例8.2中的(7,3)循环码。码宇G+C的多项式为1+x3+x?+x?。根据定理8.2,
如果我们将这个多项式乘以其他任意多项式，然后将结果mod(x?-1)降低次数，则所得的多
项式也在码中。例如，
[CI+xXI+x3+x?+x?]],=x+x3+x?+x?
=C?
(【L+x3Ax1001+x3+x?+x?)]7=1+x+x?+x?
=C+C?+C?
[(+x2+x3)(1+x3+x?+x?)]7=0
下面引入的生成多项式是设计和分析循环码的关键。
定义 如采C是一个循环码，那么C中的一个最低次非零多项式被称为它的一个生成多项
式。通常用符号g(x)表示生咸多项式。
例8.6 在例8.2的码中，码字C?所对应的多项式，是所有非零码字多项式中次数最低的，因
此g(x)=1+x2+x3+x1是该码的生成多项式。而例8.3中的码，有两个最低次数的多项式，
·3·
132 信息论与编码理论〔第二版〕
即C?=2x2+1和2C?=x2+2。下面引理的第一部分说明，循环码的生成多项式在乘以一个
标量以后总是等价的。因此我们所指的循环码生成多项式，是一个首项系数为1的多项式。
对于例8.3中的码，通常可以说g(x)=x2+2是它的生成多项式。
引理2 设C是一个循环码，具有生成多项式g(x)。
(a)如果g'(x)是另一个生成多项式，则存在某个非零元者A∈F,使g'(x)=ag(x)。
(b)如果P(x)是一个多项式，而[P(x)],是一个码字，则g(x)能整除P(x)。
证用：为证明(a),设g(x)=g,x'+…+80,g'(x)=g,x2+…+g',且g,≠0,g'≠0。这样
如果λ=g,/g,,则多项式g"(x)=g'(x)-λg(z)的次数低于r且在C中。但是┌已经是C
中非零码宇可能的最低次数，因此g"(x)=0,即g'(x)=λg(x)。
为证明(b),令Q(x)和R(x)分别是P(x)除以g(x)的商式和余式，即，
P(x)=Qx)g(x)+R(x) (8.1)
其中deg R<deg g。将这些多项式都mod(x?-1)降低次数，并利用条件deg R<degg≤
n-1[因为g(x)是一个码字，所以后面的不等式成立],我们得到：
R(x)=[P(x)],-{Qx)g(x)]。
根据假设，[P(x)],是一个码字，而根据定理8.2,[Q(x)g(x)]。也是一个码宇。又因为
码是线性的，所以R(x)也应该是一个码字。但是deg R<degg,且g(x)是最低次的非零
码字，所以R(x)=0,式(8.1)变为：
P(x)=Q(x)g(x)
这就证明了g(x)能够整除P(x)。
现在我们可以阐述井证明循环码的主要定理。它建立了一个码长为n的循环码与x?-1
的首项系数为1的因式之间的一—对应关系。
定理8.3
(a)如果C是F上的一个(n,k)循环码，则它的生成多项式是x^-1的一个因式。而矢量
C=(C,C?,…,C.1)属于该码，当且仅当它所对应的生成函数C(x)=Co+ C?x+…+
C-x-能够被g(x)整除。如采用k表示C的维数，则k=n-deg g(x)。
(b)反之，如果g(x)是x"-1的一个因式，则存在一个以g(x)为生成多项式，且k=n deg g(x)的(n,h)循环码，该码中所有矢量(Co.C?,…,C.1)的生成函数都能够被
g(x)整除。
证明(a):首先，在引理2(b)中令 P(x)=x"-1,[P(x)],=0,它当然是一个码字，所以
g(x)能够整除x-]。其次，根据定理8.2,任意长度为n、生成函数是g(x)倍式的失量
都是一个码字。相反，如果C(x)= Co+C?x+…+C-x1是一个码字，则[C(x)]。=
C(x),根据引理2,g(x)能够整除C(x)。最后，因为C(x)=Co+C?x+…+C-1x是
g(x)倍式的充分必要条件为C(x)=g(x)/(x),其中deg I≤n-1-degg,所以得出关于
g(x)次数的结论。
证明(b):设g(x)是x"-1的一个因式。则C(x)=Co+C?x+…+Ca-jx-1为g(x)倍
式的充分必要条件是C(x)=g(x)f(x),其中degg+deg I≤n-1。因此所有这些码字
第8章 循 环 码 133
的集合是一个(n,k)线性码，其中k=n-degg。为了证明这个码是循环的，必须证明任
意码字的右循环移位还是一个码字。因此令7(x)g(x)是任意码宇；根据定理8.1,它的
右循环移位为[x/(x)g(x)]。。但是因为g(x)能够整除x2-1,所以有：
[xl(x)g(x)],mod g(x}=[x/(x)g(x)]mod g(x)[根据引理I(e)]
=0[根据引理1(b)]
这就证明了[xI(x)g(x)],是g(x)的培式，因此该码确实是一个循环码。
定理8.3说明了循环码生成多项式的重要性。一个与其关系密切，且同样重要的多项式
是循环码的一致校验多项式，它表示为h(x),定义为：
)=8
定理8.3的下述推论给出了循环码g(x)和h(x)形式的生成矩阵和一致校验矩阵。
推论1 如果C是一个(n,k)循环码，具有生成多项式g(x)=go+gix+…+gx'(其中r=
n-k),以及一致校验多项式A(x)=ho+h?x+…+hx?,则下面的两个矩阵就是C的生
成矩阵和一致校验矩阵：
-
其中i(x)=h+h+…+hax?为h(x)的“反”多项式。此外，如果矢量I=(Ia,l?,…,
-1)编码为C=IG?[参照式(7.1)],则生成函数I(x)=Io+I?x+…+I-1x-1与C(x)=
Co+ C?x+…+Ca-1x-1之间的关系为：
Cx)=f(x)g{x)
证明：根据定义，G?的第i行为x'g(x),i=0,1,…,k-1。而根据定理8.2,这k个矢量都
在码C中，并且因为每行都有不同的次数，所以它们是线性无关的。又因为码C是无维的，
所以G?是码C的一个生成矩阵。此外，矢量IG,具有生成函数lg(x)+I?xg(x)+…+
I-1x-1g(x)=F(x)g(a),其中【=(lo,I,…,I-1)。
为了证明H?是码C的一个一致校验矩阵，注意G第i行与H第j行的内积是乘积g(z)h(x)
中x-的系数。而g(x)h(x)=x2-1,因此当指数k-i+j的取值范围从1(当i=k-1
且j=0时)到n-1(当i=0且j=r-1时)变化时，这些内积都等于0。可见H的每一
列都在码C的零空间内；又因为码C的掌空间是r维的，而H?有，个线性无关的行，所以
H 确实是码C的一个一致校验矩阵。
134 信忠论与编码理论(第二版)
推论〕介绍的矩阵有时很有用，但是更常用到的是下面推论2中的“系统”矩阵。
推论2 令C是一个(n,k)循环码，具有生成多项式g(x)。对i=0,1,…,k-1,令G?.是
长度为n的矢量，它的生成函数是G(x)=x"-x""mod g(x)。则kxn阶矩阵：
是码C的一个生成矩阵。类似地，如果H?,是长度为r的矢量，它的生成函数是H?,(x)=
x mod g(x),则rxn矩阵：
H?=[H0,H?…,H2.-11
是码C的一个一致校验矩阵。此外，如果矢量1=(4?,Ij,…,I-1)编码为C=IG?,则生成
函数I(x)与C(x)的关系为：
Cx)=x'f(x)-[x'I(x)]mod g(x)
并且，如果矢量R=(R?,R?,…,R)的伴随式计算公式为ST=H?R2,则生成函数R(x)
与S(x)的关系为：
S(x)=R(x)mod g(x)
证明：因为根据引理1的(c)和(a)部分，
[x'+-xr+'mod g(x)]modg(x)=x'+'mod g(x)-xt+'mod g(x)
=0
可见G?的第i行是g(x)的一个倍式，因此也是码C的一个码字。因为C?有无个线性无
关的行(G?的最后无列形成一个k×k阶单位矩阵),并且每行都是一个码宇，所以G?是
码C的一个生成矩阵。此外，矢量IG?具有生成函数I?(x-x mod g(x))+I?(x+1-
x+' mod g(x))+…+L-,(x1+*-1_x**-1 md g(x))=x/(x)-[zT(x)]mod g(x),其
中1=(I?,I,…,-1)。
为证明有关H?的结论，首先注意H?的秩为(它的前r列形成一个r×r单位矩阵)。此
外，如果R=(Ro,R,,…,Ra-;)是一个接收码宇，则H?R'是一个r×1维列矢量，它具有
生成函数乙=R,(x md g(x))=(Z=kx)mod g(x)=R(x)mod g(x)。如果 R(x)
是一个码宇，那么根据定理8.3(a),R(x)mod g(x)=0,所以H?R2=0对任意码字都成
立。从而证明了H?是C的一个一致校验矩阵。另一方面，如果R是任意接收矢量，那么
它对应H?的伴随式为S=H?R',正如我们刚才看到的，它具有生成函数S(x)=R(x)
mod g(x),命题得证。
注意 推论2中所述的对应于一败校验矩阵H?的伴随式，形式非常简单，通常称它为失量R对应循环
码生成多项式g(x)的料余伴随式。
例8.7 在例8.6中我们看到，例8.2中(7,3)循环码的生成多项式为g(x)=x?+x3+x2+1。
则相应的一致校验多项式h(x)=(x?+1)/(x?+x3+x2+1)=x3+x2+1。作为g(x)倍
第8章 循 环 码 135
式的8个码宇分别为：
Co=0-g(x)
C=1·g(x)
Cz=x·g(x)
C=x2·gx)
C4=(1+x)·g(x)
Cs=(1+x2)·g(x)
C?=(x+x2)·g(x)
C?=(1+x+x2}·g(x)
推论]中所述的生成矩阵和一致校验矩阵为：
--
-
推论2中所述的生成矩阵和一致校验矩阵为：
-
=[1,x,x2,x3,x?mod g,x?mod g,x?mod g]
注意 G?右侧的3×3阶单位矩阵，以及H?左侧的4x4阶单位矩阵。这使得这些矩阵成
为“系统的”。如果希望得到定理7.J所描述的G=[IA]和H=[-A1I-k]形式的生成
矩阵和一致校验矩阵，就可以利用码的循环特性，将G?的行循环右移3个位置，并将H?
的行循环右移3个位置，由此得到：
G-
-
(习题8.9介绍了描迷G?和H?的另一种方法。)如果利用G,对矢量I=[101]进行编码，
:
136 信息论与编码理论(第二版)
得到的码字就为(1+x2)(1+x2+x3+x?)=1+x3+x?+x?=[1001011]。而如果利用 G?,则
码字为x?(1+x2)-[x?(1+x2)]mod(x?+x3+x2+1)=x?+x?+x+1=[11001011。矢量R=
[1010011]对应H?的伴随式为[1101]。(习题8.10介绍了一种完成这个计算的有效方法。》而
如果利用H?,会发现“余数”伴随式为R(x)mod g(x)=(1+x2+x3+x?)mod(I+x2+x3+
x?)=x3+x2,即S=[0011]。
例8.8 在例8.6中我们看到，例8.3中GF(3)上(4,2)循环码的生咸多项式为g(x)=x2+2=
x2-1,而一致校验多项式为(x?-1)/(x2-1)=x2+1。根据定理8.3的推论1,生成短阵和一
致校验矩阵为：
G-[221i
H=[b969]
和
c=[0269
m=[6919}
在这个例题中，G?=G?与H?=H?只是一个巧合。参见习题8.21。
根据定理8.3,在一个给定的域F上，码长为n的循环码与域F上x-1的首项系数为1
的因式是一一对应的。显然为了研究F上的循环码，了解如何在F上因式分解x-1会很有
帮助。虽然我们这里不对因式分解x"-1做系统的研究，但是在表8.1中给出了1≤n≤31
时，GF(2)上x"-1的因式分解。这个表包含了研究GF(2)上码长≤31的循环码所需要的全
部信息。
表8.1 x-1(=x'+1)因式分解为GF(2|上不可约多项式的乘积(1≤n≤31|
7 x"+1
(x+1) I
(x+1)2 2
(x+1)(x2+x+1) 3
(x+1) 4
(x+1)(x?+x3+x2+x+1) 5
6 (x+1)(x2+x+1)2
(x+1)(x3+*+1)(3+2+1) 7
(x+1) B
(3+1)(x2+x+1)(x?+x3+1) 9
(x+1)2(x2+x3+x2++1)2 10
(x+1)(x+x+x?+x1+x+x3+x?+x3+x2+x+1) 11
(x+1)(x2+x+1) 12
(x+1(x+x"+r0+x+x?+x2+x?+x?+x?+x3+x2+x+1) 13
(x+1)(x3+x+1P2(x3t2+1)2 14
……
第8章 循 环 码 137
(续表)
n x?+1=
(x+1)(x2+x+1)(x?+x+1)(+3+1)(x?+3+2+x+1) 15
《x+1) 16
17 (x+1)(x3+r3+x?+23+1)(x?+x2+x?+x?+2+x+1)
(x+1)2(x2+x+1)2(x?+x3+1)2 18
(x+1)(?+x"+x?+…+*+1) 19
(x+1)(x?+3+x2+1+1) 20
21 (x+1)(2+x+1)(x3+x+1)x3+x2+1)(x?+x?+x2+x+1)(x+x3+x?+x2+1)
22 (z+1)(x"+x?+t+x2+z?+x3++?+3+x2++J)2
23 (3+1)(x"+?+2+x?+?+z+1)(x"+x1+t?+x?+x?+x2+1)
24 (*+1)(x2+x+1)°
25 (z+1)(x?+x3+x2+x+1)(x+x+x?+x3+1)
26 (z+122(x2+x?+x1+x?+x?+x?+x?+x3++3+x2+x+1)2
27 (x+1)(x2+x+1)(x?+r3+1)(x+x?+1)
(x+b)(3+s+1)(x3+x2+1)? 28
29 (x+1)(x+#+…+x+1)
30 (x+1)2(x2+x+1)2(?+x+1)2(x?+x3+3)(x?+x3+x2+x+1)2
(z+1)(?+x2+1)(3+3+1)(?+x3+x2+x+1)(x?+x+2+x+1)(z?+x?+x3+x+1)(x3+x? 31 ◆3+x2+1)
例8.9 这里利用表8.1列出码长为7的所有可能的二进制码。根据表8.1,x2-1可以分解
为三个不同的不可约因式：x?-1=(x+1)(x3+x+1)(x3+x2+1),因此x1-1具有Z3=
8个不同的因式g(x)。这就得出了下面的列表：
(n,k) g(x) 注 赛
(7,7) 1 无奇偶码
(7.6) *+1 全奇偶校验码
(7.4) x3+x+1 汉明码
(7,4) 3+x2+1 汉明码
(7,3) (x+)(x3+x+1) 例8.2中的码
(7,3) (x+1)(x3+x2+1) 例8.2中码的“反转”
(7,1) (x3+x+1)(x3+x2+1) 重复码
(7,0) x2+1 无信息码
例如，我们判断g(x)=x3+x+1的(7,4)循环码是汉明码。为证明这一点，注意到它的
一致校验多项式是(x?+1)/(x3+x+1)=x?+x2+x+1。因此根据定理8.3的推论1,这
个码的一个一致校验矩阵为：
=8
可见H的列非零且互不相同，因此根据7.4节的定义，它确实是一个汉明码。我们将其
他“注释”的证明留做习题8.23。
;十：·业
138 信息论与编码理论(第二版)
在例8.9中，我们看到g(x)=x3+x+1生成了一个(7,4)汉明码。但是根据表8.1,g(x)
不仅能整除x?-1.而且还能藜除x?-1,实际上，对于任意7的倍数n,x3+x+1lx"-1(见
习题8.24)。因此根据定理8.3(b),g(x)生成了整个一类循环码，它们具有参数(7,4),(14,
11),(21,18),…。然而除了第一个码以外，其余的码都含有一个生成函数为x2-1的码字，即
码的最小重量等于2。因此这些码对错误纠正是没有意义的。一般称它们为反常循环码(见
习题8.26)。在本章的剩余部分中，当我们提到生成多项式为g(x)的(n,k)循环码时，都假设
它是一个正常循环码，也就是说，它的n是使g(x)lx2-1成立的最小正整数。这个正整数有
时被称为g(x)的周期，因为它是序列[x' mod g(x)];的周期。(习题8.27是有关一致校验
多项式周期小于n的循环码的讨论。)建立了这个约定以后，我们将进一步研究循环码。
8.2 循环码的移位寄存编码器
根据定理8.3我们知道，每个循环码都可以由它的生成多项式确定，这就可以理解为什么
循环码比任意线性码更容易实现了。在本节中将证明，实际上任意循环码的编码都可以通过
一个称为移位寄存编码器的简单有限状态机来实现。
回忆一下(n,k)线性码的编码算法，不论码是否是循环的，都足将长度为k的信息序列
(Io,I…,)集合泱射为码长为n的码字(Cn,C?,…,Ca-1)集合的一种规则，或者等价地，
是映射信息多项式I(x)=Io+Ix+…+I-|x-'集合到码多项式C(x)=Co+C?x+…+
Cx-1x'集合的--种规则。如果码是循环的，定理8.3告诉我们，C(x)是一个码字的充分必
要条件为C(x)是g(x)的倍式，因此，正如在定理8.3的推论1中所看到的，将信息多项式
I(x)映射为码多项式的一个简单方法，是将(x)乘以g(x):
I(x)→I(x)g(x) (8.2)
而利用某种被称为移位寄存器逻辑的方法，很容易实现多项式乘法，现在就简单研究一下
这个专题2
图8.1是一个电路的抽象表示，它能够实现任意多项式I(x)乘以一个固定多项式g(x)
的乘法。在说明这个电路的功能之前，我们最好解释一下它的各个元件。
输出
K 8 2 品1 8,
物入.
图8.1 一个乘以g(x)=gu+gx+…+g,x的移位寄存器电路，或者说，这是
一个生成多项式为g(x)的(n,K)循环码的编码器，g(x)中的r=R-t
图8.1中的电路是由三类元件连接在一起构成的：触发器、加法器和常数乘法器。其中最
重要的是触发器，有时也称为延时元件：
解发器
第8章 循 环 码 139
触发器是一个能够存储域F中某个元素的器件。这里还有一个重要的组成部分，在我们
的简化电路图中并没有画出，这就是能够每隔。秒产生一个时间信号的外部时钟3。当时钟
输出信号时，触发器的内容沿箭头方向移出触发器，通过电路直达下一个触发器。并在这里停
止，直到下一个时钟信号到米。移位寄存器的内容可以被相邻触发器之间的电路改变，这些电
路就是接人其他两种逻辑元件的地方。双输人加法器如下图所示：
加法器
它是一种对两个输入信号求和的设备。(电路的设计必须保证每经过一个时钟周期，加法器的
每个输人都恰好收到一个信号，所以加法器的输出总是明确的。)最后介绍最简单的电路元件，
常数乘法器：
a
常数乘法器
这个设备简单地将它的输人乘以常数a,没有延迟。
现在来看一下为什么图8.1的电路可用于实现多项式乘法。首先详细写出乘积C(x)=
Co+Cx+…+Cn-1x1系数的公式，其中 C(x)=1(x)g(x):
Co=log0
C=log1+I80
C?=log2+I81+I?80
…
C=10g,+I18-1+…+Ijg0
;··
Ca-1=I 1g,
(8.3)
图8.1中触发器的初始内容为0。下面按输人箭头方向向移位寄存器中输人序列I?,…,I-,
并附加=n-k个0,每个时钟周期输人一个比特。现在研究一下在每个时钟周期内电路的
工作状态：
时钟周期0 输人：1。
移位寄存器内容：[0,0,0,…,0]
输出：10go
时钟周期1 输人：I
移位寄存器内容：[1?,0.0,…,0]
输出：lg?+I?go
:
时钟周期 输人：
移位寄存器内容：[I.,…,I?J?,….0]
.k!
140 信息论与编码理论(第二版)
输出：log;+I?8j-1+…+/80
时钟周期n-1 输人：0
移位寄存器内容：[0,…,0L-1]
输出：I-1g,
因此如果电路图8.1中触发器的初始内容是，个0,并给出n个符号的输入序列(I?,I?,…,
1.0,…,0),则输出确实是(Cn,C,…,C..1),其中C,由式(8.3)定义，所以这个电路可以用
做生成多项式为g(x)的循环码的编码器。
注意 上面描述的是一种“通用”移位寄存器电路，它可以实现任意城F上的运算。需要的设备〔触发器、
加法器、乘法器)并不是“现货供应”的器件。但是如果只考虑城GF(2),这些设备确实非常简单：
触发器 = D触发器
加法器 = 异或门
0乘法器 = 不连换
1柬法器 = 直接连线
例8.10 正如我们在例8.6中看到的，例8.2中(7,3)二进制循环码的生成多项式为g(x)=
x?+x3+x2+1。相应的移位寄存编码器如图8.2所示。如果(Io,I?,I)是将要进行编码
的三个信息比特，则四个触发器的内容应该初始化为0,而编码器的输入为7个比特(I?,
I,I?,0,0,0,0)。这7个输入比特将产生7个输出比特(Co,C?.Cz,C?,C?,Cs,C),就是
相应的码字。例如，如果信息比特为(1,0,0),那么相应的码字将是“冲激响应”(1,0,1,1,
1,0,0),这实际上就是生成多项式1+x2+x3+x?(也是例8.2中的码字C,)。
粉出
渤入 1 2 3 4
图8.2 生成多项式为g(x)=1+x2+x3+x的(7,3)循环码的非系统编码器
图8.1和图8.2中的编码器已经是最简单的了，但遗憾的是，它们是非系统的，就是说，信
息比特(1,I,…,1.1)并没有不变地出现在相应的码字(Co.C,…,Ca-1)中。但是，对任意
循环码都可以设计出系统的移位寄存编码器，它只比非系统的编码器略微复杂一点。思路是
利用定理8.3中推论2的结论，即如果7(x)是一个信息多项式，则
(x)一xl(x)-[xI(x)]mod g(x} (8.4)
是一个生成多项式为g(x)的循环码的系统编码规则。这种编码器的中心部件是一个“mod g(x)”
电路，其中g(x)为码的生成多项式。图8.3(a)描述了一个这样的电路，其中g(x)=x+
6-1x?1+…+80c
为了解图8.3(a)的电路是如何实现“mod g(x)”运算的，我们将注意力集中于移位寄存器
的内容[30,s,…,s.](称之为状态矢量),以及相应的生成函数S(x)=so+81x+…+&-x
:
第8章 循 环 码 141
(称之为状态多项式):下面这个引理解释了作为一个输人的响应，状态是怎样变化的。
引理3 如果困8.3(a)中的电路具有状态多项式S(x),而输入是s,那么下一个状态多项
式将是：
S'(x)=(3+xS(x))mod g(x)
证明：如果当前状态矢量为S=[so,…,8,_],而输入为s,则根据我们对电路组成模块功
能的描述，下一个状态矢量将是：
S'=[s-808-1,50-81S-1,…,82-&/-15y-1]
因此下一个状态多项式是：
S'(x)=s+snx+…+s-zx2-1-s-i(8o+gIx+…+&-jx'1)
=S+xS(x)-sp-18(x)
可见S(x)是一个次数<degg(x)的多项式，它使(s+xS(x))-S(x)成为g(x)的一个
倍式，根据引理1{c),有S(x)=(s+rS(x))mod g(x)。
-81 -8 -8
输入 0 1 4-
(a)
输入-
(b)
图8.3(a)一个通用的“md g(x)”移位寄存器电路，其中g(x)=x'+g/-1x?1+…+g0
(b)一个具体的“modx?+x3+2+1”移位寄存器，其中所有运算都是mod2的
定理8.4 如果图8.3(a)所示电路的初始设置为so=s?=…=3,-1=0,并且给定输入序
列aa,a,a2,…(在第0个时钟周期翰入a,在第1个时钟周期输入a?,等等),则在第：
个时钟周期之后，状态多项式为：
s)-_x-mad ge)
证明：我们对：采用归纳法。对于t=0,1,…,r-1,状态矢量为：
s,={a,
定理显然成立。然后假设定理对S?(x)成立，来考虑S?1(x):
和. !,
142 信息论与编码理论(第二版)
S+1(x)=a+I+x5;(x)mod g(x)(引理3)
m+(madsea)mod gu) (归纳假设)
=m+)modgs[引理I(d)}
∑ax+-/mod gux) [引理1(a)和(c)]
证明定理成立
定理8.4解释了为什么图8.3(a)的电路被称为“md g(x)”电路。我们的下一个目标是
利用它，以及编码规则(8.4)式，来构造一个生成多项式为g(x)的循环码系统移位寄存编码
器。编码规则(8.4)式需要计算：
KTa)modgtu)-2xmodgtu)
根据定理8.4,可以给出mod g(x)电路n个符号的输人序列：
(1,m.o,)
由于一个系统编码器从时钟周期0到k-1不变地输出k个信息符号，所以应该从第k个时
钟周期开始输出一致校验符号.即[x'I(x)]mod g(x)的系数，但是实际上将不得不再等待r个
时钟周期，才能计算出[xI(x)]mod g(x)。幸运的是，通过采用图8.4(a)的电路，可以避免这
,个时钟周期的"停歇时间"。
在图8.4(a)的电路中，输入比特从右侧送入移位寄存器，而不是像图8.3那样从左侧输
人。这样如果输入流是a,a…,则r个时钟周期之后，移位寄存器的状态多项式将是
∑j_oax*?'mod g(x),而不是∑j-oux1?mod g(x)。(习题8.31将证明这个结论。)因此如
果编码器输人k个信息符号/I-1,…,I。到图8.4的移位寄存器，则[xT(x)]mod g(x)的
系数正如所需要的那样，将在第k个时钟周期开始时推备好。图8.5(a)所示的是一个基于
图8.4(a)中移位寄存器的完整系统码编码器。注意与图8.1的非系统编码器相比，在图8.5(a)
的编码器中，信息符号以反序L?…,1。输人编码器，而码字元素也以反序Ca-1,Ca-2,…,
C,Co输入到信道中。
例8.11 如果将图8,5(a)所介绍的通用结构应用于域GF(2)上g(x)=x?+x3+x2+1这种
特殊情况，我们将得到图8.5(b)所示的编码器。例如，如果信息序列(I?,I.Ia)=(1,1,
0),并加上(0,0,0,0)作为图8.5(b)编码电路的输入序列，则输出将是(1,1,0,1,0,0,1),
详细过程如下表所示
第8章 循 环 码 143
时钟周期 输 入 答位寄存婚内窘 输 出
0 1 1011
1 L 0101
2 0 1001 0
3
4
5
6
0 0100) I
0 00L0 0
0 000L 0
0 0000 I
-品 8 -品
s 年
输入 4a)
精入
(b)
图8.4(a)对于一个生成多项式为g(x)=g+gx+…+gx的循环码，其π时钟周期
系统码编码器所需要的通用秽位寄存器。(b)特殊情况g(x)=x?+x?+x2+1
开关A:前个时钟周期闭合
后个时钟周期断开
A
-8 8 各 -1
B
输出
开关B:前个时钟周期内下
后叶时钟周期向上
{a)
前3个时钟川期闭合
G4个时钟同期听开
— 物出
输入- 前3个时钟周期向下
后4个时钟周期向上
tbj
图8.5(a)…个生成多项式为g(x)=gu+g?x+…+g-1x'+x'的循环码
的n时钟周期系统码编码器。(b)特殊情况g(x)=x?+x3+x2+!
;名。。…的…………… h…5………………6…e…………………………………………………………………………
144 信息论与编码理论(第二版)
注意码元是以反序出现的，我们发现这个码字与例8.2中的码字C+C?相同。
在结束本节之前，将简单讨论一下循环码的第三类移位寄存编码器，它基于码的一致校验
多项式。回忆一下8.1节，如果C是一个(n,k)循环码，具有生成多项式g(x),则它的一致校
验多项式h(x)=ho+h?x+…+hx*定义为：
x)=g) (8.5)
根据定理8.3,每个码字C(x)都是g(x)的倍式，因此由式(8.5)得出C(x)h(x)是
g(x)h(x)=x^-1的倍式，即，
[C(x)A(x)].=0 (8.6)
下面的定理说明，式(8.6)对码宇C(x)的系数C,具有很强的约束。
定理8.5 对于i=0,1,…,n-1、有：
LCcn=0
证明：我们有，
ac-(～)()
-c2)
如果利用mod(x°-1)来降低这个表达式的次数，再利用条件x mod(x°-1)=x(见
例8.4),会发现：
tmacn-c) (8.7)
根据式(8.6),[h(x)C(x)]。=0,得出[h(x)C(x)]。的各个系数也都为0。但是由式(8.7)
可以得出，对于i=0.1,…,n-1,[h(x)C(x)]。中x的系数为：
{c}中x3的系数
如果 m∈10,1,…,n-1|,则指数(j+m)mod n等于i的充分必要条件是m=(i-j)mod n
(见习题8.4),因此[h(x)C(x)].中x的系数为：
LC-
它必然等于0。
推论 如果ho=1,则对于i=k,k+1,…,n-1,
c=-tc,
第8章 循 环 码 145
证明：如果k≤i≤n-1,则对于j=0,1,…,k,我们有(i-j)mod n=i-j,定理8.5变为：
hC-)=0
如采ho=1,重新整理最后这个式子，枕可以得到前面的结论。
定理8,5的推论说明了，一旦知道了某个码字的前上个码元C,C,…,Ck-1,就可以通过
线性递归计算出剩下的，个码元C,C+1,…,C-1,即每个新码元都是它前面k个码元的一
个固定线性组合。由这个结论可以立即导出一个移位寄存编码器，这是因为实现线性递归计
算的移位寄存器电路很容易设计；见图8.6。
, -h h, -h
2 S
(a)
(b)
图8.6(a)一个实现k阶线性递归S?=-Z$=1h,S-,的移位寄存器
电路。(b)特殊情况S?=S-1+S-y,对应于h(x)=1+x2+x
图8.6(a)给出了一个k级移位寄存器电路，它能够产生满足线性递归S=~Z=; h,S?-,
的任意序列(S?,S?,S?,…),其中h,h?,…,h为固定常数。开始时必须在电路的无个触发
器中存人民个初始值S?,S?…,S-(S。在最右边的触发器中)。然后，对于：k,如果移位寄
存器的内容是(S,_…,S_),则在下一个时钟周期后，移位寄存器的内容将变为(S?,S?-,…,
S,-t+1)。图8.6(b)显示了一个h(x)=x3+x2+1的特殊情况，对应于二进制域GF(2)上，t≥3
时的递归S,=S,_2+S-30
现在应该清楚如何利用图8.6(a)的移位寄存器电路，构造一个具有一致校验多项式
h(x)=1+h?x+…+h,x*的循环码系统编码器了[见图8.7(a)]。在前k个时钟周期内，开关
处在“向下”的位置，k个信息符号输人k级寄存器，同时也输人信道。然后开关放在“向上”的
位置，在剩余的，个时钟周期内，移位寄存器电路利用递归C=-Cj=1 hyCl-,计算剩余的r
个码元。注意图8.7的系统“h(x)编码器”与图8.5的系统“g(x)编码器”相比，有两个重要的
不同之处：在g(x)编码器中，信息符号(1o,I,…,L-1)填充码元C,,C,+1,…,Ca-1,码字符号
小i
;…………
146 信息论与编码理论(第二版)
以反序(C?,C-2,…,Co)输送到信道中，而在h(x)编码器中，信息符号填充码元 Co,C?,…,
C_,码宇符号以自然顺序C,Ci…,C。1输送到信道中。
例8.12 如果将图8.7(a)的通用结构，应用于一个g(x)=x?+x3+x2+1,h(x)=x3+x2+1
的(7,3)循环码，会得到图8.7(b)所示的编码器。假设信息符号为(I,I?,I?)=(1,1,0),
图8.7(b)的编码器实现递归C=Ci-2+C_,,并产生码字(1,1,0,0,1,0,1),这就是例8.2
中的码字C+C?+C?。另外注意这个码的g(x)编码器，如图8.5(b)所示，需要4个触发
器和3个mod-2加法器，而图8.7(b)的h(x)编码器仅需要3个触发器和1个mod-2加法
器。作为一个通用规则，当k<r,即k<n/2时，h(x)编码器会更筒单。
前4个时钟阁期：向下
Fr个时钟周期：向： h, h? -h
输入- ·……—一输出
()
i前3个时钟周期：向下
后4个时钟周期：向上
{b)
图8.7(a)一致校验多项式为h(x)=l+hx+…+hx?的(n,k)循
环码的系统移位寄存编码器。(b)特殊情况 h(z)=I+x3+x3
8.3 循环汉明码[4]
在7.4节中，我们定义码长为2"-1的二进制汉明码，其一致校验矩阵由2"-1个长度为
m的非零二进制列矢量组成，这些列可以按任意顺序排列。例如，下面的一致校验矩阵定义
了一个(7,4)汉明码(参照7.4节中的矩阵H?): “-
显然这些列有(2”-1)!种排列方式，虽然这些排列中的任何一种都能产生一个完备的纠正单
个错误码，但是从应用的角度来看，某些排列优于其他的排列。实际上在本节中我们将要看
到，可以选择一种使汉明码具有循环特性的排列，以便通过简单的移位寄存器实现编码器和译
码器，为了描述这种排列，我们假设读者已经熟悉有限域 CF(2")等基本概念，在这个域中每
个元素都可以由一个长度为m的二进制矢量表示。(在附录C中简单概括了所需要的知
识。)
i
第8章 循 环 码 147
为了得到码长为2”-1的一个循环汉明码，首先从一个本原根a∈GF(2")开始，利用它
定义如下线性码C。元素属于GF(2)的矢量C=(Cn.C,…,C-1)“在C中，当且仅当，
Co+Ca+…+Cx-iz-I=0 (8.B)
或者，码C是由下面1×n阶一致校验矩阵所定义的二进制线性码。
H=[1 a a2 .. α"-1] (8.9)
很快将证明，由式(8.8)或式(8.9)定义的码是一个循环汉明码。但是现在需要注意的是，这个
定义中的码元属于二进制域GF(2),而一致校验矩阵中的元素属于扩展域GF(2")。后面将
看到，采用这种“双域”定义方法具有很多优点。当然通过更方便的(也是更复杂的)二进制一
致校验矩阵同样可以定义这个码，方法是将H中每个。的幂替换为相应的m比特列矢量。例
如对于m=3,如果α是GF(23)中的一个本原根，满足a3=α+1,则表8.2列出了表示α幕的
三维矢量。因此式(8.9)中的1×7阶GF(8)矩阵H,与下面的3×7阶二进制矩阵H'定义了
相同的二.进制码： "=
表8.2 GF{8)中α的幂，其中α?=α+1
i
0 001
1 010
2 100
3 011
4 110
5 1J1
6 101
下面的定理是本节的主要结论。
定理8.6 上面定义[即由式(8.8)或式(8.9)定义]的码，是一个生成多项式为g(x)
(g(x)是a的最小多项式)的(n,n-m)二进制循环码，并且是一个最小距离为3的汉明码。
证明：显然，这个码是一个码长为n的二进制线性码。需要证明它是循环码，并且以g(x)
为生成多项式。为了证明它是循环码，注意如果将式(8.8)乘以a,并利用条件α2=1,就
可以得到；
Ca-1+Coa+…+Cn-za"-2=0
显然如果C满足式(8.8),则C"也满足，因此该码是循环的。为了证明g(x)是生成多项
式，我们注意到式(8.8)等价于C(a)=0,其中C(x)=Co+Cx+…+C?x-1为码多项
式，并观察到该式成立当且仅当C(x)是a最小多项式g(x)的倍式。可见该码包含了所
有次数≤n-1且为g(x)倍式的多项式，因此根据定理8.3,g(x)是码的生成多项式。
最后需要证明的是，码的最小距离d为3。因为码是线性的，所以dL=w。利用定义
(8.8)式；如果存在一个重量为L的码字，则对于某个i,a3=0,而这显然是不可能的。类
.e
148 信息论与编码理论(第二版)
似地，存在一个重量为2的码字的充分必要条件是，对于某个i和j(这里U≤i<j≤n-1).
有a+α=0。将该式除以a2,变为1+α?1=0,而这也是不可能的，因为使a=1的最小
正整数r是n。最后，注意到存在很多重量为3的码字；例如，如果I+a=α,则存在一个
重童为3的码字，它的非零码元是Co.C?和C;。
既然已知道存在循环汉明码，则根据8.2节的结论，利用汉明码的生成多项式，可以构造
简单的移位寄存编码器。由于汉明码的生成多项式一定是一个本原多项式，为了构造一个码
长为2"-1的循环汉明码，必须寻找一个m次本原多项式。在表8.3中，对于l≤m≤12,我
们各列出一个m次本原多项式。给定一个m值，通常会有多个m次本原多项式，但表8.3中
所选的是具有最少非零系数的那些本原多项式，这可以使移位寄存编码器中的mod-2加法器
数目最少。
表8.3 可以作为汉明码生成多项式的一些本原多项式
m m次本原多项式
x+L
2 x2+x+1
3 +s+1
4 r+#+
5 x3+2+1
6 ?+x+]
7 x?+*+1
8 x?+x2+x2+x+1
9 r?+x?+1
10 x10+x3+1
11 z"+x2+1
12 #1+x?+x?+x+1
实际上，比简化汉明码编码更重要的，是构造它们的简单译码器。在图8.8中，我们描述
了一个生成多项式为g(x)=x3+x+1的(7,4)汉明码的译码器。这个译码器主要包括三个
部分，即两个移位寄存器电路和一个与门。上面的移位寄存器是一个“mod g(x)”电路，下面
的移位寄存器是一个“mod(x"+1)"电路。如果上面的移位寄存器包含图案10...0,与门就输
出1,其他情况则输出0。我们假设传输码字是C=(Ca,C?,…,C-1),而接收到的是R=(Ro,
R?,…,R._),并且R=C+E,其中E=(En,E?,…,E-1)是错误图案。
在图8.8的译码电路中，噪声码字(R?,R?,…,Ra-1)按时钟从左侧以反序输人(即Ra-1在
最前面),因此(根据定理8.4)经过n个时钟周期之后，上面的移位寄存器内容是R(x)mod g(x),
下面的移位寄存器内容是R(x)mod(x2+1),即(Ro,R,…,R-1)。由于R(x)=C(x)+E(x),
而C(x)mod g(x)=0(因为C(x)是一个码字),所以实际上，上面的移位寄存器内容是
E(x)mod g(x)。如果没有错误，即E(x)=0,上面的移位寄存器内容是全0。如果在第e个位
置有一个错误，则E(x)=x',其中0≤e≤n-1。
2!
第8章 循 环 码 149
modg{x)电路
开关A: 与门：10..0识别器
前n个时钟周期闭合
后n个时钟周期断开
开关B:前个时钟周期听开
后H个时钟周啉闭合
mod(x+1)电路
图8.8 生成多项式为g(x)=x3+x+1的(7,4)汉明码的一个译码电路
此时，开关A断开，开关B闭合，两个移位寄存器再自动运行 n个时钟周期。我们称这n
个时钟信号为译码周期。在译码周期结束时，如果最多存在一个错误，则原来的码字C(x)将
出现在下面的移位寄存器中。下面来看一下为什么会是这个结果。
在译码周期的第：个时钟周期之后，上面移位寄存器的内容将是x'E(x)mod g(x),而下
面移位寄存器的内容将是xR(x)mod(x"+1),即接收码字的第1次右循环移位(R-,…,
R-.-):这两个移位寄存器通过与门和开关B连接，当且仅当上面的移位寄存器内容是
10...0时，即当且仅当x'E(x)mod g(x)=1时，与门输出1。如果没有错误，即E(x)=0,与门
将一直不被触发，在译码周期结束后，下面的移位寄存器内容是没有变化的接收码字。但是如
果存在一个错误，并且在第e个位置上，即E(x)=x°,则在译码周期的第(n-e)mod n个时钟
周期之后，上面的移位寄存器内容将是x-x°nod g(x)=x" mod g(x)=1(因为g(x)是x"-1
的一个因式)。此时下面的移位寄存器内容是(R,R+,…,R?),因此在下一个时钟周期，与
门将输出一个1,并改变接收码字的错误码元R,即纠正错误。然后再经过(e-1)mod n个时
钟周期，接收码字将完成它在下面移位寄存器中的循环移位，这时错误已被纠正，正确的码字
出现在下面的移位寄存器中。
在8.5节中，我们将介绍如何推广图8.8的电路，以构造一个纠正突发错误循环码的译码
器。8.4节则将首先介绍纠正突发错误的基本理论。〔顺便提一句，循环汉明码的对偶码也具
有重要意义，习题8.41将进行简要介绍。)
8.4 纠正突发错误
在很多具有实际价值的信道上，经常出现的是突发错误。物理上，突发错误是因为某种原
因信道噪声在短时间内急剧增加，然后又恢复正常而产生的。本节中，将介绍如何利用循环码
来检测和纠正突发错误。
首先对突发错误做一个纯数学的定义。假设发送一个码字C,并接收到R=C+E,那么
如果E的非零分量集中在b个连续位内，则称错误矢量E是一个长度为b的突发。例如E=
(010000110)是一个长度为7的突发：
0iooooii0
(在这个表示中，*标记着错误突发。)因为我们要利用循环码来纠正突发错误，所以出于技术
上的考虑，还需要定义循环突发。如果一个错误矢量E的非零分量集中在b个循环连续位
内，就称它是一个长度为b的微环突发。例如，前文所述的长度为7的突发错误矢量E=
150 信息论与编码理论(第二版)
(010000110),也可以看做是一个长度为5的循环突发：
o1o?01i0
在本节的剩余部分中，“突发”就意味着“循环突发”。
详细地描述突发错误矢量是有意义的，因此我们引人突发图案和位置的概念。如果E是
一个非零突发错误矢盘，它的突发图案就是一个从E中的第一个非零符号开始、到最后一个
非零符号结束的符号串。而突发位置是突发中第一个非零符号的标号。例如，当矢量E=
(0L0000110)被看做一个长度为7的突发时，具有突发图案1000011和突发位置1(假设分量标
号为0,1,…,8)。遗憾的是，对大多数矢量而吉，“突发图案-突发位置”的描述并不是惟一的，
因为E中的任意非军符号都可以看做是循环突发中的第一个符号。因此一个重量为w的错
误矢量将有o种突发描述。例如，E=(010000110)有三种突发描述：
图 案 位 量
1000011 1
1L001 6
ID0I00001 7
这种歧义虽然麻烦，但通常并不严重，因为实际中发生的可纠正突发一般都非常短，而正
如下面的定理所要证明的，一个短突发可以只有一种简短的描述。
定理8.7 设E是一个长度为n的错误矢量，具有两种突发描述(图案1,位置1)和(图案2,
位置2)。如果图案1的长度+图案2的长度≤n+1,则这两种描述是相同的，即困案1=
图案2且位直1=位置2。
证明：如上所述，如果E的重量为w,则E恰好有w种不同的突发描述。如果 0=0或1,
结论无需证明，因此我们假设0≥2。
给定E的一个突发描述，困案一定包含了E的所有非零分量，而图案中没有电含的E中
分量形成了一个0的循环段，从困案中最后一个非零分量后开始，并一直持续到图案中第
一个非零分量前结束。对应给定的突发描述，我们称这个0循环段的标号集合为零段。
例如，对于E=(010000110),在前面已经看到，它有三种突发描述。在第一种描述中，困案
是1000011,它从位置1开始直到位置7结束。因此对应这个突发描述的零段为(0,8)。
可见总共有3个本段，分别对应于E的三种突发描述：
图 案 位 置 学放
L000011 1 (8?D)
11001 6 (2.3.4,5)
100100001 7 无
(在最后一种突发描述中，零段是空的，我们以“无”表示它。)显然，对应于不同突发描述的零段
是互不重叠的，因此掌段的长度总和为n-w,其中w是E的重量。为了证明定理，注意到如
采E的两种突发描述
(图案1,位置1)和(图案2,位置2)
第8章 循 环 码 151
是不同的，则由于它们的零段互不重香，故这两个零段对应于E中的(n-图案1的长度)+
(n-图案2的长度)个0。但是因为图案]的长度+图案2的长度天n+1,所以这个数目
n-1,与E的重量≥2的假设矛盾。因此这两种突发描述必然是相同的。
推论 一个错误矢量E最多只可能有一个长度≤(n+1)/2的突发描述。
证明：两个不同的长度≤(n+1)/2的描述将与定理8.7矛盾。
根据定理8.7,现在可以计算给定长度的突发图案的数自：
定理8.8 如果1≤b≤(n+1)/2,则在2-字符表上恰好存在 n2-3+1个长度为n的矢
量，其突发长度≤b
证明：根据定理8.7的推论，如果b≤(n+1)/2,长度为b的非军突发〔(作为一个长度≤b
的突发)具有惟一的描述，位置有n种可能。图案必须以1开始，且长度≤b,这意味着可
能的图案与以1开头、长度为b的z-1个二进制串是一一对应的。因此存在2?-1种可能
图案，总共有n2-1种长度≤b的非零突发。这个数值再加上代表全零突发的1,就得到
nz-1+1,定理得证。
下面的两个定理给出了纠正突发错误码参数的有价值的界。为简单起见，我们称一个能
够纠正所有长度≤b的突发错误图案的码为纠正b长突发错误码。
定理8.9(纠正突发错误的汉明界。)如果1≤b≤(n+1)/2,一个二进制纠正b长突发错
误码至多包含2"/(n2-1+1)个码字。
证明：根据定理8.8,长度≤b的突发错误图案共有n26-1+1个。如果码中有M个码字，
那么对应这些码字，有M(nz*~1+1)个字与它们相差一个长度≤b的突发。并且这些宇
必须都是不同的，因此M(n2-1+1)≤2”。
推论(Abramson界)如果1≤b≤(n+1)/2,则一个纠正b长突发错误的二进制(n,k)线
性码必须满足：
≤2-h+1-1(强Abramson界)
其中r=n-k是码的冗余。另外一个公式为：
r[log?(n+1)]+(b-D)(弱Abramson界)
证明：一个线性(n,k)码有M=2个码字，因此根据定理8.9,2?≤2/(nz?1+1)。重写
该式，我们得到n≤2*1-2-+'。因为n必须是一个整教，所以这个界可改写为 n≤
2--1,这就是强Abramson界。重写该式得到r的界，即弱Abramson界。
定理8.10 如果b≤n/2,则一个纠正b长突发错误的二进制码至多包含2"-26个码字。
证明：如果M>2*-26,则根据分类原理，一定存在两个码字，它们的前n-2b位是相同的。
这两个码字可以用图示法做如下表示：
x=AAAAA Y=***BBBBBB
;诚.!
152 信息论与编码理论(第二版)
其中“*”代表相同位，A和B是任意的。而宇
Z=********AAABBB
与X和Y都相差一个长度≤b的突发，这就产生了矛盾。
推论(Reiger界)如果0≤b≤n/2,则一个纠正b长突发错误的二进制(n,k)线性码必
须满足：
r≥2b
其中r=n-k为码的冗余。
证明：(n,k)二进制线性码中的码宇数目是2,根据定理8.10,它必须≤2-26。这与推论
所述等价。
现在将要讨论一系列纠正突发错误码的例子。在每个例子中，码都是循环的，并且满足强
Abranson界或者Reiger界(对所有线性码都适用，不仅仅是循环码)。在讨论中，当提到一个特
定的界(Abramson界或者Reiger界)是紧的时，就意味着存在一个码，它的冗余等于界的值。如
果不存在这样的码，我们就称这个界是松的。
例8.13 g(x)=x-1+x?2+…+x+1的(n,1)二进制重复码(其中n是奇数),可以纠正所
有重量≤(n-1)/2的错误图案，所以是一个纠正((n-1)/2)长突发错误码。又因为r=
n-1,所以Reiger界是紧的。
例8.14(n,n)码包含码长为n的所有可能的码字，是一个g(x)=1的循环码。它是一个
(无价值的)纠正b=0长突发错误码，因为┌也等于0,所以Reiger界还是紧的。
例8.15 任意二进制汉明码[n=2"-1,r=m,g(x)为一个m次本原多项式]是一个纠正
b=1长突发错误码。(任意重量为1的错误矢量都是一个长度为1的突发。)对于所有这
些码，强Abramson界是紧的。
例日.16+ 任意一个删除了奇数重量码字的循环汉明码，是一个纠正b=2长突发错误码，被
称为Abrameon码。这些码是生成多项式具有形式g(x)=(x+1)p(x)的循环码，其中
p(x)是一个本原多项式。(见习题8.55。)最小的Abamon码是(7,3)循环码，具有g(x)=
(x+1)(x3+x+1)和一致校验矩阵：
H=(iifii)
其中a是GF(8)中满足方程a3+a+1=0的一个本原根。为了证明这个码确实是一个纠
正b=2长突发错误码，需要验证所有长度b≤2突发的伴随或各不相同。对于b=0(全
)。对于b=1的情况，一个描述为(1,i)的突发具有伴 零错误困案)的情况，伴随式为|
1)。 对于b=2的情况，一个描述为(11,i)的突发具有伴随式 随式 a+1)。这
1+2n个伴随式各不相同，因此该码确实是一个纠正b=2长突发错误码。最后注意，如
果g(x)=(x+1)p(x),其中p(x)是一个m次本原多项式，则n=2"-1,7=m+1,而
b=2,因此强Abranson界是紧的。[考虑m=3,即(7,3)码，它的b=2,Reiger界也是紧
第8章 循 环 码 163
的，但是对于所有更大的m值，Reiger界却是松的。]
例8.170 可以证明生成多项式为g(x)=(x?+x+1)(x2+x+1)=x?+x?+x?+x3+1的
(15,9)二进制循环码，是一个纠正b=3长突发错误码。对它来说，强 Abrameon 界和
Reiger界都是紧的。为了证明这一点，我们利用一致校验矩阵：
H=(Iaa2…)
其中a是GF(16)中满足a?+α+1=0的一个本原根，w是GF(16)中满足w2+u+1=0
的一个三阶元素，现在要验证一下所有长度b≤3突发错误的伴随或各不相同。
()。对于b=1的情况，一个描述为(1,i)的突发具有伴随式)。 全零图案具有伴随式
(+))=),因为1+ 对于b=2的情况，一个描述为(11,i)的突发具有伴随式
a=a?,而l+w=w32。对于b=3的情况，有两种可能的困案，即101和I11。一个描述为
+2)=),因为1+a2=α?,而1+w2=0;一个描述为 (101,i)的突发具有伴随式
(+a+2)=(a”0),因为1+a+a2=a°而1++2=0 (111,i)的突发具有伴随式
显然全军图案和111困案不会与其他的混清，因为伴随式中的第二个元案为“0”。若要区
); 分图案1,11和101,需要做进一步研究。对于所有这三个图案，伴随式形式为 ;为了
区分它们，观察(s-t)mod 3。如果图案为1,则s=i,t=i,因此(s-t)mmod 3=0;如果图
案为11,则s=i+4,t=i+2,因此(s-B)mod 3=2;而如果图案为101,则s=i+8,t=
i+1,因此(s-r)mod 3=1。可见长度≤3的61个突发，它们的伴随式各不相同，下表总
结了突发摘述与伴随式之间的关系。
件随式 实发插述
()
) (111.s-L0 mod 15)
) (1,) 如果(s-t)md 3-0
(101,x-8mod 15) 如果(s-t)mod3=1
(11,s-4 mod 15) 如采(s-1)mod 3=2
)
具有s=11,t=0,因此它对应于突发描述(11.7),相应的错误图案为 例如，伴随式
(000000011000000)。
·i:1
……………………………9……5…………。……2………………-,、
154 信息论与编码理论(第二版)
例8.17的数学讨论比较复杂且不易推广。(见习题8.63。)但是这些年来，研究者们已经
成功地找到了大量纠正突发错误循环码，它们都能达到强 Abramson界。这些码通常称为最佳
纠正突发错误码。在表8.4中列出了许多这样的码。
表8.4 一些达到强Abramsn 界(即满足 n=2'-D+1-1)的纠正突发错误循环码
生成多项式 (n,k) b
(x3+x+J)(x+1) (7,3) 2
(x?+x+1)(x+1) (15,10) 2
(x?+x+1)(x2++1) (15,9) 3
(x?+x2+1)(x+1) (31,25) 2
(x?+x+1)(x+1) (63,56) 2
(?+x+1)(x2+x+1) (63,55) 3
(x?+x+1)(x+1) (127,119) 2
(t+*'+2+x+1)(x+1) (255.246) 2
(x?+x1+x2+s+1)(x2+x+1) (255,245) 3
(x?+x3+x?+x3+x2+x+1)(x+1) (511,501) 2
(x?+x?+t?+r3+2+x+D(r3+x+1) (511,499) 4
(x10+?+r3+x2+1)(+1) (1023,1012) 2
(x+x3+x3+x2+1)(x2+x+1) (1023,1011) 3
(x"+x?+x3+x2+1)(x2+x+1)(z+1) (102,1010) 4
(t"+x+1)(x+1) (2047,2035) Z
(x2+x1+x?+?+x3+x3+x2+x+1Hx+1) (4095,4082) 2
(x2+x"+x3+?+x2+3+x2+x+1)(x2+x+1) (4095,408E) 3
(x12+x"+x?+x?+x3+x3+x2+若+1)(x2+x+1)(x+1) (4095.4080) 4
(x?+x3+x1+x?+x?+x3+x2+k+E)(x3+x+1)(x+1) (32767,32748) 5
下面的例题将介绍重要的交织技术，这是一种能够提高码纠正突发错误能力的简单方法。
(另见习题7.32.)
例8.18 再次考虑g(x)=x?+x3+x2+1的(7,3)Abramson 码(见例8.16),它的b=2。令A,
B和C是这个码中的任意三个码字，我们可以将它们表示为一个3×7阵列：
AC AB6 ABCBC A6C?
下面的长度为21的矢量，是通过按列读上面的阵列而得到的，被称为A,B和C的交织：
An B? CodiB?C?A? B?C? A3B?C?A? B?CaAs B?Cs A? B? C6
假设这个长码字通过一个突发信道传输，并送到了一个长度为6的突发，用长表示：
Ao Bo Co A?B C?A? B?C? A?★**来**Bs Cs A6 B?C
纠正这个突发错误是可能的，只要通过简单的“解交织”,将这个长码宇恢复为它的单无码
字，因为解交织后，这三个码字中每个码宇所遇突发的长度都不超过2:
…………
第8章 循 环 码 155
Ao Ai A? A3** A? BoBB?** Bs B?
这个码包含了(7,3)Abramson码中任意3个码字的所有可能交织，被称为原始码的深度为
3的交织码。它是一个(21,9)线性码；前面的论证说明了它实际上是一个纠正b=6长突
发错误码。更普遍地，对任意正整数j,(7,3)Abranson码的深度为j的交织码是一个(7j,
3j),刻正b=2j长突发错误码。注意这些码都能使 Reiger界中的等式成立(因为r=4j,
b=2j),因此可以确定，码经过交织后并没有损失效率、
直接推广例8.18中的论证，就得出了下面的重要定理。
定理8.11 如果C是一个纠正b长突发错误的(n,k)线性码，则C的深度为j的交织码是
一个纠正bj长突发错误的(nj,j)码。
如果我们交织一个循环码到深度j,得到的码还是循环的。这个结论虽然不易直接看出，
但却是事实。下面的定理清楚地证明了这一点。
定理8.12 如果C是一个(n,k)循环码，具有生成多项式g(x),则C的深度为j的交织码
是一个(nj,bj)循环码，它具有生成多项式g(x)。
证明：为了证明这个定理，我们引入符号“?”表示交织操作。因此交织j个码字C,C?,…,
C,_,得到的矢量表示为C2c,2…2C,1。一个简单的引理(证明留做习题8.65)说明了如
何计算交织码字的右循环移位：
[Co?CI2…2Ci-1]*=[CA1Co2…2Cj-2】 (8.10)
式(8.10)证明了一个循环码的深度为j的交织码也是循环的，因为如果C,C?,…,C;_1是
一个给定循环码中的码字，则C,C,…,C,z也是。由于交织后码的冗余是j,它的生
成多项式将是惟一的次数为示首项系数为1的码多项式。如果g(x)是原码的生成多项
式，那么交织后的码字[g(x)20220]是多项式g(x),具有次数 j,因此g(x)一定是交
织码的生成多项式。
例8.19 从生成多项式为g(x)=x?+x3+x2+1且b=2的(7,3)Abramson码出发，利用交织
技术，就可以生成一类无限的纠正突发错误循环码集，即具有生成多项式g,(x)=x?+
x3+x3+1且b=2j的(7j,3j)码。类似地，从例8.17中b=3的(15,9)循环码出发，可以
得到另一类无限码集，即具有生成多项式g(x)=x+x?+x1+x3+1且b=3j的(15j,
9j)循环码。注意每一类码集中的所有码都达到了Reiger界(定理8.10的推论)。
例8.20 考虑b=1,2,…,7时，n=15的纠正突发错误二进制循环码。
在下面的表中，对于每个b值，我们利用(弱)Abramson界(r)与Reiger不(ra),列出所需
冗余的下界。在每种情况下恰巧都存在一个循环码，它的兀余等于max(rA,ra),表中列
出了每种情况下这样一个码的生成多项式g(x)。我们已经考虑了b=1,2,3的情况；
b=4的情况留做习题8.58。为了得到b=5的码，利用定理8.12,将g(x)=x2+x+1的
(3,1)重复码交织到深度3。b=6的情况留做习题8.60。最后，b=7的情况就是简单的
n=15重复码。
:
156 信息论与编码理论(第二版)
b AR g(x) 旅 释
1 4 2 x?+x+1 汉明码
2 5 4(x+x+1)(x+1) Ahrausn码(冽8.16)
3 6 6(x?+x+1)(x2++1) 例B.17
4 78(x?+x+1)(x?+x3+2+x+1) 习题8.58
5 8 10(x?+x+1)(x2+x+1)(x?+x3+1)=x"+x?+1 (3,1)交织x5
6 9 12(x?+x+1)(x?+x3+x2+x+1)(x?+x3+1)=x2+x?+?+x3+1 习题8.60
7 10 14 x"+x3+…+x+1 重复码
如果将表8.4(或者通过特殊的代数方法以及计算机手段而建立的更大规模的表)中列出
的码与交织技术结合起来，就可以产生许多好的纠正突发错误循环码，事实上，实际中用到的
一些纠正突发错误码就是通过这种方法构造的。但是还有另外一种截然不同的称为Fire:码的
方法，利用它设计纠正突发错误码同样取得了很大成功。现在就来介绍它。
Fire码在很多方面不同于我们普经研究过的纠正突发错误码。最重要的区别是Fire码能
够检测许多因错误过多而无法纠正的突发错误。下面给出了强纠正突发错误码的定义。
定义 一个生成多项式为g(x)的(n,h)循环码，被称为强纠正b长突发错误码的条件
是：如果两个突发错误矢量Z?和Z?具有相同伴随式，分别具有突发描述〔图案1,位页1〕
和(困案2,位置2),并且满足困案1的长度+图案2的长度≤2b,则有Z,=Z?。
下而的定理证明了强纠正突发错误码能够同时纠正和检测突发错误。
定理8.13 如果C是一个强纠正b长突发错误码，那么对于满足b?≤62且b?+b?=2b
的任意一对非负整数b?和b?,总可以设计码C的一个译码器，纠正所有长度≤b的突发，
同时检测所有长度≤b?的突发。
证明：根据定理7.4和强纠正突发错误码的定义可以得出这个结论。为说明这一点，令E
表示长度≤b?的突发错误集合，令下表示长度≤b?的突发错误集合。则如果Z∈E,
Z?∈F,就知道Z?和Z?的突发描述满足图案1的长度≤b?.图案2的长度≤b?。并且
b?+b?=2b,根据强纠正b长突发错误码的定义，Z?和Z?具有不同的伴随式。因此根据
定理7.4,码C具有上面所述的能力。
例8.21+ 大多数纠正b长突发错误码，包括表8.3中所列出的码，都不是强的。例如，考虑
b=2的(7,3)Abramson码，它的一致校验矩阵可以取：
H=(1i2ii)
正如我们在例8.16中所介绍的，在CF(8)中，a3+a+1=0。这个码能够纠正所有长度≤
2的突发；但是它却不能纠正所有长度≤1的突发，同时又检测所有长度≤3的突发，因
为，倒如，错误图案(110005(000010)具有相同的伴随式，即“)。(见习题8.68。)
例8.22 作为强纠正b长突发错误码一个退化的例子，考虑生成多项式为x2-1的(n,0)“无
·1
第8章 循 环 码 157
信息”循环码。这个码只有一个码字(全零码字),它不能传递任何信息；但是所有的错误
图案都具有不同的伴随式，因此它是一个强刻正n长突发错误码。(这个码将作为下面
定理8.14推论中所定义的一类码的构造模块。)类似地，假设n是奇数，则g(x)=
(x"+1)/(x+1)的(n,1)二进制重复码是一个强纠正b长错误码，其中b=(n-1)/2。
(见习题8.66.)
下面的定理给出了一种通用的强或者弱纠正b长突发错误循环码的构造方法。
定理B.14(Fire构造法)设g(x)是一个(n?,k?)循环码的生成多项式，该码是(强)纠正
6,长突发错误码，gz(x)是一个(n?,k?)循环码的生成多项式，且g?(x)的所有不可约因
式的次数都≥m,最后设g?(x)与g?(x)是互质的。则g(x)=g?(x)g?(x)是一个(n,h)
循环码的生成多项式，该码是一个(强)纠正b长突发错误码，其中：
n=lem(nl,n?)
k=n-deg(gi)-deg(g2)
b=min(b?,m,(n+1)/2)
证明：根据定理8.3(a).g(x)|x1-1,而g?(x)lx2-1。因为x^-1和x2-1都能整除
x-1,其中n=lcm(n?,n?),又因为g,(x)与g?(x)互质，所以g(x)=g?(x)g?(x)lx2-1,
根据定理8.3(b),g(x)生咸一个(n,k)循环码，其中k=n-deg(g)=n-deg(g?)-deg(g?)。
以上结论的证明非常容易。本定理证明的关键，是关于这个码纠正突发错误能力的论断。
我们将假定g?(x)生成的码是强的，然后证明其所生成的更长码也是强的。有关“弱”
g(x)的汪明留做习题8.69。
因此今生成多项式为g(x)的循环码，具有长度为n且伴随式相同的两个错谈矢量Z和
Z?,这两个错误矢量的突发描述(P?,i)和(P?,j)满足P?的长度+P?的长度≤2b。我们
需要证明Z=Z。
用P?(x)和P?(x)表示两个突发图案的生成函数。可以得出错误矢量Z和Z?的生成函
数分别是[xP?(x)]。和[xP?(x)]。,所以剩余伴随式为[x'P(x)]。mod g(x)和
[xP?(x)],mod g(x)。但是由于g(x)Ix°-1,根据引理1(e),这两个伴随式实际上可以
写做：
S?(x)=x'P(x)mod g(x)
S?(x)=x1P2(x)mod g(x)
因为假定Z和Z具有相同的伴随式，所以有：
x'P(x)=x1P?(x)(mod g(x)) (8.11)
又因为g(x)=gi(x)g?(x),所以有：
x'P(x)=xiP?(x)(mod gi(x))
根据假设，P?的长度+P?的长度≤2b,而根据b的定义，2b≤2b?e又因为g?(x)生成的
是一个强纠正b?长突发错误码，考虑g?(x)所生成的循环码，错误矢量Z和Z?是相同
的，即，
·k:
158 信息论与编码理论(第二版)
x'P?(x)=x'P?(x)(modx"1-1)
但是P?的长度+P?的长座≤2b≤n+1,因此根据定理8.7,
P=P? (8.12)
1=j(mod n) (8.13)
根据这个结论，式(8.11)意味着，
(x1x)P(x)=0(modg?(x)) (8.14)
但是2·P?的长度≤2b,因此P?(x)的次数≤b-1,它是小于m[g?(x)因式的最低次数]
的。因此P?(x)和g?(x)互质，可以从式(8.14)中删除P(x),得到：
x1-x=0(mod g2(x)) (8.15)
但是因为序列x'mod g(x)具有周期 n?,式(8.15)意味着i=j(mod n?)。将这个条件与
式(8.13)联立，再利用条件 n=lcm(n,nz),我们有i=j(mod n);但是因为i和j的范围
都在0,1,…,n-1,所以得出i=j。因为我们已经证明了P?=P?,可以得出错误矢量Z
和Z?是相同的结论，定理证毕。
推论(经典 Fre码! 令g(x)=(x2-1-1)f(x),其中f(x)是一个不可约多项式，且不是
x2-1-1的因式，它的次敏m≥b,而周期为no。则g(x)是一个强纠正b长突发错误的
(n,n-2b+1-m)循环码的生成多项式，其中n=lem(2b-1,no)。为纪念它的发现者
Philip Fire,这个码被命名为Fire码。
证明：通过令g?(x)=(x2-1-1)和g?{x)=f(x)[在例8.22中我们看到g?(x)生成的码
是一个强纠正b长突发错误码],由定理8.14可以直接得出这个结论。
例8.23 根据定理8.14的推论，g(x)=(x3+D)(x3+x+1)=x?+x?+x+1的二进制循环
码是一个(21,15)强纠正b=2长突发错误 Fire码。因此可以设计该码的一个译码器，纠
正所有长度≤2的突发；或者纠正所有长度≤1的突发，并检测所有长度≤3的突发；或者
检测所有长度≤4的突发。注意这个码既没有达到强 Abranson界，也没有达到Reiger界；
而达到这些界的码显然不是强纠正突发错误码。另外注意如果取g,(x)=x?+x3+x2+1
(它生成了b=2的《弱)(7,3)Abramson码]和g?(x)=x2+x+1,定理8.14意味着g(x)=
g,(x)g?(x)能生成一个(弱)(21,15)纠正b=2长突发错误码。但是g(x)g?(x)=x?+
+x+1,我们已经看到这个多项式是强的!
例8.24 多项式Ps(x)=x+x2+x?+x2+1是一个35次本原二进制多项式，因此根据定
理8.14的推论，g(x)=(x?+1)Ps(x)=x"+x+x?+x2+x2+x?+x3+x?+x2+1
生成一个b=7的强循环(13(2?-1),13(2°-1)-48)=(446 676598771,44667659873)
Fire码，这个特殊的 Fire码非常著名，因为IBM在它的很多磁盘驱动器中使用了该码的
“缩短”形式。什么是缩短循环码呢?一般来讲，如果g(x)的次数是r,并生成一个(n,
n-r)插环码，则对于任意n≤n,g(x)也能生成一个(ng,no-r)缩短循环码。达个码包
含所有长度为no、生成函数C(x)是g(x)倍数的失量C。IBM所用Fire码的n=152552,
因此该码实际上是一个缩短的(152552,152 504)强刻正b=7长突发错误循环码。IBM的
第8章 循 环 码 159
译码器设计非常保守，只纠正所有长度≤4的突发，因为该码是强的，所以它同时具有检
测所有长度≤10突发的能力。然而，因为这个码被大幅度地缩短了，通过计算机辅助计
算可以证明，IBM 译码器实际上能够检测所有长度≤26的突发错误图案，以及一部分更
长的突发。
我们以一个简单的表(表8.5)来结束本节。该表列出了一些有用的二进制Fire码。这些
码都有g(x)=(x2-1+1)P(x),其中P(x)是一个b次本原多项式。因此冗余就是r=3b-1,
虽然弱Abranson界和 Reiger界所需要的冗余一般比这个值小，但是显然这些“额外”的冗余是
为了使码具有强纠正突发错误能力所必须付出的代价。
表8.5一些 Fire码
(n,k) b 生成多项式
(35,27) 3 (x3+1)(x3+x+1)=x1+r?+x?+x3+x+1
(105,94) 4(x?+1)(x?+x+1)=x"+x+x?+x?+x+1
(279,265) 5 (x?+1)(x?+x2+1)=x"+x11+?+x3+2+1
(693,676) 6(x"+1)(x?+x+1)=x?+z2+x"+Z++1
(1651,1631) 7(x3+1)(x1+x+1)=x+x1+x3+x?+x+1
(255,232) 8(x1?+1)(?+s?+x3+x3+1)=x+x+x"+x"+x+x3+x?+x3+x3+l
(8687.6661) 9(x1?+1)(?+x?+1)x+x2+z"+x?+x?+1
(19437,19408) 10(t?+1)(x1+x3+1=x2+x2+s2+x+x3+1
8.5 纠正突发错误循环码的译码
在8.2节中我们看到如何设计任意循环码的移位寄存编码器。通常设计相应的译码器更
为困难，但是对于重要的纠正突发错误循环码来说，存在一种被称为突发捕获算法的简单译码
算法，它很适合于通过移位寄存器实现。在本节中我们将介绍突发捕获的工作原理。
基本思想是这样的。设g(x)生成了一个(n,A)循环码C,假设发送C的一个码字C(x),
接收为R(x),其中，
R(x)=C(x)+ E(x)
E(x)是错误图案。如果译码器根据定义
S(x)= R(x)mod g(x)
计算剩余伴随式 S(z),则由R(x)减去S(x)所得到的矢量，即，
C(x)=R(x)-S(r) (8.16)
一定是一个码字。这是因为C(x)mod g(x)=R(x)od g(x)-S(x)mod g(x)=0。因此如
果码C能够纠正集合E中的所有错误，且S(x)属于集合E,则译码器就能够可靠地判定C(x)是
实际发送的码字，原因是其他码字与R(x)相差的错误图案都不在E中。这一点对任意循环码
都成立。现在我们考虑纠正突发错误循环码的特殊情况。
假设码C是一个纠正b长突发错误码，且伴随式 S(x)满足下面两个条作：
S(0)≠0
deg(S(x))≤b-1 (8.17)
■ 1 ;
160 信息论与编码理论(第二版)
这意味若伴随式本身是一个(左对齐的)长度≤b的突发，因此根据上.面的讨论，译码器能
够可靠地判定式(8.16)中定义的C(x)是实际发送的码字。因此如果伴随式满足式(8.17),译
码就简单了。然而很遗憾，只有当错误矢量中的突发在位置0处时，这种情况才出现。
但是令人惊讶的是，只要利用码的“循环性”,即使突发不在位置0处，也可以采用这种简
单的设计思想。具体方法是：如果错误矢量E(x)是一个长度≤b的非零突发，则E(x)具有
惟一的形式为(P(x),io)的描述，其中P(0)≠0且deg(P)≤b-1。则E(x)=[xoP(x)]。,而
剩余伴随式为；
S(x)=[x1P(x)],mod g(x)
其中g(x)是码的生成多项式。图8.9(a)描述了这种情况。我们已经说过，如果突发在位置0
处，即如果i=0,而S(x)=P(x),突发错误可以被立即纠正。但是如果io=0,可以将E(x)
循环右移，直到突发图案P(x)被循环到位置0处，或者说在位置0处“被捕获”,如图8.9(b)中
所示。为此所需要的循环移位次数是惟一的整数元，其范围在0≤jn≤n-1,并满足n+jo=
0(mod n),即
jo=(-io)modn
现在如果 R,(x)表示R(x)的第方。次循环移位，我们有：
R,(x)=C,(x)+E?(x)
其中C。(x)和E,(x)分别对应C(x)和E(x)的第j。次循环移位。现在因为码是循环
的，所以C(z)是一个码字，而根据jio的定义，B。(x)=P(x),因此如果S,(x)表示 R,(x)的
剩余伴随式，我们有，
S?(x)=R?(x)mod g(x)
=(C?)+En(x))mod g(x)
=P(x)
这意味着S,。(x)满足条件(8.17)式，因此根据定义，
C。(x)=R?(x)-S,(x)
译码器能够可靠地断定C:(x)是实际发送码字的j。次循环移位。
(a) P
E(x) 1XXXX S(x)lxixJ],mod gx)
助
(b) P
E(x: ixXXX Sn(x)=Ptx}
0
图8.9(a)突发错误矢量E(x)=[xbP(x)]n。(b)将E(x)右移j。个单位后[其中j=(n-ig)md n],
错误图案被“捕获”在位置0处，相应的伴随式P(x)是一个左对齐长度≤b-1的突发
…
第8章 循 环 码 161
因此如果译码器连续计算S?(x),S?(x),…,并检查每个多项式是否满足条件(8.17)式，
就可以最终“捕获”突发错误并纠正它。实际上，突发错误图案可以由 S?(x)给出，而突发错
误位置可以由公式部=(-j0)mod n给出，其中言是捕获错误所需要的移位次数。现在就可
以利用这些思想来设计一个相当简单的译码器。但是在此之前我们希望指出，通过利用下面
的结论，可以很大程度上简化S,(x)的连续计算。
定理8.15(Mepgit引理)对于j≥0,定义
Sx)=[xR(x)].tmod g(x)
即S,(x)是R(x)第j次循环移位的剩余伴随式。那么对于j≥0,有
Sy+(x)=[xS;(x)]mod g(x)
证明：首先注意根据引理I(e),因为g(x)lx2-1,所以
S;(x)=[x1R(x)[mod g(x)
则
[xS;(x)]mod g(x)=[x([xR(x)]mod g(x)]mod g(x)
=[xJ+IR(x)]mod g(x)由引理1(d)
=S+;(x)
例8.25 以g(x)=x?+x3+x2+1,b=2的(7,3)Abramson码为例来说明这些思想。假设接
收矢重为R=[1010011],即R(x)=x?+x?+x2+1。则S。(x)=R(x)mod g(x)=(x?+
x3+x2+1)mod(x?+x3+x2+1)=x3+x2。利用 Meggitt引理，继续计算S?(z),S?(x),
等等：
Sj(r)=[xSo(x)]mod g(x)
=(x?+x3)mod(x?+x3+x2+1)
=x2+1
类似地，
S?(x)=x3+x
S?(x)=(x?+x2)mod g(x)=x3+1
S?(x)=(x?+x)mod g(x)=x3+x2+x+1
S?(x)=(x?+x3+x2+x)mod g(x)=x+1
现在因为S?(x)满足条件(8.17)式，我们停住计算，并得出结论：突发错误图案为11,突发
错误位置为(-5)md 7=2。因此错误矢量E=[0011000],纠正后的码宇是R+E=
[1001011].
图8.10给出了一个纠正b长突发错误循环码的完整译码算法，包括根据 Megit引理所
进行的简化。在这个算法中，首先在第3行计算出伴随式S?(x)。在第4行至第8行的 for循
环中，连续检测移位后的伴随式 S?(x),S?(x),…,S,,(x)是否满足条件(8.17)式。如果满足
这个条件，就在第6行纠正突发错误。然后在第7行完成接收码字的下一个循环移位R+,(x),
,!非越：
162 信息论与编码理论(第二版)
并在第8行(利用Meggit引理)计算下一个伴随式S?(x)。经过n次循环之后，在第9行输
出接收到的原始字减去突发错误图案所得的差。(如果没有错误，这个算法也能工作：参见习
题8.75)
/**Burst-Error Trapping DecodingAlgorithm**/
{
1.input R(x);
2.Rn(x)-R(x);
3.Sa(x)+· R?(x)mod g(x);
4. forU=0ton-1){
5. if(S(0)≠0 and deg S;(x)≤h-1)
6. R(x)-R;(x)-S;(x);
7. R-{x]-[xR;(x)]modx"-1;
8. S/+Ix)-[xS,(x)]mod g(x):
}
9.oueput RA(x);
图8.10 纠正突发错误循环码的“全时钟周期循环”突发捕获译码算法
图8.10所述的译码算法适合于用移位寄存器逻辑实现。在图8.11和图8.12中，以两个
不同的纠正突发错误循环码[例8.16中b=2的(7,3)Abrarson码和例8.17中b=3的(15,9)
码]为例进行说明。
modx?+x'+x2+1
寄存器
前7个时钟周期：闭合
后7个时钟周期：斯开 日?后?个时钟同期：闭合
前7个时钟周期：嘶开
A
图8.11 g(x)=x?+x3+x2+1,b=2的(7,3)Abraneun码(见例8.16)的完整译码电路。
经过14个时钟周期之后，译码光成，译码后的码字出现在下面的寄存器中
mod g(x)高存器
前15个时钟周期：闭合
后15个时钟周期：断开
100-0识别器
B
前15个时钟局期：断开
后15个时钟周期：闭合
A
图8.12 g(x)=x?+x3+x?+x3+1,b=3的(15,9)循环码(见例8.17)的完整译码电路简
化图，经过30个时钟周期之后，译码完成，译码后的码字出现在下面的寄存器中
在图8.11和图8.12的译码电路中主要有三个部分：一个mod g(x)移位寄存器，一个mod(x"-1)
移位寄存器(位于图的下方)和一个用来纠正这两个移位寄存器内容的“100…0识别器”电
路。初始时，每个触发器的内容都是0,开关A处在闭合的位置，开关B处在断开的位
置。接收矢量中的符号以顺序Ra-1,Ra-2.…,R从左侧按时钟节拍输人。经过 n个时钟周
第8章 循 环 码 163
期之后，图中上面的移位寄存器内容是S?(x)=R(x)mod g(x)(根据定理8.4),下面的移位寄
存器内容是R(x)。此后，开关A断开，开关B闭合，图中上面的移位寄存器通过100…0识别
器与下面的移位寄存器连接，译码器再工作 n个时钟周期。我们称这n个时钟周期为泽码周
期。在译码周期的第j个时钟周期之后，图中上面的移位寄存器内容是[xS?(x)]mod g(x)=
S,(x),下面的移位寄存器内容是[xR(x)]。=R;(x)。如果满足条件(8.17)式，则上面寄存器
中最左边触发器的内容将是一个1,而最右边的r-b个触发器内容将全部为0。这会使100…0
识别器输出一个1,捕获到的错误图案 S,(x)将在下一个时钟周期内加到R(x)上。在n个时
钟周期之后，译码周期完成，R(x)的符号已经在mod(x"-1)寄存器中整整转了一图，回到它
们原来的位置，其中的突发错误已经纠正。
总的来说，类似于图8.11和图8.12中的这些电路被称为“全时钟周期循环”译码器。它
们恰好需要2n个时钟周期来纠正长度≤b的任意突发，硬件复杂度为0(n)。这些电路在实
际中有着广泛应用。但是对于大幅度缩短的纠正突发错误循环码(见例8.24),可能需要对这
个电路进行修正，见习题8.77。
习题
8.1 证明城CF(q)上一个n维矢量空间的k维子空间中矢量的数目为：
I-Ig--5"
并利用此公式验证恰好存在11811个二进制(7,3)线性码。
8.2 完成下列计算：
(a)10°mod 12
(b)xmod(x2-1)
(c)(x1?-1)mod(x1-1)
8.3“mod”运算满足结合律和/或交换律吗?即下列公式是否普遍成立?
(Pmod Q)modR= Pmod(Qmod R)
PmodQ=Qmod P
8.4 设m∈10,1,…,n-1,证明当且仅当m=(i-j)mod n时，(j+m)mod n=ia
8.5(a)证明引理1(a)。
(b)证明引理1(b),
(c)证明引理1(c)。
(d)证明引理1(d)。
(e)证明引理1(e)。
B.6 证明：如果C是一个循环码，且C(x)∈C,则对于所有的i≥1,均有x'C(x)mod(x"-
1)∈C。[提示：利用引理1(d)。]
8.7 GF(3)上的一个(8,4)循环码，其生成多项式为g(x)=(x2+1)(x2+x+1),请写出
它的G?和H?矩阵。(参见定理8.3的推论1o)
:M趣。:
164 信患论与编码理论(第二版)
8.8 GF(3)上的一个(8,4)循环码，其生成多项式为g(x)=(x2+1)(x2+x+1),请写出
它的C?和H?矩阵。(参见定理8.3的推论2。)
8.9(a)设一个(n,h)循环码具有一致校验多项式h(x)(和“反”一致校验多项式
h(x)),证明其生成矩阵和一致校验矩阵具有如下形式：
G?=[Nh(x)]}(列)
H?=[x1+*-x+*前x](行)
(b)设一个(7,3)二进制循环码的生成多项式g(x)=x?+x3+x2+1,利用上问结
果写出其生成矩阵和一致校验矩阵。
8.10本习题涉及到定理8.3推论1中的矩阵H?。
(a)定义矢量R=(R?,R?,…,R,)的伴随式S由计算S= HR'得到。证明生成
函数R(x)=Ro+Rx+…+R_,x?"1与S(x)=So+S?x+…+S,_1x-1之间
具有如下关系：
sa)=Luhmdx-IARChbe]mdr
[上式通过一种间接的方法说明了(S。s,….S,)是乘积R(π)h(x)中x,
x+1,…,x-'项的系数。]
(b)设循环码的生成多项式为g(x)=x?+x3+x2+1,利用(a)的结论写出矢量R=
[1001011]所对应的H?矩阵的伴随式。(参照例8.7。)
8.11 证明一个循环码的对偶码仍然是循环码。设一个(n,k)循环码的生成多项式为
g(x),一致校验多项式为h(x),那么它的对偶码的生成多项式和一致校验多项式
各是什么?[提示：参考定理8.3的推论1.]试写出例8.2和例8.4中循环码对偶码
的生成多项式和一致校验多项式来验证你的结论。
8.12 以生成多项式g(x)=x2+2倍式的形式，写出例8.3中(4,2)循坏码的9个码字。
8.13本习题要求在不同的约束条件下，计算码长为7、码字数为16的二进制分组码的
数目。
(a)这类码共有多少个?
(b)这类码中线性码共有多少个?
(e)这类码中最小距离d=3的线性码共有多少个?
(d)这类码中循环码共有多少个?
(e)这类码中最小距离d=3的循环码共有多少个?
8.14 考虑利用一个生成多项式为g(x)=x3+x+1的(7,4)循环汉明码纠正删除符号。
由于该码的最小距离为3,我们知道它能够纠正包含不超过两个删除符号的图案。
同时，它也能纠E一部分包含3个删除符号的图案。例如，假设码字C=[1101000]
在第1位、第3位和第6位上出现删除符号，则接收矢量变成了R=[1*0*00*]。
这样的三个删除符号是可纠正的，因为在该码的16个码字中，只有码宇[1101000]
在非删除位上与R完全一致。但是，并不是所有包含三个删除符号的接收矢量都
可以被正确译码：例如[**0*000]既可以译为[1101000],也可以译为[0000000]。
.2
.
第8章 循 环 码 165
(3)=35 这就提出了问题：对于包含三个删除符号的 种可能图案，有儿种是能够被
纠正的，有几种是不能被纠正的?
8.15 对于1≤n≤20,码长为n的二进制循环码共有多少种?其中有多少种是非正常的?
8.16码长为63的二进制循环码共有多少种?其中有多少种是非正常的?
8.17当n在3≤n≤20范围内取多大值时，域F?上码长为n的循环码恰好有4种?
8.18 在域F?上码长为4的线性码中，循环码占多大比例?
8.19 F?上码长为2”的循环码有多少种?请写出计算公式。
8.20在域GF(3)上，多项式 x?-1可以被分解为x?-1=(x+1)(x+2)(x2+1)(x2+x+
1)(x2+2x+1)。对于0≤k≤8范围内的每个k值，求出GF(3)上(8,k)循环码的
个数。
8.21 在例8.8中，我们看到对于GF(3)上生成多项式为g(x)=x2-1的(4,2)循环码，由
定理8.3的推论1和推论2得出的生成矩阵和一致校验矩阵是完全相同的，即
G?=G?,H=H?。试找出一类能使这个性质普遍成立的循环码。
8.22 设在给定的域F上，多项式x2-1可以分解为：
x*-1=Pi(x)°"P?(x)?…Pu(x)“
其中P,(x)是互不相同的不可约多项式。从e,e?,…,eg的角度来看，域F上码长
为n的循环码共有多少种?
8.23解释例8.9表格巾每个“注释”的含义。
8.24证明：在域 CF(2)上，对于任意的m≥1,x3+x+11x"-1均成立。
8.25有八种形式为g(x)=x?+gxx3+gzx2+gix+1的四次二进制多项式，针对每种多
项式请回答以下问题：
(a)g(x)的周期是多少?
(b)如果用n表示(a)中求出的周期，那么相应循环码的k和d各是多少?
8.26(K.Sivarajan)试证明当且仅当一个二进制循环码是正常码时，它具有纠正单个错误
的能力，即该码的最小距离dm≥3。
8.27在8.1节的结尾，我们简单讨论了非正常循环码，也就是那些生成多项式g(x)的周
期小于n的码。在本习题中，将研究那些一致校验多项式周期小于n的循环码。
设C是一个(n,k)循环码，并设x"-1=g(x)h(x),其中g(x)代表C的生成多项
式，而h(x)代表C的一致校验多项式。进一步假设h(x)的周期n<n,而C。是一
个(m,k)循环码，其生成多项式为g(x)=(x-1)/h(x)。
(a)试问C。的一致校验多项式是什么?
(b)如果用d。表示Co的最小距离，那么C的最小距离应该如何表示?
(c)证明C=(n/na)Co,这里“)C。”表示将 C。的每个码字重复j次而得到的长度为
n的码。
8.28 对于I≤i≤16范围内的每个j值，试找出生成多项式为(x+1)的(正常)二进制循
环码的码长、维数和最小距离。[提示：可以利用上题的结论。]
8.29 如果g(x)是周期为n的r次多项式，那么对于任意的m≥1,有g(x)Ix-1。因
i过!
166 信息论与编码理论(第二版)
此由定理8.3(b)知，g(x)生成一个(nm,nm-r)循环码。(当m≥2时，这个码是非
正常的。)
(a)证明当且仪当∑C,x=0(mod g(x))时，矢量C=[Co,C?,…,Cm- ]属
于这个码。
(b)证明(a)中的条件等价于：
[Co.C…,Ca]+[Cn,Cn-J.….Cz。]
+…+[C(m-1;m,Ccm-1)小.…,Cm-1]
属于g(x)生成的(n,n-7)正常循环码。
(c)在这个码中有多少个重量为2的码字?
8.30在图8.3中，我们介绍了一种多项式g(x)的“md g(x)”电路。如果g(x)的首项系
数不为1,即g(x)=go+g:x+…+g,x(其中g,≠0,1),请问应该如何调整这个
电路?
8.31(a)试证明在图8,4(a)所示的电路中，当前状态多项式S(x)和下一个状态多项式
S'(x)之间存在如下关系：
S'(x)=(xS(x)+sx)mod g(x)
其中s是输人信号。
(b)利用(a)的结果，说明如果图8.4(a)电路的初始值为s==…s,-1=0,并给定
输入序列da,a?…,则经过：个时钟周期后，状态多项式变为：
su)-2amaodge)
8.32 考虑三元域GF(3)上的多项式g(x)=x3+2x2+2。
(a)此多项式的周期是多少?
(b)如果用n表示(a)中找出的周期，试写出由g(x)生成的码长为n的循环码的一
致校验矩阵。
(c)该码是否含有重量为2的码字?如果没有，请解释原因。如果有，请将它们列
举出来。
(d)请画出该循环码的系统码移位寄存编码器。
8.33 试设计g(x)=x?+x?+x?+x?+1的(15,7)二进制循环码的三种不同移位寄存编
码器。
8.34本习题将讨论g(x)=x3+x2+1的(31,26)循环汉明码。
(a)试写出该循环码的系统(即[AIIs]形式)一致校验矩阵。
(b)设计该码的一种译码电路。
(c)利用你在(b)中设计的译码器就下列接收字进行译码：
R=[1111111111000000000000000000]
8.35 对于由一致校验矩阵(8.9)式定义的(2“-1,2”-m-1)循环汉明码，试找出计算其
重量为3码字数目的公式。
8.36设g(x)是定义在q元有限域上的一个r次多项式、且g(0)≠0。
…
第8章 循 环 码 167
(a)试证明g(x)的周期≤g-1。
(b)证明如果g(x)的周期等于q'-1,则g(x)必须是不可约的。[注释：一个周期
为q-1的，次不可约多项式被称为本原多项式。]
8.37 考虑生成多项式为g(x)=x?+x+1的(15,11)二进制循环汉明码。
(a)试写出它的一个4×15阶二进制一致校验矩阵。
(b)试写出它在域GF(16)上的一个1×15阶一致校验矩阵。
8.38 证明：如果a是域GF(2")上最小多项式为g(x)的一个本原根，则α的展开式为：
a=2h2 对于j=0,1,…,n-1
Am×2”-1阶矩阵H=(h,;)是生成多项式为g(x)的循环汉明码的一致校验矩
阵，其中i=0,1,…,m-1,j=0,1,…,2”-2。
8.39设g(x)是一个m次二进制本原多项式，H是一个(2"-1,2"-m-1)汉明码的
m×2"-1阶二进制一致校验矩阵。试问在H各列的(2"-1)!种可能置换中，有多
少种是生成多项式为g(x)的循环汉明码的一致校验矩阵?
8.40在表8.3中，除m=1的情况外，没有其他重量为偶数的多项式。试解释其原因，即
为什么偶数重量的多项式不可能为本原多项式。
8.41(循环汉明码的对偶码——也称为循环单向码，或者最大长度移位寄存器码)设C
是一个(n,k)(正常)循环码，它的一致校验多项式h(x)是一个k次本原多项式，而
G?是定理8.3推论1所述C。的生成矩阵。
(a)试证明n=2*-1。
(b)设计C.的一种有效移位寄存编码器。
(c)说明C,中非0码字的集合恰好等于G?第一行的循环移位集合。利用表8.3中
本原多项式x?+x+1生成的码C.验证上述结论。
(d)写出C的重量枚举多项式。
8.42 试给出计算2-字符表上长度为b的普通(即非循环)突发数目的公式(参照定
理8.8),其中1≤b≤B。
8.43推广定理8.8到q-字符表的情况。
8.44 推广定理8.8,使它包括b>(n+1)/2的情况。
8.45推广定理8.9及其推论到q-字符表的情况。
8.46 推广定理8.10及其推论，使它包括q-字符表的情况。
8.47 为什么定理8.9不包括b=0的情况?
8.48为什么Abramson界的两种表示方式分别被称为“强界“和“弱界”,你是如何理解的?
8.49 二进制重复码是否达到Abranson界(定理8.9推论)?
8.50 Abranson码是否达到Reiger界?
8.51 在一些纠正突发错误的实际应用中，只需要纠正特定位置上的突发错误。其中最重
要的例子是纠正定段突发错误。在纠正定段突发错误时，分组长度n是b的倍数，
且长度为b的突发只出现在b的倍数位置上。一个能够纠正所有长度为b的定段
突发错误的码被称为纠正定段b长突发错误码。比如，一个码长为12的纠正定段3
it! 郭
168 信息论与编码理论(第二版)
长突发错误码能够纠正在位置0,3,6,9上出现的任何长度为3的突发错误。
(a)试说明纠正定段突发错误码满足定理8.10以及Reiger界。
(b)试证明如果一个码能够纠正：个长度为b的定段突发，则r≥2tb。
8.52 考虑一个(20,12)二进制线性码，其一致校验矩阵如下：
对于给定的码字[Co,C?,…,Cig],位于矩阵左上角的3×4位元素是携带信息位，
而最右边一列和最下边一行的元素是奇偶校验位。奇偶校验的规则是使每行和每
列元素的总和等于0。例如，对于第一行，有Co+C+Cg+C+C?=0;对于第二
列，有C?+C+Cn+Gs=0e
(a)试说明这个码能够纠正所有长度为4的定段突发错误。
(b)说明仅由左上角3×4位元素构成的码不能纠正所有长度为3的定段突发错
误。
(c)惟广并说明，当且仅当b+1为素数时，一个由b×(b+1)位元素构成的码能够
纠正所有长度为b的定段突发错误。
8.53(Burton码)
(a)设g(x)=(x?-1)P,(x),其中P?(x)是一个周期为n?的b次不可约多项式、
试说明g(x)可以生成一个码长 n=lem(n?,b)的(n,n-2b)循环码，该码能够
纠正所有长度为b的b个定段突发错误。(参见习题8.51。)
(b)考虑将(a)中的码进行交织，产生一系列(nj,(n-2b)j)循环码。令b;表示它
们纠正(普通的，而不是定段的)突发错误的能力。证明 lim,b;/2b,=2,即这
些码渐近地达到Reiger界。
8.54 考虑一个码长为31的二进制循环码，它能够纠正b=3长突发错误。
(a)利用Abramson界和Reiger界，估计此码最少需要的冗余位数。
(b)你是否认为存在一种码，具有(a)中预计的冗余位数?详细解释原因。
8.55设g(x)是-个(n,k)循环码的生成多项式，且(x+1)不是g(x)的因式，则g'(x)=
(x+1)g(x)是一个(n,k-1)码的生成多项式，该码是将原码中重量为奇数的码字
删除而得到的。
8.56试对例8.16中(7,3)Abranson码的下列噪声码字进行译码：
(a)[0101010]
(b)[11111]
(c)[1110010]
(d)[1101000]
(e)[1011111]
8.57 试对例8.17中(15.9)纠正b=3长突发错误码的下列噪声码字进行译码：
(a)[0000010011LL000]
:
第8章 循 环 码 169
(b)[101110001100000]
(e){111001000001111]
(d)[110100000101010]
(e)[111100000000000]
8.58验证例8.20的结论：多项式g(x)=(x?+x+1)(x?+x3+x2+x+1)能够产生一个
(15,7)纠正b=4长突发错误循环码。
8.59下列两个多项式能否产生一个(15,7)纠正b=4长突发错误循环码?
(a)g(x)=(x?+x3+1)(x?+x3+x2+x+1)
(b)g(x)=(x?+x+1)(x?+x3+1)
8.60验证例8.20的结论：多项式g(x)=x"+x?+x?+x3+1能够产生一个(15,3)纠正
b=6长突发错误循环码。
8.61 对于例8.17中所研究的(15,9)码，长度≤3的突发占用了64个陪集中的61个。请
给出剩余三个陪集的伴随式。在这儿个陪集中，最短突发图案的长度是多少?
8.62 在例8.17中，我们看到g(x)=(x?+x+1)(x2+x+1)能够产生一个(15,9)纠正
b=3长突发错误循环码。请问g(x)=(x?+x3+1)(x2+x+1)也能产生此循环码
吗?g(x)=(x?+x3+x2+x+1)(x2+x+1)呢?
8.63推广例8.17,证明一个生成多项式为g(x)=p(x)(x2+x+1)的(2”-1,2”-m-3)
二进制循环码，是一个达到Abramson界的纠正b=3长突发错误码。其中p(x)是
一个m次本原多项式，满足1+x=x°(mod p(x)),而a mod 3≠2。
8.64如果码C达到了Abramson界，那么是否码C的深度j交织也达到Abramson界?如果
是，请给出证明。如果否，请举出一个反例。
8.65 证明一个交织矢量的右循环移位满足式(8.10)。
8.66 证明：生成多项式为g(x)=(x"+1/(+1)的(n,1)二进制重复码是一个强纠正b
长突发错误码，其中b=(n-1)/2,而n为奇数。
8.67给出定理8.11的严格证明。
8.68(参见例8.11和例8.21)对于一个(7,3)Abraunson码，试说明每个图案为111的突
发，都与某个图案为1的突发具有相同的伴随式。
8.69在g?(x)生成一个弱(而不是强)纠正b长突发错误码的情况下，证明定理8.14。
8.70在例8.24中曾提到，如果g(x)是一个周期为n的r次多项式，并且n<n,则生成
多项式为g(x)的(no,no-r)缩短循环码由矢量[Co,C,…,Cn-1]构成，该矢量的
生成多项式Co+C?x+…+Gm-1x-是g(x)的倍数。
(a)试证明缩短循环码是一个线性码。
(b)如果g(x)=x?+x?+x+1(参见例8.23),找出由g(x)生成的(16,10)缩短循
环码的生成矩阵和一致校验矩阵。
8.71 为什么表8.5中没有b=2的行?
8.72 对于表8.5中的每个n和b值，利用Abraneun界和Reiger界估计需要的冗余。试比
较估计值和给定Fire码的实际冗余。
8.73 考虑表8.5中b=3的(35,27)Fire码。采用“b?=3,b?=3”译码器对下列接收码字
t!
………………………………………………………………………………;……;
170 信息论与编码理论(第二版)
进行译码(参见定理8.13):
Ri=[1101011011101011011L0LQE10100000111]
R2=[0100111010H101000001101011011010110]
如果采用的是“b?=2,b?=4”译码器，试对以上接收码宇重新进行译码。
8.74 为使一个纠正b长突发错误Fire码能够纠正所有长度≤b的突发，同时能够检测
所有长度在b?+ I和2b-b?(包括2b-b)之间的突发(这里b,是一个满足
1≤b?<b的整数),应该怎样调整它的突发捕获译码电路?请解释你的理由，并画
出修改后译码器的电路示意图。
8.75 试说明即使不出现错误，图8.10所示算法仍然适用。
8.76为了检测与长度≤b突发具有不同伴随式的长度≥b+1突发，应该如何修改
图8.10所示的算法。
B.7 图8.10描述的译码算法针对的是生成多项式为g(x)的(n,n-r)纠正突发错误循
环码。为了完成一个码长为n的码字的译码，需要在程序的第4行至第8行执行 n
次for循环。这种算法也适用于具有相同生成多项式的(no,no-r)缩短循环码，但
是仍然需要执行n次 for循环，而不是n。次。当码已经被大幅度缩短时，这是无法
接受的。例如，在例8.24中介绍的[BM所用的码，它的no=152 552,但是n=
446 676 598771。显然一个需要耗费446 676 598771步才能完成码长为152 552码字
译码的算法是毫无价值的。幸运的是，通过对这种算法进行简单的改进，就可以只需
n。步完成一个缩短码的译码。下而列出了改进算法的伪代码。(注意第7行和第8行
与图8.10中的算法不同。)
/* Burst-Error-Trapping-Decoding Algorithm for
Shortened Cyclic Codes*/
〔
1.input R(x):
2.Ro(x)+- R(x);
3.So(x)一R(x)mod g(x);
4. forU=0to A-1){ 5. if(S(0)≠0and degS(x)≤b-1) 6. R(π)一R(x)-S(x); 7. R+1(x)一[x-1R(x)]modx-1; 8. S+1(x)-[x-'S(x)]mod g(x);
output R(x); 9.
}
(a)试分析此算法的工作原理。
(b)考虑一个(30,16)缩短 Fire码，其生成多项式为g(x)=(x3+x2+1)(x?+1)。
运用上述算法对下列接收码字进行译码：
R=[111101001110100011011011110010]
(e)利用移位寄存器实现上述算法。[提示：你同时需要一个“S(x)→xS(x)mod g(x)”
移位寄存器和一个“S(x)→x?'S(x)mod g(x)”移位寄存器。]
第8章 循 环 码 171
注释
1]“mod"比较常见的用法是表示等价关系，这里的二进制算子“mod”虽然很接近于它
的常见用法，但是并不完全相同。因此Q(x)=P(x)(mod M(x))(这里的“mod”表
示等价关系)仅意味着Q(x)-P(x)可以被M(x)整除，而Q(x)=P(x)(mod M(x))
("mod"是二进制算子)除了表示Q(x)-P(x)可以被M(x)整除外，还表示
deg Q(x)< deg M(x)。
[2] 对逻辑电路感兴趣的读者可以进一步阅读 Berlekamp[14]第2章的有关内容。
[3] 就目前的逻辑电路水平而言，t。已经可以小到几皮秒的量级(pico=10-12)。
[4] 本节假定读者已经了解有限域的相关理论了。初次阅读时，可以跳过这部分内容、
[5] 这里以及本节的后续内容，我们按照惯例设n=2"-1。
[6] 这些例题都假定读者已经了解有限域的相关理论了。初次阅读时，可以跳过这些
内容。
s罐：
第9章 BCH、Reed-Solomon码及其同类码
9.1 引言[]
在第7章中，我们给出了引言中所介绍的(7,4)汉明码的一个推广：一类纠正单个错误的
(2"-1,2"-m-1)汉明码。第8章中将它进一步推广到能够纠正单个突发错误的一类码。在
这一章里，会给出一个更重要、更广泛的推广，即能够纠正多个错误的BCH2和Reed-Solomon码。
为了得到一般性的定义，回顾一下码长为n=2"-1的汉明码的一致校验矩阵，它由
H=[vo vi ..v。j] (9.1)
给出(见7.4节),其中(vo,v?,…,Va-I)是Vm=GF(2”)中2"-1个非零(列)矢量的某个排列。
矩阵H具有维数m×n,这意味着需要m个一致校验比特来纠正一个错误。如果需要纠正两
个错误，则顺理成章地还需要增加m个一致校验位。因此可以设想矩阵的一般形式为：
=[
其中wo,w,…,Wa-I∈Vn,这个矩阵将成为码长为n、能够纠正两个错误的码的一致校验矩
阵。然而巾于v,是各不相同的，所以可以将对应关系v?→w:看做是从V到它自身的一个函
数，并将H?写做：
=-() (9.2)
但是如何选取函数F呢?根据7.3节的结论，H?将定义一个纠正两个错误的码，它的充分必
要条件是重量为0,1和2的1+n+{2)个错误图案的伴随式都互不相同。任何一个这样的
伴随式都是H?中列的某个子集(可能为空集)的求和，因此它也是V2m中的一个矢量。但是为
了与我们目前的观点一致，这里将伴随式s=(,…,52m)等分为两个部分：s=(S,Q),其中
s{=(x?…,sm)和s?=(sm+…,52m)都在V中。根据这项约定，全零错误图案的伴随式为
(0,0);在位置i上出现单个错误的图案对应s=(v,,t(v;));在位置i和j上出现一对错误的
图案对应s=(v.+v,,f(v.)+f(v,))。为了使这三种情况统一，我们定义f(0)=0(注意，由于0
不是H的一个列，所以f以前在0处没有定义);则这些伴随式都不相同的条件是方程组：
口十v=s|
f(u)+f(v)=B2 (9.3)
对V.中的每一对矢量至多有一个(u,v)解。[自然我们不认为解(u,v)与(v,u)是不同的。]
现在必须设法找到一个具有上述性质的函数f:V_→V,满足 f(0)=0。可以利用某个线
第9章 BCH、Reed-Solomon 码及其同类码 173
性变换T做线性映射f(v)=Tv,但是这样的线性变换没有解(见习题9.1);因此『必须是非线
性的、为了描述矢最v∈Vm的非线性函数，需要知道可以定义一个V上矢量的乘法，当它与
矢量加法相结合时，就使V成为一个域。[这个域是伽罗华(Galois)域GF(2");附录C中介
绍了所需要的有限域性质。]根据这一点，很容易看到(见习题9.2),每个函数[:V→V。都可
以出一个多项式表示。次数≤2的多项式不起作用(见习题9.1);但是马上会看到，f(v)=3可
以满足要求。因此(这里通过改变符号来强调一下，从现在开始，不再把V中的元素看做GF(2)
上的m维矢量，而是将它看做GF(2”)中的标量),如果(ao,a,…,a-1)是CF(2”)中非零元
素的任意一种排列，则矩阵 =
(9.4)
是码长为n=2"-1、纠正两个错误的二进制码的一致校验矩阵。等价地，C=(Co,C?,…,Cn-i)∈V.
是具有一致校验矩阵H?的码中一个码字的充分必要条件是∑"=Ca,=Z。Ca3=0。因为H?
作为GF(2)上的一个矩阵，具有2m行(当m≥3时，各行是线性无关的；见习题9.5),所以码
的维数≥n-2m=2”-1-2m。
式(9.4)中的矩阵确实定义了一个纠正两个错误的码，下面这个著名的定理给出了它的证
明，以及将它推广到纠正(个错误的码的证明。
定理 9.1 设(a,a?,…,a-1)是GF(2")中n个不同非零元素的一个排列。并设1是一
个≤(n-1)/2的正整数：则1×n矩阵
是一个二进制(n,k)码的一致校验矩阵，这个码能够纠正所有重量≤t的错误图案，它的
维数k≥n-m。
证明：一个矢量C=(Co,…,C.-)∈V。为一个码字的充分必要条件是HC?=0,这与下面
关于C的一组t个线性方程等价：
ca{=0. j=1,3,…,2t-1 (9.5)
将式(9.5)中第；个方程平方，就得到0=(∑Ca)2=∑Ca2=ZCa?(因为在特征为2
的城中(x+y)2=x2+y2,而在GF(2)中x2=x)。因此这个码的一个码字的等价定义是
下面的一组2t个方程：
∑Ca{=0, j=1,2,…,2t (9.6)
由此可以等价地用下面这个2t×n维一致校验矩阵
174 信息论与编码理论(第二版)
来描述该码。根据定理7.3,H为一个纠正：个错误的码的一致校验矩阵的充分必要条件
是F中任意21或更少的列是钱性无关的。现在H中r个列组成的一个子阵(其中r
21)将具有如下形式：
其中β,β2…,良是GF(2”)中的不同非零元素。考虑由B中的前r行形成的矩阵B':
矩阵B'是非奇异的，因为由范德蒙德(Vandermonde)行列式定理(见习题9.3),它的行列式
为：
=R…s.I(S?-B)≠0
因此B'的列肯定是非线性相关的，由此可知B的列也不是线性相关的，可见这个码确实
能够纠正所有重量≤t的错误困案：为了证明维数的界kn-mt,再来观察原来的一致
校验矩阵H,将其矩阵元素看做是GF(2)中的元素，而不看做是GF(2")中的元素，则矩
阵的维数是mt×n。根据7.1节的结论，这意味着对偶码的维数≤mt,因此这个码本身的
维数≥n-mt
定理9.1所描述的这类码称为 BCH码，以纪念它的发明者 Bose,Ray-Chaudhuri和Hoc quenahem。该码的重要性主要不是体现在定理9.1本身中(其他码可能具有更高的码率和更
大的最小距离),而是在于存在有效的编码，特别是存在有效的译码算法。在接下来的一节里
将看到，如果正确地选择(an,a,,…,a-;)的顺序，BCH码将神奇地变为循环码，而根据第8章
的结论，编码会自然变得很简单。另外，BCH码的“循环性”将改进我们对码维数的估计。在
后面的9.3节到9.5节，我们将全面介绍 BCH码的一种著名的 Berlekanp译码算法。
第9章 BCH、Reed-Solomon码及其同类码 175
9.2 具有循环码特性的 BCH码
回顾一下码长为n=2”-1、纠正1个错误的BCH码的定义：C=(C,…,C-,)是一个码字
的充分必要条件是，对于j=1,3,…,2t-1(或者等价地，对于j=1,2,3,…,2z),有∑C?d=0,
其中(ao,a,,…,a-1)是GF(2”)中n个不同非零元素的一个排列。如果适当地选择这个排
列，该码就变为一个循环码，因而继承了适用于循环码的所有实现机制。这些“循环“排列具有
如下形式：
(1,α,…,a-1)
其中n是2"-1的一个因子，而a是GF(2")中的一个a阶元素。根据这样一个排列，定义变
为：C=(C,C?.…,C-1)是一个码字的充分必要条件为
cu'=0,对于j=1,3,…,2r-1(或者j=1,2,3,…,21) (9.7)
按照第8章的观点，在这个实现中，BCH码变为一个循环码。为说明这一点，令C(x)=Co+
C?x+…+C-1x?-1为码字C的生成函数；则式(9.7)变为：
C(a)=0,j=1,2,…,21 (9.8)
现在令CR是码字C的右循环移位；根据定理8.1,它的生成函数为C(x)=xC(x)mod(x°-
1),这意味着存在某个多项式 M(x),使得C(x)=xC(x)+M(x)(x°-1)。因此对于j=1,2,….
2t,
CR(α)=α'C(a)+M(a/(α-1)
但是根据式(9.8),C(α)=0,并且由于a"=1,α-1=0。因此对j=1,2,…,2r,C(d)=0,
可见C"也在由式(9.7)定义的RCH码中，这意味着该码是循环的。
现在根据定理8.3,每个 BCH码都以它的生成多项式g(x)为特征。但是如何计算g(x)
呢?根据定义，g(x)是码中次数最低的码多项式，即满足g(a)=g(a3)=…=g(a2?1)=0的
最低次多项式。g(x)的系数在 CF(2)中，但是。不同次数的幂在更大的域GF(2")中、因此
(见附录C),g(x)是GF(2")的子集A=la,a3,…,a2-|在GF(2)上的最小多项式。所以，如
果定义A*为A中元素的所有CF(2)-共轭类的集合，即A*=β2:β∈A,i≥0,则，
eu)=Ilα-3 (9.9)
我们在下面的定理中总结了上述这些结论。
定理9.2 如果用式(9.7)或式(9.8)定义码长为n的纠正：个错误的BCH码，则这个码
是循环的，生成多项式由式(9.9)给出。而码的维数为n-deg(g),即k=n-IA*1,其中
A°是CF(2")中A=la,a3,…,a2-1的GF(2)-共轭类的集合。
例9.1 考虑一个码长为15、纠正3个错误的 BCH码。令α是GF(16)中的一个本原元；则根
据定理9.2,生成多项式是集合A={α,c3,a?|的最小多项式。a的共轭类为(a,a2,a?,
,证 : n
176 信息论与编码理论(第二版)
α°);a3的共轭类为(a3、α?,α2,α?);a?的共轭类为(a3,α")。因此，
A*={a,α2.α3,a?,α?,r?,a?,a?,α10,α12}
根据定理9.2,维数是15-10=5:
要实际计算出这个例题中的g(x),需要GF(16)的一个具体表示。我们利用满足α?=
a+1的本原元α的苯来表示GF(16)。在表9.1中，元素α由次数≤3的α的多项式蛤出；
例如，α"=a3+α2+an生成多项式g(x)是a,a3和α?的最小多项式的乘积。根据定
义，α的最小多项式为x?+x+1,a3的最小多项式——记为g:(x)=gx+g?x+gxx2+
g?x3+gax?—-必须满足g?(a3)=0。由表9.1,这等价于g,[0001]+gn[1000]+
8[1100]+g[1010]+gu[m1]=[0000]。这个方程组由包含5个未知数的4个齐次
方程组成，它的惟一非全零解为[gu,81·B?·83,gu]=[1H31],因此g?(x)=x?+x3+
x2+x+1:同理，gs(x)=8o+gSux+8x2(我们已经知道a3只有两个共轭类，即a?与
a")算出是x2+x+1。因此码长为15、纠正3个错误的BCH码的生成多项式为g(x)=
(x?+x+1)(x?+x3+x2+x+1(x2+x+1)=x+x?+x?+x?+x2+x+1。而一致校
验多项式为h(x)=(x?+1)/g(x)=x?+x3+x+1。[但是我们要强调一下，g(x)依赖
于表9.1中给出的GF(16)的具体表示，见习题9.6.]
表9.1 将GF(16)表示为α的幂，其中α?=a+1 a'
0 000L
1 0010
2 0100
3 1000
4 0011
5 0110
6 1100
7 40L1
8 0101
9 1010
10 0111
11 1110
12 u111
13 LI01
14 LCOL
下面来总结一下到目前为止我们所了解的 BCH码：它可以设计成能够纠正码字中任意数
目的错误，纠错能力大约达到码分组长度的一半(定理9.1),作为循环码具有非常完美的代数
特征。然而，这种码重要的实用价值儿乎完全取决于一个非常高效的译码算法。从下一节就
开始讨论这种算法。
at4
第9章 BCH、Reed-Solomon 码及其同类码 177
9.3 BCH码的译码，第一部分：关键方程
在本节中将推导出所谓的关键方程，它是BCH码译码算法的基础。但是在推导关键方程
之前，必须先提供一些预备知识。这里将以更一般的形式来介绍这些知识，而不局限于现在必
需的，以便后面不论是讨论 BCH码还是Reed-Solomon码纠正错误或纠正删除符号，都可以
引用。
令F是一个含有n阶单位本原元a的域3。我们首先注意到，
-x°=Ta-a′s) (9.10)
这是因为式(9.10)两边的多项式都是n次的，常数项为1并具有根α',i=0,1,…,n-1。接
下来令
V=(Yo.V,…,Va-1)
为F上的一个n维矢量，并令
V=(P,V,…,Va-1)
为它的离散傅里叶变换(DFT),其元素定义如下：
D,=2va°. 对于j=0,1,…,n-1 (9.11)
有时称v?为矢量V的“时域"坐标，V,为“频域”坐标。时域分量可以从频域分量还原出来，通
过所谓的“反DFT”:
v-HZv-, 对于i=0,1,…,n-1 (9.12)
对式(9.12)中求和前面的因子“1/n”有必要详细解释一下，因为要考虑到F可能具有的有限
域特性。数值“n”是求和1+1+…+1(n项),而“1/n”是这个数的倒数。例如，如果F的特征
为2,且n是一个奇数，则1/n=1。然而，除了这个细微的差别，式(9.12)的证明等同于一般的
反DFT公式的证明，我们将它留做习题9.8。如果将V和V的分量理解为多项式的系数，即如
果定义生成函数V(x)和V(x)为：
V(x)=Vo+V?x+…+Va-lx?- (9.13)
和
V(x)=to+Vx+…+Vn-1x"- (9.14)
则DFT和 DFT的关系式(9.11)和式(9.12)变为：
V;=V(a) (9.15)
和
v.=!v(a-) (9.16)
Lt)
178 信息论与编码理论(第二版)
对于一个给定的矢量，它的时域和频域坐标之间存在许多有意义和有用的关系。其中之一就
是下面所定义的，频域的“时间变化”与时域的“相位移动”之间的对应关系。如果将矢量V的
第i个分量乘以α,即，如果定义~个新矢量V。为：
V=(Vo.V?a.…,Va-1an-) (9.17)
则它的DFT就是：
V=(VuDa+1,…,D+n-1) (9.18)
式(9.18)中的下标是按md n选取的。我们将式(9.18)的证明留做习题9.10、
作为编码理论研究者，我们总是对一个矢量的重量感兴趣。下面的经典定理告诉我们，如
果了解了矢量在频域的某些信息，应该如何估计其在时域的重量。
定理9.3(BCH论证)设V是一个非零矢量，具有如下性质：含有m个连续的0分量，
即=V,+2=…=N=0。则V的重量≥m+1。
证明：将V循环移位，直到它的m个连续0出现在位置n-m,n-m+1,…,n-1,令W
表示移位后的矢量，即
w-[..
由式(9.17)和式(9.18),W是矢量W的DFT,而W的重量与V的重量相同。但是根据
式(9.12),W=(α-),其中W(x)=中。+Wx+…+Wa-m-1x1。由于W(x)是
一个次数≤n-m-1的非零多项式，可见至多存在n-m-1个i值，使W=0;至少存在
m+1个i值，使W≠0。因此 wt(V)=wt(W)≥m+1。
现在基本上做好了介绍关键方程的准备，但是还需要一些定义。给定矢量V,这里定义它
的支持集I如下：
I={1:0≤isn-1,V≠0} (9.19)
下面定义几个关于V的多项式：位置多项式，穿孔位置多项式和数值多项式。V的位置多项
式为：
ovx)=Ia-ax) (9.20)
对应每个i值∈1,再定义；阶穿孔位置多项式o(x):
(x)=aytx)/(1-α'x)
--c (9.21)
最后，定义V的数值多项式为：
wrx)=ZvoYw (9.22)
后面，比如在9.5节和9.7节中讨论 RS/BCH译码算法时，还将需要下面的引理：
第9章 BCH、Reed-Solomon码及其同类码 179
引理1 god(oy(x),wy(x))=1
证明；根据式(9.20),god(ov(x),wv(x))=(1-αx),其中J=li∈1:wv(a3)=0。
又由式(9.22),如果i∈1,wy(a)=Vo(α)。但是根据I的定义，如果i∈I,则V?≠0,
又由式(9.21),(α')=11S(1-α?)≠0。因此集合J是空的，god(dy(x),wv(x))=1,
证毕。
现在就开始介绍“关键方程”。
定理9.4(关健方程)对于一个固定的天重V,多项式V(x),dy(x)和wy(x)满足：
av(x)V(x)=wv(x)(1-x") (9.23)
证明：利用定义(9.11)式、(9.14)式和(9.2)式，我们发现，
w=*a (9.24)
根据式(9.21),对所有i∈1,dy(x)=σ(x)(1-a3x),所以由式(9.24)我们有：
owowa)-Svolax0-axzva°
=Zoic(1-x°)
=wv(x)(L-x?)
定理9.3的下述推论告诉我们，应该如何利用a(x)和ay(x)重构V的非零分量。这涉
及到多项式dy(x)的形式导数a'v(x)。(见习题9.18。)
推论1 对于每个i∈1,我们有：
v=-ar-) (9.25)
证明：如果对关键方程(9.23)求导，特得到：
ov(x)'(x)+av(x)V(x)=av(x)(-nx"-)+wv(x)(l-x") (9.26)
注意，如果x=α-1(其中i∈1),由式(9.20)和式(9.10}可以看到av(x)和1-x”都为零。
因此如果x=α?',则式(9.26)变为：
av(a-i)(α-)=-na3wv(α-) (9.27)
但是由式(9.16),V(a-)=nV。这个条件与式(9.27)联立就完成了证明。
推论1说明，V的时域坐标可由oy(x)和wy(x)有效地恢复。接下来将要证明的推论说
明，如果知道V的前几个频域坐标，其余的就可以仅由σy(x)通过一个简单的递归运算来恢
复。在推论的表述中，设ay(x)表示为：
av(x)=1+01x+…+0ax?
.!推。:|:
180 信息论与编码理论(第二版)
推论2 对于任意下标j,我们有：
v?=-OyP (9.28)
将其中所有下标都理解为经过mod n运算的。
证明：关键方程意味着，
0y(x)V(x)=0(mod 1-x") (9.29)
式(9.29)说明，对于0≤j≤n-1范围内的每个j,多项式dy(x)V(x)md(1-x")中x的系数
都为0。但是这个系数又可以表示为ZVi-),所以对于0≤j≤n-1范围内的每个j,
都有：
P-i=0 (9.30)
其中下标是经过md n运算的，并且已经定义了do=1。因此现在式(9.30)就与式(9.28)等
价了。
例9.2 现在以城GF(16)为例进行说明，这个域中的非零元素由满足式a?=a+1的本原元
α的赛表示。我们考虑矢量
V=(0,0,α2,0,0,0.0,α?.0.0、0.0,0,0,0)
则在式(9.13)中定义的多项式V(x)为：
V(x)=α2x2+α?x?
利用式(9.11)或式(9.15),可以算出V的DFT:
V=(a12,a?,0,α3,1,0,α°,a?,0.1,α12,0,α?,a3,0)
因此如式(9.14)中的定义，(x)为：
P(x)=a12+a?x+α3x3+x?+a?x?+a?x?+x?+a12x1+a?x2+a3x13
=(a12+a?x)(1+α?x3+a12x?+a3x?+a?x12)
=(a2+a1+
=a2+ax+a
(9.31)
V的支持集为I=|2,7!,因此V的位置多项式为：
ov(x)=(1+a2x)(1+a1x)=1+a12x+a?x2 (9.32)
在这种情况下，式(9.21)中定义的多项式o(x)为：
a=(1+a?x),a?=(1+a2x)
在式(9.22)中定义的数值多项式wy(x)为：
wr(x)=a2(1+α?x)+a'(1+a2x)=a12 (9.33)
结合式(9.31)、式(9.32)和式(9.33),我们看到在这种情况下关键方程确实是成立的。为
:
第9章 BCH、Reed-Solomon码及其同类码 181
验证推论1,注意到由式(9.32),ay(x)=α2=wv(x),团此对i∈1,推论1简化为V?=a',
这是成立的(V?=a2和V=α?)。最后，注意推论2在这种情况下说明：
=a12Vj_1+a?Yj_2对于j=2,3,…,14
所以(利用V=a2和V=α?作为初始条件),
Y2=α12·α?+α?-α12=0
V3=α12·0+a?·α?=α3
=α12-α3+a?.0=1
·:·
V14=a12.α3+α?·a?=0
这与我们直接算出的一致。
有了关键方程的预备知识，就可以开始对 BCH码的译码问题进行详细地讨论了。设C=
(Co,C?,…,Ca)是由式(9.6)定义、码长为n、纠正：个错误的 BCH码中的一个码字，经过噪
声信道传输后，接收到R=(Ro,R,…,R_)。假设R的分量是0和1,即GF(2)的元素。我
们定义错误图案为矢量E=(E?,E?,…,E?)=R-C。译码的第一步是计算伴随式S,S?,…,
S?,它们定义为：
s,-_Ra,对于j=1,2,…,21 (9.34)
因为R=C+E,且C是一个码字，故得出：
s,-Ea°. 对于j=1,2,…,2r (9.35)
因此正如所料，伴随式只依赖于错误图案，而与传输的码字无关。另外注意比较式(9.35)和
式(9.11),我们看到S,是错误图案的 DFT的第j个分量；换句话说，伴随式让我们看到E的连
续2r个分量(第1个、第2个...、第21个)。现在如果定义扭曲的错误图案V为：
V=(Eo,E?a,E?a2,…,ER-1a"-1) (9.36)
则由式(9.17)和式(9.18)得出(S?,S?,…,S?)=(V,V?,…,V2-1)。
将关键方程应用于式(9.36)中定义的矢量V;但是由于只知道V(x)的前21个系数(即
o,P,,…,Vz?-1),因此我们改为关注经 mod x“降次的关键方程：
a(x)V(x)=a(x)(mod x2) (9.37)
[在式(9.37)中去掉了(x)和o(x)的下标V。]由式(9.19)和式(9.36)我们看到V的支持集
是使E≠0的标号集合，即错误位置的集合。由于这个原因，式(9.37)中的多项式o(x)称为
错误位置多项式。同理，式(9.37)中的多项式w(x)称为错误数值多项式。式(9.37)则称为
BCH关键方程，
现在观察一下，如果给定接收码字R的伴随式，或者等价地，给定V(x)modx2,我们就能
.e 1
1}
182 信息论与编码理论(第二版)
以某种方式“解”BCH关键方程(9.37)式，求出多项式o(x)和w(x),然后可以很容易地恢复出
错误图案E,以及传输的码字C=R-E。为此，可以先算出n个值a(a*'),i=0,1,…,n-1,
它可以确定式(9.19)中定义的支持集1。然后通过式(9.25)算出V的非零分量，这将得到完
整的矢量V,或者等价的E[见式(9.36)]。另一种方法是，已知(,V,…,V?,-1),可以利用
式(9.28)计算出矢量V.然后通过反DFT恢复V。在下一节里，将介绍一种利用BCH方程来计
算x(x)和0(x)的非常有效率的算法，它只要求我们再附加一个假设：实际发生的错误数目不
超过：个。(这个假设足必要的，因为所设计的一个纠正：个错误的BCH码并不是用来纠正t
个以上错误的。)
9.4 多项式的欧几里得算法
本节并不直接涉及BCH码的译码问题。但是读者应该记住，我们的目标是通过解 BCH
关键方程[式(9.37)]来求出a(x)和w(x),这里已知(x)modx"。
在整个这一节中，a{x)和b(x)都是域F上固定的多项式，并且deg a(x)≥deg b(x)?。
以后a(x)将用x“替换，b(x)将用伴随式多项式S(x)替换。
欧几里得算法是一个递归程序，目的是寻找a(x)和b(x)的最大公约数(简写为god)d(x),
并寻找a(x)和b(x)的一个线性组合，使之等于d(x),即，找到如下形式的等式：
u(x)a(r)+U(x)b(x)=d(x) (9.38)
这个算法包含四个多项式序列：(a.(x)),(v?(x)),(r?(x)),(q;(x))。初始条件为：
W-j(x)=1,U-i(x)=0,r1(x)= a(x)
to(x)=0, Do(x)=1, ro(x)=b(x) (9.39)
[这里没有定义g_i(x)和g(x)。]对于i≥l,定义q.(x)和r(x)分别表示 r?-2(x)除以r_i(x)
的商和余式：
r?-2(x)=q:(x)r,-1{x)+r(x).degr?<degiI (9.40)
而多项式n(x)和b;(x)定义为：
a;(x)=u-2(x)-q;(x)i-;(x) (9.41)
D.{x)=Di-2(x)-q{x]0;i(x) (9.42)
由于余式r的次数是严格递减的，最后将存在一个非零项；记为rn(x)。已经证实r(x)就是
a(x)和b(x)的god,此外，将 god表示为原来两个多项式的线性组合[参照式(9.38)]所需要的
等式为：
Nn(xlal.x}+0(x)b(x)=r(x) (9.43)
因为欧几里得算法的这个方面并不是我们主要关心的，所以将这些事实的证明留做习题9.18(b)。
现在对我们来说更有意义的是，表9.2中所列出的欧几里得算法中多项式之间的中间关
系式。通过对i采用归纳法，不难证明这些性质；见习题9.19(a)。
·: 年 ..
is
第9章 BCH、Reed-Solomon 码及其同类码 183
表9.2 欧几里得算法的性质
A 矿-t--r=(-1)'a 0≤iGn+l
B ,5!“=(-1)+lg 0≤iR+1
C 7,B--u-=(-1)· 0≤in+1
D u,a+b=r -Ii≤n+1
IE dg(n)+deg(r,1)=deg(b) I≤i后n+1
F deg()+deg(z-1)=dg(a) 06in+1
例9.3 令F=GF(2),a(x)=x",b(x)=x?+x?+x2+x+1。欧几里得算法的步骤由表9.3
给出。
表9.3 欧几坐得算法的一个例子
i v, 9
-1 1 0 x' …
0 0 1 x?+x?+x2+x+1
…
x2+1 x3+x+1 x2+l
2
3
x2+1 x3+x3+z2 x2 z3+1
x?+x+ x?+x?+x3+x2+1 x+1 x
4 x3+x1+x3+x2 x2+x+x3+x+1 L x+1
5 x+x?+x2+x+E 0 t+1
表9.3的i=4行显示 ged(a(x),b(x))=1(这是显然的),而根据表9.2中的性质D,得出
等式(x?+x?+x3+x2)a(x)+(x2+x?+x3+x+1)b(x)=1。例9.4中将继续研究这个
例子_
现在将注意力集中在表9.2中的性质D上，它可以重写为：
v;(x)b(x)三r?(x}{mad a(x)) (9.44)
利用性质F和条件deg F-1>deg r,得到估计：
degD,+degr<dega (9.45)
本节的主要结论(定理9.5)是式(9.44)和式(9.45)的一种逆，下面由一个引理开始。
引理2 假设将上面所述的欧几里得算法，应用于两个多项式a(x)和b(x)。给定两个
整数p≥0和v≥0,满足μ+v=deg a-1,则存在惟一的一个标号j(0≤i≤n),使得：
deg(Dy)≤ (9.46)
deg(r;)≤v (9.47)
证明：回顾 degr,是i的一个严格递减函数，直到r=gd(a,b),通过要求
deg r-!2+1 (9.48)
degr≤v (9.49)
来定义锥一的标号j。则根据性质F,我们也有：
deg v;≤μ (9.50)
degDi+1+1 (9.51)
·、i ;
184 信息论与编码理论(第二版)
式(9.49)和式(9.50)表明存在一个标号j满足式(9.46)和式(9.47),式(9.48)和式(9.51)
证明了惟一性。
下面的定理是本节的主要结论。
定理9.5 设a(x),b(x),(x)和r(x)是非零多项式，满足
D(x)b(x)=x)(mod a(x))
degb(x)+ degr(x)<deg a(x)
(9.52)
(9.53)
进一步设 v(x)和r,(x),j=-1,0,…,n+1,是对(a(x),b(x))应用欧几里得算法时产
生的多项式序列。则存在惟一的一个标号j,0≤j≤n,和一个多项式A(x),使得：
U(x)=λ(x)u(x) (9.54)
r(x)=λ(x)r(x) (9.55)
证明S):令j是满足式(9.46)和式(9.47)的标号，其中取v=deg r,μ=deg a-deg r-1。
因此由式(9.53),deg(v(x))≤μ。则根据式(9.51)和式(9.48),deg tj+1μ+1≥deg v+1,
deg 7-1≥v+I=deg r+1。因此如果存在一个标号使式(9.54)和式(9.55)成立，则它一定
是惟一的。
现在将性质D和式(9.52)重写如下：
uja+D;b=r (9.56)
ua+0b= (9.57)
其中u是某个未确定的多项式。将式(9.56)乘以v,式(9.57)乘以v;:
ujoa+ujub=rj0
ut;a+0u;b=ru;
(9.58)
(9.59)
式(9.58)和式(9.59)表明rum,(mud a)。但是根据式(9.47)和式(9.53),deg(rp)=
deg r;+deg v≤v+μ<deg a、同理，根据式(9.46)和式(9.53),deg(w,)=deg r+deg v;≤
v+μ<deg a,因此得出ro=n,。这个条件与式(9.58)和式(9.59)结合，就得出uD=0;。
但是由于性质C保证了u和v,是互质的，这就意味着对某个多项式A(x),
u(x)=l(x)u(x)
D(x)=L(x)0;(x)
则式(9.57)变为Au,a+Ayb=r;与式(9.56)比较，我们得出结论r(x)=A(x),(x)。
在后面对 BCH和Reed-Solomon码译码算法的讨论中，经常要用到定理9.5的结论。为方
便起见，现在引人算法程序Euclid(a(x),b(x),μ,v)。
定义 如果(a(x),b(x))是一对非零多项式，满足deg a(x)≥deg b(x),而(μ,v)是一对
使μ+v=deg a(x)-1成立的非负实数，则 Eucid(a(x),b(x),μ,v)是这样的程序：当对
(u(x),b(x))应用欧几里得算法时，该程序返回惟一一对多项式(v;(x),r(x)),其中
deg t(x)≤a,而deg r(x)≤va
下面的定理总结了本节的结论。
:中中事
第9章 BCH、Reed-Solomon码及其同类码 185
定理9.6 设v(x)和r(x)是非零多项式，满足
Ox)bx}三{x)(mod a(x))
dego(x)≤μ
deg rlx)≤
(9.60)
(9.61)
(9.62)
其中，μ和v是满足μ+v=deg a(x)-1的非负实数。如果(v,(x),r;(x))是由
Faclid(a(x),b(x),a,v)返回的一对多项式，则存在一个多项式A(x),使得：
D(x)=λ(x)u;(x) (9.63)
r(x)=λ(x)r(x) (9.64)
证明：定理9.5保证了存在惟一的一个标号j,可使式(9.63)和式(9.64)成立。而且，
Euclid(a(x),b(x),μ,v)一定会返回这对多项式，原因是根据式(9.63)和式(9.64),
deg ;(x)≤deg o(x)≤μ,deg r;(x)≤deg r(x)≤v。
例9.4 与例9.3中一样，令a(x)=x*,b(x)=x?+x?+x2+x+1,F=GF(2)。利用表9.2,
可以针对(μ,v)的8种可能组合，将欧几里得程序的输出列成表；
(u,v) Eucid(x,x+x+x2+x+1.μ,v)
(0.7) (1,x?+x?+x2+x+1)
(1,6) (1,x?+x?+x2+s+1)
(2,5) (Z2+1,x3+x+1)
(3,4) (2+1,x3+x+1)
(4,3) (z2+1,x3+x+1)
(5.2) (x?+x3+r2,x2)
(6.1) (x?+x?+x3+x2+l,x+1)
(7,0) (x?+x?+x3+x+1,1)
现在假设我们希望“求解”全等式(x?+x+x2+x+1)a(x)=w(x)(mod x?),约未条
件是dego(x)≤3,degw(x)≤4。根据定理9.5,调用Euclid(x°,x?+x?+x2+x+1,4,3),根
据上表，返回一对(x2+1,x3+x+1),所以针对该问题的所有解具有形式a(x)=A(x)(x2+1),
a(x)=A(x)(x3+x+1),其中degA(x)≤1。如果进一步要求ged(a(x),w(x))=1,则惟
一解将是o(x)=x2+1,w(x)=x3+x+1。
到此为止，应用定理9.4求解 BCH码关键方程的问题应该很清楚了。我们将在下一节里
针对各种情况进行详细介绍。
9.5 BCH 码的译码，第二部分：算法
接下来叙述 BCH码的译码问题，这个问题在9.3节的结尾被暂时搁置了。给定接收矢量
R=(Ro,R,,…,R.1),它是一个未知码宇C的噪声样本，即R=C+E,其中C=(Co,C?,…,
Ca-;)是由式(9.7)定义的纠正：个错误 BCH码中的一个码字，E是错误图案。我们的目标是
从R恢复 C。译码过程的第一步是计算伴随式多项式S(x),它定义为：
S(x)=Si+Szx+…+S?2-1 (9.65)
:
186 信息论与编码理论(第二版)
其中S,=2R;a",j=1,2,…,2t。前面在9.3节的结尾看到，S(x)=V(x)nod x“,其中
V(x)是式(9.36)中定义的矢量V经傅里叶变换后的生成函数，因此关键方程(9.37)式变为：
o(x)S(x)=o(x)(mod x2) (9.66)
其中o(x)是错误位置多项式，w(x)是错误数值多项式。
译码过程的下一步是利用欧几里得算法，特别是9.4节中定义的程序Euclid(a(x),b(x),
从),通过解关键方程求出σ(x)和u(x)。这是可实现的，因为如果实际发生的错误数目≤
t,则根据式(9.20)和式(9.22),
dego(x)≤r
dega(x)≤t-
并且根据引理1,ged(a(x),o(x))=1。这就满足了定理9.5的假设，其中a(x)=x2,b(x)=
S(x),v(x)=o(x),r(x)=a(x),μ=6,v=1-1,如果调用程序 Euclid(x2,S(x),t,f-1),它
将返回多项式对(v(x),r(x)),其中v(x)=Ac(x),r(x)=λo(x),A是一个非零标量。这个
标量λ可以由条件a(0)=1[见式(9.20)]确定，即A=v(0)-1,所以，
o(x)=(x)/u(0)
w(x)=r(x)/v(0)
泽码算法的最后一步是利用α(x)和w(x)确定错误图案E=(E,E?,…,E),由此确
定纠错后的码字C=R-E。在9.3节结尾处看到，有两种方法可以做到这一点，我们称之为
时城方法和频域方法。
时域方法是基于条件：
ow)=Ia-dx)
其中，I是错误定位集合，即，I=|i:E≠0[见式(9.20)和式(9.36)]。因此，为了找到错误位
置，就需要找到方程g(x)=0的根的倒数。因为只有n种可能根，即1,α-1,a-2,…,α-(a-D,
所以可以利用一种简单的“试错”算法找到E。因此所谓的“时域完成法”可以由下面的伪代码
部分描述。它以o(x)为输人，产生错误矢量(E,E,…,E-1)。
/*Time-Domain Completion*/
[
for(i=0ton-1)
{
Lf(a(a-)==0}
E=1;
else
E=0:
)
}
图9.1中介绍了一个利用时域完成法的完整译码算法。注意这里没有用到错误数值多项
式山()—它的重要性只有在下一节考虑Reed-Solomon码时才会体现出来。
第9章 BCH、Reed-Solomon 码及其同类码 187
/*'Time-Domain'' BCH Decoding Algorithm*/
{
for(j=1to 2t)
S=Z=I,R?a;
S(x)=Si+S?x+…+S?x2-1;
if(S(x)==0)
print'no errors occurred'';
else
{
Euclid (x2,S(x),t,t-1);
o(x)=ux)/u(0);
for(i=0to n-1)
{
if(0(α-)==0}
E=1;
else
E=0;
)
for(i=0to n-1)
C=Ri+E:;
print'corrected codeword:(C,Cj,…,C-1);
}
)
图9.1 一个时域 BCH译码算法
频城方法是基于定理9.4的推论2,它说明V=(Vo,…,1-I)的分量可以通过公式V;=
∑,,递归算出，这里o(x)=1+opx+…+x,条件是至少已知矢量的d个“初始
值”。由于伴随式提供了的2:个分量，即V,V2,…,V?,而 Euclid(x2,S(x),1,t-1)确保
返回的一定是一个次数≤的多项式(x),伴随式的值S?,S?,…,S?.足以满足递归算法的初
始条件，所以下面的“频域完成法”将成功地算出错误矢量E:
/*Frequency-Domain Completion*/
{
for(j=2t+1ton)
S/modn=∑i=11S,_:
for(i=0ton-1)
E,=∑=S,α-);
)
图9.2中介绍了一个利用频域完成法的完整译码算法。
例9.5 考虑码长为15、纠正3个错误的BCH码，它的生成多项式为g(x)=x"+x?+x?+x?+
x2+x+1(见例9.1)。假设接收矢量R=(110000110110101)。则伴随式分量 S,由S,=
1+d+a+a?+α+a+a2+a给出，其中a是GF(16)的本原元。利用表9.1,以
及条件Sz,=S}(见习题9.17),我们发现S,=α2,S?=a?,S?=0,S=α3,S?=1,S?=0,因
.
188 信息论与编码理论(第二版)
此S(x)=x?+a3x3+α2x+a2。将欧几里得算法应用于多项式对(x?,S(x)),得到了下
面的表：
V q:
-1 L 0
0 0 1 x?+c3x3+ox+α
—
1 1 x2+a3x+a a3 2+a3z+a?
因此，程序Euclid(x?,S(x),3,2)返回多项式对(x2+a3x+α?,α3)。将这两个多项式都乘
以a-°,发现a(x)=1+a2x+α?x2,w(x)=α2。如果选择时城完成法，我们发现对i=2
和7,o(a-i)=0,因此错误困案E=[001000010000000],纠正后的码字为C=
[111000100110101]。另一方面，如果选择频域完成法，则利用初始条件S?=α2,S?=a?,
S;=0,S=a3,Ss=1,S。=0,以及递归式S,=a2Sj-1+a°S,_2计算伴随式矢量，得出S=
(Sn,S,,…,S?s)=(0,a2,a?,0,a3,1,0,a?,a?,0,1,α2,0,a?,a3)。对矢量S进行反DFT,
就得到E=[001000010000000],C=[111000100110101],与前面的结果棋同。
/*'Frequency-Domain'' BCH Decading Algorithm*/
{
for(j=1ta 2t) S-Z"=aR?a;
S(x)=S+S?x+…+Sz,x2r-i;
if(S(x)==0)
print'no errors occurred'';
else
(
Euclid (x2,S(x),r,t-1);
o(x)=D(x)/0(0);
for(j=2t+1 ton)
Smoda=∑i?oS)-6;
for(i=0ton-1)
E=∑=Sja-);
for(i=0ton-1)
C,=R+E; printcorrected codeword:(Co,C,.…,Ca-1)';
}
}
图9.2 --个频城 BCH译码算法
如果错误数目不超过：,图9.1和图9.2中的算法会运行正常。但是如果出现了：个以上
的错误，就可能产生某些问题。例如，程序“Euclid(x2,S(x),t,t-1)”可能返回一个多项式
v(x)具有s(0)=0,因此导致在步骤“σ(x)=v(x)/v(0)”中除数为0。另外，译码器输出的
C=(Co,C,,….C-1)可能不是一个码字。因此在这个译码算法的任何实际应用中，必须检测
这些非正常情况，如果它们发生了，就打印一条出错信息，例如“t个以上错误”。
鸽
第9章 BCH、Reed-Solomon 码及其同类码 189
9.6 Reed-Solomon 码
在本章前5节中，我们介绍了有关BCH码的一套完整理论。BCH码是二进制域GF(2)上
能够纠正多个错误的线性码，它的译码算法需要在更大的域 GF(2")上实现。因此对于BCH
码，存在两个有意义的域：码宇符号域GF(2)和译码计算域GF(2")。
已经证实、可以利用几乎完全相同的理论来发展另一类码：Reed-Solonon码(简称RS码)。
RS码和 BCH码之间主要的理论差别在于，对于RS码而言，符号域和计算域是相同的。这两
类码的主要应用差别在于，RS码很自然地适合于传送信息符号，而不是比特。在这一节中，将
定义并研究Reed-Solomon码。
令F是含有阶数为 n的元素a的任意域“。如果r是一个1到n之间的固定整数，则分
量在F中，并且满足
ca?=0.j=1.2.…., (9.67)
的所有矢量C=(Co,C,…,C-)组成的集合称为域F上码长为 n、冗余为r的一个Reed-Solormon
码。属于这个码的矢量C称为它的码字。下面的定理介绍了RS码的基本性质。
定理9.7 由式(9.67)定义的码是F上的一个(n.n-r)循环码。它的生成多项式为
g(x)=1=(x-a1),最小距离dm=F+1c
证明：令C=(C,C?,….Ca-1)是F上任意一个长度为n的矢量，并令C(x)=Co+C?x+…+
C.x"-1是相应的生成函数。则式(9.67)说明C是一个码宇的充分必要条件是，对
j=1,2,…,r,C(α)=0,等价地，C(x)是g(x)=(x-a)(x-a2)…(x-a)的一个倍式。
但是由于x"-1=[(x-d),可见g(x)是x"-1的一个因式，因此根据定理8.3(b),
该码是一个(n,n-r)循环码，它的生成多项式为g(x)。为了证明关于d的结论，注
意到式(9.67)说明，如果C=(C,C?,…,C-1)是一个码字的 DFT,则C?=C?=…=
C,=0[参照式(9.11)]。因此根据有关BCH码的论证(定理9.3),任意非苯码字的重量
都≥r+1。另一方面，如果将生成多项式g(x)=x'+g,-|x1+…+ga看做一个码字，它
的重量≤r+1。因此d=r+,证毕。
例9.6 考虑GF(8)上的(7,3)Reed-Solomn码。如果α是GF(8)中的一个本原元，满足a3=α+1,
则该码的生成多项式为g(x)=(x-a)(x-a2)(x-a3)(x-a?)=x?+a3x3+x2+ax+a3。
而如果将g(x)看做一个码字，则是[a3,a,1,a3,1,0,0],其重量为5,是该码的最小重量。
我们注意到例9.6中GF(8)上的(7,3)RS码有d=5,而例8.2(及第8章其他地方)提及
的GF(2)上的(7,3)码只有dm=4。下面的定理证明了对于给定的n和t,RS码具有不依赖
于域F的最大可能dno
定理9.8(Singleton界)如果C是城F上的一个(n,A)线性码，则d≤n-k+1。
证明：首先我们回顾一下，如果T是一个线性变换，将一个有限维矢量空间U映射为另一
个矢量空间V,则
i
190 信息论与编码理论(第二版)
rank(7)+nullity(T)=dim(U) (9.68)
我们将这个公式应用于将码C映射为空间F-1的线性变换T,方法是将每个码字投影到
前k-1个坐标上：
T(C,C,…,Ca-1)=(Cn,C,…,C-2)
已知，rank(T)≤k-1,原因是映像F*1具有雄数区-1。另外，根据假设 dim(C)=t。因
此式(9.68)意味着rullity(T)≥t。至少存在一个非零码字C,使得T(C)=0。这样的一
个码宇至少有k-1个军分量，因此它的重量至多是n-k+1。
定理9.8说明，任意(n,k)线性码的d≤n-k+1。另一方面，定理9.7又说明了任意(n,k)
Reed-Solomn码的d=n-k+1,所以对于给定的码长和维数，从具有最大可能的最小距离这个意
义上来讲，Red-Solomon码是最佳的。具有dm=n-k+1的线性码有一个特定的名字；它们被称
为最大距离分离(MDS)码。(习题9.24至习题9.26中介绍了其他一些MDS码。)所有MDS码都共有
一些非常有意义的数学性质；其中最有意义的就是下面所述的MDS码的插值性质。
定理9.9 令C是城F上的一个(n,k)MDS码，并令Ic10,1,…,n-1|是任意k个坐标
位置组成的子集。则对F中任意k个无素组成的集合a:i∈I,存在惟一的一个码宇
C,使得对所有i∈1,有C;=&。
证明：我们考虑将码C映射到F的线性变换P,它将每个码字投影到标号集合I;即
P?(Cn,C?,…,Ca-1)=(C,Ci?,….C?),其中I=1ij,i2,…,F。式(9.68)在这种情况
下变为mank(P)+nullity(P?)=dim(C)。我们看到dim(C)=k、因为C是一个k维码。
而nullity(P?)=0,原因是如果存在一个非零码字C,使得P,(C)=0,则这个码字的重量至
多是n-h,这与C是一个MDS码的条件矛质。因此根据式(9.68),rank(P)=k,可见映
射P:C→是非退化的，即是一一对应并且满映的。所以将一个码宇投影到]时，F
中的每个矢量恰好出现一次，而这正是定理所保证的。
这里总结一下定理9.9的结论，它说明一个玉维MDS码的任意k个坐标位置所组成的子
集都是一个信息集合(另见习题7.13)。我们给出的证明很简短，并且是非构造性的；但是，对
于RS码存在一个有效的插值算法，它与数值分析中的拉格朗日插值公式关系密切。下面的
定理清楚地说明了这一点。
定理9.10 考虑由式(9.67)定义的域F上的(n,h)Reed-Solomon码，其中k=n-r。在
这个码的码字C=(C,C,…,Cm-1)和域F上次数等于或低于k-]的所有多项式
P(x)=P?+P?x+…+Pa-x的集合之间存在一一对应关系，由下式给出：
C?=α-《r+lP(a-)
因此除了缩放因子α-A+),一个给定的RS码宇的各个分量是某个k-1次多项式的不同值。
证明：令C=[C?.…,Ca-1]是一个给定的码宇。我们定义一个C的“扭曲”形式，称做D=
[D?,…,Da-1],定义为：
D?=α+1)C,l=0,1,n-1 (9.69)
因为根据式(9.67),有C?=C?=…=C,=0,故由式(9.17)和式(9.18)得出D_,=…=Da-1=0。
:;1
第9章 BCH、Reed-Solomon码及其同类码 191
因此D的DFT的多项式，表示为D(x),是一个次数等于或低于n-r-1=k-1的多项式：
D(x)=D+Dx+…+DA-1x1-1
现在定义多项式P(x)如下：
P(x)=bw)
则根据式(9.16),有D?=P(α-),i=0,1,…,n-1。将此式与式(9.69)联立，枕得到C,=
α-Kr+D P(α'),这正是我们需要的。
下面举例说明定理9.10。
例9.7 考虑例9.6中所述的(7,3)RS码。根据定理9.9,存在惟一的一个码宇C使得
C=a3,C=α和C?=a?:现在就来构造这个码字。
首先观察到如果1={1,4,6,根据定理9.9,C的一个3x7维生成矩阵大体上应具有如下形式： -9
其中*是GF(8)中的未知元素，需要进一步确定。一旦知道了G,所求的码字C就可由
C=[a3,a,a?]·G给出。所以现在来构造G146的三个行，我们称之为C?,C和C。
根据定理9.10,(7,3)RS码中的任意码宇C都可以表示为C=a-"P(α'),其中
P(x)=Po+P?x+P?x2为一个次数等于或小于2的多项式。例如，如果P?(x)表示对应
于G的第一行C的多项式，则有：
P(a-1)=α3,P(a-4)=0,Pi(α-6)=0 (9.70)
由式(9.70)中的条件P?(a?)=P(a??)=0可得出P?(x)=A(1+a?x)(1+a?x),A是
某个常数，它可由条件P?(α-1)=α?确定。实际上P?(α1)=a?意味着A(1+a3)(1+
a?)=α?,即A=a?(1+a3)(1+a?)=1。而P?(x)=(1+α?x)(1+a?x),因此，
C=[Pi(1),a2P?(a-1),a?R(a-2),α?Pi(a-3),
a1P(α-4),a3Pi(a-s),α3P(a-)]
=[1,1,a,α3,0,a,0]
同理，如果P(x)和P?(x)表示对应于生成矩阵Gu的C和C行的二次多项式，则会发
现P(x)=a2(I+ax)(1+a?x),P?(x)=α?(1+ax}(1+α?x)。因此计算出：
Ca=[1,0,α?,a?,1,a2,0]
C6=[1,0,a?,a?,0,α3,1]
结合C,C和C,就找到了生成矩阵Gi?,为：
c-()
最后，C=a3,C?=α,C?=a?的惟一码字C为：
C=[a3,a,a+]·GiA?=[a?,a3,a?,0,a,1,a?]
·,a1
192 信息论与编码理论(第二版)
到此就结束了对RS码的理论探讨；现在来考虑编码和译码的实际问题。
由于(n,k)RS码是循环的，根据定理9.7,可以利用第8章介绍的移位寄存器技术进行编
码。特别是可以利用图8.5(a)中的通用编码电路。但是由于RS码是定义在任意的一个域F
上的——实际应用中从来不是二进制域GF(2)(见习题9.27)——因此三个基本元件(触发
器、加法器和乘法器)--般情况下不是“现货供应”的。虽然在域 GF(2")上设计这些元件是一
个重要而有意义的课题，但它不在本书的讨论范围内，我们将以图9.3结束对RS编码器的讨
论，图中介绍了GF(8)上一个g(x)=x?+a3x3+x2+ax+a3的(7,3)系统 RS码的移位寄存
编码器(见例9.6和例9.7)。
:4
前3个时钟周期团合
后4个时钟周期断开
3 3
tt3个时忡周期向下
后4个时针周期向上
a
+ +
输出
输入
图9.3 GF(8)上一个g(x)=x?+ax3+x2+ax+a3的(7,3)系统RS码的移位寄存编码器
现在转向RS码的译码问题。它与 BCH码的译码非常相似。如果考虑到它们定义的相似
性i比较式(9.7)与式(9.67)],这就不奇怪了。
这里开始正式研究 RS的译码问题。给定一个接收矢量R=(R?,R,…,R-1),它是
式(9.67)定义的(n,k)RS码中一个未知码字C=(Co,C,…,C.,)的噪声样本，即R=C+E,
其中E是错误图案，因为根据定理9.7,d=7+1,可见只有在 w(E)≤Lr/2]时，才能正确识
别出 C,因此在下面的讨论中，将令：=Lr/2],并假设wt(E)≤1。
译码过程的第一步是计算伴随式多项式：
S(x)=S?+S?x+…+S,xr-1 (9.71)
其中S,=∑R,a?,j=1,2,…,r。根据9.3节的结论，如果定义“扭曲错误图案”为：
V=(Eo,E?a,E?α2,…,En-1a2-1)
则S(x)=V(x)mod x,而关键方程(9.23)经过mod x'降次后，变为：
o(x)S(x)=u{x)(modx')
其中g(x)是矢量V的位置多项式，w(x)是数值多项式。
现在的译码问题与9.5节中所述的 BCH码的译码问题几乎完全一样。特别是，如果调用
程序Euclid(x',S(x),t,t-1),它将返回多项式对(v(x),r(x)),其中v(x)=Ar(x),r(x)=
ku(x),λ是某个非零常数。
译码算法的最后一步是利用a(x)和w(x)来确定错误图案E=(Eo,E,…,E-1),并由
此求出原来发送的码字C=R-E。与BCH码一样，对此有两个本质不同的方法：时域方法和
频城方法。
RS译码的时城方法与BCH译码的时域方法类似，但是有一个重要的区别：对于 BCH码，
一旦知道了错误位置，立即就能够知道它们的值。这是因为 BCH码是二进制的，对于所有的
·:轴：.. 、
第9章 BCH、Reed-Solomon 码及其同类码 193
,有E=0或1。因此如果在位置i处有一个错误，即E≠0,则一定有E=l。然而，对于RS
码，E,是“大”的城F中的元素，因此仅知道E≠0是不足以确定E,的。当一个错误位置确定
后，为了计算出它的错误值，就要利用定理9.4的推论1,它的内容是，如果E≠0,即
a(a')=0,则V=aE=-a'w(a?')/o'(α'),即，
E=-ot-) (9.72)
因此RS译码算法的时域完成法可以如下：
1*Time-Domain Completion*/
{
for(i=0ton-1)
{
if(o(α-'):--0)
E,—-w(a-1yo'(α-);
else
E?=0;
}
}
图9.4中介绍的是RS码的一个完整的时域译码算法。
/*Time-Domain''RS Decoding Algorithm*/
{
for(j=1tor)
S,=∑=oRia;
S(x)=S?+S?x+…+S?x′-1;
if(S(x)==0)
print'no errors occurred'';
else
{
Euclid (x',S(x),1,1-1);
o(x)=(x)D(0);
b(x)=r(x)v(0);
for(i=0 con-1)
{
if(0(α1)==0)
E;=-w(αva'(α-);
else
E=0;
for(i=0ton-1)
C=R?-E?;
print 'corrected codeword:(Ca,C,…,Cn1)';
}
】
图9.4 一个时域RS译码算法
……
d
194 信息论与蝙码理论(第二版)
RS译码的频域方法与 BCH译码的频域方法几乎完全相同，原因是通过递归算法计算错
误矢量的思想对任意域F都适用。这里是一个频域完成法的伪代码程序。
/*Frequency-Domain Completion*/
{
for(j=r+1 ton)
S/modr=-∑S-i
for(i=0ton-1)
E,=Z=!S;a-;
)
图9.5中给出了一个利用频域完成法的完整RS译码算法。
/*Frequency-Domain''RS Decoding Algorithm*/
{
for(j=1 tor)
S=∑=sR;a;
S(x)=S+S?x+…+S,x2-1;
if(S(x)==0)
print'no errors occurred';
else
{
Euclid (x2,S(x),L1-1);
0(x)=v(x)o(0);
a(r)= Hx)/o(0);
for (j=r+1to n)
Smodn=-Z-oiSj-6;
for(i=0ton-1)
E;=E=oS;a-);
for(i=0ton-1)
C=R-Ei
printcorrected codeword:[C,C?,…,Cn-小';
}
图9.5 一个频域RS译码算法
例9.8 考虑已经在例9.6和例9.7中讨论过的GF(23)上的(7,3)RS码，它的生成多项式
g(x)=(x-α)(x-α2)(x-a3)(x-a?)=x?+a3r3+x2+ax+a3。假设接收失量为R=
(a3,a,1,a2,0,a3,1)。伴随式S,=∑R,a?为S?=α3,S?=a,S?=?,S?=0,因此S(x)=
a?x2+a?x+α3。如果调用程序 Euclid(x?.a?x2+a?x+a3,2,1),就得到了
下表：
:f Y(x) (x) q(x)
-1 0
1 a?x2+a?z+a3
32+c3x+a3 T+α e32+q3±+as 0
I
湖 ME
第9章 BCH、Reed-Solomon 码及其同类码 195
由此得出结论a(x)=a-?(c?+a3x+a3x2)=1+a?x+a?x2,w(x)=α?(x+α)=
a2x+α3:
根据时城完成法，我们发现a(α-3)=a(α-2)=0,即a(x)=(1+α2x)(1+a3x)、因此错
误位置为i=2和i=3:为了算出这两个错误的值，利用式(9.72)以及o'(x)=α3,则
w(x)/o(x)=a?x+a?,并得出：
E?=or(a-)=a·a-2+a?=a3
E=a-=a.α3+a?=a
因此E=(0,0,o3,a?,0,0,0),译码器的榆出为C=R+E=(a3,a,a,1,0,a3,1)。
根据频域方法，我们利用初始条件S,=α3,S?=α?,S?=a?,S?=0和递归公式[根据a(x)
的系数]S,=α?S;_+a?S,_2,得出：
Ss=α?-0+α?·α?=α2
Sg=α?.α2+α?.0=1
S?=So=a3.1+α?.a2=α?
因此S=(S?,S?,S?,S?,S,S,,S?)=(a?,α3,o?,a?,0,c2,1)。为了得到E,可以求S的
反DFT,利用式(9.12):
E=S=(0,0,α3,α?,0,0,0)
译码结束，结果和前面一样，
结束本节之前，我们简单讨论一下RS码的两个重要应用：纠正突发错误与级联码。
可以利用例9.8来说明纠正突发错误的应用。在该例题中我们看到了GF(8)上(7,3)RS
码的作用：纠正两个符号错误。但是可以不把每个码字看做GF(8)上的一个7维矢量，而是通
过表9.4,将GF(8)的每个元素扩展为一个3维二进制矢量，由此将这些码字转换为21维二进
制矢量。换句话说，GF(8)上的(7,3)RS码可以看做一个GF(2)上的(21,9)线性码。例如，
码字
C=(a3,a,a,I,0,a3,D
变为二进制矢量
C=(011 010 010 001 000 011 001)
现在假设C的二进制形式通过二进制信道传输，并受到下面长度为S的突发错误的干扰：
资
E=(000 000011 101 000 000 000)
则接收到的矢量将是：
R=(011 010 00)100 000 011 001)
当然，它在4个位置与C不同。通常，一个(21,9)线性码很难或者不可能纠正4个错误(见习
题9.33),但是我们观察到当将E映射为GF(8)上的一个7维矢量时，
: i
196 信息论与编码理论(第二版)
E=(0,0,a3,a?,0,0,0)
它的重量只是2!即这四个特定的错误发生在一个短暂的突发时间内，我们可以利用这一有
利条件。因此如果将R转换为GF(8)中的一个矢量，
R=(a3,α,1,α2,0,a3,1)
就能够(在例9.8中已经完成了)通过图9.4或图9.5中的译码算法，发现错误图案并纠正错
误。这样，原来的RS码就变为一个(21,9)二进制线性码，它能够纠正多种图案的突发错误。
表9.4 域GF(8)表示为α的幂，其中a3=a+1
I a2
0 001
1 010
2 10D
3 011
4
5
11D
111
6 101
推广是这样的：一个GF(2”)上码长为n、纠正1个错误的RS码，可以作为一个GF(2)上
的(m(2"-1),m(2"-1-2t))线性码应用，并且只要突发错误图案的影响不超过码字原来
GCF(2°)形式的：个符号，该线性码就能纠正这样的突发错误。
最后介绍的是RS码在级联码中的应用，这方面我们在第6章里已经简单提过。下面通过
一个具体的例子来说明。
设(7,4)二进制汉明码用于一个BSC,该 BSC的错误概率为p=0.025,如图9.6所示。利
用图9.6的符号，Plu≠vi=2(7)D(1-p2?*=0.0121。级联码的思想是将图9.6中的
“编码器-BSC-译码器”部分看做一个更大的噪声信道，称做外部信道(BSC本身则成为内部
信道),并为它设计一个码。在本例题中，外部信道是一个有16种输人的DMC;根据本节的结
论，我们将这些输入和输出看做是GF(16)中的元素，而不是GF(2)上的4维矢量。因此现在
考虑利用GF(16)上的(15,11)RS码来降低外部信道的噪声，如图9.7所示。
内部信道
(2p… 编码器 (x,"M;) BSC o-0.025l
e" 泽码暴 v?v)
外部信道
图9.6(7,4)汉明码应用于一个p=0.025的BSC
(…QuJ RS编码券 C
外部信道 R
RS译码器 -(bu…,h)
图9.7(15,11)Reetl-Sobuon码应用于图9.6中的外部信道
图9.7中的RS编码器取 GF(16)中的11个信息符号a=(ao,…,an)(它实际是原始信源
输出的44比特),并产生一个RS码字C=(Co,C,…,Cu)。外部信道干扰了C,接收为R=
(R,…,Ru)。然后RS泽码器产生一个a的估计值b=(bo,…,bn),如果外部信道产生的错
第9章 BCH,Resd-Solonn码及其同类码 197
误不超过两个符号，b就等于a 如果用e(=0.0121)表示图9.6中的译码错误概率，则图9.7
中的译码错误概率不会超过(5)eC-e)=0.0007。图9.7中所描述的编码系统的
总速率是11/15×4/7=0.42;实际上，这个系统就是一个(105,44)二进制线性码.被以一种聪明
的方式“分解”了。读者可能希望将此与一个差不多的未分解系统进行比较，例如与码长为
127、能够纠正(1个错误的(127,57)二进制BCH码进行比较。该BCH码的速率(0.45)略高一
些，面译码错误概率(0.0004)略低一些，但是它的译码复杂度却相当高——这个BCH码的错
误位置多项式一般是GF(128)上的一个11次多项式，面前面介绍的RS码的错误位置多项式
则是 GF(16)上的一个2次多项式。
上面的例子既说明了级联码的基本思想，也说明了RS码在级联系统中如此重要的原因。
任意的编码通信系统都可以被认为是一个噪声外部信道，如图9.8所示。然面，为使这种观点
有意义，就必须设计一个外部码.它能够纠正外部信道产生的大多数错误，这个外部信道很可
能非常复杂，因为它的错误是由内部译码器的失败造成的。当内部译码器失败时，即图9.6中
(n,…,)(…+n)时，符号，通常与…;ng几乎没有任何相似性。这意味着
外部信道中的错误挡向干发生在长度为k的突发中。而我们已经看到BS码非常适合于纠正
突发错误。这就是RS码作为外部码广泛应用于级联系统中的原因。
外第信道
编码器 内部信道 译码器
图9.8 一个普通的编码通信系统，看做是一个噪声“外部”信道(与图9.6比较)
9.7 出现删除时的译码
我们已经看到BCH码和RS码都能够纠正多个错误。在本节中将看到它们也能纠正另一
类信道误码，称为删除(符号)。删除是指接收到了一个无法辨认的信道符号。例如，考虑英文
单词BLOCK,如果第三个字母从0变到A,收到的就是BLACK;这是在第三个位置上出现的一
个错误。然而，如果同一个单词在第三个位置上出现了一个删除，那么结果将是BLKCK,其中
“表示删除。在实际通信中，删除相当普遍。当信道噪声在短时间内变得极端严重时，它们就
有可能出现。例如，如果你在机场谈话，一架低空飞行的喷气式飞机刚好从你头上飞过，则你的
谈话就被消除了。听你说话的人不会对你说的话产生误解；他们只是不能听懂你在说什么。
在本节中，将学习一些纠正删除的知识。我们会看到在理论上，纠正一个制除的难度只相
当于纠正一个错误的难度的一半(定理9.11);并且会看到应该怎样改进BCH和RS码的译码
算法，来同时纠正删除和错误。
为了建立一个能够同时产生删除和错误的信道模型，可以简单地将基本符号集F扩大为
F=FU],其中“+”如前文所述，是一个特殊副除。允许发送的符号只是F中的元素，但
是下中的任意元素都可能被接收到。下面介绍的是同时纠正删除和错误的主要理论结果(与
定理7.2比较)。
198 信息论与编码理论(第二版)
定理9.11 令C是符号集F上的一个码，具有最小距离d。则只要e。+2e?≤d-1,C就
能够纠正任意由en个荆除和e?个错误组成的图案。
证明：为了证明这个定理，首先引入F中符号间的扩展汉明距离dg(x.y):
an-。
倒如，如果F=[0.11,F={0,1,*1,则d,(0,1)=1,dg(1,*)=1/2,dg(1,1)=0.然后将dA的
定义扩展到失量x=(x?.…,t)与y=(y,…,y。)之间，x和y的分量在F中，如下所示：
a(x,y)=ZdHx,n)
根据这个定义，dn变为F上所有n维矢量的集合下上的一个度量。(见习题9.40。)实际
上，如果x和y中都没有删除，d(x,y)就只是普通的x与y之间的汉明距离。
接下来介绍一种特珠的译码算法，称为码C的最小距离译码(MDD)算法。当一个接收到
的R∈P作为MDD算法的输入时，将产生一个码字C,作为输出，使扩展汉明距离
da(C,,R)最小。我们将证明，如果eg+2e?≤d-1,MDD算法将纠正e,个删除和e,个错
误，这样就证明了定理9.11:
因此假设C,是发送的码字，在传输过程中出现了e。个删除和e,个错误，其中en+2e?≤
d(C,,R)=2en+e?≤(d-1)。不可能再有 d-1、如果R是C;受干扰后的样本，则
dg(C,,R)≤2(d-1),其中j≠i,则根据三角不 其他的码宇会距离R这么近，因为，如果
等式，
dn(C.C;)≤dn(C,R)+dp(R,C,)
≤:d-1)+÷-1)
=d-1
而这与码的最小距离是d这个条件相矛盾。可见d(C,,R)距离只有在j=i时是最小
的，因此MDD算法将正确识别出实际发送的码字C。
例9.9 令C是例8.2中的(7,3)循环码，具有码字：
Co=0000000
C?=1011100
C?=0101110
C?=0010111
C?=1001011
Cs=1100101
C=1110010
C=0111001
第9章 BCH、Reed-Solomon 码及其同类码 199
因为这个码是线性的，它的最小距离应等于它的最小重量；因此d=4。根据定理9.11,如
果+2e≤3,这个码就能够纠正e。个瓣除和e?个错误。下表列出了允许的删除和错
误的组合：
的
3 0
2 0
」 1
0
0 1
0 0
例如，假设接收到R=[1110*01]。MDD算法将进行如下计算：
dn(C,R 圳除的位置 错误的位置
0 4.5 14 10,1,2,6:
L 3.5 :4 1,3,6
2 5.5 :4: l0,2,3,5,6
3 3.5 14: :0.1,5
4 4.5 4: 1,2,3,5
5 1.5 4! 21
6 2.5 4 15.6
7 2.5 41 10.3
因此，MDD将输出C,并得出结论：R在位置4出现了一个湖除，在位置2出现了一个错
误，即，en=1,e?=]。另一方面，如果R=[***1010],将进行如下计算：
i d(C,A) M除的位置 错误的位置
0 3.5 10,1,2i 13,5:
1 3.5 10.1,2: 14,5:
2 2.5 10.1,2 14
3 4.5 10.1,2: :3,4,6!
4 2.5 i0,1,2i 6
5 5.5 0,1,21 13,4,5,6
6 2.5 30,1,21 :3
7 3.5 30,1,2| 15,6
这时算法面临着一个三方平局(在C?,C和C。之间),但是不论它在这三个码字中选择
哪一个，都会得出结论，码字在传输中出现了3个删除和1个错误，而这已经超出了码的
纠错能力。
定理9.11根据码的最小距离，从理论上给出了一个码纠正删除和错误的能力。但是从实
际应用的角度来看，证明中所采用的MDD算法还有很多不足，因为除非码非常小，否则将接收
字与每个码字进行比较显然是不现实的。幸运的是，对于BCH和RS码，通过对9.6节提出的
基本“单纠错”译码算法(图9.4和图9.5)进行简单地改进，就能使它们既能纠正错误，也能纠
正删除。在本节的剩余部分，将讨论这个问题。
BCH和ES码的纠正删除和错误的译码算法实质上是相同的，这类似于它们的单纠错译
200 信息论与编码理论(第二版)
码算法，但是为了精确描述，这里仅考虑RS码。在本节的最后，将讨论 BCH码所需要的筒单
改动。根据定理9.7,一个(n,k)RS码的最小距离是r+1,其中r=n-k。因此根据定理9.11
会有下面的结论。
定理9.12 令C是城F上的一个(n,k)RS码。则只要eo+2ej≤r,其中r=n-k,C就
能纠正e。个删除和e,个错误组成的任意图案。
现在，开始讨论 RS码的纠正删除及错误的译码算法。假设给定一个接收矢量R=(R,
R?,….Ra),它是一个(n.k)RS码中某个未知码字C=(Cn,C,…,Cn_i)的噪声样本，该RS
码的生成多项式为g(x)=(x-a)(x-a2)…(x-a'),其中r=n-t。这里假设R中含有eo
个删除和e,个错误，并且eo+2e?≤r。详码算法的第一步是存储删除的位置，为此先定义删
除集合1。为：
Io={i:R,=*} (9.73)
然后计算刑除位置多项式c(x):
okx)=Ia-ax) (9.74)
[如果没有删除，定义o(x)为1。]
一且删除位置被“储存”在o。(x)中，算法就将R中的*替换为0,即定义一个新的接收矢
量R'=(R,R,…,R'1)如下：
-{68如梨去： (9.75)
将*替换为0的好处在于0是域F的一个元素，因此可以对R'的任意分量进行算法操作。这
样做的缺点是，当将 R'看做C的受干扰样本时，R'中有eo+e,个错误7,可能超出了这个码
纠正错误的能力。然而，正如我们将要看到的，通过利用删除位置多项式a。(x)提供的“侧面
信息”,R'中的错误都能被纠正。
完成这个预“删除处理”以后，接下来的译码算法类似于只纠正错误时的算法。下一步是
计算伴随式多项式 S(x)=S+S?x+…+S,x?',其中，
s,-2Ra, j=1,2,…,r
如果定义错误及荆除矢量E'=(E?,EY,…,E_)为E'=R'-C,“扭曲的”错误及删除矢量V
为：
V=(Eb,Eia,…,Eh-iα"-1) (9.76)
则根据9.3节的结论有S(x)=D(x)modx',关键方程(9.37)式变为：
0(x)S(x)=a(x)(modx') (9.77)
其中α(x)是矢量V的位置多项式，w(x)是矢量V的数值多项式。从现在开始，我们将称
a(x)为错误及删除位置多项式，a(x)为错误及删除数值多项式。
下面来关注一下错误及删除位置多项式a(x)。我们有：
第9章 BCH、Reed-Solomon码及其同类码 201
ox)=IIa-ax) (9.78)
其中7是错误及删除的集合，即，
I=I?UI (9.79)
这里I。是式(9.73)中定义的制除集合，而I,是如下定义的错误集合：
I={i:R?≠*并且R?≠C}
因此由式(9.78)和式(9.79)得出：
o(x)=do(x)0?(r) (9.80)
其中σ(x)如式(9.74)所定义的，而
?x)=IIa-ax) (9.81)
很自然，可以称σ,(x)为错误位置多项式。
现在转到关键方程(9.77)式。根据式(9.80),我们已经知道a(x)的一部分，即。(x),因
此译码算法的下一步是计算修正的伴随式多项式S。(x),定义如下：
Sn(x)=0o{x)S(x)modx' (9.82)
结合式(9.77)、式(9.80)和式(9.82),关键方程变为：
o(x)Sn(x)=(x)(modx) (9.83)
现在，译码器已知道S?(x),并希望利用欧几里得算法计算出a?(x)和w(x)。这可能吗?答
案足肯定的，因为我们有：
dega?(x)=ey
deg w(x)∈ep+e-1
又因为已经假设了eo+2e?≤r,所以 deg a?+deg w≤eo+2e,-1<r=deg x。虽然
ed(g(x),o(x))=1可能不再成立，但是ged(a?(x),w(x))=1成立(见习题9.45)。因此根
据定理9.6,如果适当选择μ和v,则程序 Euclid(x,S?(π),μ,v)将返回σ(x)和w(x)。根据
下面的推导选取μ和v。由于e,+2e?≤r,故有：
degirx)=e?≤
因此deg a?(x)≤L(r-eo)/2」。同理，
deg oux)≤eo+e-1≤+{]-1
很容易证明L(r-c)2]+F(r+e?)/21=r(见习题9.43),因此如果定义：
:.播
202 信息论与编码理论(第二版)
(9.84)
则程序Euc!id(x',S。(x).μ,b)--定会返回一对多项式((x),r(x)),使得(x)= λv(x),
w(x)=λr(x),其中λ是一个非零标量。为了寻找A,考虑到a,(0)=1[见式(9.81)],因
此有：
oi(x)=DB(x)/0)
①(x)=r(x)/0(0)
现在，计算出删除位置多项式on(x)和错误位置多项式a(x)后，通过计算多项式的乘积
—见式(9.80),求出利除及错误位置多项式σ(x)。
现在，已经计算出刷除及错误矢量E'的位置多项式g(x)和删除及错误数值多项式的(x),
接下来的译码可以利用9.6节介绍的“时域完成法”或“频域完成法”实现。图9.9中总结了纠
正错误及删除的译码算法。
/*RS Errors-and-Erasures Decoding Algorithm*/
i
{
Input Ioien=|o|;
on(x)=IIrer?(1-α'x):
for(i∈lo)
R=0;
for(j=1,2,…,r) S,=Z口R,a; S(x)=S+S?x+.+S,x'-l:
So(x)=0o(x)S(x)modx:
u=[(r-eo)/2|;u=(r+eo)/2]-1
Euclid(x,So(x),u,v);
a?(x)=D(x)/D(O);
a(x)=rx)/0(0);
a(x)=co(x)01(x);
(Time-domain completion or frequency-domain
completion)
}
图9.9 当出现剧除时，RS(或BCH)码的译码
例9.10 现在以城CF(8)上，生成多项式为g(x)=(x-a)(x-c2)(x-a3)(x-a?)(x-a3)=
x?+α2x?+a3z3+a?x2+a?x+α的(7,2)RS码为例，来说明RS码的纠正删除及错误译
码算法。[假设 CF(B)中的本原元a是GF(2)上本原多项式x3+x+1的一个根。]码的冗
余是r=5,因此根据定理9.11,只要eo+2e?≤5,就能够纠正e。个州除和e?个错误组成
的任意图案。我们取被干抚过的码字为：
R=[a?,a3,a?,*,a2,a?,a2]
.瞧 1 
对l
第9章 BCH、Reed-Solomon 码及其同类码 203
并设法利用困9.9中的算法对它进行译码。
译码算法的第一步是“测除处理”,在这种情况下就是通过简单地观察得出刑除集合为I。=
13|,因此e=1,删除位置多项式为：
0o(x)=1+a3x
而修正后的接收矢量R'为：
R'=[a?,a3,α?,0,a2,α?,a2]
接下来的一步是利用R',计算伴随式的值S,Sz,S?,S,Ss。我们有：
s,=a?+a3+/+a?+2i+a2+4)+a?+5i+α2+6J
经过常规的计算，可得出：
S=1,S2=1,S?=a?,S4=α2,Ss=a?
因此改进后的伴随式多项式S?(x)为：
So(x)=(1+x+a3x2+α2x3+a?x?)(1+α3x)(modx?)
=1+αx+α2x2+a?x3+x?
由于eo=1,r=5,参数μ和》为：
u=[z]=2
v=[?±]-1=2
因此需要调用Euclid(x3,S?(x),2,2)。这里是它运行的概要：
v, r, q,
-1 0 x’
一
0 1 x?+a?x3+a2x2+ax+1
一
1 z+a1 a13+a?x2+a?x+e? t+a
2 a3s2+a?x+a? a?x2+a?a+a? a3x+a?
Euclid(x3,S?(x),2,2)返回(v?(x),r?(x))≈(a3x2+a?x+a?,a?x2+a?x+a?),所以，
a?(x)=au?(x)=a?x2+a?x+!
o(x)=ar?(x)=a?x2+a?x+1
最后，
a(x)=dofx)la[(x)=x3+a2x2+a2x+1
这就完成了泽码的“删除具体化”部分，即图9.9中所描述的算法部分。现在将利用时城
和频城完成法这两种方法实现译码。
对于时城完成法，我们注意到a(x)=x2+a2,并计算出下表：
: ?
204 信息论与编码理论(第二版)
i o{a-) o'(a-2
0 0 a- E-ca-17/0(a-
1
2 a?
3 0
4 0
u
1 尸3 e ;
5
6
?
a5
因此错误及删除矢量为E'=[α?,0,0,a,a3,0,0](这意味着除了在位置3的一个删除外，
在位置0和位置4处还有两个错误),于是译码后的码宇为C=R'+E',即，
C=[0,a3,a?,a,α3,α?.α2]
对于频域完成法，已经计算出S?,S?,S?,S,S?,通过遥归
S,=α2Sj-i+a2Sj-2+S,_3
[因为g(x)=I+a2x+α2x2+x3]计算S?和S?(=S?),得出S?=a2,So=as。这样，完整
的伴随式矢量S为：
S=[a?,1,1,a?,a2,a?,a2]
现在计算S的反DFT,即，
E;=a?+α?1+a-2i+a?-3i+α2-4i+α-5+a2-6
=α?+α?+α1+a3++a2+3+a?+2i+α2+
得出：
E'=[a?,0,0,a,α3,0,0]
与时域完成法的结论相同。因此，
C=[0,α2,a?,a,α3,α?,a2]
这与前面一样。
在结束本节之前，最后简单讨论一下当出现删除时，BCH 码的译码问题。BCH码和RS码
的(只纠正错误时)译码算法间的关链差别是，对于BCH码，一旦错误被定位，就不需要对它们
进行求值了，因为惟一可能的错误值是1。这意味着当出现删除时，图9.9中的算法仍然适用
(用2t替换r);而BCH码译码的惟一简单之处体现在时域完成法的实现中。(比较图9.1和
图9.4。)
9.8(23,12)Goiay 码
本节中将讨论一种非常完美，但是却不能通用化的码型，即二进制(23,12)Golay码。有人
认为它是惟一一种最重要的纠错码。(还有一个CF(3)上的(11,6)Golay 码；见习题9.64至
习题9.67。)
这里首先介绍一个重要的数论依据。在CF(2)上的23维矢最空间(我们称之为Vz)中，
一个半径为3的汉明球体内含有
第9章 BCH、Reed-Solormon码及其同类码 205
+(3)+(2)+(3)=2048个矢量
而2048=2"正好是2的幂，由此会想到，能否用40?2个半径为3的球体完全填满Vz2,且相
h.之间没有电叠。如果能完成这个组合的奇迹，球体的中心就能组成一个码，它包含22个码长
为23的码字(速率=12/23=0.52),能够纠正任意重量≤3的错误图案。在本节中，不仅要证明这
样的填充是可能的，还要证明球体的中心可以作为一个(23,12)二进制循环码的码字!
那么用编码理论的术语来讲，我们需要构造一个(23,12)二进制循环码，能够纠正3个错
误，即d≥7:可以利用域GF(2")的某些性质来实现这个构造。因为2"-1=2047=23·89,
所以 GF(2")一定含有一个23阶本原单位根，我们称之为β。β在GF(2)上的最小多项式为
g(x)=llye8(x-Y),其中B=1β:i=0,1,2,…是β的共轭类的集合。通过简单的计算可
以证明B仅含11个元素；实际上，
x)=a- (9.85)
其中，
B={β:j=1,2,4,8,16,9,18,13,3,6.12}
同理，β1=的最小多项式为：
gu)=Ix-r (9.86)
其中，
B={:j=22,21,19,15,7,14,5,10,20,17,11}
因为除了1以外，每个23阶单位根都是g(x)或g(x)的一个零点，所以在GF(2)上将 x?-1
分解为不可约因式：
x23-1=(x-1)g(x)g(x) (9,87)
实际上，可以证明：
g(x)=x1+x?+x?+x?+x?+x+1
g(x)=x11+x1?+x?+x?+x+x2+1 (9.88)
但是在本节的其余部分并不需要这个显式分解。现在可以定义 Golay码了。
定义(23,12)Golay 码是一个二进制循环码，它的生成多项式g(x)由式(9.85)或
式(9.88)定义。
现在要做的只是证明这个码的最小重量≥7。证明的第-步非常容易。
引理3 每个非零Golay码宇的重量都≥5。
证明：考虑到g(x)的零点集合B的结构[参照式(9.85)],我们看到对于每个码字的生成
函数 C(x),有：
Cβ)=CB2)=CB3)=Cβ)=0
因此根据有关 BCH码的论证(定理9.3),dL≥5。
(9.89)
:城：:1::
206 信息论与编码理论(第二版)
考虑到引理3,还需要证明的是，不存在重量为5或6的码字。下一个引理使我们将注意
力集中在偶数重量的码字上、
引理4 如果A,表示重量为i的Golay 码字的数目，则对于0≤i≤23,有：
A,=A23- (9.90)
证明：根据式(9.87),g(x)g(x)=(x2-D/(x-1)=l+x+x2+…+x”,因此常数夫量
K=(11111...111)是该码的码字。通过将K加到一个重量为i的码字上，就得到一个重
量为23-i的码字，反之亦然：因此C+C+K的对应就是重量为i与重量为23-i的码
宇之间的-一对应。
下一个引理排除了重量为2,6,10,14,18和22的码字；根据引理4,它也排除了重量为1,
5.9.13,17和21的码字，由此证明了Galay 码的最小距离≥7:
引理5 如果C是一个具有偶数重量 w的Golay 码字，则x=0(mod 4)
证明：令C(x)表示C的生成函数，即，
Cx)=x?+x2+…+x (9.91)
其中0≤ej<e?<…<es≤22。由于C属于Golay码，有C(β)=0,即，
C(x)=0(nod g(x)) (9.92)
又由于C具有偶数重童，有C(1)=0,即，
C(x)=0(mod(x-1) (9.93)
现在，如果定义C(x)为：
C(x)=x-+x+…+x (9.94)
其中指数按模23运算取值，就可以得出Cp-')=C(β)=0,即，
C(x)=0(mod g(x) (9.95)
结合式(9.92)、式(9.93)、式(9.95)与式(9.87),我们有：
C(x}C(x)=0(modx2-1) (9.96)
现在利用定义式(9.91)和式(9.94),来实际计算C(x)C(x)(modx"-1):
cwicx)=Zx (mod x2-1)
=+meds2-1)
(modx23-1)
(9.97)
[得到最后的全等式是因为w是偶数，且所有的计算都发生在GF(2)中。]因此，
cwcw)=2n2modx?-D)
第9章 BCH、Reed-Sulomon码及其同类码 207
其中μ是满足e-e,=b(md 23)的有序对(i,j)的个数。根据式(9.96),每个μ。都是偶
数：
Ab=0(mod2)、b=1,2,…,22 (9.98)
现在，如果e.-e,=b,则也有e,-e,=23-b(mod 23)。于是，
Mh=A23-m,b-1.2.…,1L (9.99)
最后，因为在式(9.97)右侧的求和中有w(w-1)项，所以，
m=mw-1) (9.100)
结合式(9.98)、式(9,99)和式(9.100),我们有：
ww-1)=2
=22
=0(mod4)
即o(w-1)是4的一个倍数。但是因为w-1是奇数，所以w本身是4的一个倍数，证
毕。
将引理3、引理4和引理5结合起来，就得到下面的定理。
定理9.13 除了i=0,7,8,11,12,15,16和23以外，(23,12)Golay 码中重量为其他i值的
码字数目是0.因此以码字为中心、半径为3的球体确实是恰好填满了V。
这里还需要提一下.(23,12)Golay 码有一个简单但是有用的变形、如果C=(C,C?,…,
Cz)是-个Golay码字，我们通过增加一个总奇偶校验位将C的长度扩展为24,即定义第24
个分量C?如下：
C?=Co+C?+…+C229
如果每个Colay码宇都通过这种方法进行扩展，得到的码将是一个二进制线性(但不再是循环
的)(24,12)码，称为(24,12)扩展 Colay码。我们很容易证明下面的定理。(见习题9.59。)
定理9.14 在(24.12)扩展Golay码中，除了i=0,8,12,16和24以外，重量为其他i值的
码字数目是0。
(24,12)扩展Golay码与原来的(23,12)Golay码相比，有两个小优势，但这就足以使这个扩
展码在许多应用中更容易采用。首先，因为24是8的倍数，所以(24,12)码很自然地适合面向
字节的应用。其次，因为扩展码的最小距离是8,所以如果用它来纠正所有含3个及更少个错
误的图案，就同时还能检测所有重量为4的错误图案，甚至很多更高重量的错误图案，而原来
的(23,12)码则没有这样的附加检测能力。(见习题9.59,习题9.62。)
最后我们讨论-些 Golay码的应用问题。因为(23,12)码是循环的，所以显然可以为它设
计一个11级的移位寄存编码器(见8.2节，以及习题9.60)。但是设计一个代数译码算法就不
11
208 信息论与编码理论(第二版)
那么容易了；我们可以简单地改进图9.1和图9.2中的BCH泽码算法，使其能够纠正任意两个
及更少个错误的图案，但是这个码“碰巧”能够纠正3个错误!不过幸运的是，这个码足够小，
所以7.2节中讨论的伴随式“查表”算法通常是实际可行的。(见习题9.63。)
习题
9.1 在9.1节中我们看到函数(V)=V3将式(9.2)中的矩阵H?变成一个能够纠正两个错误
的码的校验矩阵。请问以下形式的f也能做到这一点吗?
(a)f(V)=TV,其中T是Vm上的一个线性变换。
(b)f(V)=an+aV+a?V2,其中V是GF(2)中的一个元素。
(c)f(V)=V-',其中V∈ GF(2”)。
9.2 假设F是一个含q个元素的有限域。
(a)如果α是F中的任意一个元素，定义(q-1)次多项式。(x)=(x-a)'-1。当x
在F的q个元素中取值时，分别写出对应的f。(x)的值。
(b)利用(a)的结论，或者利用其他方法，证明任意函数f:F→F都可以表示为次数不高
于g-l的多项式。
9.3(在定理9.1的证明中用到了范德蒙德(Vandemonde)判决定理，本题将给出该定理的一
个推广。)设P,(x)是一个首项系数为一的i次多项式，其中i=0,1,…,n-1,并设出，
x?,…,x。是互不相等的未知数。证明：
-
(提示：如果x:=x,,则等式左边等于0。)范德蒙德判决定理就是P(x)=x'时的特例。
9.4 下面列出了一段计算码长为2"-1、纠正1个错误的 BCH码维数算法的伪代码。
S={1.3,…,21-1};
k=2年-1;
while(Sis not empty)
{
=least element inS;
M=Hi
do
{
deleteu fromS;
k=k-; v=2u mod?"-I;
while (u≠u)
}
第9章 RCH、Reed-Solomon码及其同类码 209
(a)说明算法结束时，整数无就是码长为2°-1、纠正：个错误的BCH码的维数。
(b)利用上述算法，计算码长为63、纠正t个错误的BCH码的维数，其中1≤1≤31。
9.5(a)证明：对所有m≥3.一个码长为n=2"-1、纠正两个错误的BCH码的维数是n-
2m。
(b)证明：一般情况下，只要m足够大，对任意确定的l≥1,一个码长为n=2"-1、纠正
(个锆误的BCH码的维数是n-mtc
(c)求m。的最小值，使得对任意n≥m,一个长度为n=2"-1,纠正3个错误的BCH
码的维数是n-3m。
9.6(a)分别对1≤I≤7的每个：值，计算码长为15、纠正：个错误的 BCH码的维数。
(b)计算(a)中的每一个码的生成多项式。假设GF(16)的一个本原元为α,满足等式
c?=a+1。(参照习题9.1。)
9.7 在例9.1中，计算一个码长为15、纠正3个错误的BCH码的生成多项式时，假设了GF(16)
的本原元a满足a?=a+1。现在假设我们选择一个满足a?=a3+1的本原元，则生成多
项式会足怎样的?
9.8 证明反DFT公式，即式(9.12)。
9.9 考虑有限域 GF(7),它由整数集合10,1,2,3,4,5,6|在模7运算下构成。
(a)证明3是GF(7)的6阶本原单位根。
(b)设3就是所需的6阶本原单位根，写出矢量V?=(1,2,3,4,5,6)和V?=(1,3,2,6,4,5)
的DFT。
(c)为什么V?的DFT结果要比V,的简单?请给出你的解释。
9.10证明式(9.17)中相移矢量V的DFT由式(9.18)给出。
9.11(广义 BCH码)设g(x)是一个系数分布在CF(g)上的多项式，且g(x)能整除x"-1。
进一步假设a是GF(q)某个扩展域上的n阶单位根，并且
g(a')=0,1=m,m+I,…,mo+d-2
其中，m和d均为整数。令C是一个生成多项式为g(x)的循环码。证明C的最小距
离≥d(提示：利用 BCH论证。)
9.12 BCH论证(定理9.3)的逆定理是否成立?即如果V是一个重量为w的矢量，是否其经
过 DFT后得到的V一定含有不少于w-1个的连续0分量?如果你的答案是肯定的，请
给出证明；如果是否定的，请举出一个反例。
9.13证明：gd(V(x),1-a°)=IT,(L-a'x),其中V(x)如式(9.14)中所定义，7如式(9.19)
中所定义。
9.14 如果已知V中任意连续d个分量，并且也知道ov(x),证明其余的分量也可以被计算出
来(参照推论9.2)。
9.15表9.1中列出的CF(16)包含一个5阶本原单位根，记做a3,在本题中，它将表示为月。
设V=(1,s.g,0,β2)是CF(16)上长度为5的一个矢量：按照9.3节中的定义，计算
V,oy,o(i=1,2,4),以及wy(x)。(参照例9.2。)
9.16 在例9.2中，V的元素满足递归公式V,=a?V,_j。试解释“为什么”会这样。[提示：仔细
分析式(9.31)。]
……
i.hie上
210 信息论与蝙码理论(第二版)
9.17 如果用S,表示在BCH码译码中的第j个伴随式的值[参照式(9.34)],证明对所有j,有
Sz=S}c
9.18 如果f(x)=fo+fi(x)+…+f,x"是F域上的一个多项式，它的微商形式f'(x)定义如
下：
f'(x)=fi+2fzx+…+nfax”-
根据这个定义，不考虑极限情况，推导出以下结论：
(A)(f+g)=f'+g'
(b)(fg)'=fg'+f'g
(c)()'=myf'
(a)如果f(x)=Il'=(x-R),则
rm-Sra-A)
(e)如果f(x)如(d)中所定义，且B互不相等，则
-
9.19(a)证明表9.2中列出的欧几里得算法的性质A-Fe
(b)证明：在欧儿里得算法中的最后一个非0余式r(x),就是a(x)和b(x)的最大公因
子，并证明式(9.43)成立：
9.20设a(x)=x?-1,b(x)=x?-1是GF(2)上的多项式。
(a)将欧儿里得算法应用于多项式对(a(x),b(x)),并参照例9.3列出求解过程的表
格。
(b)设p≥0,v≥0.且A+v=7,对每一对(μ,v),计算 Euelid(a,b,μ,v)。(参照
例9.4。)
9.21(Pade近似)设A(x)=ao+ax+a?x2+…是定义在F域上的幂级数。如果p和v是非
负整数，将满足下列条件的一个有理函数p(x)/g(x)定义为A(x)的(m,v)Pade近似：
(a) q(x)A(x)=p(x)(mod x)
(b) deg q(x)≤A、deg p(x)≤v
利用定理9.5,证明对于每一对(μ,v),存在惟一的一对(po(x),go(x)(不考虑标量因
子),使得如果(a)和(b)成立，则有p(x)=Ap?(x),g(x)=Ag?(x),其中λ是一个非零标
量。这样的一对(p。(x),qo(x))就称为A(x)的(μ,v)Pade近似。参考表9.3,计算
GF(2)上的A(x)=l+x+x2+x?+x?+…的Pade近似，其中μ+y=7。
9.22一个能够纠正3个错误的(15,5)BCH码经过噪声干扰后得到下列码字，试用例9.5所示
步骤对其进行译码：
R=[Ro,…,R14]=[110101010010010]
9.23 考虑…个码长为31、能够纠正3个错误的 BCH码，由满足a?+a2+1=0的本原元a∈
GF(32)定义。
(a)计算其生成多项式。
第9幸 BCH、Reed-Solomon 码及其同类码 211
(b)对下列接收矢量进行译码：[0000000111101011111011100010000]。
(e)对下列接收矢量进行译码；[1011001111101010011000100101001]。
9.24设α是域F上的n阶本原单位根，令P,表示F上次数≤k-1的多项式集合。对任意
P∈P上，定义矢景C(P)=(P(1),P(a),…,P(a-1))。
(a)证明由所有矢量C(P)构成的码是一个MDS码，并找出相应的n,k和d,
(b)此码是循环码吗?请解释原因。
(e)此码和式(9.67)定义的RS码是否有关系?是怎样的关系?
9.25设F是任意一个包含n阶本原单位根a的域。如果，和i是0到n之间的固定整数，而
矢量C=(Co,C?,…,Cn-,)的分量在F上取值，则满足以下条件的所有矢量C的集合称
为替代RS码；
ca"=0.j=+1.(+2.….i
(a)证明上：面定义的码是一个(n,r-r)循环码。写出它的生成多项式和最小距离d。
(b)当F=CF(8),n=7,r=4而i=1时，试计算该替代RS码的生成多项式g(x)。(参
照例9.6。)
(c)设在F上存在n个确定的非0元素，记做y。,…,Yn-。说明通过将原来RS码[由
式(9.67)定义]的每个码字(Ca,…,C-)映射为矢量(y?Ca,…,yn-Cn-1),就可以
实现从原来的RS码到本题定义的替代RS码的变换。
9.26设a是有限域F上的n阶本原单位根，C是一个码长为n的线性码，其定义如下：C=
(Cn,C?,…,C.)是C的一个码字的充分必要条件是：
=0(mouk)
其中x是一个未知参数
(a)证明C是一个循环码。
(b)在给定π和r的情况下，计算该码的维数。
(c)计算该码的最小距离。
(d) C和定义在F上、生成多项式为g(x)=(x-a)...(x-a)的(n,k)RS码是否有关
系?是怎样的关系?
9.27 详细讨论 GF(2)上所有MDS码的性质。
9.28 证明在任何域F上，下述的两种码都是MDS码
(a)(n.1)电复码。
(b)(n,n-1)奇偶校验码。
9.29定理9.7证明F域上的(n,k)RS码，其具有最小重量的码字的重量为n-k+1。那么,
如果F域中包含q个元素，则该码中重量为n-k+1的码字有多少个?(提示：利用定
理9.9。)
9.30 利用表9.1,计算 GF(16)上一个(15,7)RS码的生成多项式g(x)。(参照例9.6。)
9.31 考虑例9.6中介绍的(7,3)RS码。
(a)找出惟一的一个码字(Co,…,G?),使其满足Co=1,C=0,C?=0。(参照例9.7。)
.:t vi
212 信息论与编码理论(第二版)
(b)是否存在一个满足C=α3,C=α,C?=1,Cy=0的码字?
9.32(7,3)RS码经哚声下扰后接收到下列码矢，请根据例9.8对其进行译码：
R=[a31aa2 a3a1]
9.33是否存在一个(21,9)二进制线性码，能够纠正所有不多于4个错误的图案?
习题9.34至习题9.39是相互联系的，它们将介绍一种RS码的替代方法。更重要的是，
最后将给出构造一类著名的码——Juslesen码的方法(见参考文献[15])。这类码之所以重要，
是因为它们(以及它们的某些变形)是在满足下列条件的线性码中，惟一知道构造方法的码。
它们的码长n、维数k,以及最小距离d;满足：
(参照习题9.39的结论。同时参照习题7.21中的Gilbern界，它说明这类码必然存在，但是并
没有告诉我们如何构造它们。)
9.34(参照定理9.10)设P,表示有限域GF(q")上所有次数≤r的多项式集合，而(ao,a,…,
aa-1)是GF(q")上n>r个不同元素构成的序列。对任意f(x)∈P,,矢量(Co,Ci,…,
C1)∈GF(q")"的每个分量定义为C?=f(a)。证明：由P,经过上述运算得到的矢量
集合，是F上的一个线性码，该码的码长为n,维数为r+1,最小距离为n-r。
9.35 本题的假设条件与上一题相同。对任意f∈P,,重新定义相应的C为：
C=(Co,Co,C,Cj,…,Cm1,Ch1)∈GF(q)2"
其中C=f(c,),C'=af(a:)。证明用上述方法得到的矢量集合，是GF(q")上的一个
线性码，且该码的码长为2n,维数为r+1,并且在每个非0码字中，都至少存在n-r对
不同的(C,,C)。
9.38设中：CF(q")→GF(q)"是…个从GF(g")到GF(q)"的一一线性映射。考虑习
题(9.35)中定义的CF(q")上的码，并将它变成GF(g)上的一个码，方法是将每个码宇
C映射为(φ(Co),φ(Co),…,中(Ca,),Φ(C-1))。证明所得到的GF(q)上的线性码，
码长为2mn,维数为m(r+1)。并且在每个非0码宇的n个子矢量(中(C),Φ(C))中，
至少有n-r个是互不相问的。
9.37(木题看起来似乎并不合适放在这里，但实际上并非如此=)设x?,…,是由V(F?)上
M个不同的矢量构成的集合。令w=0g(x?)表示x,的汉明重量。并令p=(w?+…+
tuy)/nM。证明：
logM≤nH?(p)
其中H?是二进制熵函数。[提示：令X=(X?,X?,…,X.)是一个随机矢量，它等概地被
假设为任意x,的值。并令p,表示M个矢量中第j位是“1”的那部分矢量所占的比例，试
验证下面一系列等式和不等式：
oM-Hx)=Hx)=Rp)≤MH()
第9章 BCH、Reed-Solomon码及其同类码 213
(乂注：此结论由Janes Massey[38]得出)
9.38 现在考虑习题9.35所定义的码，设定q=2,n=2*,而(ap.a?…,a-1)是GF(2”)中元
素的任意排列。定义r/2"=p,证明该码具有下列性质：
(i)码长=m2"*'
(i)编码速率=2(o+)
(m)≥(1-)H:'[号+2m-]
这类码就是前文提到过的Justesen码。[提示：为证明(iii),需要用到习题9.37的结论。]
9.39 最后，试证明对任意0≤R≤2,在GF(2)上都存在一个无限长的Justesen码序列，它们的
码长 n;、维数k,、最小距离d,满足：
lim t=∞
limk;/n=R
lin supd/n=H?'(1/2)·(1-2R)
=0.110028(1-2R)
9.40 说明在定理9.11的证明中定义的d是一种真实的度量。(参照习题7.4。)
9.41 对例9.9中的(7,3)码，寻找一个矢量y∈10,1,*W,使min,da尽可能大。
9.42 对于一个给定的d值，满足eg+2e≤d-1的非负整数对(e。,e?)共有多少对?
9.43设m和n均为正整数，且m+n是偶数，试证明：
气|+[会]-"去"
[参见式(9.84)前的说明。]
9.44 考虑例7.3中的(7,4)汉明码。该码的最小距高d=3,因此根据定理9.11,在e。+2e?≤2
的情况下，它能够纠正所有e。个删除和e:个错误。基于这种思想，对(a),(b),(c)中的
码宇(如果可能)进行译码。
(a)[11100*0]
(b)[0*11101]
(c)[01*10*1]
(d)随机选取一个长度为7且仅含一个删除的矢量R,运用定理9.11证明中介绍的
MMD译码算法对其译码，则它被惟一译出的概率有多大?
9.45在RS码的纠正错误及删除译码中，设o,(x)是错误位置多项式，w(π)是错误及制除求
值多项式[参见式(9.77)及式(9.81)]。试证明gd(a?,w)=1。
9.46 研究在下列情况下，RS 译码器译码失败的概率。
(a)含r个删除和1个错误。
(b)含，1个删除和1个错误。
(c)仅含r+1个删除，不含错误。
9.47 考虑GF(16)上的(15,7)RS码(其本原元满足a?=a+1),对下列接收码矢进行译码：
i且湘； 、晓，
一……………… …… …一………
,4
214 信息论与编码理论〔第二版〕
R=[a131+a?α12α?*c?a3-a'a?a2a2α"]
9.48考虑一个生成多项式为g(x)=x+x?+x3+x?+x2+x+1的(15.5)BCH码(参照例9.1),
运用9.7节末的建议对下列噪声矢量进行译码：
R-[11*000*000l≠1D1]
(a)利用时域完成法。
(b)利用频域完成法。
9.49考虑一个d=d的(n,k)线性码。如果没有错误发生，定理9.11保证了该码能够纠正
任何不多于d-1个删除的图案。通过说明至少存在一种含d个剧除的图案不能被该
码纠正，米说明此结论不能进一步扩展了。
9.50在8.4节中，我们讨论了能够纠正单个突发错误的码。看起来这类码应该更适于纠正单
个突发删除串。通过本题的练习，会进一步印证这个观点。
(a)设C是一个(n,k)线性码，它能够纠正任意长度不超过b的突发删除串，试证明
n-k≥b.(参照定理8.10的推论 Reigcr界。)
(b)试证明任何(n,h)循环码都能纠正长度不超过 n-h的任意突发删除串。
(c)考虑例8.2中的(7,3)循环码，纠正下列码字中长度为4的突发删除串：(10*六**0),
(****101),(*101***)。
9.51 当…个线性码只受删除而不受错误影响时，有一种非常简单通用的方法能够纠正这些
删除，我们将在本题中介绍这种方法。基木思想是将每个删除置换成不同的未知参望，
然后利用一致校验矩阵求解这些未知参量。例如，考虑例7.3中的二进制(7.4)汉明码，
此码的d=3、故由定理9.11可知，在没有错误发生的情况下，它能够纠正刑除不多于
两个的任意图案。如果接收到的码字为R=(1*1*101),我们将其中的两个删除置换
为未知数x和y,得到R=(1xlyl01)。
(a)因为(7,4)汉明码的任何码字都满足方程HC?=0.其中H是7.4节中给出的一致校
验矩阵，故利用此性质，可同时得到3个包含未知数x和y的线性方程组，求解此方
程组，就可以纠正删除。
(b)如果删除位是3个而不是两个，则可以利用同样的方法将这些删除用3个末知数置
换，从而得到3个方程。解这3个方程求出未知数，便可以纠正3个删除、然而定
理9.11仅仅保证了该码能够纠正两个删除。请问问题出在哪里?
9.52 在本题中，我们将考虑用一种替代方法来纠正删除和错误，它包含了“猜测”删除值的想
法。
(a)首先假设只考虑二进制码，也就是说，定理9.11中的F域是GF(2)。设码 C的最小
距离为d,接收到的码字因受噪声干扰而包含了e。个删除和e,个错误，满足ea+
2e≤d-1。假设将所有删除位置换成0,然后对其进行译码，采用的是至多能够纠
正(d-1)/2个错误的单纠错译码算法。如果译码成功，我们停止。否则，将继续尝
试，这次是假设所有删除位均为1。试说明采用这样的方式，即先猜测所有删除位均
为0,再猜测所有删除位均为1,总可以成功地纠正错误和删除。
(b)通过对二进制(7,3)循环码的接收码字[1**0*01]进行译码，来验证(a)中提出的
译码方法。(参照例9.9。)
金：:1
第9章 BCH、Reed-Solomon码及其同类码 215
(c)这种“猜测”法对非二进制域也同样有效吗?特别地，为使此方法在三进制域GF(3)
上同样有效，你该如何对它进行调整?
9.53 考虑例9.9中提到的生成多项式为g(x)=x?+x3+x2+1的二进制(7,3)循环码，它的
d=4,故由定理9.10可知，它能够纠正所有删除不多于3个的图案(如果不需要同时
纠正错误)、同时、它也能纠正某些(但不是全部)含4个删除的图案。本题中，试研究在
全部包含4个删除的可能图案中，有哪些是可以被纠正的?特别要找出有多少个含4个
删除的图案能够被纠正
9.54 本题将讨论在GF(q)"上随机选取的矢量被一个RS码译码器成功译码的概率。
(a)椎导下面公式，它表示的是以GF(g)上(n,k)码的码字为中心，以!为半径的所有
无重叠汉明球体的“体积”在整个GF(q)"空间中所占的比例。
^Zi-GYxq-ly
(b)对于一个固定的t值，当q→时，考虑一个随机选取的长度为q-1的矢量，利用
(a)中的公式计算它与GN(q)上码长为q-1、纠正：个错误的RS码中某个码宇的
汉明距离不大于t的概率极限。(设该码的冗余为r=22)
9.55 设C是·个二进制(n,k)循环码，其生成多项式为g(),校验多项式为h(x)。
(a)证明如果h(1)≠0,则每个码字的重量都为偶数。
(b)如果h(x)不存在-对根(θj,0?)满足θ?θ?=1,则C的每个码字的重量都可以被4
整除。[提示：这是引理5结论的一个推广：]
9.56在本章中，我们证明了(23.12)Golay码的最小距离满足d≥7。试说明，实际上该码的
最小距离dn=7。可以用以下两种方法推导出此结论：
(a)通过分析其生成多顶式g(x)。
(b)通过证明任意二进制(23,12)线性码都满足dn≤7a
9.57试说明不存在d=5的二进制(90,78)线性码，也就是说，不存在码长为90的纠正两个
1+(99)+()=2成立。[提示：令r表示对应于1比特错误且重 错误的完备码，尽管
量为奇数的伴随式数H(伴随式含有12比特)。证明对应于2比特错误且重量为奇数的
伴随式的数目为r(90-r),然后设法确定，值。]
9.58考虑在9.8节中定义的二进制(23,12)Golay 码，结合其伴随式查表译码方法，它能够纠
正所有重量≤3的错误图案。
(a)如果错误图案的重量为4,详细描述译码器的处理过程：
(b)如果错误图案的重量为5,译码器又是怎样处理?
(c)试推广(a)及(b)的结论。对于4≤I≤23范围内的每个整数1,讨论如果错误图案的
重量为1,译码器将如何处理?
9.59 证明定理9.14。
9.60本题将讨论在(24,12)扩展Golay码中，重量为8的码字的数目：
(a)分别用两种方式证明，重量为8的码字的数目不为0:(1)通过分析原来的(23,12)
Golay码的生成多项式g(x);(2)证明任意二进制(24,12)线性码都满足d≤8。
:褂.e,
、;……………………2………………………………………………………………… 216 信息论与编码理论(第二版)
(b)给定"该码恰好含有759个重量为8的码字，试证明，对于|0,1,…,23|中任意五个
元素构成的子集，….is!恰好存在1个重量为8的码字，在这5个对应位置上的
光素都是1。
9.61 本题将研究(24,12)扩展Gday码的检错能力。[在(a)及(b)中，我们假设该码被用于纠
正重量不大于3的所有错误图案：]
(a)试证明该码能够检测出所有重量为4的错误图案。
(b)设该码的重量分布多项式为：
1+759x?+2576x2+759x1?+x2
对e在范围4≤e≤24内的每个取值，计算该码能够检测出的重量为e的错误图案
的数目。
(c)现假设该译码器仪被用来纠正重量不大于2的错误图案，重复(b)中所问。
(d)现假设该译码器仅被用来纠正重量不大于1的错误图案，重复(b)中所问。
(e)最后，假设该译码器工作于单检错模式，即如果伴随式为0,就判定接收到的码字正
确，否则，就判定出错。重复(b)中所问。
9.62在本题中，我们只考虑(23,12)和(24,12)Golay码的编码器。
(a)设计一个(23,12)Colay 码的移位寄存编码器。
(b)修改你在(a)中的设计，或者另想他法，设计一个(24,12)扩展Golay码的编码器。
9.63 试讨论(24,12)Golay码的伴随式查表译码器的大小和复杂度：
在习题9.64至习题9.67中，将研究三进制 Golay 码的性质。注意到在矢量空间CF(3")
中，一个半径为2的汉明球体包含了：
+2()+4(2)=243=3S
个矢量、这就说明可以用729=3°个半径为2的汉明球体填满 CF(3")空间。三进制Golay码
做到了这一点。它是CF(3)上的一个(11,6)线性码，当以其码字为球心时，就完成了如上所述
的“填充”。该码的定义如下：因为3?-1=11·22,故CF(3?)包含一个11阶本原单位根，我们把
它记做β在GF(3)上，将x"-1进行因式分解得到x"-1=(x-1)g(x)g(x),其中g(x)=
x?+x-x3+x2-18,g(x)=x3-x3+x2-x-1。可以假设β是g(x)的一个零点，这样，三
进制(11,6)Golay 码就可以定义为生成多项式是g(x)的循环码。为证明围绕其729个码字的
半径为2的球体是不相交的，必须先证明各码字之问的最小汉明距离≥5,即每个非零码字的
重量都≥5:下面的习题包含了此结论的一种证明1m.。
9.64试证明三进制Golay 码的最小重量≥4。(提示：利用定理9.3,BCH论证。)
9.65 证明如果 Co+C?+…+Cm=0,则码字C=(Co,C?,…,Cm)的汉明重量能够被3整除。
(提示：参见9.8节引理4。)
9.66 另一方面，如果 Co+C?+…+Cm=a≠0,试说明，(Co+a,C?+α.…,Co+a)也是该码
的一个码字，并且其汉明重量同样能被3整除。
9.67 利用前面的结果，证明该码不存在重量为4,7或10的码字。[提示：如果码字重量为4,
通过适当的标量乘法，其非0分量可以转换为(1,1,1,1)或(1,1,1,-1)。]
第9章 BCH、Reed-Solomon 码及其同类码 217
注释
1] 本节采用的方法主要来源于Berlekamp[14]的第四部分。
[2] 这种现在一般称为BCH码的码型最早在1959年被法国数学家A.Hocquenghem发
现。1960年，R.C.Bose 和 D.K.Ray-Chaurhuri也独立发现了此码。但是，由于
Horquenghem的上作在当时并未能引起注意，因此这种新码暂时被命名为Boee
Chaxdhuri码(而不是Bose-Hay-Chaudhuri码)。后来人们认识到实际上 Hocquenghem
已经早于Bose和Ray-Chaudhuri发现了此码，便将其改名为 Bose-Hocquenghem Chaudhuri码，简称 BCH码。记住这三位科学家只是发现了这种码(而不是译码算
法)是很重要的。有关译码算法的发展历史，请参见354～355页。
[3] 如果F的特征是有限值，我们假定它不能整除n:
[4] 习惯上规定0多项式的次数为-的。在这种规定下.即使a,b中的一个是0多项
式，一些基本的公式，例如 deg(ab)=deg(a)+ deg(b),deg(a+b)≤max( deg(a),
drg(b))仍然成立。
[5] 此证明来源于J.B.Shearerc
[6] 在大部分(但不是全部)应用中，F域是指GF(2")(m≥1)。但是由于这个定理对任
何域都适用，而不管这个域是有限的还是无限的，因此在这里无须对F增加不必要
的限制。
[7] 当然，除非C的某些删除位确实就是0,在这种情况下C和R'的不同位数将少于
eo+e个。
[8] 如果不做进一步的研究，很难得出这些因式。我们建议有兴趣的读者参考 Berleka mp[14]的第6章。
9] 参见习题7.17(b)。
[10] Golay 码的重最分布情况参见下表(参考文献：MacWilliams和Sloane[19],第20章):
Golay(23,12) Golay(24.12) Cday(1J,6)
A A A
0 1 0 0 」
7 253 8 759 5 132
8 506 12 2576 6 132
I1 1288 16 759 8 330
12 1288 24 1 9 [10
I5 506 11 24
16 253
23 1
...{ ·! ,
第10章 卷 积 码
10.1 引言
在本章中将研究卷积!1码。为方便起见，假设研究的码用于二进制输人信道，即信道
的输入符号集等同于有限域F?。(但是很容易推广到Ax=F的情况，其中q是素数的
幂。)
卷积码可以用多种不同的方法来描述。在引言这一节中，将介绍三种方法，分别称之为多
项式矩阵表示法、标量矩阵表示法、移位寄存器表示法。(其他三种描述方法：状态困表示法、
网格图表示法、树围表示法将在本章的后续各节中2介绍。)
●多项式矩阵表示法。回顾第7章中，一个二进制(n,k)线性分组码可以用F?上的一
个k×n阶生成矩阵G=(g)描述 一个(n,斥)卷积码(CC)也可以用一个k×a阶生成矩阵
G描述；区别只在于卷积码生成矩阵的元素g;是F?上的多项式。例如，矩阵
G=[x2+1,x2+x+1]
是一个(2,1)卷积码的生成矩阵，我们将它记做卷积码-1以备卜文采用。同样，
c=[09x1
是-个(3,2)卷积码的生成矩阵，我们称之为卷积码-2。
现在定义与卷积码相关的三个重要参数：
记忆长度：
M=max ldeg(ga (10.1)
约束长度4:
K=M+1 (10.2)
速率；
R=k/n (10.3)
这样，卷积码-1的参数为M=2,K=3,R=1/2,卷积码-2的参数为M=1,K=2,R=2/3。
这些参数的物理意义将随着研究的深人而逐步体现出来。现在通过简单的观察可以了解到，
由于分组码生成矩阵的元素是0次多项式(即元素是标量),因此(n,k)分组码可以被看做参
数为M=0,K=1,R=k/n的卷积码。
为了利用多项式矩阵G对标量信息进行编码，必须将信息比特映射成一个无重多项式
I
di■
第10章 卷 积 码 219
I=(Io(x),….I-,(x))的系数。则“码字”C=(C?(x),…,C-i(x))是一个n重多项式，它
定义为：
C=IG (10.4)
其中小圆点代表矢量-矩阵乘法。因此在多项式矩阵表示法中，生成矩阵为G的卷积码是G
的行空间。
例10.1 对于卷积码-1,可以利用式(10.4),对多项式信息I=(x3+x+1)进行编码，得到多
项式码字C=(x3+x2+x+1.x3+x?+1)。
例10.2 对于卷积码-2,可以利用式(10.4),对多项式信息]=(x2+x,x3+1)进行编码，得
到多项式码字C=(x2+x,x3+1,x?+x3)。
到现在为止，我们还没有给出k重多项式，n重多项式以及比特图案之间的对应关系。为
找出这种对应关系，需要引人卷积码的标量矩阵表示法。
●标量矩阵表示法。一个码字多项式C=(C?(x),…,C.-i(x))最自然的比特(标量)表示形
式，可以通过交织排列各多项式的系数得到。因此如果第j个多项式为C,(x)= Co+Cx+…,
则C的标量形式可以表示为：
C=(Coo,C10,…,Cn-1,0,Co,…,Cn-1.1,…) (10.5)
前面提到过，生成矩阵为G的卷积码是G的行空间。现在利用这个性质很容易得到G的标
量形式，即通过式(10.5)定义的标量码字构成标量G的行空间。令
c=LGx (10.6)
表示M次多项式G的展开式[参照式(10.1)],系数G,是一个k×n阶标量矩阵。图10.1描
述了G的标量形式。
G
G, C?
G?_ G
G
G G
G
G=
图10.1 根据式(L0.6),由多项式生成矩阵得到的标量生成矩阵(阴影区域=全零)
注意标量生成矩阵的行数和列数都是无限的。与此相对应的是，信息多项式和码字多项
式的次数都可以是任意大的：
例10.3 根据式(10.6),将卷积码-1的多项式生成矩阵展开，得到：
G=[1.1]+[0,1]x+[1,1]x2
故由图10.1得到卷积码-1的标量生成矩阵为：
:·i
220 信息论与编码理论(第二版)
0 1 1
1 1 0
1
1 1
0 1
G= 1
1 1
0
1
—
0
多项式信息I=(x3+x+1)对应的标量信息为(1101)[而不是(1011)],多项式码字C=
(x?+x2+x+1,x?+x?+1)对应的标量码字为(111010000111)(对比例10.1)。
例10.4 根据式(10.6),展开卷积码-2的多项式生成矩阵，得到：
c=69i+[881
故由图10.1得到卷积码-2的标量生成矩阵为：
G=
0 0 0 1
0 1 0 0 0
0 1 1 0 01
0 0 0
110 I
0l0
一
00
00
多项式信息【=(x2+x,x3+1)对应的标量信息为(01101001),多项式码字C=(x2+x,
x3+1,x?+x3)对应的标量码宇为(010100100011001)(对比例10.2)。
我们在前文中提到，信息多项式的次数原则上可以任意大(码字多项式也如此)。但是在
任何实际应用中，显然存在一个允许的最高次数。因此我们需要定义卷积码的L级截断。
首先，要求 deg[1,(x)]≤L-1,其中i=0,1,…,k-1。由式(10.1)和式(10.4)可知，在相
应的多项式码字C=(C(x),…,C(x))中，每个分量的次数均≤M+L-1。因此，信息
I=(I?(x),…,-(x))可以用kL个比特表示，而码字C可以用n(M+L)个比特表示。从[
到C的编码映射可以用标量运算C=I·G来表示，其中标量矩阵G是图10.1所示矩阵G的
一个截断，图10.2对它进行了描述。(图中阴影区域代表全0区域。)
Af+L blocks ofA
C, L blocks ofk - G G?
G. G G
G G
图10.2 矩阵G
第10章 卷 积 码 221
因此，可以将一个(n,k)卷积码的L级截断，看做是一个(n(M+L),kL)线性分组码，从
这个意义上讲，卷积码是一种特殊的分组码。截断码的编码速率由下式给出：
R=M+
=R(1-+)
其中，R=k/n是未截断卷积码的编码速率[见式(10.3)]。在大多数实际应用中，L的取值远
大于M,这样速率R就非常接近于R。这是将R称为谈码速率的一个原因。(另外一个原因
见后面。)
例10.5 如果对卷积码-1取L=6,将得到一个(16,6)线性分组码，其生成矩阵为：
例10.6 如果对卷积码-2取L=2,将得到一个(9,4)线性分组码，其生成矩阵为：
●移位寄存器表示法。假设现在要为卷积码-1设计一个编码器，此编码器的输入信息
比特流为1=(Io,1,…),输出编码流为C=(Cm,Cm,Co,Cn,…),其中I和C之间的关系
如下；
Co(x)= Co+Cx+…
=(x2+1)(lo+I?x+·)
=(x2+1)I(x)
和
Ci(x)= Co+Ciix+…
=(x2+x+1)(Lo+Iix+…)
=(x2+x+1)/(x)
因此编码器必须完成将输人信息流乘以两个多项式x2+1和x2+x+1的运算。幸运的是，我
们已经在第8章中(参见图8.1)看到了如何完成这种运算。电路
输出
物入·
1 x2 x
:l.
222 信息论与编码理论(第二版)
将完成乘x2+1运算，而电路
精出
袖入
1 xx2
将完成乘 x2+x+1运算、这样，图10.3所示的电路就可以看成是卷积码-1的编码器、从
图 10.3中可以看出，输入和输出流之间具有下述关系：
C=1+1,+/}, j=0,1,… (10.7)
可见输出流C.是输人流[和相应的多项式进行卷积的结果"
在图10.3中，我们注意到第j个输出比特Cn,和C,不仅取决于第j个输人比特号，还取决
于之前输入的两个比特!_和I2。编码器除了记录当前输入比特外，还必须记录前两个输
人比特，这就是定义该码的编码记忆长度M=2的原因。同时，由于每个输入比特都对应着两
个输出比特，因此该码的编码速率为1/2。最后，注意到图10.3中编码器包含3个触发器，因
此定义该码的约束长度是3、
GC.Cn)
1- :
-G=ICmCn."
图10.3 卷积码-1的移位寄有编码器
将图10.3中的编码器推广到一般(n,k)卷积码的移位寄存编码器非常简单。它需要k
个移位寄存器，每个寄存器对应于k个输人信息流L,I,,…,Ik_1中的一个。第i个移位寄存
器完成将第i个输人流依次与n个多项式g(x),…,g,,(x)中的每个多项式进行卷积的运
算。将每个移位寄存器的第j个输出流相加，便叮以得到编码器的第j个输出流。
例10.7 图10.4画出了卷积码-2的移位寄存编码器。
-C
I I x
+
C
L- 1{ x
C?
图10.4 卷积码-2的移位寄存编码器
;排
第10章 卷 积 码 223
从移位寄存的观点来看，卷积码就是一个特定编码器的所有可能输出流的汇集。表面上
看，这种表示法并不吸引人。但是在下一节中将看到，正是移位寄存表示法直接导致了状态图
表示法的产生，这可能是日前已知的一种最为有效的表示方法。
10.2 状态图、网格图及Viterbi译码
本节包括两部分内容：在第一部分，我们首先针对一个特定的卷积码，即卷积码-1,介绍
与它有关的全部概念。在完成对卷积码-1的研究后，将研究的结论推广到其他卷积码。
我们定义图10.3中编码器在某个给定时刻的状态，是移位寄存器中最右边两个触发器的
存储内容，即(I,1-2)。编码器总共有四种可能的状态：00,01,10,11、在每个时钟周期内，
编码器接收到一个输入比特(L,),作为响应转移到下一个状态(15-1),并产生两个输出比特
Ca,和C[参见式(10.7)]。因此，图10.3中编码器的工作过程可以完全用图10.5中的状态图
来描述。图10.5中的4个方框代表编码器的4种状态；实线支路表示输人“0”时编码器的状
态转移，虚线支路表示输人“1”时编码器的状态转移，支路上的标注代表编码器从一个状态向
另一个状态转移时的输出。例如，考虑从状态c(10)到d(11)的支路，它代表图10.3中移存器
的存储内容(I,I.1,12)=(110)时编码器的工作过程。此支路用虚线表示是因为I,=1。利
用方程(10.7),计算出Cn=1,Cj=0,因此支路上的标注为(10),
(00)
00 a
(1 (01) (11)
b 01 100} 10 c
(101 (10)
H1 d
01)
图10.5图10.3所示编码器状态转移图
利用图10.5所示的状态转移图，对于任何给定的输人序列，将很容易计算出图10.3所示
编码器的输出。我们只需从状态a出发，当输人为“0”时沿着实线支路走，当输入为“1”时沿
着虚线支路走，所经支路上的标注即为编码器的输出。例如，当输人信息流为H0100时，所经
过的路径为acdbcba,输出序列为111010000111。(注意，这和例10.3的输出序列计算结果
相同)
当我们通过在状态图中移动来仿真编码器的工作过程时，同一条支路可能会经过许多次；
这使我们很难保存和标记经过的路径，因此非常希望能在状态图中引人时间标记。解决这个
问题可能的最佳途径就是，保留每一个时钟周期的状态图，并将它们串联成一个如图10.6的
网格图，图中每一列的4个圆点代表a,b,c,d四种状态。对于j=0,1,2,…的每个值，都有一
:,
224 信息论与编码理论(第二版)
列与之对应。标记j称为深度，每个状态相对应的深度j将作为其下标标出。当且仅当状态
图上的两个状态之间有支路相通时，深度为j的状态才与深度为j+1的状态通过支路相连。
(惟一的例外发生在从j=0到j=1时，因为在j=0时，图10.3所示移位寄存器的存储内容是
[10,0,0],所以它只能在状态a=00.)编码器的输出可以沿着网格图上的相应路径得到。例
如，对于输入信息流110100…,找到图10.6中网格图上相应的路径aoc,d?b?c?bsa…,就可以
得到输出流为(111010000111…)。
aa 00 00 00 00 00 00
二
6 4
c
0
d
0J
= .01 0L -01
f=1 2 3 4 5 6
图10.6 对应于图10.5中状态图的网格图
在10.1节中我们曾经提到过，在任何实际应用中，需要利用的是截断的卷积码。一个L
级的截断码，对应着一个截断的网格图，当输入信息流的长度为L比特时，此网格图包含了编
码器的所有可能输出流。图10.7画出了L=6时，卷积码-1的截断网格图。(读者可能会奇
怪，为什么6个输入比特I。,I…,I?却对应着网格图上的一条8支路路径。这是因为该码有
2比特的编码记忆长度。图10.7中一条路经上的8个支路，分别对应着图10.3中移位寄存器
的存储内容是[1。,0,0],[1,J,0].…,[Is,?,J?1,[0,Is,14],[0.0.I?]时的编码器输出。这
也就解样了为什么在图10.7中任何路径的最后两个支路都是实线。)
现在来解释怎样利用网格图对一个卷积码进行译码。例如假设卷积码-」的L=6级截
P<立 断码在一个二进制对称信道中传辅，该信道的原始误码率 ,并假设接收到R=
[1011001110111100]。(在图10.7的网格图上方已经标出了此序列，作为参考。)我们已经注意
到(参照例10.5),此码是一个(16,6)线性分组码；最人似然译码器需要找出64个码字中与R
的汉明距离最小的那个(参照习题2.13及7.3节)。解决这个问题的一个比较笨拙的方法就
是将这64个码字，一比特一比特地与R做比较。但是，如果考虑到这64个码字刚好对应于
图10.7网格图中从a到的64条路径，并充分利用这一点，就会得到一种相对而言简单得
多的方法。
我们画出图10.7的一种新形式：这次各网格支路上标注的是原图10.7中的标注与R相
应位置上两比特之间的汉明距离。例如，b?→c?支路的标注为dg(00,11)=2。结果得到如
图10.8所示的网格图。如果将图10.8中支路上的标注看做是一种长度，那么R与一个给定码
字之间的汉明距离，就是网格图上该码字对应路径的总长度。例如，码字(0000110100101011)对应
的路径为doa?a?c?b?c?d?b?ag,则它和R之间的汉明距离为1+2+2+1+1+1+I+2=11。这
样，寻找与R汉明距离最小的码字的问题，转化为寻找网格图10.8中从a。到ag的最短路径
问题。现在重点研究这个最短路径的问题。
第10章 卷 积 码 225
R= 10 11 00 IⅡ 10 11 LI 00]
a an 00 00 00 00 00 00 00 00
心
h
4 4 D
O 白 白
d
O 9!
=) I 2 3 4 5 6 8
图10.7 卷积码-I的L=6截断网格图(参见例10.5)
a
! 2 0 2 1 2 2 0
2 0 0
0
0 2
2 0 0
1
0 2' 、 、2
1
1 2
c 0
1
1/ 0
1
d 1 1 2.
/=0 1 2 3 4 5 6 7 8
图10.8 图10.7所示网格图的另一种形式
假设从a到ag的最短路径P经过某个中间节点x,如图10.9所标。路径P中从an到x
的那部分用P?表示，从x到a。那部分用P?表示。显然，P?是从a到x的最短路径，因为如
果有另一条路径，比如说是Q.比P?更短，那么路径QP?将比P=P?P2短，这与P是从a。到
a的最短路径相矛盾。这个认知是Viterbi译码算法的关键。Viterbi译码算法的基本方法是，
对于每个j,找到从a,到深度j的每个节点的最短路径列表，则第(j+1)级的最短路径列表很
容易由第j级列表得到，因为如果ao…s,是通往+的最短路径，则ao…s,一定是通往s,
的最短路径，所以，深度(j+1)最短路径只需要将深度j最短路径往前延伸一个支路就可以
获得。
%
0
P
g P,
图10.9 a和a,之间的路径
现在可以正式介绍Viterbi算法了，不过在此之前需要先定义一些符号。S表示状态集
la,b,c,d。如果s,t∈S,并且在状态图上s和：之间有支路相连，则定义B(s,t)米表示此
时的输人信息：如果从状态：转移到状态：时，编码器输人信息为0,则B(s,t)=0,否则，
B(s,t)=1。如果s和t之间没有支路相通，B(s,()就没有定义(见图10.10)。同样，对于s,rES.
i.,
州
226 信息论与编码理论(第二版)
定义L,_:.,(s,t)是网格图中连接s,和t,的支路上的标注：如果不存在这条支路，定义
I-1.,(s,t)=+四。例如，lo(a,c)=1,l..3(d,b)=1,l.g(a,c)=+。
t-
a b d
0 ]
b 0 1
广门 0
0 1
图10.10 卷积码-1的Bs,t)函数
现在开始介绍Viterbi算法。它需要计算两个量：测度和幸存路径。测度；(s),s∈S.表
示从a到x,最短路径的长度；保留路径B,(s)是一个长度为j的二进制字符串，它记录了从
a到s,的最短路径。例如，B?(b)=1010意味着从a到b?的最短路径是d?cb?cyb?。
图10.1i断出了Viterbi算法的译码过程。(注意，在第2步中，运算符*表示级联；例如，1101*0=
11010.)读者现在可以毫无困难地验证(利用对j的归纳法):由Viterbi算法计算出的μ(s)实际
上就是从ao到5最短路径的长度，而B;(s)也的确记录了这条最短路径。
1.设定初始值：a(n)-0,对所有s≠a,有po(s)=+,同时，令B?(a)=φ.j=1-
2.对任意f∈S,找出一个∈S,使A-i(2)+4,.,(t,s)的值最小、然后设
n;(8)←A-i(1)+l-1,;(1,s)
B,(s)-B-:(1}=B(r,s}
3.如果j=L+虹，输出B,(a)的前工比特并停止：否则，令jj+[,回到第2步
图10.11 Viterbi译码算法。符号说明：S是状态集合，α是全0状态、b..,(t,s)是
网格图上连接L,_1和s,支路的标注，B(L,s)=0表示从状态s转移到状
态!时输人的是0,B(t,s)=1表示从状态s转移到状态：时输人的是1
我们可以用图10.12来描述对图10.8中网格图6运用Viterbi算法的过程。其中，测度
A;(s)标注在节点s;的上方，保存路径B,(s)则由a。到s,的惟一路径表示。例如，μ(a)=2,
B?(a)=0100。可见从a到ag的最短路径是a?a?c?b,arc;b?a?ag;它的长度为4。因此译码
器输出为010010,这就是与R对应的信息序列I=(Io,…,Is)的最大似然估计值。
1 3 3 2 3 3 4
益
4
a
上 2 2 3 4 4
2 3 3
3
d
2 3/ 3
=0 1 2 3 4 5678
图10.12 对图10.8所示网格图应用Vitebi算法
..i. I
第10章 卷 积 码 227
以上完成了对特定码(卷积码-1)在特定信道(二进制对称信道)中传输的讨论。现在讨
论推广间题，
首先，考虑更为…般的卷积码。我们将注意力集中在(n,1)卷积码上，而对k取更大值情
况的讨论留在习题10.5中。对(n,1)码米讲，编码器(见图10.3)包含一个长度K=M+1的
移位寄存器；编码器的状态定义为最右边M个触发器的内容所组成的长度为M的矢量。因
此，编码器共有2"个状态，在状态图中的每个状态，都有两条支路进入它，并同时有两条支路
离开它。例如，图10.137给出了一个(n,1)M=3卷积码的状态图。图10.13中省略了支路上
的标注，它们一般是长度为》的二进制矢量，依赖于定义这个码的多项式。随着M值的增大，
状态图将变得越来越复杂；当M接近于10时，状态图的结构会复杂得甚至连计算机都难以
处理。
000
001
010
101
U11
111
图10.13 M=3(K=4)(n,1)卷积码的状态图
图10.1t所示 Viterbi算法在这种一般条件下仍然适用(假设信道仍然为二迸制对称信道，
p<立)。惟-的问题是，该算法的复杂度随M的增大呈指数级递增(虽然它只随L做线性 且
递增),因此只有在M值相对较小时，该卷积码译码算法才有实际意义。事实上，就目前数字
逻辑电路的发展现状而言，即使是k=1的卷积码，通常M的值也只取到7或8。
现在考虑更为一般的信道，并将注意力集中在二进制输入离散无记忆信道(DMC)上(参见
习题10.7)。回忆习题2.13,对于一般的 DMC,最大似然译码器所选择的码字C,=(Cm,…,
C-1),必须能使概率
PiRic)-incico)
最大，其中R=(Ro,…,Ra,)是接收到的矢量，而p(ylx)是信道转移概率。因为对数函数是
其自变量的单调递增函数，所以最大似然译码器可以等效地寻找一个码字C,,使其满足：
.3 i
100
110
228 信息论与编码理论(第二版)
C,R)=hoepRIC) (10.8)
最大。这意味着只要我们重新定义支路标注L-1.;(s,t),图10.11所示的Viteri算法就适用于任
何DMC.为了给出合适的定义，假设使用的是L级截断码，而R=(R?,R?,…,R?+x-1)是接收到
的码字，它被分为L+M个n比特的矢量。如果状态图中存在从：状态到t状态的支路，则用
C.来表示相应状态转移时编码器的n比特输出，也就是s→t 支路上的标注(见图10.5)。定义：
I-1f(s,1)=L(C,,R/-1) (10.9)
其中L内式(10.8)定义 如果s和：之间没有支路相通，则依惯例定义1,_1.,(s,t)=+。
10.3 路径枚举多项式和错误概率的界
我们在10.2节中看到，卷积码编码器的呵能输出流与连接状态图中全零起始和终止状态
的路径之间具有一一对应关系。本节将利用组合技术来列举所有的这些路径，并利用其结果
得到特定卷积码的性能估计。同往常一样，首先针对卷积码-1介绍相应的基本概念，然后再
讨论推广问题。
考虑图10.5所示的状态图，定义图中某条路径的(汉明)重量为此路径上各支路标注中
“1”的数目。(例如，路径acbancddba的重量为12)对于某个确定的整数i,如果统计从状态 a
出发再回到状态a的重量为i的路径数目，可能会发现这个数目或者是0,或是无穷大，这是因
为重量为0的路径在状态a处形成了回路。解决这个问题的一种方法是，每条从a到a的路
径，都可以惟一地被分解为一系列从a直接到a的，中间没有返回过a的路径。(例如，路径
acbuaodddn可被分解为acbc,aa和acddba。)我们将从a直接到a,中问没有返回过a的路径
(除了平凡路径aa)称为基本路径，对于i的每个取值，用A表示重量为i的基本路径的数目。
经过反复试验，可以发现Ao=A=A?=A?=A?=0,A?=1,等等。下面将介绍一种能够同时
计算所有A,值的有效方法。
为了便于研究A,图10.14修改了状态图10.5的形式。注意在图10.14中，初始状态a
被分解为a和a两个状态，同时a处的自环被删去。这意味着原来状态图上的基本路径和
修改后的状态图10.14上连接，a?的所有路径之间，具有——对应的关系。图10.5中各支
路上所标注的汉明重量，在图10.14中相应地变成了未知数x的方幂。例如在图10.14中，支
路h标注的是x,因为图10.5中其标注(01)的重量为1。这种标注是一种便于我们按重量列
举出从ao和a,的所有路径的记录方式，因为如果定义路径P的标注是它所有支路上标注的
乘积，很显然路径P的重量就是其标注的指数值。例如，路径P=aocbolba;的标注为x2,因
而路径P的重量为7。
考虑到我们的月标是计算A,的数值(A的值等于从a。到a?重量为i的路径数),定义卷
积码-1的路径重量枚举多项式8为生成函数：
A(x)= Ao+AIx+A?x2+… (10.10)
对照图10.14,A(x)就是从ao到a?所有路径标注的总和。计算这类生成函数有一种通用的
方法，在附录D中做了介绍。将此方法用于图10.14所示的状态图，结果是：
第10章 卷 积 码 229
A(x)=x3/(1-2x)
=x?+2x?+4x?+…+zix3+1+… (10.11)
因此对于i≥5,卷积码-1共有A=2'3条重量为i的基本路径，{参见附录D中式(D.3)。]
a
x
c
x
x
d
x
图10.14 卷积码-1的修正状态图
为了将来的应用，我们需要一个更精确的生成函数，它不仅可以依照重量，还可以依照路
径长度以及该路径所对应输人序列中“1”的个数来列举路径。为此需要标注更详尽的状态图，
如图10.15所示，图中x的指数值描述了相应支路上编码器输出的汉明重量，z的指数值描述
了相应输人的汉明重量。y的指数值恒定为1.表示每个支路长度为1。再次定义一条路径的
标注为它所有支路上标注的乘积。例如，路径P=anchodba,的标注为x3y?z3,这意味着相应
编码器输出(110100101011)的汉明重量为7,路径长度为6,而此路径对应的输人流(101100)的
汉明重量为3、现在，我们定义完全路径枚举多项式A(x,y,z)是图10.15上从a到a,的所
有路径标注的总和：
A(K,y,2=_uxyt (10.12)
其中，A.代表从ao到a,标注为xyz 的路径数目。在附录D中，将看到卷积码-1的完全
路径枚举多项式可以表示为：
Ax,y.z)=+ (10.13)
显然，如果令y=z=1,式(10.13)将简化为式(10.11)。
的 o
x2y xy x2w
b c
2
d
xpz
y
图10.15 图10.14的更详尽标注版本
230 信息论与编码理论(第二版)
现在将介绍如何利用路径枚举多项式得到卷积码性能的一些界。
对于给定的卷积码和给定的信道，我们白然关心最终的“错误概率”。但是由于错误概率
存在几种定义方式，并且每种定义的处理方法都略有不同。因此在讨论如何获得锴误概率的
界之前，先介绍一下我们对“错误”的定义。
假设在特定的离散无记忆信道中采用特定的(n,k)卷积码(参见习题10.14),并旦截断长
度L足够大。同时假设采用最大似然译码算法(例如 Vitenbi算法),而传输的码字是全0码9。
这意味着编码器输出所对应的路径是网格图中最上方的那条水平线。译码器并不知道编码器
选择了哪条路径，只能根据接收到的(噪声)样本进行猜测。我们将编码器实际选取的路径称
为正确路径，将译码器猜测的路径称为译码路径(见图10.16):显然译码路径上包含一个由
正确路径分段组成的集合(可能为空集),它们被一系列除了结束点在正确路径上，其余部分都
在正确路径下方的路径分段分割开来。这部分错误的路径分段我们称之为错误事件(在
图10.16中共有5个错误事件)。注意每个可能的错误事件都对应着编码器状态图上的一条基本
路径。现在所要讨论的不同译码器的错误概率，就与这些错误事件的概率有关。
0 正嘀路径- 1
译码路径
图10.16 一些网格路径
首先要做的是计算没有错误事件发生的概率。既然已经假设L足够大，那么除非信道无
噪声，否则这个概率将接近于0(见习题10.12)。我们更关心的是估计起始点错误概率P,,
即在译码深度为0时就发生第一个错误事件的概率，这时译码路径的形状如图10.17所示
现在用0=(0,0,…)表示正确(传输的)路径，x=(x?,x?,…)表示任一由错误事件E作为起
始点的路径，而y=(r,y?,…)表示接收到的序列，它是0的噪声样本：令0,,x,y,表示各自
序列的前In比特。最大似然译码器将从网格图中选择一条路径x,使得P(ylx)最大。这意味
着除非P(yr)≥P(y,10:),否则将x路径上的错误事件E换做0,将得到比x更好的路
径。利用与定理7.5证明相同的论证方法[参照式(7.13)]可知，最大似然译码器判决E比0:
更优的概率不大于ya),其中γ的定义同式(7.8),而wn(E)是R的汉明重量。因此起始点
错误概率Pe.的界，由下面的不等式给出：
PsI=∑r (10.14)
式(10.14)的求和范围包括所有的错误事件E。但是已经注意到，错误事件就是状态图上的基
本路径；而A(x)[式(10.10)]按照汉明重量列出了所有这些基本路径。因此式(10.14)给出的
上界，也可以表示为下式：
Ps,1≤A(y) (10.15)
尽管我们定义 P.,为在深度为0时译码路径就离开正确路径的概率，但显然它也是深度
为j时译码路径离开正确路径的概率，这里假设在深度为j-1时译码路径还在正确路径上。
4..:
:
第10章 卷 积 码 231
这个条件似乎过于苛刻，因此现在定义错误事件概率PE表示在深度为j时译码路径离开正确
路径的概率。它也就是在译码深度为j时正确路径下方有一个错误事件发生的概率(见
图10.18).情况同以前讲过的一样，惟一的区别是长度为L的错误事件E可能发生在这!个
位置上的任意 ·个位置.因此参照式(10.14),P&的界限为；
P=∑ lengh(E)y
=ZA (10.16)
其中A,,是完全路径枚举多项式的系数”见式(10.12)]。当然求和式也可以通过求A(x,y,
z)的偏微分得到：
,_ (10.17)
0 1 ·正确路经— L.
E
错误路径
图10.17 深度为0的错误事件
j
E A
1- 1-
图10.18 一些深度为j的错误事件
最后注意到，译码器根据它假定的路径输出信息比特，而即使泽码路径是错误的，仍然可
能“意外”地正确详出某些个别比特。因此 般来讲，误比特率P.比错误事件概率要小。利
用推导式(10.15)和式(10.17)的同样方法，得到P,的界为(见习题10.13):
R (10.18)
例10.8 已知卷积码-1的路径枚举多项式A(x)和A(x.y,z)[式(10.11)和式(10.13)],我
们讨论它的上面所介绍的三个界，结果为(假设0<Y<2):
Pa-2y-r3+ai)
P3r--2°=3y3+0rv9)
P2p=v3+αv)
注意这道例题中的三个界主要内γ的高次项了决定。考察A(x)和A(x,y,z)的定义，我
们发现这是因为该码基本路径的最小重量是5。通常定义卷积码的自由距离 d,是其基本路径
:
“
232 信息论与编码理论(第二版)
的最小重量。不难验证(见习题10.15),Pe.1=αSs+0(y4+'),其中α是一个确定的常数。一
般认为自由距离是衡量卷积码对抗噪声能力的一个最重要度母，因此如何寻找具有大自由距
离的卷积码成为人们不懈努力的一个方向(见12.3节和习题10.16)。
10.4 序列译码[10]
(在本节中，我们将注意力集中在斥=)的卷积码上，一般情况留到习题10.20中考虑。)
在10.2节中我们看到，卷积码的 Viterbi译码是一种最大似然译码算法，因此对于任意特
定的卷积码都不可能进一步提高算法性能。同时我们看到，Viterbi算法的复杂度是其编码记
忆长度M的指数函数；遗憾的是，M的值越大，码的性能似乎越好。例如考虑(2,1)类卷积码。
我们在10.3节看到卷积码的性能可以由它的自由距离dy来衡量：一般来讲，dj越大，码的性
能越好 在习题10.16中进一步证明了一个(2,1)码的dj≤M[1+o(1)],如果假设这个码的自由
距离为30,它的M值将会很大.使得 Viterbi译码变得非常复杂。因此我们希望找到一种译码算法，
它适用于M取值很大的卷积码。有一类这样的算法，我们称之为序列译码算法。对于某个确定的
码而言，序列译码算法的性能可能不如最大似然泽码算法，但是由于它们适用于某些M取值很大的
卷积码的译码，在很大程度上弥补了这个缺点。
理解序列译码算法的关键是树图。在-个(n,1)卷积码的移位寄存编码器中，编码器输
入一个信息比特将产生并输出 n个编码比特(参见图10.3)。因此可以将编码过程形象地理
解为在二进制树上的漫游，如图10.19所示。
编码器从起始节点出发，输人d个信息比特后，它将到达深度为d的某个节点。如果下
一·个输入为“0”,它将沿着上行支路到达第d+1级深度。如果下一个输人为“1”,它将沿着下
行支路到达第d+1级深度。例如，如果输入为0100…,编码器的路径将如图10.19所示。一
般情况下，当编码器在树图上漫游时，树图上的各个支路都以编码器的n个输出比特标注，虽
然图10.19中并没有这样做。
0
010 1100
0
01
开始
1
深度01 2 34 5
图10.19 一个(n,1)卷积码的二进制树
:益具品
第10章 卷 积 码 233
图10.19中的码树显然可以延伸到无限深度，但是对于任何具体可实现的码而言，码树应
该是有限的。如果码的截断长度是L,码树将在第L+M级深度终止；由于编码器的最后M
个输入比特均为"0",因此从第L-1级深度开始码树就不再有分支。图10.20画出了截断长
度L=3时卷积码-1的码树，其中对各个支路做了具体标注。
00 00 00
C
00 11 01 Ⅱ
D
1E .11 00
00
B
10 10 I1
开始
Ⅱ .00 00
II 0L 00 01 11
A
10 10 11 00
01 10 11
0 —2 13 I
4 15
图10.20 胾断长度L=3时，卷积码-1的二进制码树
按照这种新的观点米看，每个传输序列在码树上都对应着从起始节点出发在第L+M级
深度结束的一条路径。接收序列是这条路径的噪声样本，译码器的任务就是找出编码器实际
选择的路径，因为共有z1条可能的路径，如果L的值很大，一般不可能将接收信息与这些路
径一条一条进行比较。针对这个问题，序列译码算法采取的措施是只研究这些可能路径的一
个很小子集。如果在一定程度上，某条被探询的路径有可能是正确路径，那么就对它做进一步
探询；否则，就这即舍弃并探询另一条路径。
我们下而将要介绍两种最著名的序列译码算法，堆栈算法和Fano算法。为了描述这些算
法，下面从一个“精心构思的实验”开始.
例10.9 假设利用困10.20所示的码树对卷积码-1进行译码，y=(yi,y?,…,yn)是接收序
列。进一步假设采用序列译码算法《没有说明具体算法)探询了四条路径，它们分别在节
点A,B,C,D处结束。注意到无论编码器实际选择的是哪一条路径，它都必然经过这4
个节点中的惟一一个节点。译码算法的下一步，是进一步探询这4条路径中最有可能的
路径、但是哪一条路径最有可能呢?为回答这个问题，先简单考虑一下码字长度各不相
同的码的译码问题。
设|xn,x?,…,x-!是一个包含M个不同码字的码、设x的长度为n,即x,=(x,,x2,…,
xm),并设n=max n。假设该码在 DMC中按照下述方式传输信息。传输码字x,的概率
为p∑p,=1。当传输完x,的n个分量后，再传输一个由n-n,个信道输入符号组
成的“随机收尾”,这些附加的符号是从信道输入符号集A?中独立选取的，服从一个确
定的概率分布p(x)。因此接收端将总是接收到一个码长为n的码字y=(yi,y?,…,
,排
234 信息论与编码理论(第二版)
v),尽管原来的码宇具有不同的码长。
在这种假设下，如果接收到y,译码器选择码宇x?,使得条件概率P|发送x?I接收到yl最
大，就会使译码错误概率最小(参照习题2.13a)。但是因为y是确定的，且P|x;ly}=
Pix,,yl/Plyi,所以这等价于使Pix,,yi =Pis,|P(ylx?)最大，而Pix.y|可以由下式
计算得到：
P发送，接收y}=pIpys)pw) (10.19)
其中P:=Pi发送x,hp(ylx)是信道的转移概率，而信道输出符号集Ar的概率分布p(y)
可以由控制随机收尾的概率分布p(x)推导出。回顾我们的目标是我出使式(10.19)的值
最大的i∈l0,1,…,M-1。为此可以将式(10.19)除以一个正值的常数，然后取对数，再
求最终表达式的最大值，我们称之为测度：
L)--司 (10.20)
综上所述，如果接收到y,译码器判断发送码字的最好方法是计算μ(x.),其中i=0,
1.…,M-1;测度最大的码字就是最有可能被发送的码宇。
现在回到例10.9;我们的问题是在接收矢量y=(y,yz,…,y)的基础上，判断A,B,C,
D中哪一个节点是编码器最有可能经过的。如果编码器经过的是A,则最开始传输的两
个符号必然是11;在“0”和“1”是等概输入的情况下，此事件发生的先验概率是1/2。同样，
如果编码器经过的是B,最开始传输的四个符号是0011,此事件发生的先验概率是1/4。
用同样的方法计算得到下表：
节点 码字 概率
A 1 12
B 0011 1/4
C o00000 1/8
D 000011 1/8
此时与导出式(10.20)的情况几乎完全相同：要根据接收到的受嗓声干扰的序列，在具有
不同长度和不同先验传输概率的码字中选择合适的一个。用于推导式(10.20)的模型和
现在情况的惟一区别仅仅在于“随机收尾”的选取：前面我们假设收尾符号是根据一个确
定的概率分布随机选取的，但是现在的收尾符号是由编码器经过被检测节点的路径决定
的、如果不对码树做进一步探测，最好假设接下来传输的符号是随机选取的。而对于任
意确定的卷积码，不难证明它的第j个传输符号取“0”和取“I”的概率相等(见习题10.22),
可见控制“收尾”符号的概率分布的最佳选择是p(0)=p(1)=1/2。
因此为了在四条路径A,B,C、D中做出选择、需要利用式(10.20)计算四个相应的测度
值。在计算过程中注意一个很重要的简化：n?"log p.项恒等于1/2。这当然不是偶然
的：对于一般的(n,1)卷积码而言，码树上深度为d≤L-1的一条路径对应一个长度为
第10章 卷 积 码 235
nd的码字，其先验传输概率为2??,因此式(10.20)中的n?'log p'项恒为1/n,即该码的
速率R[对于一般的(n,k)卷积码，此项也等于R;见习题10.20Lb]。因此用于评估码树上
路径的相应测度(命名为Fano测度以纪念它的发明者)是：
c()=2-R (10.21)
综上所述：给定{x,X?,…表示码树上具有如下性质的路径集合：码树上任意一条路径都
恰好是集合中某条路径的延仲，则Fano测度μ(x:)最大的那条路径最有可能是正确路
径。「注释：在式(10.21)中，我们假设信道是DMC——参见习题10.21——而p(ylx)是信道
的转移概率。另外，信道输出字将集Aγ的概率分布p(y)可以由信道输入字符集A=
10,1的概率分布(1/2,I/2)推导出。对于任意y∈Ay,有p(y)=[p(yl0)+p(yl1)]。]
上：面的讨论让我们很自然地得到了一种最简单的序列译码算法，堆栈算法。堆栈["译码
器将码树上有限的路径集合S=1x,x?,…按照 Fano测度μ(x)≥μ(x?)≥…进行排序。
最佳路径x排在堆栈的顶端，次最佳路径排在第二位，以此类推初始化时，S中只包括起点
和终点都在起始节点的长度为0的平凡路径；它的测度定义为0。在每一步译码中，堆栈顶端
的路径x被删除，而代之以x,的可能延伸路径，它比x?多一个支路的长度。(如果x延伸到
或者超出L深度，则只存在一条可能的延伸路径；参见图 L0.20。)利用式(10.21)计算这些新路径
的测度，并将它们插到堆栈中合适的位置：注意计算新路径的测度时，只需计算求和式(10.21)
中的最后n项，因为其余项的和就是已知的μr(x?)。译码器的判决结果为第一个到达堆栈顶
端的满径(即长度为L+M的路径):
例10.10 考虑困10.21中的码树围，它对应L=2,M=2的卷积码。这里为了讨论方便，我们
直接在各条路径的端节点上方标注了其Fano 测度：当然在实际应用中，需要利用
式(10.21),根据码树图上的支路标注和接收序列y=(yi,y?,…)来计算测度。例如，路径
ABE的测度为-2。堆栈算法的执行过程如下表所示；每个堆栈中存储的路径用它们的
端节点表示，相应的测度标注在括号中
堆栈共 I 2 3 4 S 6 7 8
Ag0} 8l)
C(2)
I)
E1-2]
C(-2)
E(-2)、
C-2Y
H( 3)-
C{2)
A3)、
H-31
1(-1)-
Y3}-
H-3)-
H-3)-
A(0)-
G(-3)-
(3)
-H(-3)-
-G(-3) 堆找
内容 (-3)
H(-3)
例如，堆栈6是将堆栈5中的C删除，并以F和G代替而得到的。由于F的测度(-1)比
6,/或H的都大，它被排到了堆栈顶端。译码器最后的判决结果是节点K;相应的信息
比特是10,但是注意K并不是测度值最大的终端节点；L才是。因为1,的前一个节点G
的测度值太小，所以堆栈译码器并不能到达L。有关堆栈算法路径选择的简单介绍参见
习题10.23。
、;雄：
236 信怠论与编码理论(第二版)
1 3
D -1
-2 A 3
0 F
4 9 !
2 J K F
C ! 3 2
G L
图10.21 一个用于序列译码的L=2.M=2码树
堆栈算法是一种利用树图寻找可能路径的相当有效的方法，但是它也存在一个缺点：由于
在译码的每一步，译码器都必须记录下一系列迄今为止访问过的所有路径，因而需要的存储量
非常大并且是变化的。Fano算法是另一种序列译码算法，它几乎总是能够找到与堆栈算法相
同的路径.而占用的存储量却很小。
Fanu)算法的基本思路是这样的。在译码的每一步，译码器停留在码树上的某个节点。译
码器由这个节点往前看(即往码树上深度更高的方向看)。如果它找到一个可能的节点，就向
前移到那个节点上。否则，就返以并设法沿着另一个分支移动。它通过将某个节点的测度[利用
式(10.21)计算]与一个活动门限T进行比较，来判断是否选择该节点。当泽码器到达一个终端节点
(即深度为L+M的节点)时就停止工作，井根据在这个节点结束的支路输出相应的信息序列，
Fano 算法的具体流程图如图10.22所示。下边是对该流程图的一些说明：
1.译码器从起始节点开始工作，此时的T=0.
2.在算法的实现过程中，门限T的数值按照△的整数倍数不断变化，其中，△是事先选定
的常数 但是，T始终要≤当前节点的测度
3.F.表示沿着码树前进(沿着增加深度的方向);B.表示后退。“向前看”是指计算码树
上前面--个支路节点的测度值，“向前移”是指译码器移到前面一个支路的节点上。“向后看”
和“向后移”的含义类似。如果算法从起始节点“向后看”,就假设其测度为μ→-∞,这样可以
避免从起始节点往后退
4.v.表示节点、对一个给定的V.,最佳V.表示沿码树具有最大测度的前面一个支路的
节点；最差V.代表具有最小测度的前面一个支路的节点。
5.在一个给定的节点，如果T值增加△后比该节点的测度大，则称门限T是紧密的。紧
缩门限是指按步长△增大门限值，直至门限是紧密的。只有在向前移动后才会问“T是否紧
密”,它涉及到移动前事件的状态。
6.“是否结束”是查询当前节点是否就是终端节点；如果是，算法结束。
例10.11 利用图10.21所示码树来描述 Fano算法，(本例题中假设△=1。)下表是对算法实
现过程的一个总结，表中列出了所有访问过的节点和门限值的变化，以及发生变化时在流
程图中的相应位置(参见图10.22中的标注1,2,3,4,5)。
步数 节点 T 位 步 数 节点 r 位置
1 A 0 1 11 E -2 2
2 A -1 4 12 B -2 5
3 B -1 2 13 A -2 5
第10章 卷 积 码 237
(续表)
步数节点 T 位 置指 数 节 点 T 位置
4 D -1 2 14 C -3 2
5 B -1 5 15 F -2 2
6 4 -1 5 16 F -L 3
7 A -2 4 17 -1 2
8 B -2 2 18 J 0 3
9 D -2 2 19 K 0 2
10 B -2 5 20 停止
建议读者按照表格中的每一步完成译码过程。这里选择其中三个特别重要的变化过
程进行介绍：
1 开始
向前司找
最佳节点
H≥" 否
是
2
向前移动
结束? 足
否
否 厂足否紧密?
向前导找
下一个最佳节点
停小
否
是
向后看 是 来自
最养节点?
3
紧缩/
r-1 否 是 μ7?
4
向后移动
5
图10.22 Fano序列译码算法的流程图
238 信息论与编码理论(第二版)
6→7:在第6步，译码器刚从节点乃向后退至节点A处，此时T=-1。问题“是否来自最
坏的节点”的答案是“否”,因为相对于A来说，节点B是最佳节点：然后我们向前寻找到
下一个最佳节点C,其测度拉=-2。所以在问题“μT”处，选择分支“否”,并开始向后
观测；结果是μ=-(参见上文的说明3):这意味着在下一个"μ≥T"问题处，我们仍然
选择分支“否”,结果是将门限T降低到-2;这样就到达表中的第7步。
12-→13:在第12步，译码器刚从节点E向后退至节点B处，此时T=-2.问题“是否来自
最坏的节点”的答案为“是”,因为相对于节点B,节点E是最坏节点。向后观测到达节点
A处(μ=0),这意味着对问题“μT”的回答为“是”,因此译码器向后移至节点A处，到
达第13步。
15→16:在第15步，译码器刚从节点C向前移至节点F处，此时T=-2。因为F不是终
端节点，所以在问题“结束”处我们选择分支“否”。因为在上一节点C处，门限T=-2是
紧密的，所以问题“T是否紧密”的答案为“是”。这样T的值被紧缩到T=-1,就到达
第16步
注意在例10.11中，Fano 译码器得到的结果(节点K)和例10.10中采用堆栈算法得到的
结果完全相同：这不是偶然的；倘若适当地安排某些细节，Faro算法和堆栈算法实际上通常
能够得到相同的结果、此结论的证明参见习题10.25~习题10.31.
最后需要指出，当卷积码的存储量超过Viterbi算法的允许范制时，序列译码算法的性能
几乎与 Vitechi算法不相上下，但是序列译码算法在码树上完成一次搜寻所需要的计算量却是
非常不确定的，这公带米一定的问题，具体参见12.3节。
习题
10.1(木习题将介绍卷积码的一些高级代数特性，它们与多项式矩阵方法有关：为此需要
了解一些主理想环上模运算的理论；参考Lang[9]的第15章第2节.)设F为一个域，
Fxj表示在F上变望为x的多项式环。F[x}”表示所有n维F=(f?(x),…,J(x))的
集合，其中每个分量都是F[xi上的多项式。卷积码C定义为F[x]”的一个子集，它满
足：(a)对矢量的加法和减法运算是封闭的；(b)对乘数为F[x]中元素的乘法运算是封
闭的，即如果f=(Si,…f.)∈C,则对任意 a∈F[x],有af=(af.…,f)∈C。C的
一个基是集合!g,…,CF[x}",它满足每个f∈C都可以被惟··地表示为
f=∑a,g:,其中的a?,…,a∈r[x]。数值h称为码的维数(或秩)。
(a)证明：每个卷积码 C都具有这样的一个基，并且C的每个基都包含相同数目的元
素；同时，请找出Fx]"自身的一个基。
(b)证明当且仅当矩阵G的行g,…,g构成该码的一个基时，式(10.4)所描述的编码
∑..a,g,=0就意 才是一一对应的。并证明这等价于g,…,g,是线性独立的，即
味着a?=…=ax=0。证明矩阵：=
城
第10章 卷 积 码 239
不满足这个条件，并找出该码的一个满足上述条件的两行生成矩阵。(注：在这一
间及本习题的后续问题中，F=F?)
(c)设C是-一个维数为A的卷积码。证明存在C的-个基1g,…,B,F[xJ"的一个
基脚，…,f1,以及首项系数为一的多项式a,…,a(对i=1,2,…,k-1,满足tI
1),使得g=a,f,.其中i=1,2.…,k。多项式a,是惟一的，被称为该码的不变
因子.试找出卷积码-1、卷积码-2以及多项式生成矩阵为G=(x+1,x2+1)的
(2.1)卷积码的这样的基。
(d)定义F[x]"上两个元素之间的点乘运算为f·g= ∑"f.g,∈Fix]。证明当且仅
当f=0时，对于所有gE F[x!",有f·g=0。
(e)如果if,…,fi是F[x]"的-个基，其对偶基P,…,f满足当i≠j时，t,f=0;
当i=j时，f·;=1。证明这样的对偶基存在并且是惟一的。
(1)如果C是一个卷积码，其对偶码C-定义为C-={h∈Fx]":h·g=0.对于任意
g∈C。采用与(c),(d),(e)问中一致的符号，试证明1f+,…,fa|构成了C-的一
个基。因此C的维数是n-k。试分别找出(e)中三种卷积码的对偶码。
(g)设C是一个卷积码，其多项式生成矩阵为kxn阶矩阵G。如果存在一个kxn阶
多项式矩阵H满足GH3=I,其中I是k×k阶单位矩阵，我们称C是可转置的。
试证明当且仅当不变因子式a,,…,o[参见(:)都等于1时，C才是可转置的。明
确写出本章中卷积码-1和卷积码-2的转置。
(h)更一般地，如果GH'=州，则矩阵H称为G的ψ(x)转置。证明当且仪当1ψ时，
G存在一个ψ(x)转置.写出G=[x+1,x2+1]的ψ(x)转置，其中ψ(x)=x+1a
10.2 我们在前面提到，一个(n,k)分组码可以看做一个M=0的(n,k)卷积码。从这个观点
出发，L级截断的分组码可以看做什么?
10.3 在卷积码的状态图上，两个状态之间可能有不止一条支路相连。试解释什么情况下会
出现这种可能?
10.4 考虑一个确定的(n,1)卷积码，其截断长度为L。试证明采用原始的“将接收序列与2
个可能码字进行比较”的译码算法所需要的计算量，是采用 Viterbi译码算法所需要计
算量的21-“倍、[这里K=码的约束长度；参见式(10.2)。]
10.5 在正文中只介绍了k=1情况下的Vitccbi 译码算法。试推广到一般的k。(注意状态之
问的多条支路(参见习题10.3);并且确认你的算法适用于分组码，因为它们是M=0的
卷积码-)
10.6 设C是一个M=1的(3,2)卷积码，其生成矩阵如下：
c=['*x'*]
(a)设计它的译码电路(参照图10.3和图10.4)。
(h)画出它的状态图(参照图10.5)。
(c)假设在二进制对称信道上使用该码，且截断长度L=6,利用Viterti算法对接收到
的序列011 011111 100 101001 101进行译码。
10.7 考虑对高斯信道使用Vierbi算法(参照第4章)。证明标注Lj-1,(s,t)的一个合适定
·效
240 信息论与编码理论(第二版)
义为：
I-1,(s,1=liy-x12
其中x是状态图上对应于s→t转移的n维传输矢量，而y是相应的n维接收矢量。
[注意，|zll2=∑"22是z=(z?,…,z)的欧几里得范数。]
10.8 参考图10.5所示的状态图，设B;表示从α到a且不经过a处自环(但是中间可以返回
到a)的重量为i的路径总数。试给出计算 B,的通用公式。
10.9 考虑如下带标注的方向图：
A
B_
C
b
万
支路标注用A,B,C,D表示，试计算从节点a到节点b的传输量。(有关定义参考附
录D。)
10.10计算卷积码-2的路径枚举多项式A(x)以及完全路径枚举多项式A(x,y,z)。
10.11设C是一个M=2的《3,1)卷积码，其生成矩阵为(x2+1,x2+x+1,x2+x+1)。计算
C的A(x)和A(x,y,z)。现在假设该码用于如下所示二进制删除信道：
0.99 0 0
001
? 001
0.99 1 1·
试给出起始点错误概率P.的上界，错误事件概率Pe的上界，以及比特错误概率P,
的上界，
10.12 考虑将·…个二进制(n,h)卷积码应用于一个确定的二输人离散无记忆信道，该信道是
有噪声干扰的，即其信道容量小于log2。令p(表示对该码的一个L级截断的码字进
行译码时，至少出现一次错误的概率。证明 lim?pl)=1。
10.13证明式(10.18)给出的P.的界是正确的。[建议：先证明k=]时的情况。]
10.14将10.3节中给出的界[式(10.15)、式(10.17),以及式(10.18)]推广到高斯信道。[提
示：界的形式应该是相同的，但是γ将等于e-z。见习题7.20。]
10.15 证明对于一个自由距离为d,的卷积码，当γ的值很小时，错误事件概率满足P=ayr+
0(y+'),并确定常数a的值。对Pg,和P.推导类似的结果(参照例10.8)。
10.16将Ploikin界(习题7.24)应用于一个L级截断的(n,k)卷积码，证明其白由距离d,满
足：
d(mM+L)2
t…171………
第10章 卷 积 码 241
10.17本习题涉及到卷积码状态图的·种特定算法。算法输出一个非负整数；希望你能指出
它的含义。假设当图中各状态之间发生转移时，相应的连接支路上将标注此时编码器
输出的“I”的数目。例如卷积码-1的状态图如下图所示(对比图10.5):
0
a
00)
2 2
!
占 01 10 c
0
I 1
11
d
一些符号的含义为：(1)V表示所有状态的集合；(2)L(n?,t)表示连接状态v到z,的支
路上的标注；(3)从状态v出发经过一步就能够到达的状态集称为v的后继——例如上
面状态图中状态d的后继为d,bl;(4)vo表示全零状态。现在介绍该算法(它包括一
个辅助函数d(v),其中v∈V,以及V的一个子集S):
算法X:
1.对于所有t∈V,令d()=+:令S①,即为空集：
2.对t的所有后继 v,除了o以外，令d(v)+1(a,)。
3.对z∈F-S,选择具有最小d(;)的v.如果r=to,输出d(m)并终止算法、
4.将：加人到S中，对状态：的所有不在S中的后维x',令d(v')+mn(d/),d(r)+Iu,')。回到第3步
现在的问题是：
(a)算法X的作用是仆么?
(b)对具有下列多项式生成矩阵的卷积码应用算法X:
[x3+x2+1,x3+x2+x+1].[Lx3+x+1.x3+x2+1,x3+x2+x41
['+1+x*
下面的两道习题涉及到错误地选择了卷积码类型时所面临的一个严重问题，灾难性错误
的传播。在习题10.18中，我们通过一个具体的例子，说明这个问题的危害。在习题10.19
中，给出了灾难性卷积码的儿个等价定义。为方便起见，在这两道习题中都假设码是截断码，
即输入和输出序列都是有限的。
10.18 考虑一个M=2的(2,1)卷积码，其多项式生成矩阵为G=[x+1,x2+1],
(a)画出它的状态图。
(b)尝试计算它的路径枚举多项式A(x)。并说明为什么这种尝试会失败。
·4 如趣。
242 信息论与编码理论(第二版)
(c)假设该码被用在二进制对称信道上，信道的原始误比特率为0<p<1/2.假设输人
流为0000000…,产生的传输流为00 00 00-00…。进一步假设接收流为1100.00 00…。
利用Viterbi算法对其进行译码。你会对结果感到惊讶吗?
(d)设(I,I?.…)为输入流，而(11.?,…)为Viterbi译码器对输人流的估计。再次假
设采用的是二进制对称信道，试证明lim,PlI,=L:=2。。[提示：利用(c)的结
果，并注意观察最后必然会出现两个连续错误比特。]
10.19在习题10.18中，我们已经看到对于某种码型，有限个信道错误可能会造成无限个译码
错误。能够产生这种效应的码称为灾难码。在本习题中，将给出若干种等价条件，来
判断一种给定的码是否是灾难码。设C是一个(n,h)卷积码，其多项式生成矩阵为G,
试证明以下条件是等价的(同时注意观察，习题10.18中的码满足以下每一个条件):
(a)仔在一个输人流包含无限多个“1”,但是相应的输出流只包含有限多个“1”。
(b)存在k个有理函数I(x)=p,(x)/q;(x),其中j=1,2,…,k[没有一个y,(x)能够被
(x)整除j,因此矢生C=(C?(x),…,C.(x))=(I?(x),…,I?(x))·G具有多项式
分量
(c)在状态图上存在一条封闭的路径(除了在全零状态上的自环以外),其每条支路上
的标注均为00…0(支路杯注如图10.5所示):
(d)假设该码被用于二进制对称信道，其中0<p<1/2,则存在一个包含有限个信道错
误的图案，它能造成无限个译码错误。[提示：令信道错误图案为(b)中的矢量C.]
(e)该码的第无个不变因子a不是x的幂(参照习题10.1c)。[注意：根据主理想定义
域上模运算的理论，这等价于断言，G的k×k阶子行列式的最大公约式不是x的
幂。特别地，如果像习题10.18中那样 k=1,这个条件意味着G=(g?(x),…,g。(x))
的n个多项式的最大公约式不是x的幂。]
10.20(a)·-般(n,k)卷积码的树图与k=1卷积码的树图(图10.19)有什么不同?
(b)证明式(10.20)中的I/n log 1/p,项等价于一个(n,k)卷积码的k/n。
10.21 如何定义高斯信道的Fano测度.参照式(10.21)]?
10.22 考虑一个周定卷积码C的固定截断。如果它的多项式生成矩阵不存在全0列，试证明
码字(x?,x?,…,Xnc+))中恰好有一半的x,=0,一半的x,=1。
10.23 在本习题中，我们将给出码树上堆栈算法所选择路径的特征描述(或者更确切地说，是
未选择路径的特征描述)。假设研究的树图如图10.20所示，对每个节点v都有一个测
度μ(n)。进一步假设利用前面所描述的堆栈算法来选择码树上的路径。设P和P是
码树上的两条路径，它们在深度为d时分叉：
V
P
F的 F-
"
P
Vr
第10章 卷 积 码 243
试证明如果miniμ(va.1),…,μ(v.w)}>min!μ(vd),…,μ(V'L),则P不可能是
堆栈算法选择的路径。(参见习题10.30,它对Fano算法选择的路径进行了类似描述。)
10.24 按如下方式对图10.21所示的码树分配新的测度：(a)长度为4的路径具有最大测度，
(b)用堆栈算法选择的路径和(c)用Fano算法选择的路径不同。
在下面的7道习题中，将介绍Fano算法(图10.22)的几个最重要的性质。特别地，我们将
得到Famo算法所选路径的一种描述(习题10.30),结合习题10.23可以证明，堆栈算法和 Fano
算法选择的路径实际上通常是相同的。这里假设译码器工作过程可以用序列(v,T?),(v?,
T?),…来描述，其中v.表示节点，T,表示访问时的门限值。节点》的测度用p(v)表示；我
们假设测度已经经过舍人处理，它们都是数值△的倍数。如果两个节点v和v'在码树的同一
路径上，并且v的深度比v大，就称v是b的一个后继，0是v的一个前趋。如果v的深度只
比v的大1,也将它称为v的直接后继。
10.25 假设 Famo算法运行到某一步时，产生了序列(v,T),(v,T?),…,(p。,T),其中v,是
v的一个后继，而v=v,但是对于i=1,2,…,n-1,v≠v。试证明T=T。
10.26假设v?是v的前趋，其余假设同习题10.25。试证明T,=T-△。
10.27 说明第一次到达任何节点(除了起始节点)时，门限在下一个“向前看“之前是紧密的，
即门限T将等于该节点的测度。
10.28说明门限为T时从节点v"向前看"失败后(也就是说，问题“μ≥T”的答案为否),从D
向前的每条路径都必然包含一个测度<T的节点。
10.29 如果Fano算法在(v,T)处，试说明从n的每个前趋向前的每条路径都必然包含一个节
点，其测度≤T。作为推论，说明v的直接后继，只要其测度>T,就必然巳经被游历
过了。
10.30 参考习题10,23的示意图，说明如果minlμ(va),μ(va+),…,μ(?,w)i>minlμ(ea)、
μ(v't+1),…,μ(vm),则Famo算法不会选择P。
10.31 习题10.30的结果说明，给定任意两条路径P和P',Famo算法将舍弃其中的一条。但
是可以想像，如果算法陷入了死循环中，它将不能选择任何路径。试说明这种情况是
不可能出现的。[提示：利用习题10.26的结果。]
10.32 考虑在一个二进制删除信道中使用卷积码-1,信道的刷除概率为e:
0
I-E 0
E
?
E
1-E 1
试对下列接收序列进行译码：??????11000000…(你可以假设其后所有的接收比特都
为0),利用(a)Vilebi算法，(b)一种序列译码算法(如果你利用的是Famo算法，取△=
1/2)。比较出现突发错误时这两种算法的性能，会得出仆么结论?
7……jnt …nn j ……p ………-…………74……………………7
.i□
244 信息论与编码理论(第二版)
注释
[1}在这里用卷积这个术语是合适的。如果|a。}和|b,是两个序列，它们的卷积是序列
c1,其定义为：
(i)ca=∑a,b
现在如果定义生成函数a(x)=2.aa",b(x)=∑bx°,等等，则(i)式变为：
(ii)c(x)=a(x)b(x)
因此生成函数的乘积对应着序列的卷积。在这里，被编码的数据用生成函数来表
示，而编码过程「见式(10.4)]就是将这些生成函数乘以一类特定的多项式。
2]至少还有一种重要的方法，即线性时序电路方法，这里未做介绍(参考文献[15],205~
232页)。
[3] 我们将第7章至第9章的线性码称为线性分组码，以区别于本章的线性卷积码。这
个术语基于如下事实：分组码将数据编码成长度为 n的独立分组，但是在卷积码
中，大小为n的相邻分组之间是相互关联的。见第7章注释2。
14]其他作者对约束长度有不同的定义。Fomey[ 15,213~232页]定义第i个输人的约
束长度为v=nax,[deg(g,)],而总的约束长度为v= ∑。Massey[21]定义约束
长度为(M+1)n,我们的定义与Vierbi和Omura[26]的相同。
[5]实用编码器的一个重要组成部分，即多路开关，在图10.3中并未标出，它的作用是
交替地从C和C,中选择比特输出到信道中。
[6]网格图是为了便于概念上的理解，在Viterbi 编码器的实际应用中并不是必需的。可
以简单地利用状态图作为算法实现的动态模型。
[7] 示意图通常称为de Bruijn图，以纪念当代荷兰数学家N.G.de Brvijn,他研究了该表
示方法的许多特性。
[8] 其他作者将这个生成函数称为码的传输增益或者传输函数。
[9] 由于码是线性的，我们将要计算的错误概率的各种界是与假设的传输路径无关的。
(见定理7.5证明中的最后两句话。)
[10]本节内容的安排是与历史上发现的顺序完全相反的，历史上发现的顺序如下：Fano
算法(1963年),堆栈算法(1969年),Fano测度的解析认证(1972年)。这里的安排借
鉴了Massey[21}。
[11]实际上，将“堆栈”理解为“优先级排队”更为恰当，这是由 Aho,Hopcroft,以及 Uillman
[1]定义的一种数据结构。
:楼：L :宏、;
第11章 变长信源编码[1
11.1 引言
考虑一个离散无记忆信源，其统计概率为p=(po,p?,…·p?-),即一系列独立、同分布的
随机变量U,,U?,…具有相同的概率分布P{U=il=p,,i=0,1,…,-1。根据第3章的结
论，无失真地表示这个信源原则上需要平均H?(p)=-∑P logp.比特每信源符号2。本
章中.我们将介绍一种称为变长信源编码的设计方法。
为了能了解一般概念(这里需要提醒读者注意，下面的例子不具有实际价值),考虑特殊的
信源p=(立，4,喜，宫),它的嫡为H?(立，本官，g)=1.75比特。信源符号集Ap=10,1,2,3|:
现在根据表11.1,对信源序列U,、U?,…进行编码。例如，信源序列03220100…编码为
+ OI111011001000…。显然采用这种编码方法，表示每个信源符号平均需要的比特数为-
4·2+3+3=1.75,等于信源的熵。这个结论本身并不令人惊讶，因为可以将每个信源
符号都编码为0,从而使平均值降为1比特每符号。表11.1中编码的重要特点是它的惟一可
译性，即根据编码流可以完全恢复信源序列。例如，比特流1001011100010110…仅对应信源序
列101300012…。(可以通过儿种方法来证明这种特殊的编码是惟一可译码，例如通过观察发
现，没有哪个码字是任意其他码字的前缀。)因此表11.1中的编码确实仅需要平均1.75比特
量·4,8,8)。 每符号，就能无失真地表示信源(·
表11.1 信源[-2,4,8·g))的一个变长编码
恼潭符号 概 率 码 字
0 立 0
1 4 10
2 110
3 京 111
在本章的剩余部分，我们将上述例子推广到任意离散无记忆信源(DMS),利用任意(不只
是二进制的)字符对其进行无失真编码。11.2节研究惟…可译码的纯组合问题。11.3节讨论
信源的匹配编码问题。11.4节介绍设计信源最佳变长码的著名 Hufman算法。
246 信息论与编码理论(第二版)
11.2 惟一可译的变长编码
设S是一个包含s个元素的有限集合.一般定义S={0,1,…,s-1:S上长度为k的宇
符串是一个由S中k个元茶sls?…s。组成的有序序列。空字符串不包含任何字符，用中表示
如果α=sjs?…s,和r=1,…t,是字符半，则它们的级联σ*r是字符串s1s?…L?…t,.如
果σ=a,*d?*a?.则o,称为σ的前缀，a?称为σ的子半，而a?称为c的后缀。因而空字符
串φ是任意字符串的前缀、后缀和子串、字符串r的长度用1a1表示。由此可知，对于任意-一
对宇符串σ和t,lo*Tl=lal+Izl均成立。
S.上的(变长)码是S七字符串的一个有限集合。组成码C的字符申称为C的码字。
设C,和C?是两个码，它们的乘积表示为C?*C?,由形式为o*o?的所有字符串组成，其中
d?∈C?.o?∈C?.-个码木身的下次乘积用C表示，即C=C*C*…*C(共k个因子)。
如果C中的每一个字符串仅由一种码字级联方式产生，则称码C为惟一可译码(UD),
这意味若，如果r?*T?#…*=0?÷a?*…*a,且每个r和σ都是一个码字，则t=a,
T?=d?,…,t=d。因而C中的每个字符串都只能惟-地分解为一种码字级联方式。(习题11.1
介绍了惟…-可译码的一个等价定义。)
例11.1 设s=2,考虑码C?=50,10,110,111}和C?=10,10,100,101{.C?是惟一可译码(事
实上它也是一个异前缀码，见下面的定义),但C?不是惟一可译码：例如，在C?中
10*101#0=101*0*10,所以字符串101010不能被C?惟一译码：
有一类特殊的称为异前缀码的惟--可泽码能够满足我们的要求：如果码中没有哪个码
字是任意其他码字的前缀，则称码C为异前缀码、异前缀码必然是惟一可译码
(见习题11.3),但反过来不一定成立。例如10,011是惟一可详码.尽管0是011的前缀。
例11.1中的码C是异前缀码，但C?不是惟一可译码，故也不是异前缀码。
本节中将要提出和解决的问题是：给定一组包括，个非负整数的(no,n,…,n,_,),是否
存在S上的惟一可译码|on,o,,…,a,_,满足laI=n,,i=0.1,…,r-1?对这个问题的回答
是肯定的，条件是当且仅当
≤1 (11.1)
这个重要的不等式称为Kraft-McMilam(KM)不等式。在定理11.1中将证明，如果不满足KM
不等式，就不存在这样的惟一可译码。在定理11.2中我们将证明相反的结论，即如果满足KM
不等式，则不仅存在惟一可译码而且存在异前缀码，其码长为n,n1,….n,1:正是由于这两
个结论，我们一般很少考虑非异前缀的惟一可译码；异前缀码很容易实现(见习题11.3),并且
对应一个确定的长度集合，如果存在惟一可译码，则必然存在异前缀码。
定理11.1(MeMillan)如果C=lo?.a?,…,a,是S=10.1,….s-1i上的一个惟一可
译码，并且n,=lo,1,则∑≤1。
证明：设k是一个正整数，则由于C是惟一可译码，
…………………………
第11章 变长信源编码 247
)=(-2-三kus
其中n是n的最小值，A是n的最大值，而K?是C中长度L的字符串c,*o,*…
的数目 因为集合S有s个元素，所以K,,≤s.因此上式最终的求和≤kn,即
)'≤
对于所有的k值均成立：求这个不等式两边的k次方根，当k→时取极值，就得到
式(11.1).
例11.2 取s=3 因为≥3-°=28/27,故不存在长度为(1,2,2,2,2,2,3,3,3,3)的惟一可译
码..直接证明这个结论并不容易
定理11.2(krafi)如果s-"≤1.则存在一个长度为 n的异前缎码。
证明：我们对n,重新排序，使ng≤n≤…≤n,-:定义整数 v,(j=0,1,…,-1)为wo=
0,x,=二s)(当j≥1时)因为∑s-"≤1,故对于所有的j,不等式u,≤-1
均成立。现在定义字符串a,是整数w,的s进制表示，并附加足够多的0字符位，使o;的长
度为a.我们断言ou.T,…,G-1是一个异前缀码。因为时于某个j<k,如果a,是r的
前缀，则可得n,=lmi/s?].但这与u/s-7=2=u,+Ls≥t切，+1
相互矛盾.由此定理得证!
例11.3 取s=3及长度(1,1,2,2,3,3,4,4,4)-则∑3-"=1.按照定理11.2的编码方式，
可以得到表11.2:注意，如果试图将这种方式应用于例11.2,将得到ry=27=1000,但是
H=3 失败的原因仅仅是不存在长度为3的字符串可以用来表示27!(习题11.6和
习题11.7介绍了定理11.2的另外一种更直接的表述形式。)
表11.2 定理11.2的一个应用
f
0 ! 0 0
1 1 1
2 2 6 20
3 2 7 21
4 3 24 220
5 3 25 221
6 4 78 2220
7 4 79 2221
8 4 80 2222
、:绿
……………
248 信息论与编码理论(第二版)
11.3 信源的匹配编码
现在我们已经了解了一些惟一可译码的纯组合性质，为了实现有效通信，准备对信源进行
匹配编码。
回顾一个给定信源符号集A=10,1.…,r-1的离散无记忆信源，可以完全由概率矢量
p=(po.p?·…,p._)确定。信源p的；进制编码被定义为A到S=10,1,….s-1上码|ao
i,…,σ,的一个映射 这表示如果希望在输人符号集为S的无噪信道上传输信源p的输
出，就需要将信源符号i映射为码字a并传输a、假设采用这个策略传输k个信源符号，比如
可以是i,i?,….,接收机将收到字符串c=o,*d?*…*a。而如果希望接收机能够从o
中恢复i,,i,…,i,就必须假定编码是惟一可译码。
对于信源p=(po,P,…,p,-1),码on,o?,…,a,-1的平均长度定义为n=2p.Ia1
它的实际意义是，如果k值足够大，则对信源的前k个符号进行5进制编码大约需要k·n位码
元(即来自S中的元素)。可见n是采用这种编码后，信道王平均负载的一个度量。定理11.3
(实际上是由本书第一部分内容得出的)给出了n的一个令入感兴趣的下界，我们假定n.表示
C中第；个码字的长度，即 n,=lo,I。
定理11.3 如果码C是惟一可译码，它的平均长度必然超过：进制的信源熵，即，
”≥BL(P)=-nloe.n
证明：
H,p)-n=2nlo-二pm
-plog
≤1
最后一步利用Jensen不等式(见附录B)。而根据定理11.1,∑5≤1,因此H,(p)-n≤0.
现在用n.(p)表水。进制惟一可译码可能的最小平均码长。定理11.3表明n,(p)≥H,(p)。
实际上证明过程说明，当且仅当每个p,是：的负整数次幂时(习题11.8),n,(p)=H,(p)成立。
4京，8)为什么会有完美的二进制编码。当然，通 这个结论解释了11.1节讨论的信源(
常不能期望会如此幸运，因而很自然想知道 n.(p)的实际值。精确的计算留到11.4节，但下面
的估计是非常有用的。
生
的t
第11章 变长信源编码 249
定理11.4
H?(p)ns(p)<H?(p)+1
[注：在此重述定理11.3的下界是考虑到论述的完整性_]
证明：定义n,=[log,p-'7,i=0,1,…,r-1。则s?i≤p?,故∑s-"≤1。因此根据定
理J1.2,存在长度为no,n,…,n,,的惟一可译码。该码的平均长度是∑P;n;,但因为
n,<log,p1+1,故这个和式<∑p,(log,p1+1)= H,(p)+1。
例11.4 设p=(0.1,0.4,0.5,),s=2。则H(p)=1.361。根据定理11.4的证明，n,应该等
于(4,2,1),得出平均码长为1.7。但是码长(2,2,1)也满足∑z-≤1,因此实际上
n,(p)≤1.5。注意一般情况下达不到定理11.4中的上界(见习题11.9),该界的优点在于
其通用性。正如前面所提到的，11.4节将给出构造特定信源最佳惟一可译码的方法。
这里我们有个问题：一方面第3章的结论告诉我们，对信源p进行无失真编码，平均来讲
每信源符号仪需要H,(p)个s进制码元来表示。另一方面刚刚乂看到，对应p的一个惟一可
译s进制码是不可能达到这个界的，因为n,(p)通常严格大于H(p),
这个问题的解决办法是考虑对扩展信源p”进行编码，m=1,2,…。信源p"定义为信源
字符集等于A”的信源(A是对应于p的信源字符集),这里给定信源符号(uy,H?,…,um)的概
率为PlU?=u?,…,Um=tm=P?,P.…P。实际上，当考虑信源p”时，我们将信源序列
u,,U2,…划分为出A中m个符号组成的连续分组，并将每个这样的分组看做是米自宇符集
A"中的单个符号：现在对应p"的一个平均码长为n,的惟一可译码，将平均需要 n个：进
制码元米表示A"中的一个符号。而A"中的一个符号代表原始信源中的m个符号，因此这个
码仅用n/m个s进制码元每信源符号，就能够无失真地表示原始信源p。下面的定理表明，
只要m取值足够大，就能够使无失真表示p所需要的平均码元数理想地趋近于H(p)a
定理11.5 lim'n,P")=H,p)
证明：容易证明H.(p")=mH,(p)(习题11.12)。因此根据定理11.4,mH,(p)≤n?(p")<
mH,(P)+1。该式除以m并取极限，就可以得到定理11.5的结论。
定理11.5理论上是成立的，因为它告诉我们采用(或许稍微多一些)H,(p)个s进制码元每
信源符号，确实能够无失真地表示信源p。但是因为它依赖于定理11.4的弱结构，从设计的角度
来看还遗留了一些闷题，在下一节中将对此加以弥补，介绍一种构造信源p”最佳码的方法。
11.4 最佳惟一可译码的构造(Huffman 算法)
根据定理11.4,n,(p)取值于H,(p)和H(p)+1之间，这个估计已经能够满足某些要求
(例如定理11.5的证明)。但是对于给定的s和p,我们自然想知道 n,(p)的确切值：本节中
就介绍一种由 David Hafinuan提出的算法，该算法不仅说明了如何计算 n,(p),而且给出了构造
-个平均码长为n,(p)的惟一可译码(实际上是一种异前缀码)的方法。
楼：,
250 信息论与编码理论(第二版)
在正式介绍 Hufiman 算法之前，先求解一道例题。在整个这一节中都称对应于p的平均
码长为n(p)的s进制惟一可译码为p的最佳编码。
例11.5 设s=4,p=(0.24,0.21,0.17,0.13,0.10,0.07,0.04,0.03,0.01)。Hffanan算法的第
一步是用更简单的概率天量p'代替p,p'是通过合并p中取值最小的三个概率而得到的。
因此元素采用降序重新排列后p'=(0.24,0.21,0.17,0.13,0.10,0.08,0.07)。因为p'仍
然很复杂，所以进一步合并p'中最小的四个概率而得到p"=(0.38,0.24,0.21,0.17)。
图11.1给出了化简过程的示意图。为什么从p到p合并3个概率，而从p'到p"却合并4
个概率?原因将随着算法的进一步介绍而给出，这里我们先接受它。
品121 0.17 2 021
0.17
013) 0.17 013 0.10 010
007 008 0041 007 003>
001
图H1.1 p的连续化简
现在可以清楚地看出应该如何构造p"的一个最佳码：码C={0,1,2,3得到n(p")=1。
从这个简单的码开始，现在可以通过一种简单的方法“扩展”码C",反推并构造出对应于
p'和p的最佳码C和C。
首先构造p'的最佳码。注意在从p'到p"的化简中，三个概率(即0.24,0.21,0.17)没有改
变，这种情况下，从C到C的扩展中相应的码字也不改变。但是p°中的概率0.38扩展
为p'中的四个概率(0.13,0.10,0.08,0.07)。此时的规则是C中对应于0.38的码字(0)
扩展为C'中的四个码宇(00,01,02,03)(见困11.2)。根据下面的定理11.7,得到的码是
p'的最佳码。
从C到C的构造过程与上面类似：除02外每个码字直接对应p中的一个概率，因此相应
的码字没有改变。但是02扩展为020,021,022(再次见图11.2)。于是综上所述，C=11,2,
3.00,01,03,020,021,022|是p的一个最佳码，且 n?(p)=1·(0.24+0.21+0.17)+2-
(0.13+0.10+0.07)+3-(0.04+0.03+0.01)=1.46。
。 ?i2 -i
2 1
2 3 自
图11.2 p最佳码的构造过程(参见图11.1)
山
第L1章 变长信源编码 251
前面的例题介绍了一般 Huifman算法的典型处理过程：p连续化简为p',p",等等，直到最
终的简化p恰好包含；个概率。对应p的最佳码显然就是10,1,…,s-11,然后将此码按
上述方法“扩展”,直到获得p的最佳码。这种算法中惟一令人费解的地方是，从p化简到p'l时
所合并的概率数目的计算。如果用s'表示这个数目，则s'可以由下面的两个条件惟一地确定：
s'∈{2,3,…,s} (11.2)
x'三r{mpds-1) (11.3)
例如(参见例11.5),当s=4,r=9时，我们得到s'=3、如果s=2,则对于所有的7≥2,都有
s'=2,因此二进制编码不需要考虑这种复杂情况3、如果s=3,则，为偶数时s'=2,r为奇数时
s'=3。注意p'中概率的数目是r=7-s+1,因此根据式(11.3)s'等于1(modx-1),可见经过
首次化简后s'就总是等于s,故不论p化简多少次，只需要利用式(11.2)和式(11.3)计算一次s'。
前面已经介绍了Huffnuan算法；现在一个非常棘手的任务是说明它的原理，也就是说，该
算法所产生的p的一个s进制异前缀码具有最小平均码长。下面的定理至关电要，它保证了
对应p总是存在一个异前缀码，其最后的s个码字等长，且这s个码字除了最后一位以外其
余的位均相同、
现在假设概率po,pi,…,n,-1按降序排列：pa≥P≥…≥P-1。考虑字符表10,t,…,s-I
上p的异前缀码，码字用co,o?,…,o,,表示，码长为n,=lal,i=0,1,…,r-1。
定理 11.6 如果r≥2,则存在p的一个最佳s进制异前缀码，具有如下两个性质：
(a)nn≤n≤…≤n,"
(b)最后的s'[见式(11.2)和式(11.3)]个码字除了最后一位以外其余的位均相同，即存
在一个长度为n,_1-1的字符串o,使得：
a,s'=G*0
0,-g'+!=0*1 ···
0r-1-0*(s'-1)
证明：给定p的一个码|oo.c,…,0,.1,显然如果i<j且o,I>Ia,1,交换d,和a,不会
增加平均长度∑p.lo,1。因此存在p的最佳s进制码，使性质(a)成立 在下面的证明
中，“最佳”码意味着具有最小平均码长且满足性质(a)的码
现在p可能存在几种完全不同的最佳码(见例11.6):我们在所有这些码中选择一种，使
∑n.尽可能小。根据定理11.1,有，
=△≥0 (11.4)
如果△≥s-1,长度(no,n,,…,n,-2,n,_-1)将满足 KM不等式，因此根据定理11.2,存
在相应长度的异前缓码。这个新构造的码必定也是最佳的(当然p,-1=0),但是这与假设
∑n,最小相矛盾。现在推断0≤A≤s-2,或者等价地，
s-△∈{2,3,…,s} (11.5)
252 信息论与编码理论(第二版)
下西设r表示码中码长为n,_1的码宇数量、如果r=1,则可以缩短惟一的最长码宇，即
删除它的最后一位，而不破坏异前缀条件，这样再一次产生矛质。可见，
2 (11.6)
如果对式(11.4)进行模s运算，会得到△=-r(mods),即r二8-△(mod s)。但由
式(11.5)和式(11.6)可以推出：
rzks+(8-△)对于某些k画0 (11.7)
如采对式(11.4)进行模x-1运算，会得到1-r△(mod s-1),即s-△=r(mod s-1)。
由这个全等式及式(11.5)可以推出s-△=s,其中s'由式(11.2)和式(11.3)定义。因此
根据式(11.7)可以推出r≥s',即至少存在s个最长码字。
下面注意如果σ'=g*a是Y个码长为n,_,的码宇中的一个，其中a是一个长度为n,-1-1
的字符串，而a∈0,1,…,s-1F,我们就可以用码中不首出现过的字符串s*0,a*1,…,
o*(s-1),替代不具有形式σ*a而长度为n,_的码宇。这不会破坏异前级条件，却因
此能获得一个最佳码，其码长为n,-1的码字中包含σ*0,o*1,…,*(s'-1)。最后，如
采必要可以重新排列最长的码宇，由此推断结论(b)成立。
在介绍重要结论之前，需要一个定义。如果po≥P?≥…≥p,-1,且r≥s,则p的s进制
Huffrnan化筒定义为：
p'=(p,pi…,Pr-s'-1,Pr-x+…+Pr-1)
即p'是通过合并p中最小的s'个概率而得到的，其中s由式(11.2)和式(11.3)确定。下面的
定理说明了如何利用p'的最佳码来构造p的最佳码。因为p'中的概率数目少于p.它给出了
构造p最佳码的一个递归过程。
定理11.7 如果C=ira.r?.…,t,x?,rl是p'的一个最佳码，则
C={,…,r-x-1,T*0,t*1,.…,T*(s'-1)} (11.8)
是p的一个最佳码。并有，
n?{p)=n?(p')+pr-r+…+Pr-1 (11.9)
证明：从证明式(1.9)开始。设(no,n?,…,n,,_,n)表示C中码字的长度。定义pono+…+
Prn,1+m=n.(p'),其中p=p-+…+p-1。如果C是p的一个码，它的平均长度为
n.(p')+p;因此，
n5(p)≤n?p')+p (11.10)
为了证明反向不等式，设|oo,aj.…,是p的一个满足定理11.6性质(a)和(b)的最佳
码：码|oo,…,0,-1-1,a|对应p',具有平均长度 n.(p)-p,即
n;(p')≤ne(p)-p (11.11)
联立式(11.10)和式(11.11),就得到式(11.9)。因此由式(11.8)定义的码C必然是最佳
的，它的平均码长为n(p')+p=n,(p)。
正如我们所希望的，定理11.7给出了构造任意信源p=(po,p.…,p.1)最佳s进制异前
清
第11章 变长信源编码 253
缀码的一个递归算法 可以归纳如下：如果7≤s,码|0,1,…,r-1|是p的最佳码，且 n,(p)=
1;如果r>s,则假设可以用少于，个符号构造任意信源的最佳码。因此将p化简为p',即一
个包含r-s'个符号的信源，并构造p'的最佳码，然后再利用定理11.7提供的方法将其扩展为
p的最佳码。如前面所提到的，这个算法的一个方便之处是，仅需要在第一次p→p'化简时计
算s'的数值；而在后续的所有化简中该值都等于s。容易证明，信源化简所需要的总次数是
「(r-s)/(s-1)];经过这么多次化简后，信源仅包含s个符号，而10,1,…,s-1}将是它的一
个最佳码(见习题11.15)。
例11.6 设s=2,r=4,而p=(3.号，6后)。信源第一次化简为(-3,3亏),第二次化简
为(云，÷),10,1是它的一个最佳码。下面的图示描述了 Huffman算法的构造过程：
P_.__ p p"
}0)——. —→}0一
(0——-——3u0
l?10)____u1 ---3
3(1)
()
也可以用下面图示的方法编码：
p P' p"
3001
01)一
3(1)- 300
(0)
0)
6110) sion)
6(m)
因而n?(,3.6,6)=2,尽管p'的不同排序得出了p的两种完全不同的最佳异前缀码
(见习题11.21),[注：二进制信源熵?(p)=1.92比特。]
例11.7 设s=2,r=2,p=(0.9,0.1)。这里H?(p)=0.469,而Huffrnan算法给出了以下数
值：
n2(p)=1.00
2n?(p2)=0.645
n?(p3)=0.533
in?(p?)=0.493
(这些计算可以由读者验证；见习题11.19。)这里需要指出的一点是，m-'n,(p")一般可以
非常快速地收效于H(p)(见定理11.5,也见习题11.20)。
接.
254 信息论与编码理论(第二版)
习题
11.1 惟可译码有时定义如下：如果z*…*T;=a?*…*a;(r利a都是偶字)意味若k=
1且T,=c(其中i=1,2.…,h),则码C是惟一可泽码：试说明这个定义等价于正文中
给出的定义.
11.2 如果在码C中增加一个新的码字就会破坏其惟一可译码的条件，我们就称惟一可译码
C为全码。如果字符串。不是C中码字任意有限级联的子串，则认为字符中o对C而
言是不可译的。如果C=iou,可，…,o,_ii,说明下列三个条件是等价的：
(a)C是全码。
(h)对C而言不存在不可译的字符串。
(c)△_s=1
11.3 证明异前缀码C必然是惟…可译码，并设计码C的--个有效泽码算法，即将C中码字
的有限级联分解为其单元码宁
11.4 证明异前缀码的乘积仍然是异前缀码。任意一对惟一可译码的乘积是否必然是惟一
可译码?
11.5 在本题中，要求构造S={0,3,2,31上指定码字长度的惟一可译码：下表中，k,表示码
中长度为i的码字数目：
k;
情况E 悄况2 情况3 快况4
1 3 2 I 0
2 3 7 7 ?
3 3 3 3 3
4 3 3 7 11
5 4 5 4 3
6 0 0 0 4
针对这四种情况，分别构造惟一可译码或解释为仆么该码不存在：
11.6 如果。和z分别可以写做=p*i*p?t=A*j*ps,其中i,j∈S且i<j,则称S=
s0.1,…,s-I:上：字符出o的字符排序小于宁符串r(写做a<·T)。试说明宁符排序是
·个全序，即对于任意一对(o,t),这里cr,必有α<T或者t<a?
11.7(续)考虑定理I1.2中构造方法的另一种表述：选择o=00---0,其长度为n.并选择
0;,的前缀不在集合ion,ai.….σ中且是长度为n?的最小字符排序出 试说明按
这种方法构造的码与定理11.2所给出的码相同
11.8 证明n(p)=H?(p),当且仅当存在正整数(no,np…,n,1)满足p,=s-,i=0,1,….
r-1,
11.9给定整数s,证明集合!x:x=n,(p)-H(p)对于某些p密集分布在[0,1]区间。也就
是说.对于任意：∈[0,1]和c>0,证明存在一个p,满足In,(p)-R,(p)-tl<E。
S;
第11章 变长信源蝙码 255
11.10本章介绍的变长编码方式并不适用于图5.1中的模型，该模型将固定数口为k的信源
符号映射为固定数日为π的信道输人符号、本习题将说明为适应这个模型，应该如何修
改变长编码的设计 设信源p=(pn,p…,p,.)始终固定不变，信道是无噪声的离散无
记忆信道，其输入和输出字符集都等于S=10.1,…,s-11,而转移概率由下武给出：
n={蜘
假设我们找到一个平均码长为 n.(p)的最传x进制异前缀码C,并设n和k是固定整
数 现在考虑下面的将k个信源符号U,U?…,U.映射为S上n个符号的策略。首
先，将每个信源符号映射为C中机应的码字，级联这些码字得到a。作为S上的一个
字符串，σ的长度足一个随机变量，但我们对σ做如下修改，使它的长度为n.如果σ
的长度超过》,就删除最后loi-n个符号；如果。的长度小于n,就在最后加上
n-101个0.采用这种方法将每组k个信源符号映射为一组n个信道输人符号，并用
r'表示
当译码器接收到a'时、它将o'惟一地(见习题1).3)分解为c,*d?*…*a,*t形式的
字符串，其中a,是码字，而r或者是某些码字的前缀，或者是一串0字符。如果l≥k,
译码器就能够正确地接收所有k个信源符号：但是如果1<k,某些信源符号将不会到
达接收端，即这些符号被系统删除了：用P表示k个信源符号分组中至少有一个符
号被删除的概率。设e>0是任意的。
(a)说明对于任意>n(p),存在-个上面所述的分类方法，满足nlk≤v且PE<E。
(h)利用(a)和定理11.5的结论，说明对于任意的r<LH,(p)J1和e>0,存在一个如
图5.1所述的(n,h)编码模式，满足h/n≥r和P:T≠li<E·
11.11设U=(U.U,…,t)是一个随机矢量Hn.(U)=n.(p),其中p是U的概率分布。现在
假设(U,U,…)是-个有限的Markow 链(见习题1.20)证明lim。(Vk)n.(U,,…,U)
等于该链的s进制熵
11.12 证明H,(p")=mH,(p)(见定理11.5)。
11.13定义n5(p)为p的一个s进制异前缀码的最小平均码长。证明n.(p)=n.(p)·
11.14如果去掉约束条件r≥2,定理11.6是否仍然成立?
11.15 试说明如果r≥s,p=(pop·…·pr-1)在经过(r-s)[s-1]次s进制化简后，恰好
只包含；个符号的概率。
11.16在信源p的第一次 Huffinan化简中，合并符号的数目可能少于s,为避免这种情况的出
现，通常采取的一种措施是，在信源字符表中额外增加s-s个“空”符号，每个空符号
出现的概率为0:这样可以保证每次化简，甚至包括第一次，都恰好合并s个概率。
[例如，在例11.5中x-s'=1,因而信源变为p=(0.24,0.21,0.17,0.13,0.10.0.07,
0.04,0.03,0.01,0.00)。i如果想利用这种技巧证明 Hufinan 构造过程，就会出现一个问
题：对(p.0,…,0)而言的最佳码，对于p本身或许并不是最佳码!试给出一个相应的
例证：..
11.17对于给定的s,试说明通过 Hufman算法寻找p=(po,p,…,p?-)最佳s进制码的计算
,上
256 信息论与编码理论(第二版)
量为0(2)。这个量是如何依赖于s的?
11.18(续)现在假设仅对 n,(p)的数值感兴趣，而不需要寻找最佳码。试利用式(11.9)设计
一个计算 n(p)的算法，使其运算次数为0(2)。
11.19 验证例11.7中的计算结果。
11.20根据定理L1.5,回答下面的问题：
(a)n,(p)<2n,(p2)是否成立?
(b)立n,(p2)<}n,(p)是否成立?
p=(,3言，6 11.21 我们注意到在例11.6中1 -)具有两个最佳二进制异前缀码，分别为100,
01,10,111和0,10,110,111}。试证明满足 p?≥p?≥p≥pa且同样具有两个最佳码的
全部概率矢量(p?,P?,Ps,pA)构成的集合，是三个固定概率矢量的凸包络，并找出这三
个矢量。
11.22 考虑一个“二十个问题”的游戏，要求你在询问一定数量的答案为“是”或“否”的问题
后，猜测--对骰子抛出的结果。(结果是整数2,3,…,12中的某一个。)平均来讲，你最
少需要问多少次问题。[提示：如果你问“是否为2”,“是否为3”等，所问问题的次数平
均来讲略小于6。但是有可能做得更好。]
11.23 本题旨在让你学会如何设计一个r迸制对称信源p,=(1/r,1/r,…,1/r)的最佳二进制
异前缀码。
(a)构造p?+p,p,ps的此类编码。
(b)一般来讲，p,的一个最佳二进制异前缀码的码字长度可能是多少?
(c)请给出n?(p.)的通用计算公式：
注释
[1] 在信息论的教科书中，本章的有关内容一般很少出现得这么晚，因为这些内容并不
是特别深奥，也确实不依赖于此前介绍的任何内容。但是我们选择将它放在这里，
是因为它介绍了信源编码问题的一种设计方法，正如第7章至第10章的内容介绍
了信道编码问题的一种设计方法。
[2] 尽管这部分内容对于本章的理解不是必需的，但我们还是将问题用第3章的语言进
行表述。现在正在讨论的是一个对应汉明失真测度的离散无记忆信源，郎信源和信
宿的字符集都等于10,i,…,s-1},而失真测度为：
du-{1如梨
这里只对零失真的情况感兴趣，即希望在信宿能够正确地复制信源(技术上允许错
误概率取一个很小的e值)。因为此时对应所期望失真度(8=0)的率失真函数
R()),就等于信源的熵H?(p)(参见图3.3)。根据信源编码定理3.4(非构造性的)
得出结论，每个信源符号仅用H?(p)比特表示，就可以在信宿无失真地恢复信源。
毫
第11章 变长信源蝙码 257
[3] 注意这种编码不同于第7章至第9章的分组码，以及第10章的卷积码。但是从某
种意义上来讲，变长码可以转换为分组码(见习题11.10)。
[4}在s进制异前缀码和s进制码树之间存在一种一一对应关系，这在大多数教科 书中
都会重点强调，我们这里只简单提一下。为了说明这个概念，考虑异前缀码(0,L0,
110,1111。相应的二进制树描述如下：
根
0
10
110 111
通常每个码字代表树上的一片“叶子”,码字的比特图案描述了从根到叶子的惟一路
径——向左的分支用一个“0”表示，向右的分支用一个“1”表示。更详细的内容参见
Knuth[7],卷1,2.3节。
[5] 实际上，证明二进制条件下 Huffinan算法的有效性相对简单。大多数的教科书(例
如 Abranson[12],Gallager[17])仅证明了s=2的情况，而将一般情况下的证明(更为
重要)留做习题(也见习题11.16)、
i-l…1………………
第12章 第二部分前沿课题综述
12.1 引言
本章在第二部分中的作用等同于第6章在第一部分中的作用，也就是说，它概述了编码理
论中的一些重要结论，而这些结论在第7章至第1]章的介绺巾并未涉及、在12.2节、12.3节
和12.4节里，我们将论述信道编码(分组码、卷积码以及两者的比较)。最后在12.5节里，将
讨论信源编码：
12.2 分组码
分组码理论的发展历史要长于卷积码理论，其内容也相对丰富，因此本节的篇幅比12.3节
长得多。(但是这种不平衡并没有影响到实际应用领域；参见12.4节。)出于结构上的考虑，我
们根据FHerlekamp在文献.15]中列举的编码理论三大主要问题，对本节将要介绍的内容进行分
类：
1.最佳码的性：能如何?
2.怎样才能设计出好码?
3.如何对这些好码进行详码?
◆最佳码的性能如何?在编码理论的发展过程中，最早提出来的…个问题是寻找完备码。
我们可以将有限域F,L:一个码长为n的码看做大量空间V?(F。)的一个子集|x?,X?,…,x,
对于某个整数e,如果环绕这M个码字的半径为e的汉明球体，无交叠地填满了整个V?(F,)
空间，就称这个码是完备的(或者密合填充的)。到1950年为止，科学家们已经发现了几种完
备码：
n 注释
2e+1 2 (任意》 重复码；见习期7,18
(g°-1Aq-1) (1:意家数的方幂)
23 2 3
汉明码；见7.4节，习题7.19
二进制Goly码；炖9.8书
11 3 2 三进制Golay码；见习题9.30~习题9.33
完备码(也许不应该包括重复码)是具有强大纠错功能的完美组合码，因此研究者们自然
希望能够找出更多的完备码来扩充上面的表格。但是经过长期的艰苦研究，人们到20世纪
70年代早期才发现了这样一个事实：除了具有上表所列参数的码以外，不存在其他的完备码
了：有关这段历程的完整记录，读者可以参阅MacWiliams和Sloane[19]的第6章。确实存在
某些完备码，与汉明码的参量相同却又不等同于汉明码；但是其他三类码都是独一光二的。那
第12章 第二部分前沿课题综述 259
么.当q不是素数的方器时、在包含g个元素的字符集上是否存在完备码呢?在写本书时对
这个问题还没有确切的答案、但是似乎是不存在这样的码
认识到并不存在其他的完备码后，失望的研究者们开始将他们搜索的范围扩大到性能与
完备码接近的码类：近似完备码和均匀填充码。在有限域上，目前已经完成了对e≥4的所有
这类码的分类；但是对于e≤3.只得到了部分结果；参见an Tilborg:46]。
(23、12)Golay完备码的存在告诉我们.若在空间V(F?)上选择矢量，使其相互之间的汉
明距≥7,则可选矢量的最大数日恰好等于40}2'.人们自然想问，当用n来代替23,用d
来代替7时.这个最大数口应该是多少。因此我们定义：
A(n,d)=最大整数 M,使得下(F)中存在M个码字
lx?…,xn满足 dg(x,x,)≥d,当i≠j时
或 (12.1)
A(n,d)=码长为n、最小距离为d的码最多所能包含的码字数口
研究A(n,d)的数值被认为是编码理论的核心问题。尽管人们对A(n,d)的精确值了解
得很少(除非n和d的值相对较小，或者2d≥n),但是为了寻找A(n,d)的上下界.仍做了大
蜃的研究工作：在接下来的内容中，将简要地介绍这方面的一些研究：有兴趣的读者可以参
阅MacWilliams 和Sloan:19]的第17章，其中详细介绍了这段历史，
当n和d取值相对较小时，获得形如A(n,d)≥M的下界的惟一已知方法，是直接列出
V,(F?)空间上满足条件(12.1)式的M个矢望。我们将在下面讨论这种构造方法。
另--方面，为了获得形如A(n,d)<M的上界，就必须证明V?(F?)空间的任何子集
ix,…,x!都至少包含一对(i,j)使得d(x,,x)<d.为此有很多种可行的方法，但是目前最
有效的方法显然是线性设计法，现在就来介绍它
如果C=|x,…,xm是一个码长为n的二进制码”即是V,(F?)空间的一个子集],则对于
任意i=0,1,…,n和x∈C,令A.(x)表示C中与x的距离为i的码字数：定义C的距离分布
为由非负实数组成的(n+1)重(Ao.A….A.)序列，其中，
A?=4x)
可以立即得出A,的如下性质：
Aa+A+…+An=M
Ao=F
(12.2)
(12.3)
如果该码的最小距离为d,则可以得到：
AI=Az=…=Aa-=0 (12.4)
线性设计法的关键是Delsarte- MaCWilians(DM)不等式：如果 P,(i)表示多项式(1-z)'(I+
z)"?'中项的系数，则A、必然满足：
A.P(0≥0, j=0,1,…,n (12.5)
(此结论的证明，请参见习题7.28。)这些结论为我们提供了如下思路。设Ap(n,d)表示由(n+1)
:1
鼎
260 信息论与编码理论(第二版)
个非负实数组成的函数f(A?,…,A,)=Ao+…+A,的最大可能取值，其中这些实数满足线性
约束条件式(12.3)～式(12.5)。则显然A(n,d)≤A(n,d);因此A(n,d)称为线性设计界
(LP):
目前对于任意一对(n,d),A(n,d)最著名的上界基本上都是根据线性设计界或它的修正
而得出的。例如，通过联立 DM不等式(12.5)和特殊不等式Ao+4A≤4(这很容易由联立方
程推出),可以求出A(13,6)的上界为A(13.6)≤32:在发现IP方法之前的相当长一段时间
内，A(13,6)是尚未知道取值的最简单A(n,d)。研究者们试图利用非常繁琐的联立方程去求
解，但是他们所能得到的最好结果也仅仪是32≤A(13,6)≤35。当然、根据原来已知的下界
(它由一种已知的 n=13、d=6而M=32的Nadler码得出)再结合新得到的上界，就可以得出
答案：A(13,6)=32。
也许在有关A(n,d)的问题中，最著名的一个就是渐近问题：如果(d)是一个整数序
列，满足d /n→δ,而0≤8≤1,那么当n→○时，A(n,d)将如何变化?更正规的表述是，由
于…个码长为n、码字数为M的码的速率为J/nlrgM,故定义：
R(o)=sup顾og2A(n,dn)
R(o)=inf im1og2An,da)
(12.6)
(12.7)
这里式(12.6)中的“sup”及式(12.7)中的“in都是对所有满足d./n→δ的序列(da)。取值：
在这种定义方式中，比较麻烦的是需要同时定义R(8)的上界值和下界值；虽然人们都相信
(但却没有人证明过)对于所有的8值，均有R(8)=R(8)。因此，为了简化下面的讨论，我们
仅考虑R(8),并认为其上界就是R(δ)的上界，其下界就是R(8)的下界。
已知(也很容易证明)R(0)=1,并且对于1/2≤δ≤1,有R(8)=0,但是当0<δ<1/2时，
R(8)的值尚术确定-在这个区间内，目前已知的R(h)的最佳下界为：
R(o)=1-H?(6) (12.8)
这个结论是由 Cilhert 在1952年证明的。(此下界也是习题7.21所给出下界的一种渐近形
式。)没有人能够进一步提高 Gilberl下界，但R(8)的上界却在逐渐降低。目前已知的最佳上
界，是由 MeEliece,Rodemich,Rumsey 和Welch利用线性设计法得到的，为：
R(b)min?{1+g(u2)-g(u2+2ou+28)} (12.9)
其中g(x)=H?[(-√1-x)/2]。图12.1而出了这两个界的曲线。人们普遍猜测R(A)=
1-H?(b),但是支持这个论断的惟一真实证据，仅仅是多年来上界不断被降低，而下界却一直
保持不变的事实!
●怎样才能设计出好码?在前面的内容里，我们已经讨论了编码理论中的一些重要结论，
但都没有涉及到如何构造好码的问题。为此人们做了大量的研究工作；尽管目前还没有人能
够构造出达到信道编码理论预计效果的码，但是已经取得了一些值得注意的结果。
迄今为止，已经发现的最重要一类码，就是第9章中介绍的BCH码。BCH码之所以重要，
器： 药
第12章 第二部分前沿课题综述 261
不仅因为它们本身性能优越，还因为它们具有一种简单有效的译码算法。然而对于我们即将
介绍的大多数码而言，并没有找到它们的一种比较有效的译码算法。在下面的章节里，将针对
译码算法的设计介绍一些研究成果。
1,0
19
08
0.7 上界
06 「式(1291
(g0.5
04
03 下养
02 式：128月
01
o
a1 02 03 04 05
δ—
图12.1 目前已知的R(δ)上下界的最佳结果
在有关编码理论的构造性研究中，最重要的成果可能就是关于循环码的。F上的一个
(n,k)线性码C在满足下列条件时称为循环码：只要c=(cn,c?.…,cn1)属于码C,那么它的
循环移位c'=(ca-1.eg,c?,…、ca-2)也属于码C。当n≥3时，无论q取什么值，至少存在四种
码长为n的循环码：
●只包含一个全0码字0=(0,0,0,…,0)。
●常数码字α=(α,a,…,α)的集合。
●满足∑"c=0的码字。
◆整个空间V?(F)。
这四种循环码的维数分别是0,1,n-1和n。对于某些(q,n)的取值(例如，q=2,n=11;
q=3,n=7),除了这四种循环码外，不存在其他种类的循环码。但是在一般情况下，存在许多
非常有趣的循环码。例如第9章中介绍的BCH码，RS码，以及两种Golay 码都属于循环码。
在这部分内容里，将介绍其他几种循环码，但是首先需要做一个简略的初步介绍。
对应F。上的任意一个(n,t)循环码，都存在一个生成多项式g(x),其系数在F。上取值，
次数为n-k,并且能够整除x"-1。当且仅当多项式co+ejx+…+Ca-1x??1是g(x)的倍式时，
矢量c=(cu,…,c-1)∈V(F)属于该循环码。g(x)的互补多项式h(x)=(x"-1)/g(x)称为
一致校验多项式，因为g(x)能整除x"-1,所以g(x)的每个零点同时也是x-1的零点。如
果 n和a是互质的(不满足此条件的循环码通常没有研究价值),x"-1的零点就是11,β,…,
-1},其中β是F。上的n阶本原单位根；这样g(x)的零点具有{β°:a∈A}形式，其中AS
10,1,…,n-1}。由于g(x)的系数在F。上取值，于是根据伽罗瓦(Galois)定理，A一定是q级
: 受
262 信息论与编码理论(第二版)
封闭的，也就是说，如果α∈A,则同时有qa(mod n)∈4.现在任意取ACl0.1,…,n~11,我
们定义它的g级封闭集A为包含A的最小q级封闭子集。利用这个定义，可以将F,上任·
(n,k)循环码的生成多项式和一致校验多项式分解为：
循环码的所有重要结论基本上都可以用集合A,A,B和B的形式表述。例如，BCH码的定理9.3
可以表述如下：如果n=2"-1,q=2,面j A=+1,3,…,2t-11,则码的最小距离d满足d
2t+(.现在我们以这种表示方法列出循环码的一些重要结论(下面均假设q=2,尽管q取更
大值时的结论通常是已知的):
●如果 n=2"-1,而B=11,3,…,2c-11.则有dm≥2"1-(t-1)22(参见Van Timt
[18],定理6.3.6)。
●如果n是一个等于-1(mod 4)的素数，而A=1二次剩余(mod n){,则k=(n+1)2,且
,n=I(mod 8) {13=1a?
这种码称为二次剩余码；参见Ma:Wilians和 Sloane[ 19],第16章。
●如果不存在j重序列b,,b?,…,b,∈B满足b,+…+b,a0(mwodn),则每个码字的重量
都能够被2'整除。(本书9.8节的引理5,是此定理在j=2的特殊情况下的一种变换形
式。有关它的证明和进一步推广，请参见Delsarte和MeEliece[34]
●如果B=|1,该码被称为不可约循环码[因为校验多项式h(x)是不可约的]或者最小
循环码(因为它们不再包含任何非平凡循环子码)。有关它们的详细理论，请参见Mav Wiliams和 Sloanc[19]第8章，或者MeEliece[391。
●如果 n=2”-1,B=30≤b<2”-1:b可以表示为2的≤d次幂的和},则这个码与习题7.30
介绍的Reed-Muller码RM(m,a)本质上是相同的。参见MacWiliams和 Sloane[19]第13
章，或者Delsarte和McEliece[34]第5节。
通过前面的例子，我们了解到有关循环码的理论是非常丰富的，但是从另一个角度来说，
这也令人感到失望，因为最佳码很少是循环码。换句话说，如果随机地选取一对(n,d),很可
能并不存在一个包含A(n,d)个码字的循环码[参见定义(12.1)式]。事实上，最佳码甚至一
般不是线性的，因此人们研究的焦点又转移到寻找非线性最佳码上。下边的内容是这方面取
得的一些成果(同样，对所有码都假设g=2):
●n≤2d的最佳码都不是线性的，并且与 Hadamand矩阵相关联。参见MacWilians和
Sloane[19],第2章
●Kerdock非线性码的参数为：n=22°,码字数M=2,d=22-1-2(2m-2h2,m≥2。最简
单的例子(m=2)是码长为16、含256个码字、d=6的Kendock码。而n=16、d=6的
;
第12章 第二部分前沿课题综述 263
最佳非线性码只包含128个码字.参见MacWiliams和Sioane[19],第15章。
·P'eparata码的参最为n=2”.M=232-,dm=6,m≥2。它们是Kerdbock码的对偶码；
参见MacWiliams和Sloune[19].第15章。
最后我们注意到，在MacWHiams 和Slkoanc[19]附录A的一个表格中，作者列出了d≤29,n≤512
的所有已知最佳码。其中很多码的构造方法非常巧妙，这里就不一一赘述了。
●如何对这些好码进行译码?对于确定的n和d,寻找其最大可能码是一项重要而艰巨
的任务。但是.为了将这样一个码(当然也可以是任意码)实际应用于有噪声的信道，必须寻找
一种实用的泽码算法：如果所用的码字数目相对较少，可以将它们与接收字一一进行比较，泽码
并不成问题。如果该码是一个(n,去)线性码，Aq?相对较小，也可以运用在7.2节和7.5节
介绍的伴随式表译码方法，译码同样不成问题。但是在人多数实际应用中，不会采用这种小型
码，这就导致两种基本的译码算法失去了使用价值。于是，人们耗费了大量精力去寻找大型码
的有效译码算法。在以下的内容里，就将介绍其中的一些算法
首先介绍的是一种最重要的译码算法，即第9章中详细介绍过的BCH-RS译码算法。为
了纪念这个重要成果，先来介绍…下算法的发现者。
在1959年至1960年间，Hocquengherm(参见文献[15],72～74页),以及 Rose和 Ray Chauklhuri(参见文献15),75~78页)在他们发表的论文巾，首次提到BCH码的概念。应该注意，
这些早期论文部只涉及了码的构造方法，而没有涉及到译码：1960年，Peterson(参见文献[15].
109-120页)提出了一种相当简单的译码算法，它需要求解特定有限城上的线性方程组，一年
以后，Corenstein和Zierler(参见文献[15],87~B9页)将此前的研究成果推广到非线性码，并发
现他们的推广包括了Hred和Solomun(参见文献[15],70~71页)早在1960年就提出的一类码，
这个时间要早于Rose和Ray-Chaudhuri论文发表的时间!有关BCH码译码的重大突破发生在
1968年，Berlekamp[参见文献[15].145~148页，也可以参见文献14]第7章)在那一年发表了
他的迭代译码算法：人们至今还会选择将 Bedekamp的算法应用于系统工程中，因为它能够在
很大程度上减少 BCH详码器的复杂度。但是发展到当时，译码理论中的一些重要概念还未提
出
1970年，Goppa(参见文献[15],102~106页)发现了一类码(后来人们就用 Goppa的名字来
命名这类码),它们是BCH码的一种自然推广。Goppa指出，存在码长足够长的Goppa码，具有
很好的渐近性，因为它们能够从上方逼近图12.1所示的Gilbert下界。(这与BCH码形成鲜明
的对比，尽管 BCH码的应用较广，但它们的渐近性很“差”。因为对于任意码率≥R>0的BCH
码序列，比率d/n必然趟近丁0;参见 Berlekampi31]。)Goppa同时还给出了Goppa码的一种
译码算法、该算法类似于以前提出的Peterson-Gorenstein-Zieder算法；遗憾的是，他并没有对
Berlekamp的递归算法进行推广。到了1975年，Sugiyama,Kasahara,Hirasawa和Naunekawa[45]发
现了一个重要事实，即可以采用Euclid算法对 BCH码和Reed-Solomon码进行译码，这一点我们
已在第9章中详细论述过。实际上，采用Fuclid算法对 BCH码进行译码，比采用Berlekamp算
法差一个很小的常数因子。但是，Luclid算法更容易理解，在某种程度上影响了Berdekamp算
法的应用。从今天的角度来看，完全可以将 Berlekamp算法看做 Euclid算法的一个升级!最
后，在1975年，Delsate[33]和其他的一些研究者发现 Goppa码实际上就是RS码的一种改善，
、
264 信息论与编码理论(第二版)
从而为译码理论的发展画上了一个完美的句号。
尽管BCH-RS码的代数译码算法是该领域中的最重要成果，但是除此以外，仍有很多同样
有效的译码算法。现在就来介绍其中的一部分。
最早发现的重要译码算法是门限译码，它是我们在引言中提到的“多票判决”方法的一种推
广。门限译码方法由Reed在1984年提出，当时是为了对Reedl-Muller码进行译码(参照习题7.30
Muller发现了这类码，泽码算法由Reed 提出，他们在1954年分别发表了论文。)下面将简单地
介绍…下Reed的算法。考虑一个(7,3)二进制线性码，其一致校验矩阵为：
[该码就是引盲中介绍的(7,4)汉明码的对偶码。]容易验证，该码中的每一个码字C=(C,
C?…,C)都满足下列三个校验方程：
Co=Ci+C?
Co=C2+C4
Co=Cs+C6
现在假设码字C在二进制对称信道中传输，该信道的原始误比特率为p,接收到的矢量R=
(Ro.…,R?)=C+E,其中E=(E?,…,E)是错误图案。由上边给出的校验方程，译码器得到：
三维虽主璃：0en
因此，如果信道至多只发生一个错误，那么它最多也只能影响上述对Co的一个估计，对这四
个估计采用多票判决，就可以得到正确的 Co。如果信道发生了两个错误，那么判决中就出现
了2比2的平局，不过考虑到估计值Ro,这种平局就很容易被打破，因为在0<p<1/2的惰况
下，显然{E=0}的概率要大于|E?+E,=0的概率。
Reed将上述方法进行了推广，得到一种适用于全部 Reel-Muler类码的泽码方法。后来的
研究者们又发现，很多种码都可以采用门限译码方法进行译码——这些码的构造通常都依赖
于某些有限几何特征的存在。对这方面有兴趣的读者可以参考 MacWilliams和 Sloame[19]的
第13章，及Massey[20]。
下面要介绍的最后一种译码算法是一种严格受限的译码算法，它只适用于第一类 Heed
Muller码。这类码实质上是汉明码的对偶码。其中前几个码的长度和维数分别是(8,4),(16.5),
(32,6),…。一般来讲，对于任意m,都存在一个(2”,m+1)RM码。针对这类码，我们有一种
特殊的译码算法，它建立在一个2”阶阿贝尔(Abelian)基群的快速傅里叶变换(FFT)基础上；参
见MaeWillams和 Sloane[19],第14章。这种算法的最大优点就是很容易应用在高斯信道上，
因为它不需要对输出进行二进制量化。下面解释原因。我们可以在平均功率限制为
E(X2)≤β的高斯信道上传输任意的二进制矢量 x=(x?,…,x。)∈V(F?),方法是将x中的
“0"元素映射为+√β,将x中的“1”元素映射为-√F。如果x是一个BCH码中的码宇，如果想
要用第9章介绍的算法对接收矢量y进行泽码，就必须先将y的相应分量—它们都是实
wdal
第12章 第二部分前沿课题综述 265
数——变换成0和1,例如将正数位映射为0,将负数位映射为1。这就是所谓的输出二进制量
化：遗憾的是，这样做会降低信道容量(大概2dB左有；参见习题4.15),由于这个原因，需要
运用二进制译码算法的码，在有噪声高斯信道上是没有实用价值的。
但是正如我们前面捉到的，第一类Reed-Muller码的FFT译码算法并不要求二进制量化，
因而它们适用于高斯信道：而太空通信信道与高斯信道模型非常类似；因此，我们就不奇怪为
什么1969年到1976年期间，所有NASA(美国国家宁航局)的Mariner型太空探测器上便用的都
是(32,6)Reed-Muller码了。(其余的太空探测器上使用的是卷积码；参见12.4节。)
12.3 卷积码
有关卷积码的理论远不如分组码的完善，其中一部分原囚是卷积码的发展历史较短，但更
主要的原因是对卷积码的研究更为困难。例如，到1970年Fomey(参见文献[15],213~232页)
才发表了有关卷积码的开创性论文，证明了卷积码的基本理论类似于我们在7.1节介绍的分
组码的有关结论!当然这并不是说卷积码的理论研究没有产生过重要成果，它只是解释了为
什么本节的篇幅远比上一节短(当然在实际应用中，卷积码的地位通常比分组码高；参见
12.4节。)
卷积码的自由距离的作用类似于分组码的最小距离：对于一个确定的编码速率，具有最大
自由距离的码通常就是最伟码。因此，寻找拥有最大可能自由距离的卷积码，成为研究者们努
力的口标。尽管人们尚未找到性能类似于 BCH分组码的卷积码，但是已经发现了大量不同类
型的好卷积码。例如，Larsen[37]给出了一个编码存储M≤13的(2,1),(3,1)和(4,1)好卷积码
的表；Joharnesson[36]列出了编码存储M=35的(2,1)好卷积码。卷积码所具有的额外自由
度，即被称为编码存储的M,使得针对(2,1)卷积码的研究也变得非常丰富，而(2,1)分组码却
是很普通的。级然人们对于确定N而改变(n,h)的卷积码也进行了大量的研究，但是还没有
取得重大突破。
信道编码定理2.4是利用分组码证明的。这时很自然会想到能否利用卷积码证明该定
理。迄今为止，这个答案还不确定。当然可以利用树状码(该码可以通过在类似于图10.20所
示的树状结构上进行标注面得到)、网格码(该码可以通过在类似于图10.7所示的网格结构上
进行标注而得到)或者它们的某种受限子集去证明。这些码都可以利用移位寄存器得到(参见
图10.3和图10.4),但移位寄存器的连接是可以随时间变化的：因此这类码有时也称为时变卷
职码，而一般的卷积码则称为固定卷积码。有兴趣研究时变卷积码编码定理的读者可以参考
Massey[21]或者Viterbi和Omura[26]的第5章。
序列译码是最早提出的卷积码译码算法，人们对序列译码的研究直接导致了卷积编码理
论中一些重要结论的诞生，在10.4节中曾指出，实际应用中序列译码算法与最大似然译码器
在码树上选择的路径通常是相同的。遗憾的是，序列译码算法做出判决所需要的计算次数是
一个随机变量，它依赖于噪声的大小。事实上，如果用C表示序列译码器译出前L个信息比
特所需要探测的路径数，就会有：
P{C>x}=Lx-“
其中。是一个取决于信道和编码速率的正值常数，它与x无关。如果编码速率过于接近信道
容量，a的取值就会介于1和2之间。这反过来也说明，尽管随机变量C的均值是有限的，但
、知h场.
266 信息论与编码理论(第二版)
它的方差却是无限的。这对实际应用非常不利。应当注意到，当译码器试图在码树上寻找它
的路径时，同时会有更多的符号到达接收端.这些等待译码的符号将被存储在一些长度有限
的缓冲器中，如果译码器需要的计算量过大，这些缓冲器就会溢出，导致信息丢失。如果C
的方差是无限的，缓冲器将一直处于溢出状态，序列详码会失去作用。
发生这种不利现象时的速率称为计算终止速率：它正是我们在习题2.21至习题2.26及习
题4.3至习题4.9中提到的速率R;R。有时也表示为Rmpc但是即使速率低于R,这种缓冲
器溢出问题也会影响码的性能，例如，在宽带高斯信道上传输一个(2,1)卷积码，该码的编码
存储和自由距离都很大，人们可以使误比特率降到很低，但却不容易将它的删除概率(即没有
足够的时间对一个给定比特进行译码的概率)降低到103以下。有关序列译码计算量分布的
详细介绍，可以参阅 Viterbi和Omural26第6章：
除了Viterhi译码和序列译码以外，卷积码还有第三种很重要的译码方法，称为门限译码。
该方法与我们在12.2节中介绍的分组码门限泽码方法类似.它是由 Vassey[20]在1963年提
出的；在Gulager[17]的6.8节中对它进行了讨论 最近，Wu[48]又在级联卷积编码系统中非
常巧妙地运用了门限译码方法.
最后我们提醒读者注意，Schalkwijk和Vinck在1976年发明了卷积码的一种泽码算法，它
类似于分组码的伴随式译码算法(参见7.2节),同时又与Viterbi译码算法有很多共同点：
12.4 分组码和卷积码的比较
在本节中，将对分组码和卷积码在实际应用中的优点做一个简略的比较。
很显然，在编码理论(分组码或卷积码)中取得的最重要成果，当属 BCH-RS码的代数泽码
算法，我们已经在第9章对它进行了介绍。但是值得注意的是，这类码是为一类非常特殊的信
道而设计的，即q进制对称信道(特别地，对应 BCH码的是二进制对称信道),所以其译码算法
不易(如果不是不可能)应用于其他信道。
另一方面，卷积码的两种最重要的译码算法(即 Viterbi 译码和序列译码算法),尽管不需
要深奥的数学理论，但适应性却非常强，在大多数类型的信道中都适用。由于在实际系统中只
有很少一部分通信信道能够被模拟为q进制对称信道，因此我们就不奇怪为什么在大多数通
信系统中采用的是卷积码而不是分组码了。下面将通过两个特殊的例子来说明这一点。
首先考虑一个二进制对称信道，其原始误比特率为p,0<p<1/2。我们在图12.2中给出
了两种实际编码系统在这个信道中的性能，一种是(127,64)纠正10个错误的BCH码，采用图9.1
所示的译码算法进行译码，分-种是生成矩阵为G=(x?+x?+x3+x+1,x?+x3+x?+x3+1)
的(2,1)M=6卷积码.从图中可以看出，当p的值大于p=0.003时，卷积码的性能优于 BCH
码，但是当p取很小的值时，BCH码的性能更优；例如。在p=0.001时，BCH码的性能约超过
卷积码两个量级。BCH码的性能优于卷积码的根本原因，在于它的最小距离(21)比卷积码的
自由距离(10)大得多。在速率为12的条件下，要进-步改善图12.2所示卷积码的性能是非
常困难的，因为惟一途径就是增加它的编码存储；但是当M的值增大到超过7或8时，就很难
通过 Viterdi算法实现译码了，而当M取值较大时，如果采用序列译码算法，捌除概率(即12.3
节所介绍的由于计算量问题而引起的算法判决失败的概率)就会决定码的性能。但另一方面，
却不难构造一个速率接近12,码长为255或511的BCH码，在适度增加算法复杂度的条件下，
第12章 第二部分前沿课题综述 267
其性能显著优于图12.2所示的性能.至此我们可以得出结论，在一个二进制对称信道中，除
非信道受噪声于扰非常严重，否则一个分组码，或者更具体地说，一个BCH码，将会比卷积码
更加适用。
10'
10
10 (2.1M=6.
卷积码
1
…
(127.641BCH
10?
100016 0010 a008 0006000500040003 0002 0001
——P、原始识比特率
图12.2 二进制对称信道中分组码和卷积码的性能比较
作为第二个例子，考虑第4章中介绍过的宽带高斯信道。在图12.3中给出了前面所述那
两种码的性能曲线；数值E。是比值PIR,其中P是发射功率(单位为瓦特),R是信源速率(单
位为比特/秒)。因此 E的单位是焦耳/比特；它通常称为每比特能量，面E?/N。称为比特信
噪比。符号“dB”意味着坐标不是E,/N。的直接比值，而是10logm E/Noc这是信道的一种标
准表示方式；例如，参见Heller和Jacob[35]。
在图12.3中，BCH码不仅失去了它的优越性；而且现在它的性能明显比卷积码差。这是
因为为了应用第9章介绍的 BCH码代数译码算法，必须先进行输出二进制量化，而 Viterbi算
法却可以将未经量化的实数作为输人，实现译码(参见10.2节)。由于输出二进制量化造成的
信息损失过大，所以尽管 BCH码本身的性能比卷积码更优越，却不能弥补这些损失。
通过这两个具体的例子，我们想说明的是，在实际应用中的大部分通信信道都可以模拟为
宽带高斯信道，却很少能用二进制对称信道来模拟。因此在大多数实际应用中选择卷积码作
为纠错码
[实际应用中的一个有趣例子：太空航行器和地球之间的通信链路通常可以近似地模拟为
一个宽带高斯信道。自20世纪60年代末以来，已经有多种成熟的编码方案被用于太空通信。
·刻楼
268 信息论与编码理论〔第二版〕
1969年至1976年期间，NASA的Mariner号宇宙飞船上采用的是(32,6)第一类 Reed-Muller码配
合FFT译码方法，但是在1977年，这套系统被本节介绍的(2,1)M=6卷积码替代。其他的航
天器上(例如，NASA的“先锋号"以及西德的“太阳神号”)都采用了M≥24的长(2,1)卷积码配
合序列译码方法。]
我们还要指出.在1976年，当本书的作者在NASA的喷气推进研究室工作时，曾经针对一
种性能较好的分组码，郎(48,24)二次剩余码，提出了一种不需要进行输出二进制量化的译码
算法。在图12.3中以虚线标出了这种码的性能。尽管它的性能不如卷积码，但却提供了如下
思路：由于(127,64)BCH码的性能要优于(48,24)码(du=21对比d=12),因此如果能够找
出BCH码的非二进制译码算法，那么BCH码也许会远远优于卷积码。
最后，我们注意到在图12.3中，卷积码只有在P,值约等于10~3或者更高时性能较好。当
P,取较小的值时，目前已知的最佳应用方案是级联码方案(参见6.2节和9.6节),它的内码是
一个卷积码，外码是一个Reed-Solomon(分组)码(请参考文献 Odenwalder[41])。
101— T
102L
102- BCH(127.64)-
10
48,24
QR
us 卷积码 (2.1M=6-
10?-
10'-
10?0 234567
1-8910
EA.dB—
图12.3 宽带高斯信道中分组码和卷积码的性能比较
12.5 信源编码
香农的信源编码定理3.4与他的信道编码理论都存在一个相同的主要缺点：不可构造性
(参见第7章引言部分的注释)。因此，人们白然想发展一种信源编码的构造性理论，正如我们
在第7章至第10章所介绍的信道编码构造性理论一样。但是到目前为止，这个月标还没有实
现。研究者们仅仅得出了一些零散的结论(例如，第10章介绍的零失真方法，以及本节将要介
第12章 第二部分前沿课题综述 269
绍的内容),并没有形成系统的理论。出现这种情况主要有以下几个原因：(a)研究信源编码显
然比研究信道编码更为困难：(b)实际中可以接受的失真过小，因此很难达到这一点；(c)实际
应用中的很多或者说大部分信源都很难进行数学建模，也无法估量相应的失真度。印证最后
一点的经典例子就是数据的可视化，例如，远处飞行的飞机的照片。
现在我们来介绍一些在构造性信源编码理论中的最重要结论。
首先从对应均方误差失真测度的无记忆高斯信源(参照4.2节)开始，无记忆高斯信源是
实际应用中经常遇到的一种信源模型，但是由于它的R(0)=0,因此不可能实现理想传输(参
照图4.2),因此研究该信源的编码问题非常重要。幸运的是，我们可以采用一种非常简单的
技术，即量化。
氧化是一种将信源符号 u映射为f(a)的方法，其中f是一个单调步进函数，它只取有限
多个值。因此，存在实数L<…</(称为量化电平)和T?<…<Tn.1(称为量化门限)满足：
当且仅当T-1<u≤T时，f(u)=L,其中To=-的，T.=+的。这种映射将连续无记忆信
源U(均值为0、方差为c2的高斯随机变量)变换为一个离散无记忆信源(U),该信源输出 L
的概率为p=PIT.1<U≤T。显然用/(U)表示U的平均失真度为δ=E[U-f(U)]2。
此外，由第11章的内容可知，表示信源f(U)的一个符号所需要的平均比特数为H[f(U)]。
因此(参考图4.2),通过这种虽化方案，可以计算出点R=Hf(U)],8=E[U-f(U)]2的值。
Max 和其他人通过大量的方法证明了一个惊人的结论，即如果恰当地选取量化电平和量化门
限，这种方案的性能是非常接近于(在1比特范国内)R(8)曲线的。(参见文献[25]中267~
276页Max的论文，Ferger[13]5.1节更详细地总结了各种量化方法，包括将它们应用于有记
忆高斯信源的讨论。也可以参见文献[16]中的论文19-25。)
在介绍一些更复杂的信源编码技术之前，首先讨论一下信源编码和信道译码之间的相似
之处。为清楚起见.这里将重点讨论对应汉明失真测度的二进制对称信源。
回顾一个码长为k,编码速率为R的信源编码，它是子集C,=iv,v?·…,vwIcV?(F?)=V?,
满足k"'lrg,M=R。其失真度由下式给出：
(C)=2anla,O]
其中对于任意u∈V?,编码函数f(u)定义为C,中与a汉明距离da最小的码字[参见
式(3.18)]。
现在回顾一个码长为n,编码速率为R?的信道编码，它是子集 C=x,X,…,xFc
v?,满足R.=n-1logM。当只传输码宇x,时，由于信道噪声的于扰，接收可能为任意y∈Va
译码函数f。必须能够将V。映射为C,;理想的f,应该将接收到的y映射为与y汉明距离dA最
小的码字。
化这两种情况下，函数了都是将属于整个空间的一个矢量映射为与它最接近的一个码字。
这意味着，给定一个性能较好的信道编码和译码算法，该码同样可以用于信源编码，此时信道
译码算法即是相应的信源编码算法。(同样，信道编码算法应作为信源译码算法使用。你能说
明为仆么吗?)这是一种很好的思路，不过它同时也具有缺点，下面我们将加以解释。
在引言中已经看到反向应用信道编码得到信源编码的例子；当时采用了重复码，更重要的
海上
270 信息论与编码理论(第二版)
是，我们反向应用(7,4)汉明码得到了一个R=0.5714和d=0.1250的信源编码。当A=
0.1250时、R(8)=1-H?(?)的值为0.456 4.因此汉明码作为信源编码使用，其性能相当好。
类似地，如果完备(23.12)Golay码(采用伴随式查表译码方法)被用于信源编码，将得到R=
0.5217,8=0.124 0[对比R(0.124 0)=0.45927,因此也不存在问题。
考虑到第9章的结果，我们自然希望能够将BCH码用于信源编码，但是这就会产生严重
的问题，因为第9章介绍的译码算法是不完善的。也就是说，只有当接收矢量y与发送码字相
当接近时，该算法才能正确泽码；而在其他情况下，该算法的性能很不理想。例如，考虑一个
(31,16)纠正3个错误BCH码。当接收矢量与发送码字的汉明距离不超过3时，它的泽码算法
(参见图9.1)才会成功实现。但足在V中与发送码字距离如此近的矢量总数只有：
26.(1+31+()+())=3.3×10?
这大约占V中21=2.1×10°个矢量的15??对信道编码而言，这不存在问题，因为通常情况
下，在信道中传输该码出现3个以上的错误几乎是不可能的。但是对于信源编码而言，V?中
每个矢墅的发送概率都是相等的，这就带来严重的后果；在85??时间里，译码器/编码器会溢
出![通常的失败模式是错误位置多项式a(x)的最高次数为3,但在F域上的零点数少于
3个。1
上述的考虑使研究者们试图设计出 BCH码的实用译码算法，即不论译码器的输人是仆
么,它都能产生一个最接近的码字。对于纠正单个错误 BCH码，找到这样的算法不成问题；因
为译码算法本身就已经是完善的了。Berlekamp[14]的第16章给出了纠正两个错误 BCH码的
完善译码算法。最后，Vandertorst和 Berger[47]研究了纠正3个错误 BCH码的情况。
上面我们针对分组码的情况，描述了将信道编码用做信源编码的概念，这个概念同样适用
于卷积码，事实上已经有一些研究者进行了这方面的研究。例如，Berger[13]的第6章中讨论
了对序列译码方法进行-些改善，以得到更好的译码结果。Anderson 最近发表的一篇论文(参
见文献[28])给出了适应信源编码的堆栈算法。在Davisson和Gray 编辑的文选[16]中收录了
更多这方面的论文，包括在语音压缩方面的应用。
附录A 概 率 理论
首先需要强调的是，我们的日的并非是让读者学习概率理论。关于慨率论的知识，这里推荐
两本书，一本是[umperti的简明教材(参见文献[8]),另一本是Feller的两卷论著(参见文献[4])。
这部分内容只是介绍一些标准符号表示法和某些惯例，其中还介绍了弱大数定理，该定理是本
书第2章和第3章中编码定理证明的基本工其。
最基本的概念是概率空间(2,B,P),其中Ω是一个称为样本空间的非空集合，B是Ω子
集的一个Borel域，而P是定义于A∈B的一个非负值函数，具有性质P2!=1,以及
P{UA}-二PA)
这里假设所有的A,∈B,FLA,之间互不相容。P称为概率测度。例如，如果Ω=la,2,…
是有限的或者可数的、B是Ω所有子集的集合，而(pp,…)是总和为1的-组非负数，则定
义PIA、= ∑'pa:w∈A|将使(2,B,P)构成一个概率空间，我们称它为离散概率空间。
随机变量X是一个将Ω映射为某一集合R的函数，R称为X的取值范围。[我们用字母
表中最后儿个宁母的大写形式(如X,Y)来表示随机变量。]通常假设R是实数的一个子集，但
有时R也可能是其他种类的集合。例如，如果R是n维欧几里得空间的一个子集，则X称为
随机矢量，用黑体字X表示：X的组成分量表示为X,X?,…,X;因此可以将随机矢量X=
(X,,X?.…,X)看做是一系列(一维)随机变量。
对于定义在相同概率空间上的两个随机变量X和Y,如果集合1w:X(w)=Y(w)的P测
度为0,则认为这两个随机变量在任何情况下都相等。用符号表示为：
X=Y当且仅当P{X≠Y}=0
如果随机变量X的取值范围R为整个实数轴，则它的期望或者均值定义为：
E(X)=[。x(cm)dP
也就是说，E(X)是函数X关于测度P的Lebesgue积分。
期望的另外一个等价定义通常更便于计算。对于任何的Borel实数集合，通过定义P(S)=
Pla:X(w)∈SI,将定义在Ω上的测度P转换为R上的概率测度Px。这个测度称为X的分
布，而函数
Fx(x)=P{a;X(a)≤x}
称为X的分布函数。从Iehesgue-Stieltjes的意义上讲，X的期望等价于：
E(x)=[xdPx=xdFx(x) (A.1)
下面通过两种特殊情况对式(A.1)加以说明。
·非小i
272 信息论与编码理论(第二版)
首先，如果Ω是离散的，并且对于任意x∈R,我们定义p(x)=Py(ixb)=Pia:X(w)=x},
则定义(A.1)式变为：
E(X)=∑p)-x
这里没有规定求和范围；它可以是满足PiX∈Si=1的任何离散实数子集S。更为一般地，如
果f是定义在S上的任意实数值函数，则f(X)就是一个新的随机变墅，它的期望由下式给出：
E[f(X)=∑px/() (A.2)
此类求和式在本书的第一部分中多次出现，并且通常假设f(x)的值不等于±0,或者对x的
某些确定值不做定义。但是一般情况下，f(x)仅在某些0测度点上[即对应p(x)=0的某些x
值]取值不确定，而此时通常假设它对总和的贡献为0。
其次，如果随机变量X存在概率密度函数，也就是说，它的分布函数可以表示为F(x)=
p(u),其中p是一个非负值函数，则X的期望可以按照下面的公式计算：
Ex)=[u pluyd (A.3)
类似地，E[f(X)]=f(n)p(u)du。
接下来介绍“相互独立”这个重要概念
设(Ω,B.P)是概率空间，并设A,A?,…,A,是属于B的集合。如果对于事件A?,A?,…,
A。的任意子集A,,…,A,都有：
P{A?∩A?∩…∩Ai}=P{A}…P{A:}
我们就称事件A,A?,…,A.之间是相互独立的。更重要地，如果对于任意选择的S,S?,…,S。
∈B,事件A=3w:X,(o)∈S,F之间相互独立，则定义在相同样本空间上的随机变量X?,…、XA
也是相互独立的。这个结论不容易直接证明，因此下面仅对有两个随机变量的情况进行
讨论。
如果X和Y是任意一对定义在相同样本空间上的实数随机变量，则不论它们是否相互独
立，映射w(X(m),Y(o))都产生一个二维 Borel集合上的测度Pxy。这个测度称为X和Y
的联合分布，而函数
Fxr(x,y)= P{w:X(w)≤x,Y(w)≤y}
称为X和Y的联合分布函数。如果X和Y是相互独立的，就意味着测度P是一个乘积测
度，即对于任意两个一维 Borel集合S和T,有Px(S×T)=P(S)Pr(T),其中Px和Py是由
X和Y产生的-维测度。等价地，当且仅当
Fx(x,y)=Fx(x)Fr(y)
X和Y相互独立。其中Fx利Fr分别是X和Y的分布函数。
在离散情况下，如果对于(X范围内和Y范围内的)任意x和y,定义p(x,y)=P|w:X(w)=x,
Y(w)=y,则当且仅当p(x,y)=p(x)p(y)时，X和Y相互独立，其中p(x)=PIX(w)=x},
p(y)=PIY(w)=yi。(注意符号的两种不同含义：相同的符号p(·)用在两种完全不同的离
.i:
附录A 概率理论 273
散分布函数中；它们的区别仪在于X范围内的元素用x来表示，而Y范围内的元素用y来
表示。)
在下面的情形中，如果 X和Y分别具有密度p(x)和q(y),则当且仅当
Fxx.y=pU)g(Odsd
即X和Y具有联合密度p(x,y)=p(x)q(y)时，X和Y相互独立。
现在就来叙述弱大数定理，在编码定理的证明中需要利用该定理。
弱大数定理 对于任意n,设X,X?,…、X。是相互独立的随机变量，每个随机变量的期
望都是一个有限值μ——实际上它们都具有相同的分布函数、则对于任意e>0,有：
m1++:-≥B}=0
,::
附录B 凸函数和Jensen不等式
请参考Heming[6],13~28页和53~66页；Feller[4],卷Ⅱ,153-155页。
设一·个子集KCE(欧几里得n维空间),如果连接K内任意两点的线段均包含在K内，
则称该子集是凸的
x x:
1
凸的 七凸的
连接x,和x?的线段形式上定义为3x:x=tx,+(1-t)x?,t∈[0,1]!。
尽管以上凸集的定义是以成对点的形式给出的，但也可以按照如下任意有限个点的凸组
合形式来定义。如果∑x?=x,其中a,,a?,…,a是一组非负值标量，满足∑a=1,则
称点x是xj,x?,…,xm的凸组合·x?,x?,…,x。的所有凸组合的集合称为x?,x?,…,xm的
凸包络(见图B.1)。容易证明当且仅当K内任意点的凸组合仍在K内时，集合K是凸的。
X
x
:
,
x
xi
图B.1 二维空间中的一些凸包络
现在设f是一个实值函数，并设K是厂定义域上的一个凸子集。如果对于任意的x,x?∈
K,及L∈[0,1],
x+(1-t?}≤f(x?J+(1-r)f(x?) (B.1)
则称f是下凸U的("杯状凸"),此外，如果当x?≠x?且0<t<1时，式(B.1)中的不等式严格
成立，则称f是严格下凸U的。如下图所示的一维空间的例子。
下凸U 严格下凸J 非下凸u
附录B 凸函数和Jensen不等式 275
从几何学的角度讲，当且仅当f所有的弦都位于了曲线上方或曲线上时，才称了是下凸U的。
类似地，如果-f是下凸U的或严格下凸U的，也就是说，如果式(B.1)中不等号的方向是
相反的，即
f(A1+(1-)xz}f(x?)+(1-0)f(xz) (B.1')
则称函数子为上凸∩的("帽状凸")①或严格上凸∩的。
上凸∩ 严情上凸n 非上凸n
值得注意的是，凸函数连续意味着：如果K是一个开放凸集，且f在K上是凸的(∩或
U),则/在K上是连续的。但是，如果K是非开放的，则f在K的边界点上有可能不连续，例
如设K=[0,1],当0<x≤1时，f(x)=x,而f(0)=1(见图B.2)。
0 1
图D.2 f在[0.1]区间内下凸U(非上凸∩),但在x=0点不连续
如果f充分平滑，我们可以利用微积分来检验f的凸性。例如，设f是一维空间中的一个
函数，且对于任意点x∈K,一阶导数f'(x)均存在。则当且仅当厂'在K上非递减时，f是下凸U
的；当且仅当了'在K上递增时，是严格下凸U的。而如果f"存在，则当且仅当在K上f"(x)≥0,
f是下凸U的；并且如果除了有限个点以外，都有f"(x)>0,则f是严格下凸U的。这些情况
对于上凸∩函数是类似的。(在更高维空间中，可以利用混合二阶偏微商矩阵[Df]来检验凸
性；详细内容参见Fleming[6],2~4节。)
另外，如果f在K上是可微的，则当且仅当对于所有的x,y∈K,f(x)≥f(y)+ Vf(y)·
(x-y)均成立时，f是下凸U的；并且当且仅当x≠y,上述不等式严格成立时，f是严格下凸
U的：
最后讨论 Jensen不等式，它是针对只有一个变量的凸函数的。设K是E11上的一个区间，
而F(x)是集中在区间K内的一个概率分布。并设X是相应的随机变量，即PIX≤xl=
F(x)。如果期望 E(X)存在，并且f(x)是一个下凸U函数，则Jensen不等式可以表示为：
EU(X)≈f(E(X)) (B.2)
另外，如果f是严格凸的，则不等式(B.2)严格成立，除非X集中于某个固定点x?,即P(X=xo)=1。
从儿何学的角度来看，Jensen不等式(见图B,3)表明，如果一个集中分布位于曲线广上，则其重
① 有时用“凹”(cncne)代替下凸U(cowexU),而用“凸”(cmvc)表示上凸∩(ouaN)。
,2
276 信息论与编码理论(第二版)
心将位干曲线f的上方(或曲线上)。显然如果f是上凸∩的，则不等号的方向相反：
EU(X)≤f(E(X)) (B.3)
(AL,YMELA)))
LE(D,AE(X))
5(M
K—
图B.3 离散分布的Jeneen不等式
最后介绍两道例题，其中f(x)是上凸∩函数logx(这里没有明确规定对数运算的基底)。
在第一道例题中X是离散的，而在第二道例题中X具有一个密度函数。
例B.1 设Ω=|w?,o?,…是一个离散的实数集合，并设p(w)是一个非负值函数，满足
∑p(m,)=1。则显然Ω是一个高散样本空间《参见附录A)。设q(m)是定义在Ω上的
另外一个非负值函数，并定义随机变量X为：
x()=g(
[X在p(w)=0点的取值并不重要，我们可以假设这些点的X(w)=0]。因此根据Jeneen
不等式(B.3),E(logX)≤logE(X)。但是，
EUogx)=Zpronlo
而，
Ex)=.∑go)
[参见有关式(A.2)的讨论。]因此，如果a表示上式中E(X)的和，可以得到：
∑pro,Jo =Z,loe+1oga
并且由于 logx 是严格凸的，当且仅当X=β(即某个常数)时，等式成立；但是由于
∑p(w,)=1,这个常数必然等于a,因此对于所有p(w.)-0的i,当且仅当q(m)=ap(w)
时等式成立。显然其中并没有涉及到集合0,因此可以得到如下定理。
定理B.1 设I是一个离散的整数集合，并设p(i∈/)是一个满足∑P= 1的正
(NB)实数集合。如果q是另外一个满足∑.e9=a的非负值(NB)实数集合，则
mhogpnloe+loga (B.4)
当且仅当对于所有的i值，q=:时等式成立。
附录B 凸函数和Jensen不等式 277
例B.2 设Ω等于实数轴，而p(x)是一个密度函数，即一个满足p(x)dx=1的非负值函
数；显然p(x)是Ω上的一个概率测度(参见附录A)。设q(x)是定义在Ω上的另外一个
非负值函数，并定义随机变量X(x)=g(x}/p(x)。再次应用Jenen 不等式，这次利用
式(A.3)计算期望，会得到：
pn)lo《≤log J,qtx)dr
其中l=}x:p(x)>0。类似于例B.1中的讨论，可以引入另外一个定理。
定理B.2 设I是实数轴上一个可测量的子集，而p(x)是定义在I上的一个正(NB)函
数，满足 ,p(x)dx =1。如果 g(x)是定义在I上的一个非负值(NB)西数，满足
J,q(x)d=a,则
,pu)loeArJ,px)loggdx+loga (B.5)
当且仅当q(x)=p(x)时等式成立。
注：式(B.4)左边的求和项称为概率分布(p?+p?,…)的熵；式(B.5)左边的积分项则是密度
为p(x)的随机变量的微分熵。熵和微分熵是信息理论研究的中心，在本书的第一部分中有许
多类似于以上两式的讨论。
排
附录C 有 限 域
在这部分，作为参考我们将介绍有限域的基本知识，以满足第8章和第9章的需求。推荐
的参考文献是Berlekamp[14]第2章、第3章、第4章和第6章，以及Niedereiterl 11;。
C.1 构造
素数域下，是基本的构造模块，在这里p是一个素数.F,域的元素包括10.1.…,p-1:,
运算匙以p为模的。
r,L的m维矢量空间V(F,)是m重a=(au,u…·m-)的集合，元素之间定义了加
法运算。通过按照下列方式定义乘法运算，可以将V(F)转化为一个域.设f(x)=fo+
fix+…+f”是F,上的一个m次不可约多项式。对于任意的m和p,该多项式均存在；实际
上在F,上存在：
(=-ZAdpm
个首项系数为1的m次不可约多项式，这里μ是Mobius-μ函数，并且对m的所有(正)因子求
和。文献[22]和文献[23]中给出了大量已被计算出的不可约多项式表：现在定义V(F,)上
a=(co,ai,…,a-1)和b=(bo,b?,…,bm-1)的乘积是c=(cn,c,…,c),Hc由下列等式
惟一确定：
o+=iYco+cx+am-xhu-pyx+(mod/(D
按照这种方式定义的乘法运算与元素之间的加法运算相结合，使V(F)转化为一个含p"个
元素的域。根据以上构造过程，有多少个m次不可约多项式，就有多少种乘法的定义方式；但
实际上所有这些域都是同构的，因此这种域通常称为含pm个元素的域，并表示为GF(p")
(GF即Galois Fields的英文缩写，以纪念其发现者Galois)或Fm。
上述构造过程说明了对于所有的素数p和正整数m,如何构造一个含p个元素的域。反
之，任何包含有限个元素的域必然具有这种结构，例如不存在含6个元素的域。素数p称为域
的特征。
更一般地，如果F,是-…个含q个元素的有限域(在此q不必是一个素数；也可以是一个素
数的方幂),则通过利用F。上的一个m次不可约多项式，可以将矢量空间V(F,)转化为一个
更大的有限域。设g=pd和m=n/d,可以证明如果n能够被d整除，则F可以看做是F
的一个子域。反之，如果n不能被d整除，则F不是F的一个子城：
C.2 乘法结构
设F,是一个含q=pm个元素的有限域。F,中的非零元素构成一个(g-1)阶交换群
附录C 有 限 城 279
F:.实质上也是一个循环群。由此可知当且仅当d是(q-1)的因子时，F,包含一个d阶元
素；实际上如果(y-1)能够皱d整除，则恰好存在中(d)个d阶元素(中= Euler中函数)。一个
(q-1)阶乘法元素，即群F,的生成元素被称为本原根。
出此可以得出结论，F中的每个元素都满足a?-'=1,面F,中的每个元素都满足a?=a。
如果对于某个m值，将域F。看做是F的一个子城，则下面的等式描述了F?的基本性质，即：
a?-α,当只仅当a∈Fq
C.3 共轭和最小多项式
如果将F,看做F,的一个m阶扩展，则映射a→a?称为共轭。共轭是线性的，即
(a+f)=(?+β
a的共轭类是序列。.a°,a3.…中取值不同的元素：因此，如果。是满足a=a的最小整数，
则a的共轭类包括ia,a?,…,a1:.这里k称为a的阶数；由此可知k是m的因子，并月
a∈F&,而不可能属于其他任何一个更小的域。
a的最小多项式定义为系数属于F、阶数最低、首项系数为1且满足f(α)=0的多项式
f(x)。f(x)在F,上是不可约的，但在更大的域F中，f(x)可以进行线性因式分解：
(r)=(x-aHx-a…(x-a)
因此?(x)的次数与a的阶数相同。
如果a是F中的一个本原根，则α的最小多项式称为F,上的本原多项式。为方便起见，
通常将这个过程反过来，利用一个本原多项式来构造域。例如，通过参考文献{22]或文献[23]
中的表，我们发现f(x)=x?+x+1是F?上的一个本原(因此也是不可约的)多项式。即f(x)
是F个本原根(我们用a表示)的最小多项式。因此F由元素10,1?α,a2,…,a?|组
成，并且通过反复利用等式α?=α+1,可以将每个幂c表示为a的一个次数≤3的多项式。
最后得出下表：
α3
0 1
a
2
3 3
4
5
6
7
立+1
2+口 3+2
a3+
8
9 a3
10
II α3+a2+
12
13
3+o2+a+1 3+a2+
14
E
280 信息论与编码理论〔第二版〕
这种表非常便于计算。例如，如果用来自V?(F?)的矢量表示F6中的元素，则可以按如下
方式计算1101乘以0111的结果：
1101=α3+a2+1=a13
0111=c2+a+1=α10
α13·α1=a23=α?=α2+1=0101
因此在F中(1101)·(0111)=(0101)。
C.4(x2-1)在F。上的因式分解
如果F。的特征值为p,且n=p'no,其中i≥1,则在F,中x-1=(x°-1)。如果假设n
和p是互质的，则至少存在一个整数m,使得q=1(mod n),即n能够整除q-1。因此城
F,而不是一个更小的域，将包含一个n阶本原单位根，以β表示。在城Fm中，
x-1-Tu-A
但在更小的域F,中，x2-1是β的各次幂(互不相等)的最小多项式乘积。这里通过一个例题
加以说明(参照9.8节)。
设q=2,n=23。因为2"=1(mod 23),故F?n包含一个23阶本原单位根。=1的最小
多项式显然是x-1。3的最小多项式为：
u)-ia-)
因为"=β,所以《利用3=1),
g(x)=(x-βxx-β2)x-β?)(x-βx-β?xx-β)(x-B1?)
·(x-β3xx-β3)(x-β")x-β12)
类似地，β的最小多项式是：
g(x)=(x-β)(x-βl)(x-B2)(x-β)x-β)(x-B22)x-B2)
·(x-β1?xx-β1?)(x-β?xx-β14)
因为上面已经包括了β的各个方幂，所以x-1在F?上可因式分解为如下不可约因式：
(x23-1)=(x-1)g(x}g(x)
通过在F?上对x2-1直接分解因式，可以得到：
g(x)=x11+x?+x?+x?+x?+x+
8(x)=x1'+xl0+x?+x?+x?+x2+1
(参见文献[22]或文献[23]。)
附录D 利用方向图求解路径枚举多项式
(为了更详细地了解本部分内容，可以参考 Aho,Hopcroft和UILman[1]第5章，或者Mason
和Zimmenran[ 10]第4章。)
设G=(V,E)是一个方向图，其中V={v?,B?,…是有限个节点的集合，而E是V中有序
对(被称为分支)的子集。通过平面上一组与V中元素相对应的点，可以用图示的方法表示
G;如果(z,,v)∈E,就从v.到v,画一条带方向的连线。例如在图D.1中，我们画出了G的图
形，其中V=}a,a?,b,c,d.E=|(ap,c),(b,a?),(b,c),(c,b),(c,d),(d,b),(d,d)。
[注：图D.1中的图形与图10.14中的完全相同。]
在这种图形中，路径由一系列形式为(vo.v?),(v?,v?),…,(va-1,vn)的分支组成，这样的
一条路径称为从vo到vn的长度为n的路径，并且通常用字符串 vnv?…。表示。例如，在
图D.1中P=acheddba?是一条从a。到a:长度为7的路径。
a
B
A
C
b
D
F F
G
图D.1 图形G
现在假设在G的每个分支上做一个标注，并且明确规定这些标注是0和1之间的实数。
当然如果标注取自更为一般的代数域，下面的论述仍然有效。(参见文献[1].5.6节。)在
图D.1中的7个分支分别被标注为A,B,…,G。我们定义路径的标注为其组成分支的标注的
乘积。例如上述路径P的标注为ABCDEFG。这里需要研究的问题是计算G中连接两个指定
节点的所有路径标注的总和，称这个数值为两个节点之间的传榆量。
在讨论图D.1之前，先考虑一个简单一些的图形，如图D.2所示，其中V=1v?.y,v,l.
E=1(?,v?),(,,v,),(v?,v,),(D.v,)。在这个图形中，v.和v,之间存在无穷多条路径，例如
(v,v),(ev,e),(Uv,t,),(v,eeDx,)等。显然v.和v,之间所有路径标注的总和是：
Ly+LLy+LL、Ls+LL2,Ly+…
=Ly+L?L(1+Ls+L2+L+…)
=Ly+
因此，图D.2中v和v,之间的传输量由下式给出：
涂、:1 :
282 信息论与编码理论(第二版)
TU,Y)=L+
换句话说，图D.2中v,和v;之间的传输量与图D.3中v,和1,之间的传输量相同，图D.3中的
图形G可以由图D.2中的图形G删除节点v,,并根据下述规则改写标注L面得到。
Li=L+ (D.1)
这意味着，当计算一个复杂图形中两个给定节点之间的传输量时，可以将图形中的中间节点一
个接一个地删除，并根据式(D.1)重新定义分支标注。因此最终将得到一个仅含两个节点的
图形，而这两个节点之间的传输量可以直接从图形中读取(见习题10.9)。
L
v
下 L
图D.2 另一个图形
;
号
图D.3 G的图形
现在利用这种方法计算图D.1中a和a,间的传输量。首先删除节点d;结果如图D.4
所示。
a1
B
c+
h c
D
图D.4 图D.1剧除节点d后
然后删除节点c。结果如图 D.5所示。图D.5中的图形与图D.2中的类似，这样可以直
接利用式(D.1)计算a和a,间的传输量。结果是：
T(ao,a)=-G-C-+CDG-DEF (D.2)
l
附录D 利用方向图求解路径杜举多项式 283
a
B
b
AC-I-C+AEF
CDCDG+DEF 1-G
图D.5 图D.4删除节点c后的图形
在第10章中，需要考感式(D.2)的两种特殊情形，其中的标注由下表给出(见图10.14和
图10.15):
标注 情况1 情况2
A x3 x2x
B 2y
C y
D 1 yt
E K 都
F x 矿
G x
将这些值代人式(D.2),得到：
Ax)-- (D.3)
AUK,y,.z)=-+ (D.4)
[比较式(10.11)和式(10.13)。]
·
!
定理索引
序 号 主 要内 容
1.1H(X)的最大值
1.2 H(XIY)≤H(Z)+E(logA)(推论：Fano不等式)
1.3I(X;Y)≥0
(X,Y;Z)≥I(Y;Z) 1.4
1.5X,Y、Z是一个Markos链：(X;Z)≤I(X;Y)
1.6I(X;Y)是输人概率分布的上凸∩函数
1.7I(X;Y)是转移概率分布的下凹U函数
1.8 如果X,之间相互独立，则I(X;Y)≥2I(X?;Y)
如果信道无记忆，则f(X;Y)≤2I(X?;Y) 1.9
1.10 I(X:Y)=h(X)-h(XIY)
1.11 给定二阶矩，h(X)的极大值
2.1C(3)的上凸∩性
对于DMC.C(β)=nC?(β) 2.2
2.3 对称DMC的容量
2.4 信道编码定理
3.1
3.2
3.3
3.4
R(δ)的下凹U性
对于DMS,R(δ)=kR?(δ)
对称 DMS的R(8)
信源编码定理
4.1
4.2
高斯信道：C(β)=log(1+B/o2)
高斯信道的编码定理
4.3
4.4
4.5
高斯信源：R?(&)=max(÷logo2/8,0)
高斯信源：R(δ)=kR?(8)
高斯信源的信源编码定理
5.1信源-信道编码定理
页 码
14
18
20
21
22
23
23
25
26
29
31
40
40
43
47
58
59
62
64
74
75
76
78
79
88
定理索引
7.1 线性码的基本矩阵
7.2
7.3
7.4
7.5
7.6
e≤L(dmn-1)/2」
利用H求dmn
纠E检F码
Px≤A(Y)-1
Mac Wilians恒等式
8.1循环移位的代数表示
循环码对多项式乘法的封闭性 8.2
有关循环码的主要定理 8.3
8.4“mod g(x)”电路
289
8.5
8.6
8.7
8.8
循环码码字分量所满足的递推公式
循环汉明码
短突发描述的惟一性
长度为b的突发图案的数日
8.9 突发错误的汉明界
8.10 纠正突发错误码的容限
8.11 纠正突发错误码的交织定理
8.12 交织循环码
8.13 强纠正突发错误码
8.14 Fire构造法
8.15 Meggit引理
9.1 BCH码
9.2 循环BCH码
9.3 BCH论证
9,4 关键方程
9.5 利用欧几里得算法求解全等方程
9.6 欧几里得“程序”
9.7 循环RS码
9.8 Singleton界
9.9MDS码的插值特性
9.10 RS码的另外-种描述
9.11 eo+2e?≤d-1(eo=删除符号数，ey=错误数)
9.12 对于RS码，eo+2e≤r
9.13 (23,12)Golay码的重量
9.14 (24,12)Golay码的重量
110
112
113
116
117
118
130
131
132
141
144
147
150
151
151
151
155
155
156
157
161
173
175
178
179
184
185
189
189
190
190
198
200
207
207
290 信息论与编码理论(第二版)
11.1 对于UD码，有∑s≤1
11.2 如果∑s≤1,则存在异前缀码
11.3 n.(p)≥H,(p)
11.4
11.5
n,(p)<H?(p)+1
lim m?'n,(p")=H?(p)
11.6 有关最佳异前缀码的结论
11.7 Huffiman结论
B.1 Jersen不等式(离散情况)
B.2 Jensen不等式(连续情况)
